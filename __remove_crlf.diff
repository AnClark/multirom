diff --git a/Android.mk b/Android.mk
index 6f58a4f..2aec8d0 100755
--- a/Android.mk
+++ b/Android.mk
@@ -1,86 +1,86 @@
-# MultiROM
-ifeq ($(TARGET_RECOVERY_IS_MULTIROM),true)
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-multirom_local_path := $(LOCAL_PATH)
-
-LOCAL_C_INCLUDES += $(multirom_local_path) \
-    external/libpng \
-    external/zlib \
-    external/freetype/include \
-    $(multirom_local_path)/lib
-
-LOCAL_SRC_FILES:= \
-    kexec.c \
-    main.c \
-    multirom.c \
-    multirom_ui.c \
-    multirom_ui_landscape.c \
-    multirom_ui_portrait.c \
-    multirom_ui_themes.c \
-    pong.c \
-    rcadditions.c \
-    rom_quirks.c \
-
-# With these, GCC optimizes aggressively enough so full-screen alpha blending
-# is quick enough to be done in an animation
-LOCAL_CFLAGS += -O3 -funsafe-math-optimizations
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-#LOCAL_CFLAGS += -D_FORTIFY_SOURCE=2 -fstack-protector-all -O0 -g -fno-omit-frame-pointer -Wall
-
-LOCAL_MODULE:= multirom
-LOCAL_MODULE_TAGS := eng
-
-LOCAL_FORCE_STATIC_EXECUTABLE := true
-LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
-LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
-
-LOCAL_STATIC_LIBRARIES := libcutils libc libmultirom_static
-LOCAL_WHOLE_STATIC_LIBRARIES := libm libcutils libpng libz libft2_mrom_static
-
-# clone libbootimg to /system/extras/ from
-# https://github.com/Tasssadar/libbootimg.git
-LOCAL_STATIC_LIBRARIES += libbootimg
-LOCAL_C_INCLUDES += system/extras/libbootimg/include
-
-include $(multirom_local_path)/device_defines.mk
-
-ifneq ($(MR_DEVICE_HOOKS),)
-ifeq ($(MR_DEVICE_HOOKS_VER),)
-    $(info MR_DEVICE_HOOKS is set but MR_DEVICE_HOOKS_VER is not specified!)
-else
-    LOCAL_CFLAGS += -DMR_DEVICE_HOOKS=$(MR_DEVICE_HOOKS_VER)
-    LOCAL_SRC_FILES += ../../../$(MR_DEVICE_HOOKS)
-endif
-endif
-
-include $(BUILD_EXECUTABLE)
-
-
-
-# Trampoline
-include $(multirom_local_path)/trampoline/Android.mk
-
-# ZIP installer
-include $(multirom_local_path)/install_zip/Android.mk
-
-# Kexec-tools
-include $(multirom_local_path)/kexec-tools/Android.mk
-
-# adbd
-include $(multirom_local_path)/adbd/Android.mk
-
-# trampoline_encmnt
-ifeq ($(MR_ENCRYPTION),true)
-include $(multirom_local_path)/trampoline_encmnt/Android.mk
-endif
-
-# libmultirom
-include $(multirom_local_path)/lib/Android.mk
-
-endif
+# MultiROM
+ifeq ($(TARGET_RECOVERY_IS_MULTIROM),true)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+multirom_local_path := $(LOCAL_PATH)
+
+LOCAL_C_INCLUDES += $(multirom_local_path) \
+    external/libpng \
+    external/zlib \
+    external/freetype/include \
+    $(multirom_local_path)/lib
+
+LOCAL_SRC_FILES:= \
+    kexec.c \
+    main.c \
+    multirom.c \
+    multirom_ui.c \
+    multirom_ui_landscape.c \
+    multirom_ui_portrait.c \
+    multirom_ui_themes.c \
+    pong.c \
+    rcadditions.c \
+    rom_quirks.c \
+
+# With these, GCC optimizes aggressively enough so full-screen alpha blending
+# is quick enough to be done in an animation
+LOCAL_CFLAGS += -O3 -funsafe-math-optimizations
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+#LOCAL_CFLAGS += -D_FORTIFY_SOURCE=2 -fstack-protector-all -O0 -g -fno-omit-frame-pointer -Wall
+
+LOCAL_MODULE:= multirom
+LOCAL_MODULE_TAGS := eng
+
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
+LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
+
+LOCAL_STATIC_LIBRARIES := libcutils libc libmultirom_static
+LOCAL_WHOLE_STATIC_LIBRARIES := libm libcutils libpng libz libft2_mrom_static
+
+# clone libbootimg to /system/extras/ from
+# https://github.com/Tasssadar/libbootimg.git
+LOCAL_STATIC_LIBRARIES += libbootimg
+LOCAL_C_INCLUDES += system/extras/libbootimg/include
+
+include $(multirom_local_path)/device_defines.mk
+
+ifneq ($(MR_DEVICE_HOOKS),)
+ifeq ($(MR_DEVICE_HOOKS_VER),)
+    $(info MR_DEVICE_HOOKS is set but MR_DEVICE_HOOKS_VER is not specified!)
+else
+    LOCAL_CFLAGS += -DMR_DEVICE_HOOKS=$(MR_DEVICE_HOOKS_VER)
+    LOCAL_SRC_FILES += ../../../$(MR_DEVICE_HOOKS)
+endif
+endif
+
+include $(BUILD_EXECUTABLE)
+
+
+
+# Trampoline
+include $(multirom_local_path)/trampoline/Android.mk
+
+# ZIP installer
+include $(multirom_local_path)/install_zip/Android.mk
+
+# Kexec-tools
+include $(multirom_local_path)/kexec-tools/Android.mk
+
+# adbd
+include $(multirom_local_path)/adbd/Android.mk
+
+# trampoline_encmnt
+ifeq ($(MR_ENCRYPTION),true)
+include $(multirom_local_path)/trampoline_encmnt/Android.mk
+endif
+
+# libmultirom
+include $(multirom_local_path)/lib/Android.mk
+
+endif
diff --git a/COPYING b/COPYING
index 818433e..94a9ed0 100755
--- a/COPYING
+++ b/COPYING
@@ -1,674 +1,674 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/DONORS.md b/DONORS.md
index 490d6d8..74840fc 100755
--- a/DONORS.md
+++ b/DONORS.md
@@ -1,19 +1,19 @@
-# MultiROM's Indiegogo campaign
-
-http://www.indiegogo.com/projects/multirom-for-nexus-7-2013/
-
-A crowdfunding campaign to get test devices took place from July 28th
-to August 27th 2013. Thanks all contributors, the campaign was successful,
-raising a total of $562. This enabled a purchase of _flo_ and resulted in
-MultiROM being ported to said device and the code became much more portable.
-
-These are the contributors who pledged $20 or more and got perk _The Code_:
-* jbaumert
-* viper08
-* marius15
-* x.nicow.x
-* Ben Hagen
-
-More contributors are named in the XDA thread or during build of
-`multirom_zip` target, but thanks goes to all who contributed, either
-by pledging money or by promoting the campaign. Thank you all.
+# MultiROM's Indiegogo campaign
+
+http://www.indiegogo.com/projects/multirom-for-nexus-7-2013/
+
+A crowdfunding campaign to get test devices took place from July 28th
+to August 27th 2013. Thanks all contributors, the campaign was successful,
+raising a total of $562. This enabled a purchase of _flo_ and resulted in
+MultiROM being ported to said device and the code became much more portable.
+
+These are the contributors who pledged $20 or more and got perk _The Code_:
+* jbaumert
+* viper08
+* marius15
+* x.nicow.x
+* Ben Hagen
+
+More contributors are named in the XDA thread or during build of
+`multirom_zip` target, but thanks goes to all who contributed, either
+by pledging money or by promoting the campaign. Thank you all.
diff --git a/README.md b/README.md
index 88b1660..62f43d5 100755
--- a/README.md
+++ b/README.md
@@ -1,37 +1,37 @@
-# MultiROM
-MultiROM is a one-of-a-kind multi-boot solution. It can boot android ROM while
-keeping the one in internal memory intact or boot Ubuntu without formating
-the whole device. MultiROM can boot either from internal memory of the device
-or from USB flash drive.
-
-XDA threads:
-* grouper: http://forum.xda-developers.com/showthread.php?t=2011403
-* flo: http://forum.xda-developers.com/showthread.php?t=2457063
-* mako: http://forum.xda-developers.com/showthread.php?p=46223377
-* hammerhead: http://forum.xda-developers.com/showthread.php?t=2571011
-
-###Sources
-MultiROM uses git submodules, so you need to clone them as well:
-
-    git clone https://github.com/Tasssadar/multirom.git system/extras/multirom
-    cd system/extras/multirom
-    git submodule update --init
-
-It also needs libbootimg:
-
-    git clone https://github.com/Tasssadar/libbootimg.git system/extras/libbootimg
-
-###Build
-Clone repo to folder `system/extras/multirom` inside Android 4.x source tree.
-You can find device folders on my github, I currently use OmniROM tree for
-building (means branch android-4.4-mrom in device repos).
-MultiROM also needs libbootimg (https://github.com/Tasssadar/libbootimg)
-in folder `system/extras/libbootimg`. Use something like this to build:
-
-    . build/envsetup.sh
-    lunch full_grouper-userdebug
-    make -j4 multirom trampoline
-
-To build installation ZIP file, use `multirom_zip` target:
-
-    make -j4 multirom_zip
+# MultiROM
+MultiROM is a one-of-a-kind multi-boot solution. It can boot android ROM while
+keeping the one in internal memory intact or boot Ubuntu without formating
+the whole device. MultiROM can boot either from internal memory of the device
+or from USB flash drive.
+
+XDA threads:
+* grouper: http://forum.xda-developers.com/showthread.php?t=2011403
+* flo: http://forum.xda-developers.com/showthread.php?t=2457063
+* mako: http://forum.xda-developers.com/showthread.php?p=46223377
+* hammerhead: http://forum.xda-developers.com/showthread.php?t=2571011
+
+###Sources
+MultiROM uses git submodules, so you need to clone them as well:
+
+    git clone https://github.com/Tasssadar/multirom.git system/extras/multirom
+    cd system/extras/multirom
+    git submodule update --init
+
+It also needs libbootimg:
+
+    git clone https://github.com/Tasssadar/libbootimg.git system/extras/libbootimg
+
+###Build
+Clone repo to folder `system/extras/multirom` inside Android 4.x source tree.
+You can find device folders on my github, I currently use OmniROM tree for
+building (means branch android-4.4-mrom in device repos).
+MultiROM also needs libbootimg (https://github.com/Tasssadar/libbootimg)
+in folder `system/extras/libbootimg`. Use something like this to build:
+
+    . build/envsetup.sh
+    lunch full_grouper-userdebug
+    make -j4 multirom trampoline
+
+To build installation ZIP file, use `multirom_zip` target:
+
+    make -j4 multirom_zip
diff --git a/adbd b/adbd
--- a/adbd
+++ b/adbd
@@ -1 +1 @@
-Subproject commit 6db99f070766bc948e2b405cd52aa1e61ddd55bb
+Subproject commit 6db99f070766bc948e2b405cd52aa1e61ddd55bb-dirty
diff --git a/device_defines.mk b/device_defines.mk
index ecc002e..2c4113e 100755
--- a/device_defines.mk
+++ b/device_defines.mk
@@ -1,110 +1,110 @@
-# Defines from device files
-# Init default define values
-MULTIROM_DEFAULT_ROTATION := 0
-
-# This value is used to have different folders on USB drives
-# for different devices. Grouper didn't have that, hence the hack
-LOCAL_CFLAGS += -DTARGET_DEVICE="\"$(TARGET_DEVICE)\""
-ifeq ($(TARGET_DEVICE),grouper)
-    LOCAL_CFLAGS += -DMR_MOVE_USB_DIR
-endif
-
-ifneq ($(TW_DEFAULT_ROTATION),)
-    MULTIROM_DEFAULT_ROTATION := $(TW_DEFAULT_ROTATION)
-endif
-LOCAL_CFLAGS += -DMULTIROM_DEFAULT_ROTATION=$(MULTIROM_DEFAULT_ROTATION)
-
-# TWRP framebuffer flags
-ifeq ($(RECOVERY_GRAPHICS_USE_LINELENGTH), true)
-    LOCAL_CFLAGS += -DRECOVERY_GRAPHICS_USE_LINELENGTH
-endif
-
-ifeq ($(MR_PIXEL_FORMAT),)
-    MR_PIXEL_FORMAT := $(TARGET_RECOVERY_PIXEL_FORMAT)
-endif
-
-ifeq ($(MR_PIXEL_FORMAT),"RGBX_8888")
-    LOCAL_CFLAGS += -DRECOVERY_RGBX
-else ifeq ($(MR_PIXEL_FORMAT),"BGRA_8888")
-    LOCAL_CFLAGS += -DRECOVERY_BGRA
-else ifeq ($(MR_PIXEL_FORMAT),"RGB_565")
-    LOCAL_CFLAGS += -DRECOVERY_RGB_565
-else ifeq ($(MR_PIXEL_FORMAT),"ABGR_8888")
-	LOCAL_CFLAGS += -DRECOVERY_ABGR
-else
-    $(info TARGET_RECOVERY_PIXEL_FORMAT or MR_PIXEL_FORMAT not set or have invalid value)
-endif
-
-ifeq ($(MR_DPI),)
-    $(info MR_DPI not defined in device files)
-else ifeq ($(MR_DPI),hdpi)
-ifeq ($(MR_DPI_MUL),)
-    MR_DPI_MUL := 1
-endif
-else ifeq ($(MR_DPI),xhdpi)
-ifeq ($(MR_DPI_MUL),)
-    MR_DPI_MUL := 1.5
-endif
-else ifeq ($(MR_DPI),xxhdpi)
-ifeq ($(MR_DPI_MUL),)
-    MR_DPI_MUL := 2.0
-endif
-endif
-
-ifeq ($(MR_DPI_FONT),)
-    MR_DPI_FONT := 96
-endif
-
-LOCAL_CFLAGS += -DMR_DPI_FONT=$(MR_DPI_FONT)
-
-ifneq ($(MR_DPI_MUL),)
-    LOCAL_CFLAGS += -DDPI_MUL=$(MR_DPI_MUL)
-else
-    $(info MR_DPI_MUL not defined!)
-endif
-
-ifeq ($(MR_DISABLE_ALPHA),true)
-    LOCAL_CFLAGS += -DMR_DISABLE_ALPHA
-endif
-
-ifneq ($(TW_BRIGHTNESS_PATH),)
-    LOCAL_CFLAGS += -DTW_BRIGHTNESS_PATH=\"$(TW_BRIGHTNESS_PATH)\"
-endif
-
-ifeq ($(TW_SCREEN_BLANK_ON_BOOT), true)
-    LOCAL_CFLAGS += -DTW_SCREEN_BLANK_ON_BOOT
-endif
-
-ifneq ($(MR_DEFAULT_BRIGHTNESS),)
-    LOCAL_CFLAGS += -DMULTIROM_DEFAULT_BRIGHTNESS=\"$(MR_DEFAULT_BRIGHTNESS)\"
-else
-    LOCAL_CFLAGS += -DMULTIROM_DEFAULT_BRIGHTNESS=40
-endif
-
-ifneq ($(MR_KEXEC_MEM_MIN),)
-    LOCAL_CFLAGS += -DMR_KEXEC_MEM_MIN=\"$(MR_KEXEC_MEM_MIN)\"
-else
-    $(info MR_KEXEC_MEM_MIN was not defined in device files!)
-endif
-
-ifeq ($(MR_KEXEC_DTB),true)
-    LOCAL_CFLAGS += -DMR_KEXEC_DTB
-endif
-
-ifeq ($(MR_CONTINUOUS_FB_UPDATE),true)
-    LOCAL_CFLAGS += -DMR_CONTINUOUS_FB_UPDATE
-endif
-
-LOCAL_CFLAGS += -DPLATFORM_SDK_VERSION=$(PLATFORM_SDK_VERSION)
-
-ifeq ($(MR_USE_MROM_FSTAB),true)
-    LOCAL_CFLAGS += -DMR_USE_MROM_FSTAB
-endif
-
-ifeq ($(MR_ENCRYPTION),true)
-    LOCAL_CFLAGS += -DMR_ENCRYPTION
-endif
-
-ifneq ($(MR_RD_ADDR),)
-    LOCAL_CFLAGS += -DMR_RD_ADDR=$(MR_RD_ADDR)
-endif
+# Defines from device files
+# Init default define values
+MULTIROM_DEFAULT_ROTATION := 0
+
+# This value is used to have different folders on USB drives
+# for different devices. Grouper didn't have that, hence the hack
+LOCAL_CFLAGS += -DTARGET_DEVICE="\"$(TARGET_DEVICE)\""
+ifeq ($(TARGET_DEVICE),grouper)
+    LOCAL_CFLAGS += -DMR_MOVE_USB_DIR
+endif
+
+ifneq ($(TW_DEFAULT_ROTATION),)
+    MULTIROM_DEFAULT_ROTATION := $(TW_DEFAULT_ROTATION)
+endif
+LOCAL_CFLAGS += -DMULTIROM_DEFAULT_ROTATION=$(MULTIROM_DEFAULT_ROTATION)
+
+# TWRP framebuffer flags
+ifeq ($(RECOVERY_GRAPHICS_USE_LINELENGTH), true)
+    LOCAL_CFLAGS += -DRECOVERY_GRAPHICS_USE_LINELENGTH
+endif
+
+ifeq ($(MR_PIXEL_FORMAT),)
+    MR_PIXEL_FORMAT := $(TARGET_RECOVERY_PIXEL_FORMAT)
+endif
+
+ifeq ($(MR_PIXEL_FORMAT),"RGBX_8888")
+    LOCAL_CFLAGS += -DRECOVERY_RGBX
+else ifeq ($(MR_PIXEL_FORMAT),"BGRA_8888")
+    LOCAL_CFLAGS += -DRECOVERY_BGRA
+else ifeq ($(MR_PIXEL_FORMAT),"RGB_565")
+    LOCAL_CFLAGS += -DRECOVERY_RGB_565
+else ifeq ($(MR_PIXEL_FORMAT),"ABGR_8888")
+	LOCAL_CFLAGS += -DRECOVERY_ABGR
+else
+    $(info TARGET_RECOVERY_PIXEL_FORMAT or MR_PIXEL_FORMAT not set or have invalid value)
+endif
+
+ifeq ($(MR_DPI),)
+    $(info MR_DPI not defined in device files)
+else ifeq ($(MR_DPI),hdpi)
+ifeq ($(MR_DPI_MUL),)
+    MR_DPI_MUL := 1
+endif
+else ifeq ($(MR_DPI),xhdpi)
+ifeq ($(MR_DPI_MUL),)
+    MR_DPI_MUL := 1.5
+endif
+else ifeq ($(MR_DPI),xxhdpi)
+ifeq ($(MR_DPI_MUL),)
+    MR_DPI_MUL := 2.0
+endif
+endif
+
+ifeq ($(MR_DPI_FONT),)
+    MR_DPI_FONT := 96
+endif
+
+LOCAL_CFLAGS += -DMR_DPI_FONT=$(MR_DPI_FONT)
+
+ifneq ($(MR_DPI_MUL),)
+    LOCAL_CFLAGS += -DDPI_MUL=$(MR_DPI_MUL)
+else
+    $(info MR_DPI_MUL not defined!)
+endif
+
+ifeq ($(MR_DISABLE_ALPHA),true)
+    LOCAL_CFLAGS += -DMR_DISABLE_ALPHA
+endif
+
+ifneq ($(TW_BRIGHTNESS_PATH),)
+    LOCAL_CFLAGS += -DTW_BRIGHTNESS_PATH=\"$(TW_BRIGHTNESS_PATH)\"
+endif
+
+ifeq ($(TW_SCREEN_BLANK_ON_BOOT), true)
+    LOCAL_CFLAGS += -DTW_SCREEN_BLANK_ON_BOOT
+endif
+
+ifneq ($(MR_DEFAULT_BRIGHTNESS),)
+    LOCAL_CFLAGS += -DMULTIROM_DEFAULT_BRIGHTNESS=\"$(MR_DEFAULT_BRIGHTNESS)\"
+else
+    LOCAL_CFLAGS += -DMULTIROM_DEFAULT_BRIGHTNESS=40
+endif
+
+ifneq ($(MR_KEXEC_MEM_MIN),)
+    LOCAL_CFLAGS += -DMR_KEXEC_MEM_MIN=\"$(MR_KEXEC_MEM_MIN)\"
+else
+    $(info MR_KEXEC_MEM_MIN was not defined in device files!)
+endif
+
+ifeq ($(MR_KEXEC_DTB),true)
+    LOCAL_CFLAGS += -DMR_KEXEC_DTB
+endif
+
+ifeq ($(MR_CONTINUOUS_FB_UPDATE),true)
+    LOCAL_CFLAGS += -DMR_CONTINUOUS_FB_UPDATE
+endif
+
+LOCAL_CFLAGS += -DPLATFORM_SDK_VERSION=$(PLATFORM_SDK_VERSION)
+
+ifeq ($(MR_USE_MROM_FSTAB),true)
+    LOCAL_CFLAGS += -DMR_USE_MROM_FSTAB
+endif
+
+ifeq ($(MR_ENCRYPTION),true)
+    LOCAL_CFLAGS += -DMR_ENCRYPTION
+endif
+
+ifneq ($(MR_RD_ADDR),)
+    LOCAL_CFLAGS += -DMR_RD_ADDR=$(MR_RD_ADDR)
+endif
diff --git a/hooks.h b/hooks.h
index ae124ec..09dd885 100755
--- a/hooks.h
+++ b/hooks.h
@@ -1,46 +1,46 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MR_DEVICE_HOOKS_H
-#define MR_DEVICE_HOOKS_H
-
-#ifdef MR_DEVICE_HOOKS
-
-#if MR_DEVICE_HOOKS >= 1
-int mrom_hook_after_android_mounts(const char *busybox_path, const char *base_path, int type);
-#endif
-
-#if MR_DEVICE_HOOKS >= 2
-void mrom_hook_before_fb_close(void);
-#endif
-
-#if MR_DEVICE_HOOKS >= 3
-void tramp_hook_before_device_init(void);
-#endif
-
-#if MR_DEVICE_HOOKS >= 4
-int mrom_hook_allow_incomplete_fstab(void);
-#endif
-
-#if MR_DEVICE_HOOKS >= 5
-void mrom_hook_fixup_bootimg_cmdline(char *bootimg_cmdline, size_t bootimg_cmdline_cap);
-int mrom_hook_has_kexec(void);
-#endif
-
-#endif /* MR_DEVICE_HOOKS */
-
-#endif /* MR_DEVICE_HOOKS_H */
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MR_DEVICE_HOOKS_H
+#define MR_DEVICE_HOOKS_H
+
+#ifdef MR_DEVICE_HOOKS
+
+#if MR_DEVICE_HOOKS >= 1
+int mrom_hook_after_android_mounts(const char *busybox_path, const char *base_path, int type);
+#endif
+
+#if MR_DEVICE_HOOKS >= 2
+void mrom_hook_before_fb_close(void);
+#endif
+
+#if MR_DEVICE_HOOKS >= 3
+void tramp_hook_before_device_init(void);
+#endif
+
+#if MR_DEVICE_HOOKS >= 4
+int mrom_hook_allow_incomplete_fstab(void);
+#endif
+
+#if MR_DEVICE_HOOKS >= 5
+void mrom_hook_fixup_bootimg_cmdline(char *bootimg_cmdline, size_t bootimg_cmdline_cap);
+int mrom_hook_has_kexec(void);
+#endif
+
+#endif /* MR_DEVICE_HOOKS */
+
+#endif /* MR_DEVICE_HOOKS_H */
diff --git a/install_zip/Android.mk b/install_zip/Android.mk
index b567c3e..3edc3c9 100755
--- a/install_zip/Android.mk
+++ b/install_zip/Android.mk
@@ -1,152 +1,152 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-install_zip_path := $(multirom_local_path)/install_zip
-
-MULTIROM_ZIP_TARGET := $(PRODUCT_OUT)/multirom
-MULTIROM_INST_DIR := $(PRODUCT_OUT)/multirom_installer
-multirom_binary := $(TARGET_ROOT_OUT)/multirom
-trampoline_binary := $(TARGET_ROOT_OUT)/trampoline
-
-ifeq ($(MR_FSTAB),)
-    $(info MR_FSTAB not defined in device files)
-endif
-
-multirom_extra_dep :=
-ifeq ($(MR_ENCRYPTION),true)
-	multirom_extra_dep += trampoline_encmnt linker
-	
-	# ANCLARK MODIFIED on 2017-4-4
-	# Dependency file list for trampoline_encmnt.
-	# NOTICE: Qualcomm devices have their own essential vendor-lib: libcryptfs_hw. This file links to a number of shared libraries.	
-	TRAMPOLINE_ENCMNT_DEPENDENCIES := \
-		libbacktrace.so libbase.so libcryptfslollipop.so \
-		libcrypto.so libc.so libc++.so libcutils.so libdl.so \
-		libhardware.so liblog.so libm.so libunwind.so libutils.so
-	TRAMPOLINE_ENCMNT_DEPENDENCIES_VENDOR := libcryptfs_hw.so
-
-else
-	MR_ENCRYPTION := false
-endif
-
-MR_DEVICES := $(TARGET_DEVICE)
-ifneq ($(MR_DEVICE_VARIANTS),)
-	MR_DEVICES += $(MR_DEVICE_VARIANTS)
-endif
-
-# ANCLARK MODIFIED on 2017-4-7
-# If keymaster switch is turned on, it will be compulsory, or encryption will not work properly.
-ifeq ($(MR_ENCRYPTION), true)
-    ifeq ($(MR_USE_KEYMASTER), true)
-        ifndef MR_KEYMASTER_LIB_PATH
-            $(info *******************************[ E R R O R ! ]*************************************)
-            $(info You must specify the path to keymaster lib in MR_KEYMASTER_LIB_PATH, or encryption won't work.)
-            $(info **********************************************************************************)
-            $(error stop)
-        endif
-    endif
-endif
-
-# ANCLARK MODIFIED on 2017-4-4
-# Qualcomm devices require their own fstab format (fstab.qcom) to work with encryption. 
-# However, this format is not supported by extract_boot_dev.sh. So an exception will occur.
-# To resume making multirom zip, we must prepare another fstab to its appetite.
-ifeq ($(MR_USE_QCOM_SPECIFIED_FSTAB), true)
-    $(info =================================================================================================================)
-    $(info -                                         N O T I C E !)
-    $(info -----------------------------------------------------------------------------------------------------------------)
-    $(info This device uses Qualcomm specified fstab file.)
-    $(info ------ You can know its syntax by reading /fstab.qcom on your device.)
-    $(info =================================================================================================================)
-    ifndef MR_FSTAB_FOR_EXTRACTING_BOOTDEV
-        $(info *******************************[ E R R O R ! ]*************************************)
-        $(info You must specify a standard fstab which Multirom can recognize to generate bootdev info-file. 
-        $(info Set it through var MR_FSTAB_FOR_EXTRACTING_BOOTDEV.)
-        $(info **********************************************************************************)
-        $(error stop)
-    else
-        MR_FSTAB_FOR_EXTRACTING_BOOTDEV := $(MR_FSTAB_FOR_EXTRACTING_BOOTDEV)
-    endif
-else
-    $(info =================================================================================================================)
-    $(info -                                         N O T I C E !)
-    $(info -----------------------------------------------------------------------------------------------------------------)
-    $(info   Now Multirom will directly use mrom.fstab you specified.)
-    $(info   If you use a Qualcomm device with encryption, you may have to specify a fstab written in Qualcomm's format.)
-    $(info   ------ You can know its syntax by reading /fstab.qcom on your device.)
-    $(info =================================================================================================================)
-    MR_FSTAB_FOR_EXTRACTING_BOOTDEV := $(MR_FSTAB)
-endif
-
-
-
-$(MULTIROM_ZIP_TARGET): multirom trampoline signapk bbootimg mrom_kexec_static mrom_adbd $(multirom_extra_dep)
-	@echo
-	@echo
-	@echo "A crowdfunding campaign for MultiROM took place in 2013. These people got perk 'The Tenth':"
-	@echo "    * Bibi"
-	@echo "    * flash5000"
-	@echo "Thank you. See DONORS.md in MultiROM's folder for more informations."
-	@echo
-	@echo
-
-	@echo ----- Making MultiROM ZIP installer ------
-	rm -rf $(MULTIROM_INST_DIR)
-	mkdir -p $(MULTIROM_INST_DIR)
-	cp -a $(install_zip_path)/prebuilt-installer/* $(MULTIROM_INST_DIR)/
-	cp -a $(TARGET_ROOT_OUT)/multirom $(MULTIROM_INST_DIR)/multirom/
-	cp -a $(TARGET_ROOT_OUT)/trampoline $(MULTIROM_INST_DIR)/multirom/
-	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/mrom_kexec_static $(MULTIROM_INST_DIR)/multirom/kexec
-	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/mrom_adbd $(MULTIROM_INST_DIR)/multirom/adbd
-
-	# ANCLARK MODIFIED ON 2017-4-3
-	# Bugfix: All possible dependencies should be added.
-	# NOTICE: Should specify dependency file list above (TRAMPOLINE_ENCMNT_DEPENDENCIES and TRAMPOLINE_ENCMNT_DEPENDENCIES_VENDOR).
-	if $(MR_ENCRYPTION); then \
-		mkdir -p $(MULTIROM_INST_DIR)/multirom/enc/res; \
-		cp -a $(TARGET_ROOT_OUT)/trampoline_encmnt $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_EXECUTABLES)/linker $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(install_zip_path)/prebuilt-installer/multirom/res/Roboto-Regular.ttf $(MULTIROM_INST_DIR)/multirom/enc/res/; \
-		\
-		for f in $(TRAMPOLINE_ENCMNT_DEPENDENCIES); do cp -av $(TARGET_OUT_SHARED_LIBRARIES)/$$f $(MULTIROM_INST_DIR)/multirom/enc/; done; \
-		for f in $(TRAMPOLINE_ENCMNT_DEPENDENCIES_VENDOR); do cp -av $(TARGET_OUT_VENDOR_SHARED_LIBRARIES)/$$f $(MULTIROM_INST_DIR)/multirom/enc/; done; \
-                if [ -e "$(MR_KEYMASTER_LIB_PATH)" ]; then cp -av "$(MR_KEYMASTER_LIB_PATH)" $(MULTIROM_INST_DIR)/multirom/enc/keystore.default.so; fi; \
-		if [ -n "$(MR_ENCRYPTION_SETUP_SCRIPT)" ]; then sh "$(ANDROID_BUILD_TOP)/$(MR_ENCRYPTION_SETUP_SCRIPT)" "$(ANDROID_BUILD_TOP)" "$(MULTIROM_INST_DIR)/multirom/enc"; fi; \
-	fi
-
-	mkdir $(MULTIROM_INST_DIR)/multirom/infos
-	if [ -n "$(MR_INFOS)" ]; then cp -r $(PWD)/$(MR_INFOS)/* $(MULTIROM_INST_DIR)/multirom/infos/; fi
-	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/bbootimg $(MULTIROM_INST_DIR)/scripts/
-	cp $(PWD)/$(MR_FSTAB) $(MULTIROM_INST_DIR)/multirom/mrom.fstab
-	$(install_zip_path)/extract_boot_dev.sh $(PWD)/$(MR_FSTAB_FOR_EXTRACTING_BOOTDEV) $(MULTIROM_INST_DIR)/scripts/bootdev
-	$(install_zip_path)/make_updater_script.sh "$(MR_DEVICES)" $(MULTIROM_INST_DIR)/META-INF/com/google/android "Installing MultiROM for"
-	rm -f $(MULTIROM_ZIP_TARGET).zip $(MULTIROM_ZIP_TARGET)-unsigned.zip
-	cd $(MULTIROM_INST_DIR) && zip -qr ../$(notdir $@)-unsigned.zip *
-	java -jar $(HOST_OUT_JAVA_LIBRARIES)/signapk.jar $(DEFAULT_SYSTEM_DEV_CERTIFICATE).x509.pem $(DEFAULT_SYSTEM_DEV_CERTIFICATE).pk8 $(MULTIROM_ZIP_TARGET)-unsigned.zip $(MULTIROM_ZIP_TARGET).zip
-	$(install_zip_path)/rename_zip.sh $(MULTIROM_ZIP_TARGET) $(TARGET_DEVICE) $(PWD)/$(multirom_local_path)/version.h
-	@echo ----- Made MultiROM ZIP installer -------- $@.zip
-
-.PHONY: multirom_zip
-multirom_zip: $(MULTIROM_ZIP_TARGET)
-
-
-
-MULTIROM_UNINST_TARGET := $(PRODUCT_OUT)/multirom_uninstaller
-MULTIROM_UNINST_DIR := $(PRODUCT_OUT)/multirom_uninstaller
-
-$(MULTIROM_UNINST_TARGET): signapk bbootimg
-	@echo ----- Making MultiROM uninstaller ------
-	rm -rf $(MULTIROM_UNINST_DIR)
-	mkdir -p $(MULTIROM_UNINST_DIR)
-	cp -a $(install_zip_path)/prebuilt-uninstaller/* $(MULTIROM_UNINST_DIR)/
-	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/bbootimg $(MULTIROM_UNINST_DIR)/scripts/
-	$(install_zip_path)/extract_boot_dev.sh $(PWD)/$(MR_FSTAB) $(MULTIROM_UNINST_DIR)/scripts/bootdev
-	echo $(MR_RD_ADDR) > $(MULTIROM_UNINST_DIR)/scripts/rd_addr
-	$(install_zip_path)/make_updater_script.sh "$(MR_DEVICES)" $(MULTIROM_UNINST_DIR)/META-INF/com/google/android "MultiROM uninstaller -"
-	rm -f $(MULTIROM_UNINST_TARGET).zip $(MULTIROM_UNINST_TARGET)-unsigned.zip
-	cd $(MULTIROM_UNINST_DIR) && zip -qr ../$(notdir $@)-unsigned.zip *
-	java -jar $(HOST_OUT_JAVA_LIBRARIES)/signapk.jar $(DEFAULT_SYSTEM_DEV_CERTIFICATE).x509.pem $(DEFAULT_SYSTEM_DEV_CERTIFICATE).pk8 $(MULTIROM_UNINST_TARGET)-unsigned.zip $(MULTIROM_UNINST_TARGET).zip
-	@echo ----- Made MultiROM uninstaller -------- $@.zip
-
-.PHONY: multirom_uninstaller
-multirom_uninstaller: $(MULTIROM_UNINST_TARGET)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+install_zip_path := $(multirom_local_path)/install_zip
+
+MULTIROM_ZIP_TARGET := $(PRODUCT_OUT)/multirom
+MULTIROM_INST_DIR := $(PRODUCT_OUT)/multirom_installer
+multirom_binary := $(TARGET_ROOT_OUT)/multirom
+trampoline_binary := $(TARGET_ROOT_OUT)/trampoline
+
+ifeq ($(MR_FSTAB),)
+    $(info MR_FSTAB not defined in device files)
+endif
+
+multirom_extra_dep :=
+ifeq ($(MR_ENCRYPTION),true)
+	multirom_extra_dep += trampoline_encmnt linker
+	
+	# ANCLARK MODIFIED on 2017-4-4
+	# Dependency file list for trampoline_encmnt.
+	# NOTICE: Qualcomm devices have their own essential vendor-lib: libcryptfs_hw. This file links to a number of shared libraries.	
+	TRAMPOLINE_ENCMNT_DEPENDENCIES := \
+		libbacktrace.so libbase.so libcryptfslollipop.so \
+		libcrypto.so libc.so libc++.so libcutils.so libdl.so \
+		libhardware.so liblog.so libm.so libunwind.so libutils.so
+	TRAMPOLINE_ENCMNT_DEPENDENCIES_VENDOR := libcryptfs_hw.so
+
+else
+	MR_ENCRYPTION := false
+endif
+
+MR_DEVICES := $(TARGET_DEVICE)
+ifneq ($(MR_DEVICE_VARIANTS),)
+	MR_DEVICES += $(MR_DEVICE_VARIANTS)
+endif
+
+# ANCLARK MODIFIED on 2017-4-7
+# If keymaster switch is turned on, it will be compulsory, or encryption will not work properly.
+ifeq ($(MR_ENCRYPTION), true)
+    ifeq ($(MR_USE_KEYMASTER), true)
+        ifndef MR_KEYMASTER_LIB_PATH
+            $(info *******************************[ E R R O R ! ]*************************************)
+            $(info You must specify the path to keymaster lib in MR_KEYMASTER_LIB_PATH, or encryption won't work.)
+            $(info **********************************************************************************)
+            $(error stop)
+        endif
+    endif
+endif
+
+# ANCLARK MODIFIED on 2017-4-4
+# Qualcomm devices require their own fstab format (fstab.qcom) to work with encryption. 
+# However, this format is not supported by extract_boot_dev.sh. So an exception will occur.
+# To resume making multirom zip, we must prepare another fstab to feed its appetite.
+ifeq ($(MR_USE_QCOM_SPECIFIED_FSTAB), true)
+    $(info =================================================================================================================)
+    $(info -                                         N O T I C E !)
+    $(info -----------------------------------------------------------------------------------------------------------------)
+    $(info This device uses Qualcomm specified fstab file.)
+    $(info ------ You can know its syntax by reading /fstab.qcom on your device.)
+    $(info =================================================================================================================)
+    ifndef MR_FSTAB_FOR_EXTRACTING_BOOTDEV
+        $(info *******************************[ E R R O R ! ]*************************************)
+        $(info You must specify a standard fstab which Multirom can recognize to generate bootdev info-file. 
+        $(info Set it through var MR_FSTAB_FOR_EXTRACTING_BOOTDEV.)
+        $(info **********************************************************************************)
+        $(error stop)
+    else
+        MR_FSTAB_FOR_EXTRACTING_BOOTDEV := $(MR_FSTAB_FOR_EXTRACTING_BOOTDEV)
+    endif
+else
+    $(info =================================================================================================================)
+    $(info -                                         N O T I C E !)
+    $(info -----------------------------------------------------------------------------------------------------------------)
+    $(info   Now Multirom will directly use mrom.fstab you specified.)
+    $(info   If you use a Qualcomm device with encryption, you may have to specify a fstab written in Qualcomm's format.)
+    $(info   ------ You can know its syntax by reading /fstab.qcom on your device.)
+    $(info =================================================================================================================)
+    MR_FSTAB_FOR_EXTRACTING_BOOTDEV := $(MR_FSTAB)
+endif
+
+
+
+$(MULTIROM_ZIP_TARGET): multirom trampoline signapk bbootimg mrom_kexec_static mrom_adbd $(multirom_extra_dep)
+	@echo
+	@echo
+	@echo "A crowdfunding campaign for MultiROM took place in 2013. These people got perk 'The Tenth':"
+	@echo "    * Bibi"
+	@echo "    * flash5000"
+	@echo "Thank you. See DONORS.md in MultiROM's folder for more informations."
+	@echo
+	@echo
+
+	@echo ----- Making MultiROM ZIP installer ------
+	rm -rf $(MULTIROM_INST_DIR)
+	mkdir -p $(MULTIROM_INST_DIR)
+	cp -a $(install_zip_path)/prebuilt-installer/* $(MULTIROM_INST_DIR)/
+	cp -a $(TARGET_ROOT_OUT)/multirom $(MULTIROM_INST_DIR)/multirom/
+	cp -a $(TARGET_ROOT_OUT)/trampoline $(MULTIROM_INST_DIR)/multirom/
+	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/mrom_kexec_static $(MULTIROM_INST_DIR)/multirom/kexec
+	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/mrom_adbd $(MULTIROM_INST_DIR)/multirom/adbd
+
+	# ANCLARK MODIFIED ON 2017-4-3
+	# Bugfix: All possible dependencies should be added.
+	# NOTICE: Should specify dependency file list above (TRAMPOLINE_ENCMNT_DEPENDENCIES and TRAMPOLINE_ENCMNT_DEPENDENCIES_VENDOR).
+	if $(MR_ENCRYPTION); then \
+		mkdir -p $(MULTIROM_INST_DIR)/multirom/enc/res; \
+		cp -a $(TARGET_ROOT_OUT)/trampoline_encmnt $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_EXECUTABLES)/linker $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(install_zip_path)/prebuilt-installer/multirom/res/Roboto-Regular.ttf $(MULTIROM_INST_DIR)/multirom/enc/res/; \
+		\
+		for f in $(TRAMPOLINE_ENCMNT_DEPENDENCIES); do cp -av $(TARGET_OUT_SHARED_LIBRARIES)/$$f $(MULTIROM_INST_DIR)/multirom/enc/; done; \
+		for f in $(TRAMPOLINE_ENCMNT_DEPENDENCIES_VENDOR); do cp -av $(TARGET_OUT_VENDOR_SHARED_LIBRARIES)/$$f $(MULTIROM_INST_DIR)/multirom/enc/; done; \
+                if [ -e "$(MR_KEYMASTER_LIB_PATH)" ]; then cp -av "$(MR_KEYMASTER_LIB_PATH)" $(MULTIROM_INST_DIR)/multirom/enc/keystore.default.so; fi; \
+		if [ -n "$(MR_ENCRYPTION_SETUP_SCRIPT)" ]; then sh "$(ANDROID_BUILD_TOP)/$(MR_ENCRYPTION_SETUP_SCRIPT)" "$(ANDROID_BUILD_TOP)" "$(MULTIROM_INST_DIR)/multirom/enc"; fi; \
+	fi
+
+	mkdir $(MULTIROM_INST_DIR)/multirom/infos
+	if [ -n "$(MR_INFOS)" ]; then cp -r $(PWD)/$(MR_INFOS)/* $(MULTIROM_INST_DIR)/multirom/infos/; fi
+	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/bbootimg $(MULTIROM_INST_DIR)/scripts/
+	cp $(PWD)/$(MR_FSTAB) $(MULTIROM_INST_DIR)/multirom/mrom.fstab
+	$(install_zip_path)/extract_boot_dev.sh $(PWD)/$(MR_FSTAB_FOR_EXTRACTING_BOOTDEV) $(MULTIROM_INST_DIR)/scripts/bootdev
+	$(install_zip_path)/make_updater_script.sh "$(MR_DEVICES)" $(MULTIROM_INST_DIR)/META-INF/com/google/android "Installing MultiROM for"
+	rm -f $(MULTIROM_ZIP_TARGET).zip $(MULTIROM_ZIP_TARGET)-unsigned.zip
+	cd $(MULTIROM_INST_DIR) && zip -qr ../$(notdir $@)-unsigned.zip *
+	java -jar $(HOST_OUT_JAVA_LIBRARIES)/signapk.jar $(DEFAULT_SYSTEM_DEV_CERTIFICATE).x509.pem $(DEFAULT_SYSTEM_DEV_CERTIFICATE).pk8 $(MULTIROM_ZIP_TARGET)-unsigned.zip $(MULTIROM_ZIP_TARGET).zip
+	$(install_zip_path)/rename_zip.sh $(MULTIROM_ZIP_TARGET) $(TARGET_DEVICE) $(PWD)/$(multirom_local_path)/version.h
+	@echo ----- Made MultiROM ZIP installer -------- $@.zip
+
+.PHONY: multirom_zip
+multirom_zip: $(MULTIROM_ZIP_TARGET)
+
+
+
+MULTIROM_UNINST_TARGET := $(PRODUCT_OUT)/multirom_uninstaller
+MULTIROM_UNINST_DIR := $(PRODUCT_OUT)/multirom_uninstaller
+
+$(MULTIROM_UNINST_TARGET): signapk bbootimg
+	@echo ----- Making MultiROM uninstaller ------
+	rm -rf $(MULTIROM_UNINST_DIR)
+	mkdir -p $(MULTIROM_UNINST_DIR)
+	cp -a $(install_zip_path)/prebuilt-uninstaller/* $(MULTIROM_UNINST_DIR)/
+	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/bbootimg $(MULTIROM_UNINST_DIR)/scripts/
+	$(install_zip_path)/extract_boot_dev.sh $(PWD)/$(MR_FSTAB) $(MULTIROM_UNINST_DIR)/scripts/bootdev
+	echo $(MR_RD_ADDR) > $(MULTIROM_UNINST_DIR)/scripts/rd_addr
+	$(install_zip_path)/make_updater_script.sh "$(MR_DEVICES)" $(MULTIROM_UNINST_DIR)/META-INF/com/google/android "MultiROM uninstaller -"
+	rm -f $(MULTIROM_UNINST_TARGET).zip $(MULTIROM_UNINST_TARGET)-unsigned.zip
+	cd $(MULTIROM_UNINST_DIR) && zip -qr ../$(notdir $@)-unsigned.zip *
+	java -jar $(HOST_OUT_JAVA_LIBRARIES)/signapk.jar $(DEFAULT_SYSTEM_DEV_CERTIFICATE).x509.pem $(DEFAULT_SYSTEM_DEV_CERTIFICATE).pk8 $(MULTIROM_UNINST_TARGET)-unsigned.zip $(MULTIROM_UNINST_TARGET).zip
+	@echo ----- Made MultiROM uninstaller -------- $@.zip
+
+.PHONY: multirom_uninstaller
+multirom_uninstaller: $(MULTIROM_UNINST_TARGET)
diff --git a/install_zip/Android.mk.bak b/install_zip/Android.mk.bak
index 67f864e..b270625 100755
--- a/install_zip/Android.mk.bak
+++ b/install_zip/Android.mk.bak
@@ -1,100 +1,100 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-install_zip_path := $(multirom_local_path)/install_zip
-
-MULTIROM_ZIP_TARGET := $(PRODUCT_OUT)/multirom
-MULTIROM_INST_DIR := $(PRODUCT_OUT)/multirom_installer
-multirom_binary := $(TARGET_ROOT_OUT)/multirom
-trampoline_binary := $(TARGET_ROOT_OUT)/trampoline
-
-ifeq ($(MR_FSTAB),)
-    $(info MR_FSTAB not defined in device files)
-endif
-
-multirom_extra_dep :=
-ifeq ($(MR_ENCRYPTION),true)
-	multirom_extra_dep += trampoline_encmnt linker
-else
-	MR_ENCRYPTION := false
-endif
-
-MR_DEVICES := $(TARGET_DEVICE)
-ifneq ($(MR_DEVICE_VARIANTS),)
-	MR_DEVICES += $(MR_DEVICE_VARIANTS)
-endif
-
-$(MULTIROM_ZIP_TARGET): multirom trampoline signapk bbootimg mrom_kexec_static mrom_adbd $(multirom_extra_dep)
-	@echo
-	@echo
-	@echo "A crowdfunding campaign for MultiROM took place in 2013. These people got perk 'The Tenth':"
-	@echo "    * Bibi"
-	@echo "    * flash5000"
-	@echo "Thank you. See DONORS.md in MultiROM's folder for more informations."
-	@echo
-	@echo
-
-	@echo ----- Making MultiROM ZIP installer ------
-	rm -rf $(MULTIROM_INST_DIR)
-	mkdir -p $(MULTIROM_INST_DIR)
-	cp -a $(install_zip_path)/prebuilt-installer/* $(MULTIROM_INST_DIR)/
-	cp -a $(TARGET_ROOT_OUT)/multirom $(MULTIROM_INST_DIR)/multirom/
-	cp -a $(TARGET_ROOT_OUT)/trampoline $(MULTIROM_INST_DIR)/multirom/
-	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/mrom_kexec_static $(MULTIROM_INST_DIR)/multirom/kexec
-	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/mrom_adbd $(MULTIROM_INST_DIR)/multirom/adbd
-
-	if $(MR_ENCRYPTION); then \
-		mkdir -p $(MULTIROM_INST_DIR)/multirom/enc/res; \
-		cp -a $(TARGET_ROOT_OUT)/trampoline_encmnt $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_EXECUTABLES)/linker $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(install_zip_path)/prebuilt-installer/multirom/res/Roboto-Regular.ttf $(MULTIROM_INST_DIR)/multirom/enc/res/; \
-		\
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libcryptfslollipop.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libcrypto.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libc.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libcutils.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libdl.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libhardware.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/liblog.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libm.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libstdc++.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libc++.so $(MULTIROM_INST_DIR)/multirom/enc/; \
-		if [ -n "$(MR_ENCRYPTION_SETUP_SCRIPT)" ]; then sh "$(ANDROID_BUILD_TOP)/$(MR_ENCRYPTION_SETUP_SCRIPT)" "$(ANDROID_BUILD_TOP)" "$(MULTIROM_INST_DIR)/multirom/enc"; fi; \
-	fi
-
-	mkdir $(MULTIROM_INST_DIR)/multirom/infos
-	if [ -n "$(MR_INFOS)" ]; then cp -r $(PWD)/$(MR_INFOS)/* $(MULTIROM_INST_DIR)/multirom/infos/; fi
-	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/bbootimg $(MULTIROM_INST_DIR)/scripts/
-	cp $(PWD)/$(MR_FSTAB) $(MULTIROM_INST_DIR)/multirom/mrom.fstab
-	$(install_zip_path)/extract_boot_dev.sh $(PWD)/$(MR_FSTAB) $(MULTIROM_INST_DIR)/scripts/bootdev
-	$(install_zip_path)/make_updater_script.sh "$(MR_DEVICES)" $(MULTIROM_INST_DIR)/META-INF/com/google/android "Installing MultiROM for"
-	rm -f $(MULTIROM_ZIP_TARGET).zip $(MULTIROM_ZIP_TARGET)-unsigned.zip
-	cd $(MULTIROM_INST_DIR) && zip -qr ../$(notdir $@)-unsigned.zip *
-	java -jar $(HOST_OUT_JAVA_LIBRARIES)/signapk.jar $(DEFAULT_SYSTEM_DEV_CERTIFICATE).x509.pem $(DEFAULT_SYSTEM_DEV_CERTIFICATE).pk8 $(MULTIROM_ZIP_TARGET)-unsigned.zip $(MULTIROM_ZIP_TARGET).zip
-	$(install_zip_path)/rename_zip.sh $(MULTIROM_ZIP_TARGET) $(TARGET_DEVICE) $(PWD)/$(multirom_local_path)/version.h
-	@echo ----- Made MultiROM ZIP installer -------- $@.zip
-
-.PHONY: multirom_zip
-multirom_zip: $(MULTIROM_ZIP_TARGET)
-
-
-
-MULTIROM_UNINST_TARGET := $(PRODUCT_OUT)/multirom_uninstaller
-MULTIROM_UNINST_DIR := $(PRODUCT_OUT)/multirom_uninstaller
-
-$(MULTIROM_UNINST_TARGET): signapk bbootimg
-	@echo ----- Making MultiROM uninstaller ------
-	rm -rf $(MULTIROM_UNINST_DIR)
-	mkdir -p $(MULTIROM_UNINST_DIR)
-	cp -a $(install_zip_path)/prebuilt-uninstaller/* $(MULTIROM_UNINST_DIR)/
-	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/bbootimg $(MULTIROM_UNINST_DIR)/scripts/
-	$(install_zip_path)/extract_boot_dev.sh $(PWD)/$(MR_FSTAB) $(MULTIROM_UNINST_DIR)/scripts/bootdev
-	echo $(MR_RD_ADDR) > $(MULTIROM_UNINST_DIR)/scripts/rd_addr
-	$(install_zip_path)/make_updater_script.sh "$(MR_DEVICES)" $(MULTIROM_UNINST_DIR)/META-INF/com/google/android "MultiROM uninstaller -"
-	rm -f $(MULTIROM_UNINST_TARGET).zip $(MULTIROM_UNINST_TARGET)-unsigned.zip
-	cd $(MULTIROM_UNINST_DIR) && zip -qr ../$(notdir $@)-unsigned.zip *
-	java -jar $(HOST_OUT_JAVA_LIBRARIES)/signapk.jar $(DEFAULT_SYSTEM_DEV_CERTIFICATE).x509.pem $(DEFAULT_SYSTEM_DEV_CERTIFICATE).pk8 $(MULTIROM_UNINST_TARGET)-unsigned.zip $(MULTIROM_UNINST_TARGET).zip
-	@echo ----- Made MultiROM uninstaller -------- $@.zip
-
-.PHONY: multirom_uninstaller
-multirom_uninstaller: $(MULTIROM_UNINST_TARGET)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+install_zip_path := $(multirom_local_path)/install_zip
+
+MULTIROM_ZIP_TARGET := $(PRODUCT_OUT)/multirom
+MULTIROM_INST_DIR := $(PRODUCT_OUT)/multirom_installer
+multirom_binary := $(TARGET_ROOT_OUT)/multirom
+trampoline_binary := $(TARGET_ROOT_OUT)/trampoline
+
+ifeq ($(MR_FSTAB),)
+    $(info MR_FSTAB not defined in device files)
+endif
+
+multirom_extra_dep :=
+ifeq ($(MR_ENCRYPTION),true)
+	multirom_extra_dep += trampoline_encmnt linker
+else
+	MR_ENCRYPTION := false
+endif
+
+MR_DEVICES := $(TARGET_DEVICE)
+ifneq ($(MR_DEVICE_VARIANTS),)
+	MR_DEVICES += $(MR_DEVICE_VARIANTS)
+endif
+
+$(MULTIROM_ZIP_TARGET): multirom trampoline signapk bbootimg mrom_kexec_static mrom_adbd $(multirom_extra_dep)
+	@echo
+	@echo
+	@echo "A crowdfunding campaign for MultiROM took place in 2013. These people got perk 'The Tenth':"
+	@echo "    * Bibi"
+	@echo "    * flash5000"
+	@echo "Thank you. See DONORS.md in MultiROM's folder for more informations."
+	@echo
+	@echo
+
+	@echo ----- Making MultiROM ZIP installer ------
+	rm -rf $(MULTIROM_INST_DIR)
+	mkdir -p $(MULTIROM_INST_DIR)
+	cp -a $(install_zip_path)/prebuilt-installer/* $(MULTIROM_INST_DIR)/
+	cp -a $(TARGET_ROOT_OUT)/multirom $(MULTIROM_INST_DIR)/multirom/
+	cp -a $(TARGET_ROOT_OUT)/trampoline $(MULTIROM_INST_DIR)/multirom/
+	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/mrom_kexec_static $(MULTIROM_INST_DIR)/multirom/kexec
+	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/mrom_adbd $(MULTIROM_INST_DIR)/multirom/adbd
+
+	if $(MR_ENCRYPTION); then \
+		mkdir -p $(MULTIROM_INST_DIR)/multirom/enc/res; \
+		cp -a $(TARGET_ROOT_OUT)/trampoline_encmnt $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_EXECUTABLES)/linker $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(install_zip_path)/prebuilt-installer/multirom/res/Roboto-Regular.ttf $(MULTIROM_INST_DIR)/multirom/enc/res/; \
+		\
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libcryptfslollipop.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libcrypto.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libc.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libcutils.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libdl.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libhardware.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/liblog.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libm.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libstdc++.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		cp -a $(TARGET_OUT_SHARED_LIBRARIES)/libc++.so $(MULTIROM_INST_DIR)/multirom/enc/; \
+		if [ -n "$(MR_ENCRYPTION_SETUP_SCRIPT)" ]; then sh "$(ANDROID_BUILD_TOP)/$(MR_ENCRYPTION_SETUP_SCRIPT)" "$(ANDROID_BUILD_TOP)" "$(MULTIROM_INST_DIR)/multirom/enc"; fi; \
+	fi
+
+	mkdir $(MULTIROM_INST_DIR)/multirom/infos
+	if [ -n "$(MR_INFOS)" ]; then cp -r $(PWD)/$(MR_INFOS)/* $(MULTIROM_INST_DIR)/multirom/infos/; fi
+	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/bbootimg $(MULTIROM_INST_DIR)/scripts/
+	cp $(PWD)/$(MR_FSTAB) $(MULTIROM_INST_DIR)/multirom/mrom.fstab
+	$(install_zip_path)/extract_boot_dev.sh $(PWD)/$(MR_FSTAB) $(MULTIROM_INST_DIR)/scripts/bootdev
+	$(install_zip_path)/make_updater_script.sh "$(MR_DEVICES)" $(MULTIROM_INST_DIR)/META-INF/com/google/android "Installing MultiROM for"
+	rm -f $(MULTIROM_ZIP_TARGET).zip $(MULTIROM_ZIP_TARGET)-unsigned.zip
+	cd $(MULTIROM_INST_DIR) && zip -qr ../$(notdir $@)-unsigned.zip *
+	java -jar $(HOST_OUT_JAVA_LIBRARIES)/signapk.jar $(DEFAULT_SYSTEM_DEV_CERTIFICATE).x509.pem $(DEFAULT_SYSTEM_DEV_CERTIFICATE).pk8 $(MULTIROM_ZIP_TARGET)-unsigned.zip $(MULTIROM_ZIP_TARGET).zip
+	$(install_zip_path)/rename_zip.sh $(MULTIROM_ZIP_TARGET) $(TARGET_DEVICE) $(PWD)/$(multirom_local_path)/version.h
+	@echo ----- Made MultiROM ZIP installer -------- $@.zip
+
+.PHONY: multirom_zip
+multirom_zip: $(MULTIROM_ZIP_TARGET)
+
+
+
+MULTIROM_UNINST_TARGET := $(PRODUCT_OUT)/multirom_uninstaller
+MULTIROM_UNINST_DIR := $(PRODUCT_OUT)/multirom_uninstaller
+
+$(MULTIROM_UNINST_TARGET): signapk bbootimg
+	@echo ----- Making MultiROM uninstaller ------
+	rm -rf $(MULTIROM_UNINST_DIR)
+	mkdir -p $(MULTIROM_UNINST_DIR)
+	cp -a $(install_zip_path)/prebuilt-uninstaller/* $(MULTIROM_UNINST_DIR)/
+	cp -a $(TARGET_OUT_OPTIONAL_EXECUTABLES)/bbootimg $(MULTIROM_UNINST_DIR)/scripts/
+	$(install_zip_path)/extract_boot_dev.sh $(PWD)/$(MR_FSTAB) $(MULTIROM_UNINST_DIR)/scripts/bootdev
+	echo $(MR_RD_ADDR) > $(MULTIROM_UNINST_DIR)/scripts/rd_addr
+	$(install_zip_path)/make_updater_script.sh "$(MR_DEVICES)" $(MULTIROM_UNINST_DIR)/META-INF/com/google/android "MultiROM uninstaller -"
+	rm -f $(MULTIROM_UNINST_TARGET).zip $(MULTIROM_UNINST_TARGET)-unsigned.zip
+	cd $(MULTIROM_UNINST_DIR) && zip -qr ../$(notdir $@)-unsigned.zip *
+	java -jar $(HOST_OUT_JAVA_LIBRARIES)/signapk.jar $(DEFAULT_SYSTEM_DEV_CERTIFICATE).x509.pem $(DEFAULT_SYSTEM_DEV_CERTIFICATE).pk8 $(MULTIROM_UNINST_TARGET)-unsigned.zip $(MULTIROM_UNINST_TARGET).zip
+	@echo ----- Made MultiROM uninstaller -------- $@.zip
+
+.PHONY: multirom_uninstaller
+multirom_uninstaller: $(MULTIROM_UNINST_TARGET)
diff --git a/install_zip/README.md b/install_zip/README.md
index 25d4a0c..788e9ae 100755
--- a/install_zip/README.md
+++ b/install_zip/README.md
@@ -1,9 +1,9 @@
-# MultiROM ZIP installer
-This folder contains prebuilt part of the ZIP installer for MultiROM - the file
-which is flashed in recovery and it installs MultiROM to the device.
-
-To build the ZIP file, use target `multirom_zip`.
-
-    make multirom_zip
-
-The zip file is automatically signed with testkey.
+# MultiROM ZIP installer
+This folder contains prebuilt part of the ZIP installer for MultiROM - the file
+which is flashed in recovery and it installs MultiROM to the device.
+
+To build the ZIP file, use target `multirom_zip`.
+
+    make multirom_zip
+
+The zip file is automatically signed with testkey.
diff --git a/install_zip/prebuilt-installer/multirom/res/OxygenMono-LICENSE_OFL.txt b/install_zip/prebuilt-installer/multirom/res/OxygenMono-LICENSE_OFL.txt
index 905e1d6..31f9967 100755
--- a/install_zip/prebuilt-installer/multirom/res/OxygenMono-LICENSE_OFL.txt
+++ b/install_zip/prebuilt-installer/multirom/res/OxygenMono-LICENSE_OFL.txt
@@ -1,92 +1,92 @@
-Copyright (c) 2012, vernon adams (vern@newtypography.co.uk), with Reserved Font Names 'Oxygen'
-This Font Software is licensed under the SIL Open Font License, Version 1.1.
-This license is copied below, and is also available with a FAQ at:
-http://scripts.sil.org/OFL
-
-
------------------------------------------------------------
-SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
------------------------------------------------------------
-
-PREAMBLE
-The goals of the Open Font License (OFL) are to stimulate worldwide
-development of collaborative font projects, to support the font creation
-efforts of academic and linguistic communities, and to provide a free and
-open framework in which fonts may be shared and improved in partnership
-with others.
-
-The OFL allows the licensed fonts to be used, studied, modified and
-redistributed freely as long as they are not sold by themselves. The
-fonts, including any derivative works, can be bundled, embedded, 
-redistributed and/or sold with any software provided that any reserved
-names are not used by derivative works. The fonts and derivatives,
-however, cannot be released under any other type of license. The
-requirement for fonts to remain under this license does not apply
-to any document created using the fonts or their derivatives.
-
-DEFINITIONS
-"Font Software" refers to the set of files released by the Copyright
-Holder(s) under this license and clearly marked as such. This may
-include source files, build scripts and documentation.
-
-"Reserved Font Name" refers to any names specified as such after the
-copyright statement(s).
-
-"Original Version" refers to the collection of Font Software components as
-distributed by the Copyright Holder(s).
-
-"Modified Version" refers to any derivative made by adding to, deleting,
-or substituting -- in part or in whole -- any of the components of the
-Original Version, by changing formats or by porting the Font Software to a
-new environment.
-
-"Author" refers to any designer, engineer, programmer, technical
-writer or other person who contributed to the Font Software.
-
-PERMISSION & CONDITIONS
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of the Font Software, to use, study, copy, merge, embed, modify,
-redistribute, and sell modified and unmodified copies of the Font
-Software, subject to the following conditions:
-
-1) Neither the Font Software nor any of its individual components,
-in Original or Modified Versions, may be sold by itself.
-
-2) Original or Modified Versions of the Font Software may be bundled,
-redistributed and/or sold with any software, provided that each copy
-contains the above copyright notice and this license. These can be
-included either as stand-alone text files, human-readable headers or
-in the appropriate machine-readable metadata fields within text or
-binary files as long as those fields can be easily viewed by the user.
-
-3) No Modified Version of the Font Software may use the Reserved Font
-Name(s) unless explicit written permission is granted by the corresponding
-Copyright Holder. This restriction only applies to the primary font name as
-presented to the users.
-
-4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
-Software shall not be used to promote, endorse or advertise any
-Modified Version, except to acknowledge the contribution(s) of the
-Copyright Holder(s) and the Author(s) or with their explicit written
-permission.
-
-5) The Font Software, modified or unmodified, in part or in whole,
-must be distributed entirely under this license, and must not be
-distributed under any other license. The requirement for fonts to
-remain under this license does not apply to any document created
-using the Font Software.
-
-TERMINATION
-This license becomes null and void if any of the above conditions are
-not met.
-
-DISCLAIMER
-THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
-OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
-COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
-DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
-OTHER DEALINGS IN THE FONT SOFTWARE.
+Copyright (c) 2012, vernon adams (vern@newtypography.co.uk), with Reserved Font Names 'Oxygen'
+This Font Software is licensed under the SIL Open Font License, Version 1.1.
+This license is copied below, and is also available with a FAQ at:
+http://scripts.sil.org/OFL
+
+
+-----------------------------------------------------------
+SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
+-----------------------------------------------------------
+
+PREAMBLE
+The goals of the Open Font License (OFL) are to stimulate worldwide
+development of collaborative font projects, to support the font creation
+efforts of academic and linguistic communities, and to provide a free and
+open framework in which fonts may be shared and improved in partnership
+with others.
+
+The OFL allows the licensed fonts to be used, studied, modified and
+redistributed freely as long as they are not sold by themselves. The
+fonts, including any derivative works, can be bundled, embedded, 
+redistributed and/or sold with any software provided that any reserved
+names are not used by derivative works. The fonts and derivatives,
+however, cannot be released under any other type of license. The
+requirement for fonts to remain under this license does not apply
+to any document created using the fonts or their derivatives.
+
+DEFINITIONS
+"Font Software" refers to the set of files released by the Copyright
+Holder(s) under this license and clearly marked as such. This may
+include source files, build scripts and documentation.
+
+"Reserved Font Name" refers to any names specified as such after the
+copyright statement(s).
+
+"Original Version" refers to the collection of Font Software components as
+distributed by the Copyright Holder(s).
+
+"Modified Version" refers to any derivative made by adding to, deleting,
+or substituting -- in part or in whole -- any of the components of the
+Original Version, by changing formats or by porting the Font Software to a
+new environment.
+
+"Author" refers to any designer, engineer, programmer, technical
+writer or other person who contributed to the Font Software.
+
+PERMISSION & CONDITIONS
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of the Font Software, to use, study, copy, merge, embed, modify,
+redistribute, and sell modified and unmodified copies of the Font
+Software, subject to the following conditions:
+
+1) Neither the Font Software nor any of its individual components,
+in Original or Modified Versions, may be sold by itself.
+
+2) Original or Modified Versions of the Font Software may be bundled,
+redistributed and/or sold with any software, provided that each copy
+contains the above copyright notice and this license. These can be
+included either as stand-alone text files, human-readable headers or
+in the appropriate machine-readable metadata fields within text or
+binary files as long as those fields can be easily viewed by the user.
+
+3) No Modified Version of the Font Software may use the Reserved Font
+Name(s) unless explicit written permission is granted by the corresponding
+Copyright Holder. This restriction only applies to the primary font name as
+presented to the users.
+
+4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
+Software shall not be used to promote, endorse or advertise any
+Modified Version, except to acknowledge the contribution(s) of the
+Copyright Holder(s) and the Author(s) or with their explicit written
+permission.
+
+5) The Font Software, modified or unmodified, in part or in whole,
+must be distributed entirely under this license, and must not be
+distributed under any other license. The requirement for fonts to
+remain under this license does not apply to any document created
+using the Font Software.
+
+TERMINATION
+This license becomes null and void if any of the above conditions are
+not met.
+
+DISCLAIMER
+THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
+COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
+DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
+OTHER DEALINGS IN THE FONT SOFTWARE.
diff --git a/install_zip/prebuilt-installer/multirom/ubuntu-init/init b/install_zip/prebuilt-installer/multirom/ubuntu-init/init
index 89643f2..1c4880e 100755
--- a/install_zip/prebuilt-installer/multirom/ubuntu-init/init
+++ b/install_zip/prebuilt-installer/multirom/ubuntu-init/init
@@ -1,357 +1,357 @@
-#!/bin/sh
-
-[ -d /dev ] || mkdir -m 0755 /dev
-[ -d /root ] || mkdir -m 0700 /root
-[ -d /sys ] || mkdir /sys
-[ -d /proc ] || mkdir /proc
-[ -d /tmp ] || mkdir /tmp
-mkdir -p /var/lock
-mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
-mount -t proc -o nodev,noexec,nosuid proc /proc
-# Some things don't work properly without /etc/mtab.
-ln -sf /proc/mounts /etc/mtab
-
-grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."
-
-# Note that this only becomes /dev on the real filesystem if udev's scripts
-# are used; which they will be, but it's worth pointing out
-if ! mount -t devtmpfs -o mode=0755 udev /dev; then
-	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
-	mount -t tmpfs -o mode=0755 udev /dev
-	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
-	[ -e /dev/null ] || mknod /dev/null c 1 3
-fi
-mkdir /dev/pts
-mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
-mount -t tmpfs -o "noexec,nosuid,size=10%,mode=0755" tmpfs /run
-mkdir /run/initramfs
-# compatibility symlink for the pre-oneiric locations
-ln -s /run/initramfs /dev/.initramfs
-
-# Export the dpkg architecture
-export DPKG_ARCH=
-. /conf/arch.conf
-
-# Set modprobe env
-export MODPROBE_OPTIONS="-qb"
-
-# Export relevant variables
-export ROOT=
-export ROOTDELAY=
-export ROOTFLAGS=
-export ROOTFSTYPE=
-export IP=
-export BOOT=
-export BOOTIF=
-export UBIMTD=
-export break=
-export init=/sbin/init
-export quiet=n
-export readonly=y
-export rootmnt=/root
-export debug=
-export panic=
-export blacklist=
-export resume=
-export resume_offset=
-export recovery=
-export FLASH_KERNEL_SKIP=1
-
-# mdadm needs hostname to be set. This has to be done before the udev rules are called!
-if [ -f "/etc/hostname" ]; then
-        /bin/hostname -b -F /etc/hostname 2>&1 1>/dev/null
-fi
-
-# Bring in the main config
-. /conf/initramfs.conf
-for conf in conf/conf.d/*; do
-	[ -f ${conf} ] && . ${conf}
-done
-. /scripts/functions
-
-# Parse command line options
-for x in $(cat /proc/cmdline); do
-	case $x in
-	init=*)
-		init=${x#init=}
-		;;
-	root=*)
-		ROOT=${x#root=}
-		case $ROOT in
-		LABEL=*)
-			ROOT="${ROOT#LABEL=}"
-
-			# support any / in LABEL= path (escape to \x2f)
-			case "${ROOT}" in
-			*/*)
-			if command -v sed >/dev/null 2>&1; then
-				ROOT="$(echo ${ROOT} | sed 's,/,\\x2f,g')"
-			else
-				if [ "${ROOT}" != "${ROOT#/}" ]; then
-					ROOT="\x2f${ROOT#/}"
-				fi
-				if [ "${ROOT}" != "${ROOT%/}" ]; then
-					ROOT="${ROOT%/}\x2f"
-				fi
-				IFS='/'
-				newroot=
-				for s in $ROOT; do
-					newroot="${newroot:+${newroot}\\x2f}${s}"
-				done
-				unset IFS
-				ROOT="${newroot}"
-			fi
-			esac
-			ROOT="/dev/disk/by-label/${ROOT}"
-			;;
-		UUID=*)
-			ROOT="/dev/disk/by-uuid/${ROOT#UUID=}"
-			;;
-		/dev/nfs)
-			[ -z "${BOOT}" ] && BOOT=nfs
-			;;
-		esac
-		;;
-	rootflags=*)
-		ROOTFLAGS="-o ${x#rootflags=}"
-		;;
-	rootfstype=*)
-		ROOTFSTYPE="${x#rootfstype=}"
-		;;
-	rootdelay=*)
-		ROOTDELAY="${x#rootdelay=}"
-		case ${ROOTDELAY} in
-		*[![:digit:].]*)
-			ROOTDELAY=
-			;;
-		esac
-		;;
-	resumedelay=*)
-		RESUMEDELAY="${x#resumedelay=}"
-		;;
-	loop=*)
-		LOOP="${x#loop=}"
-		;;
-	loopflags=*)
-		LOOPFLAGS="-o ${x#loopflags=}"
-		;;
-	loopfstype=*)
-		LOOPFSTYPE="${x#loopfstype=}"
-		;;
-	rootsubdir=*)
-		ROOTSUBDIR="${x#rootsubdir=}"
-		;;
-	cryptopts=*)
-		cryptopts="${x#cryptopts=}"
-		;;
-	nfsroot=*)
-		NFSROOT="${x#nfsroot=}"
-		;;
-	netboot=*)
-		NETBOOT="${x#netboot=}"
-		;;
-	ip=*)
-		IP="${x#ip=}"
-		;;
-	boot=*)
-		BOOT=${x#boot=}
-		;;
-	ubi.mtd=*)
-		UBIMTD=${x#ubi.mtd=}
-		;;
-	resume=*)
-		RESUME="${x#resume=}"
-		;;
-	resume_offset=*)
-		resume_offset="${x#resume_offset=}"
-		;;
-	noresume)
-		noresume=y
-		;;
-	panic=*)
-		panic="${x#panic=}"
-		case ${panic} in
-		*[![:digit:].]*)
-			panic=
-			;;
-		esac
-		;;
-	quiet)
-		quiet=y
-		;;
-	ro)
-		readonly=y
-		;;
-	rw)
-		readonly=n
-		;;
-	debug)
-		debug=y
-		quiet=n
-		exec >/run/initramfs/initramfs.debug 2>&1
-		set -x
-		;;
-	debug=*)
-		debug=y
-		quiet=n
-		set -x
-		;;
-	break=*)
-		break=${x#break=}
-		;;
-	break)
-		break=premount
-		;;
-	blacklist=*)
-		blacklist=${x#blacklist=}
-		;;
-	netconsole=*)
-		netconsole=${x#netconsole=}
-		;;
-	BOOTIF=*)
-		BOOTIF=${x#BOOTIF=}
-		;;
-	hwaddr=*)
-		BOOTIF=${x#BOOTIF=}
-		;;
-	recovery)
-		recovery=y
-		;;
-	esac
-done
-
-if [ -n "${noresume}" ]; then
-	export noresume
-	unset resume
-else
-	resume=${RESUME:-}
-fi
-
-maybe_break top
-
-# export BOOT variable value for compcache,
-# so we know if we run from casper
-export BOOT
-
-# Don't do log messages here to avoid confusing graphical boots
-run_scripts /scripts/init-top
-
-maybe_break modules
-[ "$quiet" != "y" ] && log_begin_msg "Loading essential drivers"
-load_modules
-[ "$quiet" != "y" ] && log_end_msg
-
-[ -n "${netconsole}" ] && modprobe netconsole netconsole="${netconsole}"
-
-maybe_break premount
-[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-premount"
-run_scripts /scripts/init-premount
-[ "$quiet" != "y" ] && log_end_msg
-
-maybe_break mount
-log_begin_msg "Mounting root file system"
-. /scripts/${BOOT}
-parse_numeric ${ROOT}
-maybe_break mountroot
-mountroot
-log_end_msg
-
-maybe_break bottom
-[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-bottom"
-run_scripts /scripts/init-bottom
-[ "$quiet" != "y" ] && log_end_msg
-
-# Preserve information on old systems without /run on the rootfs
-if [ -d ${rootmnt}/run ]; then
-	mount -n -o move /run ${rootmnt}/run
-else
-	# The initramfs udev database must be migrated:
-	if [ -d /run/udev ] && [ ! -d /dev/.udev ]; then
-		mv /run/udev /dev/.udev
-	fi
-	# The initramfs debug info must be migrated:
-	if [ -d /run/initramfs ] && [ ! -d /dev/.initramfs ]; then
-		mv /run/initramfs /dev/.initramfs
-	fi
-	umount /run
-fi
-
-# Move virtual filesystems over to the real filesystem
-mount -n -o move /sys ${rootmnt}/sys
-mount -n -o move /proc ${rootmnt}/proc
-
-validate_init() {
-	checktarget="${1}"
-
-	# Work around absolute symlinks
-	if [ -d "${rootmnt}" ] && [ -h "${rootmnt}${checktarget}" ]; then
-		case $(readlink "${rootmnt}${checktarget}") in /*)
-			checktarget="$(chroot ${rootmnt} readlink ${checktarget})"
-			;;
-		esac
-	fi
-
-	# Make sure the specified init can be executed
-	if [ ! -x "${rootmnt}${checktarget}" ]; then
-		return 1
-	fi
-
-	# Upstart uses /etc/init as configuration directory :-/
-	if [ -d "${rootmnt}${checktarget}" ]; then
-		return 1
-	fi
-}
-
-# Check init bootarg
-if [ -n "${init}" ]; then
-	if ! validate_init "$init"; then
-		echo "Target filesystem doesn't have requested ${init}."
-		init=
-	fi
-fi
-
-# Common case: /sbin/init is present
-if [ ! -x "${rootmnt}/sbin/init" ]; then
-	# ... if it's not available search for valid init
-	if [ -z "${init}" ] ; then
-		for inittest in /sbin/init /etc/init /bin/init /bin/sh; do
-			if validate_init "${inittest}"; then
-				init="$inittest"
-				break
-			fi
-		done
-	fi
-
-	# No init on rootmount
-	if ! validate_init "${init}" ; then
-		panic "No init found. Try passing init= bootarg."
-	fi
-fi
-
-maybe_break init
-
-# don't leak too much of env - some init(8) don't clear it
-# (keep init, rootmnt)
-unset debug
-unset MODPROBE_OPTIONS
-unset DPKG_ARCH
-unset ROOTFLAGS
-unset ROOTFSTYPE
-unset ROOTDELAY
-unset ROOT
-unset IP
-unset BOOT
-unset BOOTIF
-unset UBIMTD
-unset blacklist
-unset break
-unset noresume
-unset panic
-unset quiet
-unset readonly
-unset resume
-unset resume_offset
-
-# Chain to real filesystem
-exec run-init ${rootmnt} ${init} "$@" ${recovery:+--startup-event=recovery} <${rootmnt}/dev/console >${rootmnt}/dev/console 2>&1
-panic "Could not execute run-init."
+#!/bin/sh
+
+[ -d /dev ] || mkdir -m 0755 /dev
+[ -d /root ] || mkdir -m 0700 /root
+[ -d /sys ] || mkdir /sys
+[ -d /proc ] || mkdir /proc
+[ -d /tmp ] || mkdir /tmp
+mkdir -p /var/lock
+mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
+mount -t proc -o nodev,noexec,nosuid proc /proc
+# Some things don't work properly without /etc/mtab.
+ln -sf /proc/mounts /etc/mtab
+
+grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."
+
+# Note that this only becomes /dev on the real filesystem if udev's scripts
+# are used; which they will be, but it's worth pointing out
+if ! mount -t devtmpfs -o mode=0755 udev /dev; then
+	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
+	mount -t tmpfs -o mode=0755 udev /dev
+	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
+	[ -e /dev/null ] || mknod /dev/null c 1 3
+fi
+mkdir /dev/pts
+mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
+mount -t tmpfs -o "noexec,nosuid,size=10%,mode=0755" tmpfs /run
+mkdir /run/initramfs
+# compatibility symlink for the pre-oneiric locations
+ln -s /run/initramfs /dev/.initramfs
+
+# Export the dpkg architecture
+export DPKG_ARCH=
+. /conf/arch.conf
+
+# Set modprobe env
+export MODPROBE_OPTIONS="-qb"
+
+# Export relevant variables
+export ROOT=
+export ROOTDELAY=
+export ROOTFLAGS=
+export ROOTFSTYPE=
+export IP=
+export BOOT=
+export BOOTIF=
+export UBIMTD=
+export break=
+export init=/sbin/init
+export quiet=n
+export readonly=y
+export rootmnt=/root
+export debug=
+export panic=
+export blacklist=
+export resume=
+export resume_offset=
+export recovery=
+export FLASH_KERNEL_SKIP=1
+
+# mdadm needs hostname to be set. This has to be done before the udev rules are called!
+if [ -f "/etc/hostname" ]; then
+        /bin/hostname -b -F /etc/hostname 2>&1 1>/dev/null
+fi
+
+# Bring in the main config
+. /conf/initramfs.conf
+for conf in conf/conf.d/*; do
+	[ -f ${conf} ] && . ${conf}
+done
+. /scripts/functions
+
+# Parse command line options
+for x in $(cat /proc/cmdline); do
+	case $x in
+	init=*)
+		init=${x#init=}
+		;;
+	root=*)
+		ROOT=${x#root=}
+		case $ROOT in
+		LABEL=*)
+			ROOT="${ROOT#LABEL=}"
+
+			# support any / in LABEL= path (escape to \x2f)
+			case "${ROOT}" in
+			*/*)
+			if command -v sed >/dev/null 2>&1; then
+				ROOT="$(echo ${ROOT} | sed 's,/,\\x2f,g')"
+			else
+				if [ "${ROOT}" != "${ROOT#/}" ]; then
+					ROOT="\x2f${ROOT#/}"
+				fi
+				if [ "${ROOT}" != "${ROOT%/}" ]; then
+					ROOT="${ROOT%/}\x2f"
+				fi
+				IFS='/'
+				newroot=
+				for s in $ROOT; do
+					newroot="${newroot:+${newroot}\\x2f}${s}"
+				done
+				unset IFS
+				ROOT="${newroot}"
+			fi
+			esac
+			ROOT="/dev/disk/by-label/${ROOT}"
+			;;
+		UUID=*)
+			ROOT="/dev/disk/by-uuid/${ROOT#UUID=}"
+			;;
+		/dev/nfs)
+			[ -z "${BOOT}" ] && BOOT=nfs
+			;;
+		esac
+		;;
+	rootflags=*)
+		ROOTFLAGS="-o ${x#rootflags=}"
+		;;
+	rootfstype=*)
+		ROOTFSTYPE="${x#rootfstype=}"
+		;;
+	rootdelay=*)
+		ROOTDELAY="${x#rootdelay=}"
+		case ${ROOTDELAY} in
+		*[![:digit:].]*)
+			ROOTDELAY=
+			;;
+		esac
+		;;
+	resumedelay=*)
+		RESUMEDELAY="${x#resumedelay=}"
+		;;
+	loop=*)
+		LOOP="${x#loop=}"
+		;;
+	loopflags=*)
+		LOOPFLAGS="-o ${x#loopflags=}"
+		;;
+	loopfstype=*)
+		LOOPFSTYPE="${x#loopfstype=}"
+		;;
+	rootsubdir=*)
+		ROOTSUBDIR="${x#rootsubdir=}"
+		;;
+	cryptopts=*)
+		cryptopts="${x#cryptopts=}"
+		;;
+	nfsroot=*)
+		NFSROOT="${x#nfsroot=}"
+		;;
+	netboot=*)
+		NETBOOT="${x#netboot=}"
+		;;
+	ip=*)
+		IP="${x#ip=}"
+		;;
+	boot=*)
+		BOOT=${x#boot=}
+		;;
+	ubi.mtd=*)
+		UBIMTD=${x#ubi.mtd=}
+		;;
+	resume=*)
+		RESUME="${x#resume=}"
+		;;
+	resume_offset=*)
+		resume_offset="${x#resume_offset=}"
+		;;
+	noresume)
+		noresume=y
+		;;
+	panic=*)
+		panic="${x#panic=}"
+		case ${panic} in
+		*[![:digit:].]*)
+			panic=
+			;;
+		esac
+		;;
+	quiet)
+		quiet=y
+		;;
+	ro)
+		readonly=y
+		;;
+	rw)
+		readonly=n
+		;;
+	debug)
+		debug=y
+		quiet=n
+		exec >/run/initramfs/initramfs.debug 2>&1
+		set -x
+		;;
+	debug=*)
+		debug=y
+		quiet=n
+		set -x
+		;;
+	break=*)
+		break=${x#break=}
+		;;
+	break)
+		break=premount
+		;;
+	blacklist=*)
+		blacklist=${x#blacklist=}
+		;;
+	netconsole=*)
+		netconsole=${x#netconsole=}
+		;;
+	BOOTIF=*)
+		BOOTIF=${x#BOOTIF=}
+		;;
+	hwaddr=*)
+		BOOTIF=${x#BOOTIF=}
+		;;
+	recovery)
+		recovery=y
+		;;
+	esac
+done
+
+if [ -n "${noresume}" ]; then
+	export noresume
+	unset resume
+else
+	resume=${RESUME:-}
+fi
+
+maybe_break top
+
+# export BOOT variable value for compcache,
+# so we know if we run from casper
+export BOOT
+
+# Don't do log messages here to avoid confusing graphical boots
+run_scripts /scripts/init-top
+
+maybe_break modules
+[ "$quiet" != "y" ] && log_begin_msg "Loading essential drivers"
+load_modules
+[ "$quiet" != "y" ] && log_end_msg
+
+[ -n "${netconsole}" ] && modprobe netconsole netconsole="${netconsole}"
+
+maybe_break premount
+[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-premount"
+run_scripts /scripts/init-premount
+[ "$quiet" != "y" ] && log_end_msg
+
+maybe_break mount
+log_begin_msg "Mounting root file system"
+. /scripts/${BOOT}
+parse_numeric ${ROOT}
+maybe_break mountroot
+mountroot
+log_end_msg
+
+maybe_break bottom
+[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-bottom"
+run_scripts /scripts/init-bottom
+[ "$quiet" != "y" ] && log_end_msg
+
+# Preserve information on old systems without /run on the rootfs
+if [ -d ${rootmnt}/run ]; then
+	mount -n -o move /run ${rootmnt}/run
+else
+	# The initramfs udev database must be migrated:
+	if [ -d /run/udev ] && [ ! -d /dev/.udev ]; then
+		mv /run/udev /dev/.udev
+	fi
+	# The initramfs debug info must be migrated:
+	if [ -d /run/initramfs ] && [ ! -d /dev/.initramfs ]; then
+		mv /run/initramfs /dev/.initramfs
+	fi
+	umount /run
+fi
+
+# Move virtual filesystems over to the real filesystem
+mount -n -o move /sys ${rootmnt}/sys
+mount -n -o move /proc ${rootmnt}/proc
+
+validate_init() {
+	checktarget="${1}"
+
+	# Work around absolute symlinks
+	if [ -d "${rootmnt}" ] && [ -h "${rootmnt}${checktarget}" ]; then
+		case $(readlink "${rootmnt}${checktarget}") in /*)
+			checktarget="$(chroot ${rootmnt} readlink ${checktarget})"
+			;;
+		esac
+	fi
+
+	# Make sure the specified init can be executed
+	if [ ! -x "${rootmnt}${checktarget}" ]; then
+		return 1
+	fi
+
+	# Upstart uses /etc/init as configuration directory :-/
+	if [ -d "${rootmnt}${checktarget}" ]; then
+		return 1
+	fi
+}
+
+# Check init bootarg
+if [ -n "${init}" ]; then
+	if ! validate_init "$init"; then
+		echo "Target filesystem doesn't have requested ${init}."
+		init=
+	fi
+fi
+
+# Common case: /sbin/init is present
+if [ ! -x "${rootmnt}/sbin/init" ]; then
+	# ... if it's not available search for valid init
+	if [ -z "${init}" ] ; then
+		for inittest in /sbin/init /etc/init /bin/init /bin/sh; do
+			if validate_init "${inittest}"; then
+				init="$inittest"
+				break
+			fi
+		done
+	fi
+
+	# No init on rootmount
+	if ! validate_init "${init}" ; then
+		panic "No init found. Try passing init= bootarg."
+	fi
+fi
+
+maybe_break init
+
+# don't leak too much of env - some init(8) don't clear it
+# (keep init, rootmnt)
+unset debug
+unset MODPROBE_OPTIONS
+unset DPKG_ARCH
+unset ROOTFLAGS
+unset ROOTFSTYPE
+unset ROOTDELAY
+unset ROOT
+unset IP
+unset BOOT
+unset BOOTIF
+unset UBIMTD
+unset blacklist
+unset break
+unset noresume
+unset panic
+unset quiet
+unset readonly
+unset resume
+unset resume_offset
+
+# Chain to real filesystem
+exec run-init ${rootmnt} ${init} "$@" ${recovery:+--startup-event=recovery} <${rootmnt}/dev/console >${rootmnt}/dev/console 2>&1
+panic "Could not execute run-init."
diff --git a/install_zip/prebuilt-installer/multirom/ubuntu-init/local b/install_zip/prebuilt-installer/multirom/ubuntu-init/local
index 2a1ac93..ac20dce 100755
--- a/install_zip/prebuilt-installer/multirom/ubuntu-init/local
+++ b/install_zip/prebuilt-installer/multirom/ubuntu-init/local
@@ -1,170 +1,170 @@
-# Local filesystem mounting			-*- shell-script -*-
-
-pre_mountroot()
-{
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
-	run_scripts /scripts/local-top
-	[ "$quiet" != "y" ] && log_end_msg
-
-	# Don't wait for a root device that doesn't have a corresponding
-	# device in /dev (ie, mtd0)
-	if [ "${ROOT#/dev}" = "${ROOT}" ]; then
-		return
-	fi
-
-	while [ -z "${FSTYPE}" ]; do
-		FSTYPE=$(wait-for-root "${ROOT}" ${ROOTDELAY:-30})
-
-		# Load ubi with the correct MTD partition and return since
-		# fstype doesn't work with a char device like ubi.
-		if [ -n "$UBIMTD" ]; then
-			modprobe ubi mtd=$UBIMTD
-			return
-		fi
-
-		# Run failure hooks, hoping one of them can fix up the system
-		# and we can restart the wait loop.  If they all fail, abort
-		# and move on to the panic handler and shell.
-		if [ -z "${FSTYPE}" ] && ! try_failure_hooks; then
-			break
-		fi
-	done
-
-	# We've given up, but we'll let the user fix matters if they can
-	while [ -z "${FSTYPE}" -a ! -e "${ROOT}" ]; do
-		# give hint about renamed root
-		case "${ROOT}" in
-		/dev/hd*)
-			suffix="${ROOT#/dev/hd}"
-			major="${suffix%[[:digit:]]}"
-			major="${major%[[:digit:]]}"
-			if [ -d "/sys/block/sd${major}" ]; then
-				echo "WARNING bootdevice may be renamed. Try root=/dev/sd${suffix}"
-			fi
-			;;
-		/dev/sd*)
-			suffix="${ROOT#/dev/sd}"
-			major="${suffix%[[:digit:]]}"
-			major="${major%[[:digit:]]}"
-			if [ -d "/sys/block/hd${major}" ]; then
-				echo "WARNING bootdevice may be renamed. Try root=/dev/hd${suffix}"
-			fi
-			;;
-		esac
-		echo "Gave up waiting for root device.  Common problems:"
-		echo " - Boot args (cat /proc/cmdline)"
-		echo "   - Check rootdelay= (did the system wait long enough?)"
-		echo "   - Check root= (did the system wait for the right device?)"
-		echo " - Missing modules (cat /proc/modules; ls /dev)"
-		panic "ALERT!  ${ROOT} does not exist.  Dropping to a shell!"
-	done
-}
-
-mountroot()
-{
-	pre_mountroot
-
-	# Get the root filesystem type if not set
-	if [ -z "${ROOTFSTYPE}" ]; then
-		[ -n "${FSTYPE}" ] || FSTYPE=$(blkid -s TYPE -o value "${ROOT}")
-		ROOTFSTYPE="${FSTYPE}"
-	else
-		FSTYPE=${ROOTFSTYPE}
-	fi
-
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
-	run_scripts /scripts/local-premount
-	[ "$quiet" != "y" ] && log_end_msg
-
-	if [ "${readonly}" = "y" ] && \
-	   [ -z "$LOOP" ]; then
-		roflag=-r
-	else
-		roflag=-w
-	fi
-
-	# FIXME This has no error checking
-	[ -n "${FSTYPE}" ] && modprobe ${FSTYPE}
-
-	# FIXME This has no error checking
-	# Mount root
-	mount ${roflag} ${FSTYPE:+-t ${FSTYPE} }${ROOTFLAGS} ${ROOT} ${rootmnt}
-	mountroot_status="$?"
-	if [ "$LOOP" ]; then
-		if [ "$mountroot_status" != 0 ]; then
-			if [ ${FSTYPE} = ntfs ] || [ ${FSTYPE} = vfat ]; then
-				panic "
-Could not mount the partition ${ROOT}.
-This could also happen if the file system is not clean because of an operating
-system crash, an interrupted boot process, an improper shutdown, or unplugging
-of a removable device without first unmounting or ejecting it.  To fix this,
-simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
-gracefully shut down and reboot back into Windows. After this you should be
-able to reboot again and resume the installation.
-(filesystem = ${FSTYPE}, error code = $mountroot_status)
-"
-			fi
-		fi
-	
-		mkdir -p /host
-		mount -o move ${rootmnt} /host
-
-		while [ ! -e "/host/${LOOP#/}" ]; do
-			panic "ALERT!  /host/${LOOP#/} does not exist.  Dropping to a shell!"
-		done
-
-		# Get the loop filesystem type if not set
-		if [ -z "${LOOPFSTYPE}" ]; then
-			eval $(fstype < "/host/${LOOP#/}")
-		else
-			FSTYPE="${LOOPFSTYPE}"
-		fi
-		if [ "$FSTYPE" = "unknown" ] && [ -x /sbin/blkid ]; then
-			FSTYPE=$(/sbin/blkid -s TYPE -o value "/host/${LOOP#/}")
-			[ -z "$FSTYPE" ] && FSTYPE="unknown"
-		fi
-
-		if [ ${readonly} = y ]; then
-			roflag=-r
-		else
-			roflag=-w
-		fi
-
-		# FIXME This has no error checking
-		modprobe loop
-		modprobe ${FSTYPE}
-
-		# FIXME This has no error checking
-		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "/host/${LOOP#/}" ${rootmnt}
-
-		if [ -d ${rootmnt}/host ]; then
-			mount -o move /host ${rootmnt}/host
-		fi
-	elif [ "$ROOTSUBDIR" ]; then
-		if [ "$mountroot_status" != 0 ]; then
-			panic "
-Could not mount the partition ${ROOT}.
-This could also happen if the file system is not clean because of an operating
-system crash, an interrupted boot process, an improper shutdown, or unplugging
-of a removable device without first unmounting or ejecting it.
-(filesystem = ${FSTYPE}, error code = $mountroot_status)
-"
-		fi
-
-		mkdir -p /host
-		mount -o move ${rootmnt} /host
-		
-		if [ ! -d "/host/$ROOTSUBDIR" ]; then
-		    panic "Failed to bind folder ${ROOTSUBDIR} as root: folder does not exist."
-		fi
-		
-		mount -o bind /host/$ROOTSUBDIR ${rootmnt}
-		if [ -d ${rootmnt}/host ]; then
-			mount -o move /host ${rootmnt}/host
-		fi
-	fi
-
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-bottom"
-	run_scripts /scripts/local-bottom
-	[ "$quiet" != "y" ] && log_end_msg
-}
+# Local filesystem mounting			-*- shell-script -*-
+
+pre_mountroot()
+{
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
+	run_scripts /scripts/local-top
+	[ "$quiet" != "y" ] && log_end_msg
+
+	# Don't wait for a root device that doesn't have a corresponding
+	# device in /dev (ie, mtd0)
+	if [ "${ROOT#/dev}" = "${ROOT}" ]; then
+		return
+	fi
+
+	while [ -z "${FSTYPE}" ]; do
+		FSTYPE=$(wait-for-root "${ROOT}" ${ROOTDELAY:-30})
+
+		# Load ubi with the correct MTD partition and return since
+		# fstype doesn't work with a char device like ubi.
+		if [ -n "$UBIMTD" ]; then
+			modprobe ubi mtd=$UBIMTD
+			return
+		fi
+
+		# Run failure hooks, hoping one of them can fix up the system
+		# and we can restart the wait loop.  If they all fail, abort
+		# and move on to the panic handler and shell.
+		if [ -z "${FSTYPE}" ] && ! try_failure_hooks; then
+			break
+		fi
+	done
+
+	# We've given up, but we'll let the user fix matters if they can
+	while [ -z "${FSTYPE}" -a ! -e "${ROOT}" ]; do
+		# give hint about renamed root
+		case "${ROOT}" in
+		/dev/hd*)
+			suffix="${ROOT#/dev/hd}"
+			major="${suffix%[[:digit:]]}"
+			major="${major%[[:digit:]]}"
+			if [ -d "/sys/block/sd${major}" ]; then
+				echo "WARNING bootdevice may be renamed. Try root=/dev/sd${suffix}"
+			fi
+			;;
+		/dev/sd*)
+			suffix="${ROOT#/dev/sd}"
+			major="${suffix%[[:digit:]]}"
+			major="${major%[[:digit:]]}"
+			if [ -d "/sys/block/hd${major}" ]; then
+				echo "WARNING bootdevice may be renamed. Try root=/dev/hd${suffix}"
+			fi
+			;;
+		esac
+		echo "Gave up waiting for root device.  Common problems:"
+		echo " - Boot args (cat /proc/cmdline)"
+		echo "   - Check rootdelay= (did the system wait long enough?)"
+		echo "   - Check root= (did the system wait for the right device?)"
+		echo " - Missing modules (cat /proc/modules; ls /dev)"
+		panic "ALERT!  ${ROOT} does not exist.  Dropping to a shell!"
+	done
+}
+
+mountroot()
+{
+	pre_mountroot
+
+	# Get the root filesystem type if not set
+	if [ -z "${ROOTFSTYPE}" ]; then
+		[ -n "${FSTYPE}" ] || FSTYPE=$(blkid -s TYPE -o value "${ROOT}")
+		ROOTFSTYPE="${FSTYPE}"
+	else
+		FSTYPE=${ROOTFSTYPE}
+	fi
+
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
+	run_scripts /scripts/local-premount
+	[ "$quiet" != "y" ] && log_end_msg
+
+	if [ "${readonly}" = "y" ] && \
+	   [ -z "$LOOP" ]; then
+		roflag=-r
+	else
+		roflag=-w
+	fi
+
+	# FIXME This has no error checking
+	[ -n "${FSTYPE}" ] && modprobe ${FSTYPE}
+
+	# FIXME This has no error checking
+	# Mount root
+	mount ${roflag} ${FSTYPE:+-t ${FSTYPE} }${ROOTFLAGS} ${ROOT} ${rootmnt}
+	mountroot_status="$?"
+	if [ "$LOOP" ]; then
+		if [ "$mountroot_status" != 0 ]; then
+			if [ ${FSTYPE} = ntfs ] || [ ${FSTYPE} = vfat ]; then
+				panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+			fi
+		fi
+	
+		mkdir -p /host
+		mount -o move ${rootmnt} /host
+
+		while [ ! -e "/host/${LOOP#/}" ]; do
+			panic "ALERT!  /host/${LOOP#/} does not exist.  Dropping to a shell!"
+		done
+
+		# Get the loop filesystem type if not set
+		if [ -z "${LOOPFSTYPE}" ]; then
+			eval $(fstype < "/host/${LOOP#/}")
+		else
+			FSTYPE="${LOOPFSTYPE}"
+		fi
+		if [ "$FSTYPE" = "unknown" ] && [ -x /sbin/blkid ]; then
+			FSTYPE=$(/sbin/blkid -s TYPE -o value "/host/${LOOP#/}")
+			[ -z "$FSTYPE" ] && FSTYPE="unknown"
+		fi
+
+		if [ ${readonly} = y ]; then
+			roflag=-r
+		else
+			roflag=-w
+		fi
+
+		# FIXME This has no error checking
+		modprobe loop
+		modprobe ${FSTYPE}
+
+		# FIXME This has no error checking
+		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "/host/${LOOP#/}" ${rootmnt}
+
+		if [ -d ${rootmnt}/host ]; then
+			mount -o move /host ${rootmnt}/host
+		fi
+	elif [ "$ROOTSUBDIR" ]; then
+		if [ "$mountroot_status" != 0 ]; then
+			panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+		fi
+
+		mkdir -p /host
+		mount -o move ${rootmnt} /host
+		
+		if [ ! -d "/host/$ROOTSUBDIR" ]; then
+		    panic "Failed to bind folder ${ROOTSUBDIR} as root: folder does not exist."
+		fi
+		
+		mount -o bind /host/$ROOTSUBDIR ${rootmnt}
+		if [ -d ${rootmnt}/host ]; then
+			mount -o move /host ${rootmnt}/host
+		fi
+	fi
+
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-bottom"
+	run_scripts /scripts/local-bottom
+	[ "$quiet" != "y" ] && log_end_msg
+}
diff --git a/install_zip/prebuilt-installer/multirom/ubuntu-touch-init/init b/install_zip/prebuilt-installer/multirom/ubuntu-touch-init/init
index 99425be..7cdc5da 100755
--- a/install_zip/prebuilt-installer/multirom/ubuntu-touch-init/init
+++ b/install_zip/prebuilt-installer/multirom/ubuntu-touch-init/init
@@ -1,356 +1,356 @@
-#!/bin/sh
-
-[ -d /dev ] || mkdir -m 0755 /dev
-[ -d /root ] || mkdir -m 0700 /root
-[ -d /sys ] || mkdir /sys
-[ -d /proc ] || mkdir /proc
-[ -d /tmp ] || mkdir /tmp
-mkdir -p /var/lock
-mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
-mount -t proc -o nodev,noexec,nosuid proc /proc
-# Some things don't work properly without /etc/mtab.
-ln -sf /proc/mounts /etc/mtab
-
-grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."
-
-# Note that this only becomes /dev on the real filesystem if udev's scripts
-# are used; which they will be, but it's worth pointing out
-if ! mount -t devtmpfs -o mode=0755 udev /dev; then
-	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
-	mount -t tmpfs -o mode=0755 udev /dev
-	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
-	[ -e /dev/null ] || mknod /dev/null c 1 3
-fi
-mkdir /dev/pts
-mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
-mount -t tmpfs -o "noexec,nosuid,size=10%,mode=0755" tmpfs /run
-mkdir /run/initramfs
-# compatibility symlink for the pre-oneiric locations
-ln -s /run/initramfs /dev/.initramfs
-
-# Export the dpkg architecture
-export DPKG_ARCH=
-. /conf/arch.conf
-
-# Set modprobe env
-export MODPROBE_OPTIONS="-qb"
-
-# Export relevant variables
-export ROOT=
-export ROOTDELAY=
-export ROOTFLAGS=
-export ROOTFSTYPE=
-export IP=
-export BOOT=
-export BOOTIF=
-export UBIMTD=
-export break=
-export init=/sbin/init
-export quiet=n
-export readonly=y
-export rootmnt=/root
-export debug=
-export panic=
-export blacklist=
-export resume=
-export resume_offset=
-export recovery=
-
-# mdadm needs hostname to be set. This has to be done before the udev rules are called!
-if [ -f "/etc/hostname" ]; then
-        /bin/hostname -b -F /etc/hostname 2>&1 1>/dev/null
-fi
-
-# Bring in the main config
-. /conf/initramfs.conf
-for conf in conf/conf.d/*; do
-	[ -f ${conf} ] && . ${conf}
-done
-. /scripts/functions
-
-# Parse command line options
-for x in $(cat /proc/cmdline); do
-	case $x in
-	init=*)
-		init=${x#init=}
-		;;
-	root=*)
-		ROOT=${x#root=}
-		case $ROOT in
-		LABEL=*)
-			ROOT="${ROOT#LABEL=}"
-
-			# support any / in LABEL= path (escape to \x2f)
-			case "${ROOT}" in
-			*/*)
-			if command -v sed >/dev/null 2>&1; then
-				ROOT="$(echo ${ROOT} | sed 's,/,\\x2f,g')"
-			else
-				if [ "${ROOT}" != "${ROOT#/}" ]; then
-					ROOT="\x2f${ROOT#/}"
-				fi
-				if [ "${ROOT}" != "${ROOT%/}" ]; then
-					ROOT="${ROOT%/}\x2f"
-				fi
-				IFS='/'
-				newroot=
-				for s in $ROOT; do
-					newroot="${newroot:+${newroot}\\x2f}${s}"
-				done
-				unset IFS
-				ROOT="${newroot}"
-			fi
-			esac
-			ROOT="/dev/disk/by-label/${ROOT}"
-			;;
-		UUID=*)
-			ROOT="/dev/disk/by-uuid/${ROOT#UUID=}"
-			;;
-		/dev/nfs)
-			[ -z "${BOOT}" ] && BOOT=nfs
-			;;
-		esac
-		;;
-	rootflags=*)
-		ROOTFLAGS="-o ${x#rootflags=}"
-		;;
-	rootfstype=*)
-		ROOTFSTYPE="${x#rootfstype=}"
-		;;
-	rootdelay=*)
-		ROOTDELAY="${x#rootdelay=}"
-		case ${ROOTDELAY} in
-		*[![:digit:].]*)
-			ROOTDELAY=
-			;;
-		esac
-		;;
-	resumedelay=*)
-		RESUMEDELAY="${x#resumedelay=}"
-		;;
-	loop=*)
-		LOOP="${x#loop=}"
-		;;
-	loopflags=*)
-		LOOPFLAGS="-o ${x#loopflags=}"
-		;;
-	loopfstype=*)
-		LOOPFSTYPE="${x#loopfstype=}"
-		;;
-	rootsubdir=*)
-		ROOTSUBDIR="${x#rootsubdir=}"
-		;;
-	cryptopts=*)
-		cryptopts="${x#cryptopts=}"
-		;;
-	nfsroot=*)
-		NFSROOT="${x#nfsroot=}"
-		;;
-	netboot=*)
-		NETBOOT="${x#netboot=}"
-		;;
-	ip=*)
-		IP="${x#ip=}"
-		;;
-	boot=*)
-		BOOT=${x#boot=}
-		;;
-	ubi.mtd=*)
-		UBIMTD=${x#ubi.mtd=}
-		;;
-	resume=*)
-		RESUME="${x#resume=}"
-		;;
-	resume_offset=*)
-		resume_offset="${x#resume_offset=}"
-		;;
-	noresume)
-		noresume=y
-		;;
-	panic=*)
-		panic="${x#panic=}"
-		case ${panic} in
-		*[![:digit:].]*)
-			panic=
-			;;
-		esac
-		;;
-	quiet)
-		quiet=y
-		;;
-	ro)
-		readonly=y
-		;;
-	rw)
-		readonly=n
-		;;
-	debug)
-		debug=y
-		quiet=n
-		exec >/run/initramfs/initramfs.debug 2>&1
-		set -x
-		;;
-	debug=*)
-		debug=y
-		quiet=n
-		set -x
-		;;
-	break=*)
-		break=${x#break=}
-		;;
-	break)
-		break=premount
-		;;
-	blacklist=*)
-		blacklist=${x#blacklist=}
-		;;
-	netconsole=*)
-		netconsole=${x#netconsole=}
-		;;
-	BOOTIF=*)
-		BOOTIF=${x#BOOTIF=}
-		;;
-	hwaddr=*)
-		BOOTIF=${x#BOOTIF=}
-		;;
-	recovery)
-		recovery=y
-		;;
-	esac
-done
-
-if [ -n "${noresume}" ]; then
-	export noresume
-	unset resume
-else
-	resume=${RESUME:-}
-fi
-
-maybe_break top
-
-# export BOOT variable value for compcache,
-# so we know if we run from casper
-export BOOT
-
-# Don't do log messages here to avoid confusing graphical boots
-run_scripts /scripts/init-top
-
-maybe_break modules
-[ "$quiet" != "y" ] && log_begin_msg "Loading essential drivers"
-load_modules
-[ "$quiet" != "y" ] && log_end_msg
-
-[ -n "${netconsole}" ] && modprobe netconsole netconsole="${netconsole}"
-
-maybe_break premount
-[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-premount"
-run_scripts /scripts/init-premount
-[ "$quiet" != "y" ] && log_end_msg
-
-maybe_break mount
-log_begin_msg "Mounting root file system"
-. /scripts/${BOOT}
-parse_numeric ${ROOT}
-maybe_break mountroot
-mountroot
-log_end_msg
-
-maybe_break bottom
-[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-bottom"
-run_scripts /scripts/init-bottom
-[ "$quiet" != "y" ] && log_end_msg
-
-# Preserve information on old systems without /run on the rootfs
-if [ -d ${rootmnt}/run ]; then
-	mount -n -o move /run ${rootmnt}/run
-else
-	# The initramfs udev database must be migrated:
-	if [ -d /run/udev ] && [ ! -d /dev/.udev ]; then
-		mv /run/udev /dev/.udev
-	fi
-	# The initramfs debug info must be migrated:
-	if [ -d /run/initramfs ] && [ ! -d /dev/.initramfs ]; then
-		mv /run/initramfs /dev/.initramfs
-	fi
-	umount /run
-fi
-
-# Move virtual filesystems over to the real filesystem
-mount -n -o move /sys ${rootmnt}/sys
-mount -n -o move /proc ${rootmnt}/proc
-
-validate_init() {
-	checktarget="${1}"
-
-	# Work around absolute symlinks
-	if [ -d "${rootmnt}" ] && [ -h "${rootmnt}${checktarget}" ]; then
-		case $(readlink "${rootmnt}${checktarget}") in /*)
-			checktarget="$(chroot ${rootmnt} readlink ${checktarget})"
-			;;
-		esac
-	fi
-
-	# Make sure the specified init can be executed
-	if [ ! -x "${rootmnt}${checktarget}" ]; then
-		return 1
-	fi
-
-	# Upstart uses /etc/init as configuration directory :-/
-	if [ -d "${rootmnt}${checktarget}" ]; then
-		return 1
-	fi
-}
-
-# Check init bootarg
-if [ -n "${init}" ]; then
-	if ! validate_init "$init"; then
-		echo "Target filesystem doesn't have requested ${init}."
-		init=
-	fi
-fi
-
-# Common case: /sbin/init is present
-if [ ! -x "${rootmnt}/sbin/init" ]; then
-	# ... if it's not available search for valid init
-	if [ -z "${init}" ] ; then
-		for inittest in /sbin/init /etc/init /bin/init /bin/sh; do
-			if validate_init "${inittest}"; then
-				init="$inittest"
-				break
-			fi
-		done
-	fi
-
-	# No init on rootmount
-	if ! validate_init "${init}" ; then
-		panic "No init found. Try passing init= bootarg."
-	fi
-fi
-
-maybe_break init
-
-# don't leak too much of env - some init(8) don't clear it
-# (keep init, rootmnt)
-unset debug
-unset MODPROBE_OPTIONS
-unset DPKG_ARCH
-unset ROOTFLAGS
-unset ROOTFSTYPE
-unset ROOTDELAY
-unset ROOT
-unset IP
-unset BOOT
-unset BOOTIF
-unset UBIMTD
-unset blacklist
-unset break
-unset noresume
-unset panic
-unset quiet
-unset readonly
-unset resume
-unset resume_offset
-
-# Chain to real filesystem
-exec run-init ${rootmnt} ${init} "$@" ${recovery:+--startup-event=recovery} <${rootmnt}/dev/console >${rootmnt}/dev/console 2>&1
-panic "Could not execute run-init."
+#!/bin/sh
+
+[ -d /dev ] || mkdir -m 0755 /dev
+[ -d /root ] || mkdir -m 0700 /root
+[ -d /sys ] || mkdir /sys
+[ -d /proc ] || mkdir /proc
+[ -d /tmp ] || mkdir /tmp
+mkdir -p /var/lock
+mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
+mount -t proc -o nodev,noexec,nosuid proc /proc
+# Some things don't work properly without /etc/mtab.
+ln -sf /proc/mounts /etc/mtab
+
+grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."
+
+# Note that this only becomes /dev on the real filesystem if udev's scripts
+# are used; which they will be, but it's worth pointing out
+if ! mount -t devtmpfs -o mode=0755 udev /dev; then
+	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
+	mount -t tmpfs -o mode=0755 udev /dev
+	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
+	[ -e /dev/null ] || mknod /dev/null c 1 3
+fi
+mkdir /dev/pts
+mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
+mount -t tmpfs -o "noexec,nosuid,size=10%,mode=0755" tmpfs /run
+mkdir /run/initramfs
+# compatibility symlink for the pre-oneiric locations
+ln -s /run/initramfs /dev/.initramfs
+
+# Export the dpkg architecture
+export DPKG_ARCH=
+. /conf/arch.conf
+
+# Set modprobe env
+export MODPROBE_OPTIONS="-qb"
+
+# Export relevant variables
+export ROOT=
+export ROOTDELAY=
+export ROOTFLAGS=
+export ROOTFSTYPE=
+export IP=
+export BOOT=
+export BOOTIF=
+export UBIMTD=
+export break=
+export init=/sbin/init
+export quiet=n
+export readonly=y
+export rootmnt=/root
+export debug=
+export panic=
+export blacklist=
+export resume=
+export resume_offset=
+export recovery=
+
+# mdadm needs hostname to be set. This has to be done before the udev rules are called!
+if [ -f "/etc/hostname" ]; then
+        /bin/hostname -b -F /etc/hostname 2>&1 1>/dev/null
+fi
+
+# Bring in the main config
+. /conf/initramfs.conf
+for conf in conf/conf.d/*; do
+	[ -f ${conf} ] && . ${conf}
+done
+. /scripts/functions
+
+# Parse command line options
+for x in $(cat /proc/cmdline); do
+	case $x in
+	init=*)
+		init=${x#init=}
+		;;
+	root=*)
+		ROOT=${x#root=}
+		case $ROOT in
+		LABEL=*)
+			ROOT="${ROOT#LABEL=}"
+
+			# support any / in LABEL= path (escape to \x2f)
+			case "${ROOT}" in
+			*/*)
+			if command -v sed >/dev/null 2>&1; then
+				ROOT="$(echo ${ROOT} | sed 's,/,\\x2f,g')"
+			else
+				if [ "${ROOT}" != "${ROOT#/}" ]; then
+					ROOT="\x2f${ROOT#/}"
+				fi
+				if [ "${ROOT}" != "${ROOT%/}" ]; then
+					ROOT="${ROOT%/}\x2f"
+				fi
+				IFS='/'
+				newroot=
+				for s in $ROOT; do
+					newroot="${newroot:+${newroot}\\x2f}${s}"
+				done
+				unset IFS
+				ROOT="${newroot}"
+			fi
+			esac
+			ROOT="/dev/disk/by-label/${ROOT}"
+			;;
+		UUID=*)
+			ROOT="/dev/disk/by-uuid/${ROOT#UUID=}"
+			;;
+		/dev/nfs)
+			[ -z "${BOOT}" ] && BOOT=nfs
+			;;
+		esac
+		;;
+	rootflags=*)
+		ROOTFLAGS="-o ${x#rootflags=}"
+		;;
+	rootfstype=*)
+		ROOTFSTYPE="${x#rootfstype=}"
+		;;
+	rootdelay=*)
+		ROOTDELAY="${x#rootdelay=}"
+		case ${ROOTDELAY} in
+		*[![:digit:].]*)
+			ROOTDELAY=
+			;;
+		esac
+		;;
+	resumedelay=*)
+		RESUMEDELAY="${x#resumedelay=}"
+		;;
+	loop=*)
+		LOOP="${x#loop=}"
+		;;
+	loopflags=*)
+		LOOPFLAGS="-o ${x#loopflags=}"
+		;;
+	loopfstype=*)
+		LOOPFSTYPE="${x#loopfstype=}"
+		;;
+	rootsubdir=*)
+		ROOTSUBDIR="${x#rootsubdir=}"
+		;;
+	cryptopts=*)
+		cryptopts="${x#cryptopts=}"
+		;;
+	nfsroot=*)
+		NFSROOT="${x#nfsroot=}"
+		;;
+	netboot=*)
+		NETBOOT="${x#netboot=}"
+		;;
+	ip=*)
+		IP="${x#ip=}"
+		;;
+	boot=*)
+		BOOT=${x#boot=}
+		;;
+	ubi.mtd=*)
+		UBIMTD=${x#ubi.mtd=}
+		;;
+	resume=*)
+		RESUME="${x#resume=}"
+		;;
+	resume_offset=*)
+		resume_offset="${x#resume_offset=}"
+		;;
+	noresume)
+		noresume=y
+		;;
+	panic=*)
+		panic="${x#panic=}"
+		case ${panic} in
+		*[![:digit:].]*)
+			panic=
+			;;
+		esac
+		;;
+	quiet)
+		quiet=y
+		;;
+	ro)
+		readonly=y
+		;;
+	rw)
+		readonly=n
+		;;
+	debug)
+		debug=y
+		quiet=n
+		exec >/run/initramfs/initramfs.debug 2>&1
+		set -x
+		;;
+	debug=*)
+		debug=y
+		quiet=n
+		set -x
+		;;
+	break=*)
+		break=${x#break=}
+		;;
+	break)
+		break=premount
+		;;
+	blacklist=*)
+		blacklist=${x#blacklist=}
+		;;
+	netconsole=*)
+		netconsole=${x#netconsole=}
+		;;
+	BOOTIF=*)
+		BOOTIF=${x#BOOTIF=}
+		;;
+	hwaddr=*)
+		BOOTIF=${x#BOOTIF=}
+		;;
+	recovery)
+		recovery=y
+		;;
+	esac
+done
+
+if [ -n "${noresume}" ]; then
+	export noresume
+	unset resume
+else
+	resume=${RESUME:-}
+fi
+
+maybe_break top
+
+# export BOOT variable value for compcache,
+# so we know if we run from casper
+export BOOT
+
+# Don't do log messages here to avoid confusing graphical boots
+run_scripts /scripts/init-top
+
+maybe_break modules
+[ "$quiet" != "y" ] && log_begin_msg "Loading essential drivers"
+load_modules
+[ "$quiet" != "y" ] && log_end_msg
+
+[ -n "${netconsole}" ] && modprobe netconsole netconsole="${netconsole}"
+
+maybe_break premount
+[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-premount"
+run_scripts /scripts/init-premount
+[ "$quiet" != "y" ] && log_end_msg
+
+maybe_break mount
+log_begin_msg "Mounting root file system"
+. /scripts/${BOOT}
+parse_numeric ${ROOT}
+maybe_break mountroot
+mountroot
+log_end_msg
+
+maybe_break bottom
+[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-bottom"
+run_scripts /scripts/init-bottom
+[ "$quiet" != "y" ] && log_end_msg
+
+# Preserve information on old systems without /run on the rootfs
+if [ -d ${rootmnt}/run ]; then
+	mount -n -o move /run ${rootmnt}/run
+else
+	# The initramfs udev database must be migrated:
+	if [ -d /run/udev ] && [ ! -d /dev/.udev ]; then
+		mv /run/udev /dev/.udev
+	fi
+	# The initramfs debug info must be migrated:
+	if [ -d /run/initramfs ] && [ ! -d /dev/.initramfs ]; then
+		mv /run/initramfs /dev/.initramfs
+	fi
+	umount /run
+fi
+
+# Move virtual filesystems over to the real filesystem
+mount -n -o move /sys ${rootmnt}/sys
+mount -n -o move /proc ${rootmnt}/proc
+
+validate_init() {
+	checktarget="${1}"
+
+	# Work around absolute symlinks
+	if [ -d "${rootmnt}" ] && [ -h "${rootmnt}${checktarget}" ]; then
+		case $(readlink "${rootmnt}${checktarget}") in /*)
+			checktarget="$(chroot ${rootmnt} readlink ${checktarget})"
+			;;
+		esac
+	fi
+
+	# Make sure the specified init can be executed
+	if [ ! -x "${rootmnt}${checktarget}" ]; then
+		return 1
+	fi
+
+	# Upstart uses /etc/init as configuration directory :-/
+	if [ -d "${rootmnt}${checktarget}" ]; then
+		return 1
+	fi
+}
+
+# Check init bootarg
+if [ -n "${init}" ]; then
+	if ! validate_init "$init"; then
+		echo "Target filesystem doesn't have requested ${init}."
+		init=
+	fi
+fi
+
+# Common case: /sbin/init is present
+if [ ! -x "${rootmnt}/sbin/init" ]; then
+	# ... if it's not available search for valid init
+	if [ -z "${init}" ] ; then
+		for inittest in /sbin/init /etc/init /bin/init /bin/sh; do
+			if validate_init "${inittest}"; then
+				init="$inittest"
+				break
+			fi
+		done
+	fi
+
+	# No init on rootmount
+	if ! validate_init "${init}" ; then
+		panic "No init found. Try passing init= bootarg."
+	fi
+fi
+
+maybe_break init
+
+# don't leak too much of env - some init(8) don't clear it
+# (keep init, rootmnt)
+unset debug
+unset MODPROBE_OPTIONS
+unset DPKG_ARCH
+unset ROOTFLAGS
+unset ROOTFSTYPE
+unset ROOTDELAY
+unset ROOT
+unset IP
+unset BOOT
+unset BOOTIF
+unset UBIMTD
+unset blacklist
+unset break
+unset noresume
+unset panic
+unset quiet
+unset readonly
+unset resume
+unset resume_offset
+
+# Chain to real filesystem
+exec run-init ${rootmnt} ${init} "$@" ${recovery:+--startup-event=recovery} <${rootmnt}/dev/console >${rootmnt}/dev/console 2>&1
+panic "Could not execute run-init."
diff --git a/install_zip/prebuilt-installer/multirom/ubuntu-touch-init/scripts/touch b/install_zip/prebuilt-installer/multirom/ubuntu-touch-init/scripts/touch
index 91547f2..e048a1b 100755
--- a/install_zip/prebuilt-installer/multirom/ubuntu-touch-init/scripts/touch
+++ b/install_zip/prebuilt-installer/multirom/ubuntu-touch-init/scripts/touch
@@ -1,264 +1,264 @@
-# Local filesystem mounting			-*- shell-script -*-
-
-pre_mountroot()
-{
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
-	run_scripts /scripts/local-top
-	[ "$quiet" != "y" ] && log_end_msg
-	
-	# Don't wait for a root device that doesn't have a corresponding
-	# device in /dev (ie, mtd0)
-	if [ "${ROOT#/dev}" = "${ROOT}" ]; then
-		return
-	fi
-
-	while [ -z "${FSTYPE}" ]; do
-		FSTYPE=$(wait-for-root "${ROOT}" ${ROOTDELAY:-30})
-
-		# Load ubi with the correct MTD partition and return since
-		# fstype doesn't work with a char device like ubi.
-		if [ -n "$UBIMTD" ]; then
-			modprobe ubi mtd=$UBIMTD
-			return
-		fi
-
-		# Run failure hooks, hoping one of them can fix up the system
-		# and we can restart the wait loop.  If they all fail, abort
-		# and move on to the panic handler and shell.
-		if [ -z "${FSTYPE}" ] && ! try_failure_hooks; then
-			break
-		fi
-	done
-
-	# We've given up, but we'll let the user fix matters if they can
-	while [ -z "${FSTYPE}" -a ! -e "${ROOT}" ]; do
-		# give hint about renamed root
-		case "${ROOT}" in
-		/dev/hd*)
-			suffix="${ROOT#/dev/hd}"
-			major="${suffix%[[:digit:]]}"
-			major="${major%[[:digit:]]}"
-			if [ -d "/sys/block/sd${major}" ]; then
-				echo "WARNING bootdevice may be renamed. Try root=/dev/sd${suffix}"
-			fi
-			;;
-		/dev/sd*)
-			suffix="${ROOT#/dev/sd}"
-			major="${suffix%[[:digit:]]}"
-			major="${major%[[:digit:]]}"
-			if [ -d "/sys/block/hd${major}" ]; then
-				echo "WARNING bootdevice may be renamed. Try root=/dev/hd${suffix}"
-			fi
-			;;
-		esac
-		echo "Gave up waiting for root device.  Common problems:"
-		echo " - Boot args (cat /proc/cmdline)"
-		echo "   - Check rootdelay= (did the system wait long enough?)"
-		echo "   - Check root= (did the system wait for the right device?)"
-		echo " - Missing modules (cat /proc/modules; ls /dev)"
-		panic "ALERT!  ${ROOT} does not exist.  Dropping to a shell!"
-	done
-}
-
-process_ubuntu()
-{
-	mrom_dir=$1
-
-	if [ -e /tmpmnt/system.img ]; then
-		# Prepare the root filesystem
-		if [ -e /tmpmnt/.developer_mode ]; then
-			echo "initrd: mounting system.img (developer mode)" >/dev/kmsg || true
-			mount -o loop,rw /tmpmnt/system.img ${rootmnt}
-			mountroot_status="$?"
-		else
-			echo "initrd: mounting system.img (user mode)" >/dev/kmsg || true
-			mount -o loop,ro /tmpmnt/system.img ${rootmnt}
-			mountroot_status="$?"
-		fi
-		mount --move /tmpmnt ${rootmnt}/data
-
-		# Create any missing persistent directory
-		for dir in system-data system-data/dbus \
-			system-data/network-manager/connections \
-			system-data/network-manager/lib \
-			system-data/log system-data/log/upstart userdata android-data; do
-			mkdir -p ${rootmnt}/data/$dir
-		done
-
-		# Move some data to persistant storage (first-boot)
-		if [ ! -d ${rootmnt}/data/phablet ]; then
-			cp -Ra ${rootmnt}/home/phablet ${rootmnt}/data/phablet
-		fi
-
-		# Mount all the Android partitions
-		mkdir -p ${rootmnt}/android/cache
-		mkdir -p ${rootmnt}/android/system
-		mount -o bind $mrom_dir/cache ${rootmnt}/android/cache
-		mount -o loop,ro ${rootmnt}/var/lib/lxc/android/system.img ${rootmnt}/android/system
-
-		# Apply device-specific udev rules
-		device=$(grep ^ro.product.device= ${rootmnt}/android/system/build.prop |sed -e 's/.*=//')
-		if [ -n "$device" ]; then
-			echo "initrd: identified device as $device" >/dev/kmsg || true
-			mount --bind ${rootmnt}/usr/lib/lxc-android-config/70-$device.rules ${rootmnt}/lib/udev/rules.d/70-android.rules
-		fi
-
-		# Bind-mount /lib/modules from Android
-		[ -e /system/lib/modules ] && mount --bind /system/lib/modules /lib/modules
-
-		# Bind-mount the fstab
-		mount --bind ${rootmnt}/usr/lib/lxc-android-config/image-fstab ${rootmnt}/etc/fstab
-	elif [ -d /tmpmnt/ubuntu ]; then
-		mount --bind /tmpmnt/ubuntu ${rootmnt}
-		mountroot_status="$?"
-		# Possibly a re-partitioned device
-	else
-		echo "initrd: Couldn't find a system partition." >/dev/kmsg || true
-		panic "Couldn't find a system partition. Spawning adbd ..."
-	fi
-}
-
-mountroot()
-{
-	pre_mountroot
-
-	# Make sure the device has been created by udev before we try to mount
-	udevadm settle
-
-	# Get the root filesystem type if not set
-	if [ -z "${ROOTFSTYPE}" ]; then
-		[ -n "${FSTYPE}" ] || FSTYPE=$(blkid -s TYPE -o value "${ROOT}")
-		ROOTFSTYPE="${FSTYPE}"
-	else
-		FSTYPE=${ROOTFSTYPE}
-	fi
-	
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
-	run_scripts /scripts/local-premount
-	[ "$quiet" != "y" ] && log_end_msg
-
-	if [ "${readonly}" = "y" ] && \
-	   [ -z "$LOOP" ]; then
-		roflag=-r
-	else
-		roflag=-w
-	fi
-
-	# FIXME This has no error checking
-	[ -n "${FSTYPE}" ] && modprobe ${FSTYPE}
-
-	# FIXME This has no error checking
-	# Mount root
-	mount ${roflag} ${FSTYPE:+-t ${FSTYPE} }${ROOTFLAGS} ${ROOT} ${rootmnt}
-	mountroot_status="$?"
-	if [ "$LOOP" ]; then
-		if [ "$mountroot_status" != 0 ]; then
-			if [ ${FSTYPE} = ntfs ] || [ ${FSTYPE} = vfat ]; then
-				panic "
-Could not mount the partition ${ROOT}.
-This could also happen if the file system is not clean because of an operating
-system crash, an interrupted boot process, an improper shutdown, or unplugging
-of a removable device without first unmounting or ejecting it.  To fix this,
-simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
-gracefully shut down and reboot back into Windows. After this you should be
-able to reboot again and resume the installation.
-(filesystem = ${FSTYPE}, error code = $mountroot_status)
-"
-			fi
-		fi
-	
-		mkdir -p /host
-		mount -o move ${rootmnt} /host
-
-		if [ ! -d "/host/${LOOP}" ]; then
-		    panic "LOOP folder does not exit on the device, ${LOOP}"
-		fi
-
-		# Get the loop filesystem type if not set
-		if [ -z "${LOOPFSTYPE}" ]; then
-			panic "LOOPFSTYPE was not set!"
-		else
-			FSTYPE="${LOOPFSTYPE}"
-		fi
-
-		if [ "$FSTYPE" = "unknown" ]; then
-			panic "LOOPFSTYPE was set to unknown!"
-		fi
-
-		if [ ${readonly} = y ]; then
-			roflag=-r
-		else
-			roflag=-w
-		fi
-
-		# FIXME This has no error checking
-		modprobe loop
-		modprobe ${FSTYPE}
-
-		mkdir -p /tmpmnt
-		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "/host/${LOOP}/data.img" /tmpmnt
-
-		echo "initrd: mounted all loops" >/dev/kmsg || true
-
-		process_ubuntu "/mrom_dir/"
-		
-		echo "process_ubuntu complete" >/dev/kmsg || true
-
-		mkdir -p ${rootmnt}/host
-		mount -o move /host ${rootmnt}/host
-
-		mkdir -p ${rootmnt}/mrom_dir/data
-		mkdir -p ${rootmnt}/mrom_dir/system
-		mkdir -p ${rootmnt}/mrom_dir/cache
-		mkdir -p ${rootmnt}/data
-		mkdir -p ${rootmnt}/system
-		
-		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "${rootmnt}/host/${LOOP}/system.img" ${rootmnt}/mrom_dir/system
-		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "${rootmnt}/host/${LOOP}/cache.img" ${rootmnt}/mrom_dir/cache
-		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "${rootmnt}/host/${LOOP}/data.img" ${rootmnt}/mrom_dir/data
-		mount -o bind ${rootmnt}/mrom_dir/system ${rootmnt}/system
-		mount -o bind ${rootmnt}/mrom_dir/data ${rootmnt}/data
-	elif [ "$ROOTSUBDIR" ]; then
-		if [ "$mountroot_status" != 0 ]; then
-			panic "
-Could not mount the partition ${ROOT}.
-This could also happen if the file system is not clean because of an operating
-system crash, an interrupted boot process, an improper shutdown, or unplugging
-of a removable device without first unmounting or ejecting it.
-(filesystem = ${FSTYPE}, error code = $mountroot_status)
-"
-		fi
-
-		mkdir -p /host
-		mount -o move ${rootmnt} /host
-		
-		if [ ! -d "/host/$ROOTSUBDIR" ]; then
-		    panic "Failed to bind folder ${ROOTSUBDIR} as root: folder does not exist."
-		fi
-
-		if [ ! -d "/host/$ROOTSUBDIR/data" ]; then
-		    panic "Failed to bind folder ${ROOTSUBDIR}/data: folder does not exist."
-		fi
-
-		mkdir -p /tmpmnt
-		mount -o bind "/host/$ROOTSUBDIR/data" /tmpmnt
-
-		process_ubuntu "/host/$ROOTSUBDIR/"
-
-		mkdir -p ${rootmnt}/host
-		mount -o move /host ${rootmnt}/host
-
-		mrom_dir="${rootmnt}/host/$ROOTSUBDIR"
-
-		mkdir -p ${rootmnt}/system
-		mkdir -p ${rootmnt}/data
-		mkdir -p ${rootmnt}/mrom_dir
-		mount -o bind ${mrom_dir}/system ${rootmnt}/system
-		mount -o bind ${mrom_dir}/data ${rootmnt}/data
-		mount -o bind ${mrom_dir} ${rootmnt}/mrom_dir
-	fi
-
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-bottom"
-	run_scripts /scripts/local-bottom
-	[ "$quiet" != "y" ] && log_end_msg
-}
+# Local filesystem mounting			-*- shell-script -*-
+
+pre_mountroot()
+{
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
+	run_scripts /scripts/local-top
+	[ "$quiet" != "y" ] && log_end_msg
+	
+	# Don't wait for a root device that doesn't have a corresponding
+	# device in /dev (ie, mtd0)
+	if [ "${ROOT#/dev}" = "${ROOT}" ]; then
+		return
+	fi
+
+	while [ -z "${FSTYPE}" ]; do
+		FSTYPE=$(wait-for-root "${ROOT}" ${ROOTDELAY:-30})
+
+		# Load ubi with the correct MTD partition and return since
+		# fstype doesn't work with a char device like ubi.
+		if [ -n "$UBIMTD" ]; then
+			modprobe ubi mtd=$UBIMTD
+			return
+		fi
+
+		# Run failure hooks, hoping one of them can fix up the system
+		# and we can restart the wait loop.  If they all fail, abort
+		# and move on to the panic handler and shell.
+		if [ -z "${FSTYPE}" ] && ! try_failure_hooks; then
+			break
+		fi
+	done
+
+	# We've given up, but we'll let the user fix matters if they can
+	while [ -z "${FSTYPE}" -a ! -e "${ROOT}" ]; do
+		# give hint about renamed root
+		case "${ROOT}" in
+		/dev/hd*)
+			suffix="${ROOT#/dev/hd}"
+			major="${suffix%[[:digit:]]}"
+			major="${major%[[:digit:]]}"
+			if [ -d "/sys/block/sd${major}" ]; then
+				echo "WARNING bootdevice may be renamed. Try root=/dev/sd${suffix}"
+			fi
+			;;
+		/dev/sd*)
+			suffix="${ROOT#/dev/sd}"
+			major="${suffix%[[:digit:]]}"
+			major="${major%[[:digit:]]}"
+			if [ -d "/sys/block/hd${major}" ]; then
+				echo "WARNING bootdevice may be renamed. Try root=/dev/hd${suffix}"
+			fi
+			;;
+		esac
+		echo "Gave up waiting for root device.  Common problems:"
+		echo " - Boot args (cat /proc/cmdline)"
+		echo "   - Check rootdelay= (did the system wait long enough?)"
+		echo "   - Check root= (did the system wait for the right device?)"
+		echo " - Missing modules (cat /proc/modules; ls /dev)"
+		panic "ALERT!  ${ROOT} does not exist.  Dropping to a shell!"
+	done
+}
+
+process_ubuntu()
+{
+	mrom_dir=$1
+
+	if [ -e /tmpmnt/system.img ]; then
+		# Prepare the root filesystem
+		if [ -e /tmpmnt/.developer_mode ]; then
+			echo "initrd: mounting system.img (developer mode)" >/dev/kmsg || true
+			mount -o loop,rw /tmpmnt/system.img ${rootmnt}
+			mountroot_status="$?"
+		else
+			echo "initrd: mounting system.img (user mode)" >/dev/kmsg || true
+			mount -o loop,ro /tmpmnt/system.img ${rootmnt}
+			mountroot_status="$?"
+		fi
+		mount --move /tmpmnt ${rootmnt}/data
+
+		# Create any missing persistent directory
+		for dir in system-data system-data/dbus \
+			system-data/network-manager/connections \
+			system-data/network-manager/lib \
+			system-data/log system-data/log/upstart userdata android-data; do
+			mkdir -p ${rootmnt}/data/$dir
+		done
+
+		# Move some data to persistant storage (first-boot)
+		if [ ! -d ${rootmnt}/data/phablet ]; then
+			cp -Ra ${rootmnt}/home/phablet ${rootmnt}/data/phablet
+		fi
+
+		# Mount all the Android partitions
+		mkdir -p ${rootmnt}/android/cache
+		mkdir -p ${rootmnt}/android/system
+		mount -o bind $mrom_dir/cache ${rootmnt}/android/cache
+		mount -o loop,ro ${rootmnt}/var/lib/lxc/android/system.img ${rootmnt}/android/system
+
+		# Apply device-specific udev rules
+		device=$(grep ^ro.product.device= ${rootmnt}/android/system/build.prop |sed -e 's/.*=//')
+		if [ -n "$device" ]; then
+			echo "initrd: identified device as $device" >/dev/kmsg || true
+			mount --bind ${rootmnt}/usr/lib/lxc-android-config/70-$device.rules ${rootmnt}/lib/udev/rules.d/70-android.rules
+		fi
+
+		# Bind-mount /lib/modules from Android
+		[ -e /system/lib/modules ] && mount --bind /system/lib/modules /lib/modules
+
+		# Bind-mount the fstab
+		mount --bind ${rootmnt}/usr/lib/lxc-android-config/image-fstab ${rootmnt}/etc/fstab
+	elif [ -d /tmpmnt/ubuntu ]; then
+		mount --bind /tmpmnt/ubuntu ${rootmnt}
+		mountroot_status="$?"
+		# Possibly a re-partitioned device
+	else
+		echo "initrd: Couldn't find a system partition." >/dev/kmsg || true
+		panic "Couldn't find a system partition. Spawning adbd ..."
+	fi
+}
+
+mountroot()
+{
+	pre_mountroot
+
+	# Make sure the device has been created by udev before we try to mount
+	udevadm settle
+
+	# Get the root filesystem type if not set
+	if [ -z "${ROOTFSTYPE}" ]; then
+		[ -n "${FSTYPE}" ] || FSTYPE=$(blkid -s TYPE -o value "${ROOT}")
+		ROOTFSTYPE="${FSTYPE}"
+	else
+		FSTYPE=${ROOTFSTYPE}
+	fi
+	
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
+	run_scripts /scripts/local-premount
+	[ "$quiet" != "y" ] && log_end_msg
+
+	if [ "${readonly}" = "y" ] && \
+	   [ -z "$LOOP" ]; then
+		roflag=-r
+	else
+		roflag=-w
+	fi
+
+	# FIXME This has no error checking
+	[ -n "${FSTYPE}" ] && modprobe ${FSTYPE}
+
+	# FIXME This has no error checking
+	# Mount root
+	mount ${roflag} ${FSTYPE:+-t ${FSTYPE} }${ROOTFLAGS} ${ROOT} ${rootmnt}
+	mountroot_status="$?"
+	if [ "$LOOP" ]; then
+		if [ "$mountroot_status" != 0 ]; then
+			if [ ${FSTYPE} = ntfs ] || [ ${FSTYPE} = vfat ]; then
+				panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+			fi
+		fi
+	
+		mkdir -p /host
+		mount -o move ${rootmnt} /host
+
+		if [ ! -d "/host/${LOOP}" ]; then
+		    panic "LOOP folder does not exit on the device, ${LOOP}"
+		fi
+
+		# Get the loop filesystem type if not set
+		if [ -z "${LOOPFSTYPE}" ]; then
+			panic "LOOPFSTYPE was not set!"
+		else
+			FSTYPE="${LOOPFSTYPE}"
+		fi
+
+		if [ "$FSTYPE" = "unknown" ]; then
+			panic "LOOPFSTYPE was set to unknown!"
+		fi
+
+		if [ ${readonly} = y ]; then
+			roflag=-r
+		else
+			roflag=-w
+		fi
+
+		# FIXME This has no error checking
+		modprobe loop
+		modprobe ${FSTYPE}
+
+		mkdir -p /tmpmnt
+		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "/host/${LOOP}/data.img" /tmpmnt
+
+		echo "initrd: mounted all loops" >/dev/kmsg || true
+
+		process_ubuntu "/mrom_dir/"
+		
+		echo "process_ubuntu complete" >/dev/kmsg || true
+
+		mkdir -p ${rootmnt}/host
+		mount -o move /host ${rootmnt}/host
+
+		mkdir -p ${rootmnt}/mrom_dir/data
+		mkdir -p ${rootmnt}/mrom_dir/system
+		mkdir -p ${rootmnt}/mrom_dir/cache
+		mkdir -p ${rootmnt}/data
+		mkdir -p ${rootmnt}/system
+		
+		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "${rootmnt}/host/${LOOP}/system.img" ${rootmnt}/mrom_dir/system
+		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "${rootmnt}/host/${LOOP}/cache.img" ${rootmnt}/mrom_dir/cache
+		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "${rootmnt}/host/${LOOP}/data.img" ${rootmnt}/mrom_dir/data
+		mount -o bind ${rootmnt}/mrom_dir/system ${rootmnt}/system
+		mount -o bind ${rootmnt}/mrom_dir/data ${rootmnt}/data
+	elif [ "$ROOTSUBDIR" ]; then
+		if [ "$mountroot_status" != 0 ]; then
+			panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+		fi
+
+		mkdir -p /host
+		mount -o move ${rootmnt} /host
+		
+		if [ ! -d "/host/$ROOTSUBDIR" ]; then
+		    panic "Failed to bind folder ${ROOTSUBDIR} as root: folder does not exist."
+		fi
+
+		if [ ! -d "/host/$ROOTSUBDIR/data" ]; then
+		    panic "Failed to bind folder ${ROOTSUBDIR}/data: folder does not exist."
+		fi
+
+		mkdir -p /tmpmnt
+		mount -o bind "/host/$ROOTSUBDIR/data" /tmpmnt
+
+		process_ubuntu "/host/$ROOTSUBDIR/"
+
+		mkdir -p ${rootmnt}/host
+		mount -o move /host ${rootmnt}/host
+
+		mrom_dir="${rootmnt}/host/$ROOTSUBDIR"
+
+		mkdir -p ${rootmnt}/system
+		mkdir -p ${rootmnt}/data
+		mkdir -p ${rootmnt}/mrom_dir
+		mount -o bind ${mrom_dir}/system ${rootmnt}/system
+		mount -o bind ${mrom_dir}/data ${rootmnt}/data
+		mount -o bind ${mrom_dir} ${rootmnt}/mrom_dir
+	fi
+
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-bottom"
+	run_scripts /scripts/local-bottom
+	[ "$quiet" != "y" ] && log_end_msg
+}
diff --git a/install_zip/prebuilt-installer/multirom/ubuntu-touch-sysimage-init/init b/install_zip/prebuilt-installer/multirom/ubuntu-touch-sysimage-init/init
index 99425be..7cdc5da 100755
--- a/install_zip/prebuilt-installer/multirom/ubuntu-touch-sysimage-init/init
+++ b/install_zip/prebuilt-installer/multirom/ubuntu-touch-sysimage-init/init
@@ -1,356 +1,356 @@
-#!/bin/sh
-
-[ -d /dev ] || mkdir -m 0755 /dev
-[ -d /root ] || mkdir -m 0700 /root
-[ -d /sys ] || mkdir /sys
-[ -d /proc ] || mkdir /proc
-[ -d /tmp ] || mkdir /tmp
-mkdir -p /var/lock
-mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
-mount -t proc -o nodev,noexec,nosuid proc /proc
-# Some things don't work properly without /etc/mtab.
-ln -sf /proc/mounts /etc/mtab
-
-grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."
-
-# Note that this only becomes /dev on the real filesystem if udev's scripts
-# are used; which they will be, but it's worth pointing out
-if ! mount -t devtmpfs -o mode=0755 udev /dev; then
-	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
-	mount -t tmpfs -o mode=0755 udev /dev
-	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
-	[ -e /dev/null ] || mknod /dev/null c 1 3
-fi
-mkdir /dev/pts
-mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
-mount -t tmpfs -o "noexec,nosuid,size=10%,mode=0755" tmpfs /run
-mkdir /run/initramfs
-# compatibility symlink for the pre-oneiric locations
-ln -s /run/initramfs /dev/.initramfs
-
-# Export the dpkg architecture
-export DPKG_ARCH=
-. /conf/arch.conf
-
-# Set modprobe env
-export MODPROBE_OPTIONS="-qb"
-
-# Export relevant variables
-export ROOT=
-export ROOTDELAY=
-export ROOTFLAGS=
-export ROOTFSTYPE=
-export IP=
-export BOOT=
-export BOOTIF=
-export UBIMTD=
-export break=
-export init=/sbin/init
-export quiet=n
-export readonly=y
-export rootmnt=/root
-export debug=
-export panic=
-export blacklist=
-export resume=
-export resume_offset=
-export recovery=
-
-# mdadm needs hostname to be set. This has to be done before the udev rules are called!
-if [ -f "/etc/hostname" ]; then
-        /bin/hostname -b -F /etc/hostname 2>&1 1>/dev/null
-fi
-
-# Bring in the main config
-. /conf/initramfs.conf
-for conf in conf/conf.d/*; do
-	[ -f ${conf} ] && . ${conf}
-done
-. /scripts/functions
-
-# Parse command line options
-for x in $(cat /proc/cmdline); do
-	case $x in
-	init=*)
-		init=${x#init=}
-		;;
-	root=*)
-		ROOT=${x#root=}
-		case $ROOT in
-		LABEL=*)
-			ROOT="${ROOT#LABEL=}"
-
-			# support any / in LABEL= path (escape to \x2f)
-			case "${ROOT}" in
-			*/*)
-			if command -v sed >/dev/null 2>&1; then
-				ROOT="$(echo ${ROOT} | sed 's,/,\\x2f,g')"
-			else
-				if [ "${ROOT}" != "${ROOT#/}" ]; then
-					ROOT="\x2f${ROOT#/}"
-				fi
-				if [ "${ROOT}" != "${ROOT%/}" ]; then
-					ROOT="${ROOT%/}\x2f"
-				fi
-				IFS='/'
-				newroot=
-				for s in $ROOT; do
-					newroot="${newroot:+${newroot}\\x2f}${s}"
-				done
-				unset IFS
-				ROOT="${newroot}"
-			fi
-			esac
-			ROOT="/dev/disk/by-label/${ROOT}"
-			;;
-		UUID=*)
-			ROOT="/dev/disk/by-uuid/${ROOT#UUID=}"
-			;;
-		/dev/nfs)
-			[ -z "${BOOT}" ] && BOOT=nfs
-			;;
-		esac
-		;;
-	rootflags=*)
-		ROOTFLAGS="-o ${x#rootflags=}"
-		;;
-	rootfstype=*)
-		ROOTFSTYPE="${x#rootfstype=}"
-		;;
-	rootdelay=*)
-		ROOTDELAY="${x#rootdelay=}"
-		case ${ROOTDELAY} in
-		*[![:digit:].]*)
-			ROOTDELAY=
-			;;
-		esac
-		;;
-	resumedelay=*)
-		RESUMEDELAY="${x#resumedelay=}"
-		;;
-	loop=*)
-		LOOP="${x#loop=}"
-		;;
-	loopflags=*)
-		LOOPFLAGS="-o ${x#loopflags=}"
-		;;
-	loopfstype=*)
-		LOOPFSTYPE="${x#loopfstype=}"
-		;;
-	rootsubdir=*)
-		ROOTSUBDIR="${x#rootsubdir=}"
-		;;
-	cryptopts=*)
-		cryptopts="${x#cryptopts=}"
-		;;
-	nfsroot=*)
-		NFSROOT="${x#nfsroot=}"
-		;;
-	netboot=*)
-		NETBOOT="${x#netboot=}"
-		;;
-	ip=*)
-		IP="${x#ip=}"
-		;;
-	boot=*)
-		BOOT=${x#boot=}
-		;;
-	ubi.mtd=*)
-		UBIMTD=${x#ubi.mtd=}
-		;;
-	resume=*)
-		RESUME="${x#resume=}"
-		;;
-	resume_offset=*)
-		resume_offset="${x#resume_offset=}"
-		;;
-	noresume)
-		noresume=y
-		;;
-	panic=*)
-		panic="${x#panic=}"
-		case ${panic} in
-		*[![:digit:].]*)
-			panic=
-			;;
-		esac
-		;;
-	quiet)
-		quiet=y
-		;;
-	ro)
-		readonly=y
-		;;
-	rw)
-		readonly=n
-		;;
-	debug)
-		debug=y
-		quiet=n
-		exec >/run/initramfs/initramfs.debug 2>&1
-		set -x
-		;;
-	debug=*)
-		debug=y
-		quiet=n
-		set -x
-		;;
-	break=*)
-		break=${x#break=}
-		;;
-	break)
-		break=premount
-		;;
-	blacklist=*)
-		blacklist=${x#blacklist=}
-		;;
-	netconsole=*)
-		netconsole=${x#netconsole=}
-		;;
-	BOOTIF=*)
-		BOOTIF=${x#BOOTIF=}
-		;;
-	hwaddr=*)
-		BOOTIF=${x#BOOTIF=}
-		;;
-	recovery)
-		recovery=y
-		;;
-	esac
-done
-
-if [ -n "${noresume}" ]; then
-	export noresume
-	unset resume
-else
-	resume=${RESUME:-}
-fi
-
-maybe_break top
-
-# export BOOT variable value for compcache,
-# so we know if we run from casper
-export BOOT
-
-# Don't do log messages here to avoid confusing graphical boots
-run_scripts /scripts/init-top
-
-maybe_break modules
-[ "$quiet" != "y" ] && log_begin_msg "Loading essential drivers"
-load_modules
-[ "$quiet" != "y" ] && log_end_msg
-
-[ -n "${netconsole}" ] && modprobe netconsole netconsole="${netconsole}"
-
-maybe_break premount
-[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-premount"
-run_scripts /scripts/init-premount
-[ "$quiet" != "y" ] && log_end_msg
-
-maybe_break mount
-log_begin_msg "Mounting root file system"
-. /scripts/${BOOT}
-parse_numeric ${ROOT}
-maybe_break mountroot
-mountroot
-log_end_msg
-
-maybe_break bottom
-[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-bottom"
-run_scripts /scripts/init-bottom
-[ "$quiet" != "y" ] && log_end_msg
-
-# Preserve information on old systems without /run on the rootfs
-if [ -d ${rootmnt}/run ]; then
-	mount -n -o move /run ${rootmnt}/run
-else
-	# The initramfs udev database must be migrated:
-	if [ -d /run/udev ] && [ ! -d /dev/.udev ]; then
-		mv /run/udev /dev/.udev
-	fi
-	# The initramfs debug info must be migrated:
-	if [ -d /run/initramfs ] && [ ! -d /dev/.initramfs ]; then
-		mv /run/initramfs /dev/.initramfs
-	fi
-	umount /run
-fi
-
-# Move virtual filesystems over to the real filesystem
-mount -n -o move /sys ${rootmnt}/sys
-mount -n -o move /proc ${rootmnt}/proc
-
-validate_init() {
-	checktarget="${1}"
-
-	# Work around absolute symlinks
-	if [ -d "${rootmnt}" ] && [ -h "${rootmnt}${checktarget}" ]; then
-		case $(readlink "${rootmnt}${checktarget}") in /*)
-			checktarget="$(chroot ${rootmnt} readlink ${checktarget})"
-			;;
-		esac
-	fi
-
-	# Make sure the specified init can be executed
-	if [ ! -x "${rootmnt}${checktarget}" ]; then
-		return 1
-	fi
-
-	# Upstart uses /etc/init as configuration directory :-/
-	if [ -d "${rootmnt}${checktarget}" ]; then
-		return 1
-	fi
-}
-
-# Check init bootarg
-if [ -n "${init}" ]; then
-	if ! validate_init "$init"; then
-		echo "Target filesystem doesn't have requested ${init}."
-		init=
-	fi
-fi
-
-# Common case: /sbin/init is present
-if [ ! -x "${rootmnt}/sbin/init" ]; then
-	# ... if it's not available search for valid init
-	if [ -z "${init}" ] ; then
-		for inittest in /sbin/init /etc/init /bin/init /bin/sh; do
-			if validate_init "${inittest}"; then
-				init="$inittest"
-				break
-			fi
-		done
-	fi
-
-	# No init on rootmount
-	if ! validate_init "${init}" ; then
-		panic "No init found. Try passing init= bootarg."
-	fi
-fi
-
-maybe_break init
-
-# don't leak too much of env - some init(8) don't clear it
-# (keep init, rootmnt)
-unset debug
-unset MODPROBE_OPTIONS
-unset DPKG_ARCH
-unset ROOTFLAGS
-unset ROOTFSTYPE
-unset ROOTDELAY
-unset ROOT
-unset IP
-unset BOOT
-unset BOOTIF
-unset UBIMTD
-unset blacklist
-unset break
-unset noresume
-unset panic
-unset quiet
-unset readonly
-unset resume
-unset resume_offset
-
-# Chain to real filesystem
-exec run-init ${rootmnt} ${init} "$@" ${recovery:+--startup-event=recovery} <${rootmnt}/dev/console >${rootmnt}/dev/console 2>&1
-panic "Could not execute run-init."
+#!/bin/sh
+
+[ -d /dev ] || mkdir -m 0755 /dev
+[ -d /root ] || mkdir -m 0700 /root
+[ -d /sys ] || mkdir /sys
+[ -d /proc ] || mkdir /proc
+[ -d /tmp ] || mkdir /tmp
+mkdir -p /var/lock
+mount -t sysfs -o nodev,noexec,nosuid sysfs /sys
+mount -t proc -o nodev,noexec,nosuid proc /proc
+# Some things don't work properly without /etc/mtab.
+ln -sf /proc/mounts /etc/mtab
+
+grep -q '\<quiet\>' /proc/cmdline || echo "Loading, please wait..."
+
+# Note that this only becomes /dev on the real filesystem if udev's scripts
+# are used; which they will be, but it's worth pointing out
+if ! mount -t devtmpfs -o mode=0755 udev /dev; then
+	echo "W: devtmpfs not available, falling back to tmpfs for /dev"
+	mount -t tmpfs -o mode=0755 udev /dev
+	[ -e /dev/console ] || mknod -m 0600 /dev/console c 5 1
+	[ -e /dev/null ] || mknod /dev/null c 1 3
+fi
+mkdir /dev/pts
+mount -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts || true
+mount -t tmpfs -o "noexec,nosuid,size=10%,mode=0755" tmpfs /run
+mkdir /run/initramfs
+# compatibility symlink for the pre-oneiric locations
+ln -s /run/initramfs /dev/.initramfs
+
+# Export the dpkg architecture
+export DPKG_ARCH=
+. /conf/arch.conf
+
+# Set modprobe env
+export MODPROBE_OPTIONS="-qb"
+
+# Export relevant variables
+export ROOT=
+export ROOTDELAY=
+export ROOTFLAGS=
+export ROOTFSTYPE=
+export IP=
+export BOOT=
+export BOOTIF=
+export UBIMTD=
+export break=
+export init=/sbin/init
+export quiet=n
+export readonly=y
+export rootmnt=/root
+export debug=
+export panic=
+export blacklist=
+export resume=
+export resume_offset=
+export recovery=
+
+# mdadm needs hostname to be set. This has to be done before the udev rules are called!
+if [ -f "/etc/hostname" ]; then
+        /bin/hostname -b -F /etc/hostname 2>&1 1>/dev/null
+fi
+
+# Bring in the main config
+. /conf/initramfs.conf
+for conf in conf/conf.d/*; do
+	[ -f ${conf} ] && . ${conf}
+done
+. /scripts/functions
+
+# Parse command line options
+for x in $(cat /proc/cmdline); do
+	case $x in
+	init=*)
+		init=${x#init=}
+		;;
+	root=*)
+		ROOT=${x#root=}
+		case $ROOT in
+		LABEL=*)
+			ROOT="${ROOT#LABEL=}"
+
+			# support any / in LABEL= path (escape to \x2f)
+			case "${ROOT}" in
+			*/*)
+			if command -v sed >/dev/null 2>&1; then
+				ROOT="$(echo ${ROOT} | sed 's,/,\\x2f,g')"
+			else
+				if [ "${ROOT}" != "${ROOT#/}" ]; then
+					ROOT="\x2f${ROOT#/}"
+				fi
+				if [ "${ROOT}" != "${ROOT%/}" ]; then
+					ROOT="${ROOT%/}\x2f"
+				fi
+				IFS='/'
+				newroot=
+				for s in $ROOT; do
+					newroot="${newroot:+${newroot}\\x2f}${s}"
+				done
+				unset IFS
+				ROOT="${newroot}"
+			fi
+			esac
+			ROOT="/dev/disk/by-label/${ROOT}"
+			;;
+		UUID=*)
+			ROOT="/dev/disk/by-uuid/${ROOT#UUID=}"
+			;;
+		/dev/nfs)
+			[ -z "${BOOT}" ] && BOOT=nfs
+			;;
+		esac
+		;;
+	rootflags=*)
+		ROOTFLAGS="-o ${x#rootflags=}"
+		;;
+	rootfstype=*)
+		ROOTFSTYPE="${x#rootfstype=}"
+		;;
+	rootdelay=*)
+		ROOTDELAY="${x#rootdelay=}"
+		case ${ROOTDELAY} in
+		*[![:digit:].]*)
+			ROOTDELAY=
+			;;
+		esac
+		;;
+	resumedelay=*)
+		RESUMEDELAY="${x#resumedelay=}"
+		;;
+	loop=*)
+		LOOP="${x#loop=}"
+		;;
+	loopflags=*)
+		LOOPFLAGS="-o ${x#loopflags=}"
+		;;
+	loopfstype=*)
+		LOOPFSTYPE="${x#loopfstype=}"
+		;;
+	rootsubdir=*)
+		ROOTSUBDIR="${x#rootsubdir=}"
+		;;
+	cryptopts=*)
+		cryptopts="${x#cryptopts=}"
+		;;
+	nfsroot=*)
+		NFSROOT="${x#nfsroot=}"
+		;;
+	netboot=*)
+		NETBOOT="${x#netboot=}"
+		;;
+	ip=*)
+		IP="${x#ip=}"
+		;;
+	boot=*)
+		BOOT=${x#boot=}
+		;;
+	ubi.mtd=*)
+		UBIMTD=${x#ubi.mtd=}
+		;;
+	resume=*)
+		RESUME="${x#resume=}"
+		;;
+	resume_offset=*)
+		resume_offset="${x#resume_offset=}"
+		;;
+	noresume)
+		noresume=y
+		;;
+	panic=*)
+		panic="${x#panic=}"
+		case ${panic} in
+		*[![:digit:].]*)
+			panic=
+			;;
+		esac
+		;;
+	quiet)
+		quiet=y
+		;;
+	ro)
+		readonly=y
+		;;
+	rw)
+		readonly=n
+		;;
+	debug)
+		debug=y
+		quiet=n
+		exec >/run/initramfs/initramfs.debug 2>&1
+		set -x
+		;;
+	debug=*)
+		debug=y
+		quiet=n
+		set -x
+		;;
+	break=*)
+		break=${x#break=}
+		;;
+	break)
+		break=premount
+		;;
+	blacklist=*)
+		blacklist=${x#blacklist=}
+		;;
+	netconsole=*)
+		netconsole=${x#netconsole=}
+		;;
+	BOOTIF=*)
+		BOOTIF=${x#BOOTIF=}
+		;;
+	hwaddr=*)
+		BOOTIF=${x#BOOTIF=}
+		;;
+	recovery)
+		recovery=y
+		;;
+	esac
+done
+
+if [ -n "${noresume}" ]; then
+	export noresume
+	unset resume
+else
+	resume=${RESUME:-}
+fi
+
+maybe_break top
+
+# export BOOT variable value for compcache,
+# so we know if we run from casper
+export BOOT
+
+# Don't do log messages here to avoid confusing graphical boots
+run_scripts /scripts/init-top
+
+maybe_break modules
+[ "$quiet" != "y" ] && log_begin_msg "Loading essential drivers"
+load_modules
+[ "$quiet" != "y" ] && log_end_msg
+
+[ -n "${netconsole}" ] && modprobe netconsole netconsole="${netconsole}"
+
+maybe_break premount
+[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-premount"
+run_scripts /scripts/init-premount
+[ "$quiet" != "y" ] && log_end_msg
+
+maybe_break mount
+log_begin_msg "Mounting root file system"
+. /scripts/${BOOT}
+parse_numeric ${ROOT}
+maybe_break mountroot
+mountroot
+log_end_msg
+
+maybe_break bottom
+[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/init-bottom"
+run_scripts /scripts/init-bottom
+[ "$quiet" != "y" ] && log_end_msg
+
+# Preserve information on old systems without /run on the rootfs
+if [ -d ${rootmnt}/run ]; then
+	mount -n -o move /run ${rootmnt}/run
+else
+	# The initramfs udev database must be migrated:
+	if [ -d /run/udev ] && [ ! -d /dev/.udev ]; then
+		mv /run/udev /dev/.udev
+	fi
+	# The initramfs debug info must be migrated:
+	if [ -d /run/initramfs ] && [ ! -d /dev/.initramfs ]; then
+		mv /run/initramfs /dev/.initramfs
+	fi
+	umount /run
+fi
+
+# Move virtual filesystems over to the real filesystem
+mount -n -o move /sys ${rootmnt}/sys
+mount -n -o move /proc ${rootmnt}/proc
+
+validate_init() {
+	checktarget="${1}"
+
+	# Work around absolute symlinks
+	if [ -d "${rootmnt}" ] && [ -h "${rootmnt}${checktarget}" ]; then
+		case $(readlink "${rootmnt}${checktarget}") in /*)
+			checktarget="$(chroot ${rootmnt} readlink ${checktarget})"
+			;;
+		esac
+	fi
+
+	# Make sure the specified init can be executed
+	if [ ! -x "${rootmnt}${checktarget}" ]; then
+		return 1
+	fi
+
+	# Upstart uses /etc/init as configuration directory :-/
+	if [ -d "${rootmnt}${checktarget}" ]; then
+		return 1
+	fi
+}
+
+# Check init bootarg
+if [ -n "${init}" ]; then
+	if ! validate_init "$init"; then
+		echo "Target filesystem doesn't have requested ${init}."
+		init=
+	fi
+fi
+
+# Common case: /sbin/init is present
+if [ ! -x "${rootmnt}/sbin/init" ]; then
+	# ... if it's not available search for valid init
+	if [ -z "${init}" ] ; then
+		for inittest in /sbin/init /etc/init /bin/init /bin/sh; do
+			if validate_init "${inittest}"; then
+				init="$inittest"
+				break
+			fi
+		done
+	fi
+
+	# No init on rootmount
+	if ! validate_init "${init}" ; then
+		panic "No init found. Try passing init= bootarg."
+	fi
+fi
+
+maybe_break init
+
+# don't leak too much of env - some init(8) don't clear it
+# (keep init, rootmnt)
+unset debug
+unset MODPROBE_OPTIONS
+unset DPKG_ARCH
+unset ROOTFLAGS
+unset ROOTFSTYPE
+unset ROOTDELAY
+unset ROOT
+unset IP
+unset BOOT
+unset BOOTIF
+unset UBIMTD
+unset blacklist
+unset break
+unset noresume
+unset panic
+unset quiet
+unset readonly
+unset resume
+unset resume_offset
+
+# Chain to real filesystem
+exec run-init ${rootmnt} ${init} "$@" ${recovery:+--startup-event=recovery} <${rootmnt}/dev/console >${rootmnt}/dev/console 2>&1
+panic "Could not execute run-init."
diff --git a/install_zip/prebuilt-installer/multirom/ubuntu-touch-sysimage-init/scripts/touch b/install_zip/prebuilt-installer/multirom/ubuntu-touch-sysimage-init/scripts/touch
index cfcbc67..f8eede1 100755
--- a/install_zip/prebuilt-installer/multirom/ubuntu-touch-sysimage-init/scripts/touch
+++ b/install_zip/prebuilt-installer/multirom/ubuntu-touch-sysimage-init/scripts/touch
@@ -1,461 +1,461 @@
-# Local filesystem mounting			-*- shell-script -*-
-
-pre_mountroot()
-{
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
-	run_scripts /scripts/local-top
-	[ "$quiet" != "y" ] && log_end_msg
-	
-	# Don't wait for a root device that doesn't have a corresponding
-	# device in /dev (ie, mtd0)
-	if [ "${ROOT#/dev}" = "${ROOT}" ]; then
-		return
-	fi
-
-	while [ -z "${FSTYPE}" ]; do
-		FSTYPE=$(wait-for-root "${ROOT}" ${ROOTDELAY:-30})
-
-		# Load ubi with the correct MTD partition and return since
-		# fstype doesn't work with a char device like ubi.
-		if [ -n "$UBIMTD" ]; then
-			modprobe ubi mtd=$UBIMTD
-			return
-		fi
-
-		# Run failure hooks, hoping one of them can fix up the system
-		# and we can restart the wait loop.  If they all fail, abort
-		# and move on to the panic handler and shell.
-		if [ -z "${FSTYPE}" ] && ! try_failure_hooks; then
-			break
-		fi
-	done
-
-	# We've given up, but we'll let the user fix matters if they can
-	while [ -z "${FSTYPE}" -a ! -e "${ROOT}" ]; do
-		# give hint about renamed root
-		case "${ROOT}" in
-		/dev/hd*)
-			suffix="${ROOT#/dev/hd}"
-			major="${suffix%[[:digit:]]}"
-			major="${major%[[:digit:]]}"
-			if [ -d "/sys/block/sd${major}" ]; then
-				echo "WARNING bootdevice may be renamed. Try root=/dev/sd${suffix}"
-			fi
-			;;
-		/dev/sd*)
-			suffix="${ROOT#/dev/sd}"
-			major="${suffix%[[:digit:]]}"
-			major="${major%[[:digit:]]}"
-			if [ -d "/sys/block/hd${major}" ]; then
-				echo "WARNING bootdevice may be renamed. Try root=/dev/hd${suffix}"
-			fi
-			;;
-		esac
-		echo "Gave up waiting for root device.  Common problems:"
-		echo " - Boot args (cat /proc/cmdline)"
-		echo "   - Check rootdelay= (did the system wait long enough?)"
-		echo "   - Check root= (did the system wait for the right device?)"
-		echo " - Missing modules (cat /proc/modules; ls /dev)"
-		panic "ALERT!  ${ROOT} does not exist.  Dropping to a shell!"
-	done
-}
-
-mount_ubuntu_overlay() {
-	source=$1
-	target=$2
-
-	if [ -d ${source} ]; then
-		OLD_PWD=$PWD
-		cd ${source}
-
-		for overlay in `find . -type f`; do
-			[ -f ${target}/${overlay} ] && mount --bind ${source}/${overlay} ${target}/${overlay}
-		done
-
-		cd $OLD_PWD
-	fi
-}
-
-
-sync_dirs() {
-	base=$1
-	source=$2
-	target=$3
-
-	OLD_PWD=$PWD
-	cd $base
-
-	for file in $source/*
-	do
-		# Skip empty directories
-		[ ! -e "$base/$file" ] && continue
-
-		# If the target already exists as a file or link, there's nothing we can do
-		[ -e "$target/$file" -o -L "$target/$file" ] && [ ! -d "$target/$file" ] && continue
-
-		# If the target doesn't exist, just copy it over
-		if [ ! -e "$target/$file" -a ! -L "$target/$file" ]; then
-			cp -Ra "$base/$file" "$target/$file"
-			continue
-		fi
-
-		# That leaves us with directories and a recursive call
-		[ -d $file ] && sync_dirs $base $file $target
-	done
-
-	cd $OLD_PWD
-}
-
-process_ubuntu()
-{
-	cache_dir="$1"
-	fw_image="$2"
-
-	# Loop-mounted flipped model
-	if [ -e /tmpmnt/system.img ]; then
-		# Transition .developer_mode to .writable_image
-		[ -e /tmpmnt/.developer_mode ] && mv /tmpmnt/.developer_mode /tmpmnt/.writable_image
-
-		# Prepare the root filesystem
-		# NOTE: We mount it read-write in all cases, then remount read-only.
-		#       This is to workaround a behaviour change in busybox which now
-		#       uses read-only loops if the fs is initially mounted read-only.
-		#       An alternative implementation would be to add losetup support
-		#       to busybox and do the mount in two steps (rw loop, ro fs).
-		mount -o loop,rw /tmpmnt/system.img ${rootmnt}
-		if [ -e /tmpmnt/.writable_image ]; then
-			echo "initrd: mounting system.img (image developer mode)" >/dev/kmsg || true
-			mountroot_status="$?"
-		else
-			echo "initrd: mounting system.img (user mode)" >/dev/kmsg || true
-			mount -o remount,ro ${rootmnt}
-			mountroot_status="$?"
-		fi
-		mount --move /tmpmnt ${rootmnt}/userdata
-
-		# Mount the android system partition to a temporary location
-		mkdir -p /android-system
-		mount -o loop,ro ${rootmnt}/var/lib/lxc/android/system.img /android-system
-
-		# Get device information
-		device=$(grep ^ro.product.device= /android-system/build.prop |sed -e 's/.*=//')
-		[ -z "$device" ] && device="unknown"
-		echo "initrd: device is $device" >/dev/kmsg || true
-
-		# Mount some tmpfs
-		mkdir -p ${rootmnt}/android
-		mount -o rw,size=4096 -t tmpfs none ${rootmnt}/android
-		mount -o rw,nosuid,noexec,relatime,mode=755 -t tmpfs tmpfs ${rootmnt}/run
-
-		# Create some needed paths on tmpfs
-		mkdir -p ${rootmnt}/android/data ${rootmnt}/android/system ${rootmnt}/android/cache
-
-		# Prepare the fstab
-		FSTAB=${rootmnt}/etc/fstab
-		touch ${rootmnt}/run/image.fstab
-		mount -o bind ${rootmnt}/run/image.fstab $FSTAB || panic "drop to adb"
-		echo "/dev/root / rootfs defaults,ro 0 1" >> $FSTAB
-
-		# Process the list of bind-mounts
-		# (but don't mount them, mountall will do it)
-		cat ${rootmnt}/etc/system-image/writable-paths | while read line; do
-			set -- $line
-			# Skip invalid/commented entries
-			([ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ] || [ -z "$5" ]) && continue
-			[ "$1" = "#" ] && continue
-
-			# Skip invalid mount points
-			dstpath="${rootmnt}/$1"
-			[ ! -e "$dstpath" ] && continue
-
-			if [ "$3" = "temporary" ]; then
-				# Temporary entries are simple, just mount a tmpfs
-				echo "tmpfs $1 tmpfs $5 0 0" >> $FSTAB
-			elif [ "$3" = "persistent" ] || [ "$3" = "synced" ]; then
-				# Figure out the source path
-				if [ "$2" = "auto" ]; then
-					srcpath="${rootmnt}/userdata/system-data/$1"
-					path="/userdata/system-data/$1"
-				else
-					srcpath="${rootmnt}/userdata/$2"
-					path="/userdata/$2"
-				fi
-
-				if [ ! -e "$srcpath" ]; then
-					# Process new persistent or synced paths
-					dstown=$(stat -c "%u:%g" $dstpath)
-					dstmode=$(stat -c "%a" $dstpath)
-					mkdir -p ${srcpath%/*}
-					if [ ! -d "$dstpath" ]; then
-						# Deal with redirected files
-						if [ "$4" = "transition" ]; then
-							cp -a $dstpath $srcpath
-						else
-							touch $srcpath
-							chown $dstown $srcpath
-							chmod $dstmode $srcpath
-						fi
-					else
-						# Deal with redirected directories
-						if [ "$4" = "transition" ] || [ "$3" = "synced" ]; then
-							cp -aR $dstpath $srcpath
-						else
-							mkdir $srcpath
-							chown $dstown $srcpath
-							chmod $dstmode $srcpath
-						fi
-					fi
-				elif [ "$3" = "synced" ]; then
-					# Process existing synced paths
-					sync_dirs $dstpath . $srcpath
-				fi
-
-				# Write the fstab entry
-				if [ "$5" = "none" ]; then
-					echo "$path $1 none bind 0 0" >> $FSTAB
-				else
-					echo "$path $1 none bind,$5 0 0" >> $FSTAB
-				fi
-			else
-				continue
-			fi
-		done
-
-		# Extract the fstab from the android initrd
-		# NOTE: we should find a faster way of doing that or cache it
-		OLD_CWD=$(pwd)
-#		cd /android-initrd
-#		cat /android-system/boot/android-ramdisk.img | gzip -d | cpio -i fstab*
-		mount -n -t tmpfs tmpfs ${rootmnt}/var/lib/lxc/android/rootfs
-		cd ${rootmnt}/var/lib/lxc/android/rootfs
-		cat /android-system/boot/android-ramdisk.img | gzip -d | cpio -i
-		cd $OLD_CWD
-
-		# Mount all the Android partitions
-		cat ${rootmnt}/var/lib/lxc/android/rootfs/fstab* | while read line; do
-			set -- $line
-
-			# Skip any unwanted entry
-			echo $1 | egrep -q "^#" && continue
-			([ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]) && continue
-			([ "$2" = "/system" ] || [ "$2" = "/data" ] || [ "$2" = "/cache" ]) && continue
-			# Skip firmware if custom fw_image is present
-			([ -n "$fw_image" ] && [ "$2" = "/firmware" ]) && continue
-
-			label=$(echo $1 | awk -F/ '{print $NF}')
-			[ -z "$label" ] && continue
-
-			echo "initrd: checking mount label $label" >/dev/kmsg || true
-
-			for dir in by-partlabel by-name by-label by-path by-uuid by-partuuid by-id; do
-				path="/dev/disk/$dir/$label"
-				[ -e "$path" ] && break
-			done
-
-			# MTD based devices, such as the emulator
-			if [ ! -e "$path" ] && echo $label | egrep -q "^mtdblock"; then
-				path="/dev/$label"
-			fi
-
-			[ ! -e "$path" ] && continue
-
-			mkdir -p ${rootmnt}/android/$2
-			echo "initrd: mounting $path as ${rootmnt}/android/$2" >/dev/kmsg || true
-			mount $path ${rootmnt}/android/$2 -t $3 -o $4
-		done
-
-		# system is a special case
-		echo "initrd: mounting ${rootmnt}/var/lib/lxc/android/system.img as ${rootmnt}/android/system" >/dev/kmsg || true
-		mount --move /android-system ${rootmnt}/android/system
-
-		# cache is a special case
-		echo "initrd: mounting ${cache_dir} as ${rootmnt}/android/cache" >/dev/kmsg || true
-		mount -o bind ${cache_dir} ${rootmnt}/android/cache
-
-		# mount fw image if present
-		if [ -n "$fw_image" ]; then
-			echo "initrd: mounting ${fw_image} as ${rootmnt}/android/firmware" > /dev/kmsg || true
-			mkdir -p ${rootmnt}/android/firmware
-			mount -o loop,ro,shortname=lower,uid=1000,gid=1000,dmask=227,fmask=337 -t vfat ${fw_image} ${rootmnt}/android/firmware
-		fi
-
-		# Ubuntu overlay available in the Android system image (hardware specific configs)
-		mount_ubuntu_overlay ${rootmnt}/android/system/ubuntu ${rootmnt}
-
-		# Apply device-specific udev rules
-		if [ ! -f ${rootmnt}/android/system/ubuntu/lib/udev/rules.d/70-android.rules ] && [ "$device" != "unknown" ]; then
-			mount --bind ${rootmnt}/usr/lib/lxc-android-config/70-$device.rules ${rootmnt}/lib/udev/rules.d/70-android.rules
-		fi
-
-		# Bind-mount /lib/modules from Android
-		[ -e ${rootmnt}/android/system/lib/modules ] && mount --bind ${rootmnt}/android/system/lib/modules ${rootmnt}/lib/modules
-
-		# Bind-mount /var/lib/ureadahead if available on persistent storage
-		# this is required because ureadahead runs before mountall
-		if [ -e ${rootmnt}/userdata/system-data/var/lib/ureadahead ] && \
-				[ -e ${rootmnt}/var/lib/ureadahead ]; then
-			mount --bind ${rootmnt}/userdata/system-data/var/lib/ureadahead ${rootmnt}/var/lib/ureadahead
-		fi
-
-		# Setup the swap device
-		[ -e ${rootmnt}/userdata/SWAP.img ] && swapon ${rootmnt}/userdata/SWAP.img
-
-		# Apply customized content
-		for user in ${rootmnt}/userdata/user-data/*
-		do
-			if [ -d ${rootmnt}/custom/home ] && [ ! -e "$user/.customized" ]; then
-				echo "initrd: copying custom content tp " >/dev/kmsg || true
-				cp -Rap ${rootmnt}/custom/home/* "$user/"
-				cp -Rap ${rootmnt}/custom/home/.[a-zA-Z0-9]* "$user/"
-				touch "$user/.customized"
-				dstown=$(stat -c "%u:%g" "$user")
-				chown -R $dstown "$user/"
-			fi
-		done
-
-	# Old flipped model
-	elif [ -d /tmpmnt/ubuntu ]; then
-		mount --bind /tmpmnt/ubuntu ${rootmnt}
-		mountroot_status="$?"
-
-	# Possibly a re-partitioned device
-	else
-		echo "initrd: Couldn't find a system partition." >/dev/kmsg || true
-		panic "Couldn't find a system partition. Spawning adbd ..."
-	fi
-}
-
-mountroot()
-{
-	pre_mountroot
-
-	# Make sure the device has been created by udev before we try to mount
-	udevadm settle
-
-	# Get the root filesystem type if not set
-	if [ -z "${ROOTFSTYPE}" ]; then
-		[ -n "${FSTYPE}" ] || FSTYPE=$(blkid -s TYPE -o value "${ROOT}")
-		ROOTFSTYPE="${FSTYPE}"
-	else
-		FSTYPE=${ROOTFSTYPE}
-	fi
-	
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
-	run_scripts /scripts/local-premount
-	[ "$quiet" != "y" ] && log_end_msg
-
-	if [ "${readonly}" = "y" ] && \
-	   [ -z "$LOOP" ]; then
-		roflag=-r
-	else
-		roflag=-w
-	fi
-
-	# FIXME This has no error checking
-	[ -n "${FSTYPE}" ] && modprobe ${FSTYPE}
-
-	# FIXME This has no error checking
-	# Mount root
-	mount ${roflag} ${FSTYPE:+-t ${FSTYPE} }${ROOTFLAGS} ${ROOT} ${rootmnt}
-	mountroot_status="$?"
-	if [ "$LOOP" ]; then
-		if [ "$mountroot_status" != 0 ]; then
-			if [ ${FSTYPE} = ntfs ] || [ ${FSTYPE} = vfat ]; then
-				panic "
-Could not mount the partition ${ROOT}.
-This could also happen if the file system is not clean because of an operating
-system crash, an interrupted boot process, an improper shutdown, or unplugging
-of a removable device without first unmounting or ejecting it.  To fix this,
-simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
-gracefully shut down and reboot back into Windows. After this you should be
-able to reboot again and resume the installation.
-(filesystem = ${FSTYPE}, error code = $mountroot_status)
-"
-			fi
-		fi
-	
-		mkdir -p /host
-		mount -o move ${rootmnt} /host
-
-		if [ ! -d "/host/${LOOP}" ]; then
-		    panic "LOOP folder does not exit on the device, ${LOOP}"
-		fi
-
-		# Get the loop filesystem type if not set
-		if [ -z "${LOOPFSTYPE}" ]; then
-			panic "LOOPFSTYPE was not set!"
-		else
-			FSTYPE="${LOOPFSTYPE}"
-		fi
-
-		if [ "$FSTYPE" = "unknown" ]; then
-			panic "LOOPFSTYPE was set to unknown!"
-		fi
-
-		if [ ${readonly} = y ]; then
-			roflag=-r
-		else
-			roflag=-w
-		fi
-
-		# FIXME This has no error checking
-		modprobe loop
-		modprobe ${FSTYPE}
-
-		mkdir -p /tmpmnt
-		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "/host/${LOOP}/data.img" /tmpmnt
-
-		mkdir -p $ /android-cache
-		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "/host/${LOOP}/cache.img" /android-cache
-
-		if [ -f "/host/${LOOP}/firmware.img" ]; then
-			fw_image="/host/${LOOP}/firmware.img"
-		fi
-
-		echo "initrd: mounted all loops" >/dev/kmsg || true
-
-		process_ubuntu "/android-cache" "$fw_image"
-		
-		echo "process_ubuntu complete" >/dev/kmsg || true
-
-		mkdir -p ${rootmnt}/android/realdata
-		mount -o move /host ${rootmnt}/android/realdata
-	elif [ "$ROOTSUBDIR" ]; then
-		if [ "$mountroot_status" != 0 ]; then
-			panic "
-Could not mount the partition ${ROOT}.
-This could also happen if the file system is not clean because of an operating
-system crash, an interrupted boot process, an improper shutdown, or unplugging
-of a removable device without first unmounting or ejecting it.
-(filesystem = ${FSTYPE}, error code = $mountroot_status)
-"
-		fi
-
-		mkdir -p /host
-		mount -o move ${rootmnt} /host
-		
-		if [ ! -d "/host/$ROOTSUBDIR" ]; then
-		    panic "Failed to bind folder ${ROOTSUBDIR} as root: folder does not exist."
-		fi
-
-		if [ ! -d "/host/$ROOTSUBDIR/data" ]; then
-		    panic "Failed to bind folder ${ROOTSUBDIR}/data: folder does not exist."
-		fi
-
-		mkdir -p /tmpmnt
-		mount -o bind "/host/$ROOTSUBDIR/data" /tmpmnt
-
-		if [ -f "/host/${ROOTSUBDIR}/firmware.img" ]; then
-			fw_image="/host/${ROOTSUBDIR}/firmware.img"
-		fi
-
-		process_ubuntu "/host/$ROOTSUBDIR/cache" "$fw_image"
-
-		mkdir -p ${rootmnt}/android/realdata
-		mount -o move /host ${rootmnt}/android/realdata
-	fi
-
-	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-bottom"
-	run_scripts /scripts/local-bottom
-	[ "$quiet" != "y" ] && log_end_msg
-}
+# Local filesystem mounting			-*- shell-script -*-
+
+pre_mountroot()
+{
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
+	run_scripts /scripts/local-top
+	[ "$quiet" != "y" ] && log_end_msg
+	
+	# Don't wait for a root device that doesn't have a corresponding
+	# device in /dev (ie, mtd0)
+	if [ "${ROOT#/dev}" = "${ROOT}" ]; then
+		return
+	fi
+
+	while [ -z "${FSTYPE}" ]; do
+		FSTYPE=$(wait-for-root "${ROOT}" ${ROOTDELAY:-30})
+
+		# Load ubi with the correct MTD partition and return since
+		# fstype doesn't work with a char device like ubi.
+		if [ -n "$UBIMTD" ]; then
+			modprobe ubi mtd=$UBIMTD
+			return
+		fi
+
+		# Run failure hooks, hoping one of them can fix up the system
+		# and we can restart the wait loop.  If they all fail, abort
+		# and move on to the panic handler and shell.
+		if [ -z "${FSTYPE}" ] && ! try_failure_hooks; then
+			break
+		fi
+	done
+
+	# We've given up, but we'll let the user fix matters if they can
+	while [ -z "${FSTYPE}" -a ! -e "${ROOT}" ]; do
+		# give hint about renamed root
+		case "${ROOT}" in
+		/dev/hd*)
+			suffix="${ROOT#/dev/hd}"
+			major="${suffix%[[:digit:]]}"
+			major="${major%[[:digit:]]}"
+			if [ -d "/sys/block/sd${major}" ]; then
+				echo "WARNING bootdevice may be renamed. Try root=/dev/sd${suffix}"
+			fi
+			;;
+		/dev/sd*)
+			suffix="${ROOT#/dev/sd}"
+			major="${suffix%[[:digit:]]}"
+			major="${major%[[:digit:]]}"
+			if [ -d "/sys/block/hd${major}" ]; then
+				echo "WARNING bootdevice may be renamed. Try root=/dev/hd${suffix}"
+			fi
+			;;
+		esac
+		echo "Gave up waiting for root device.  Common problems:"
+		echo " - Boot args (cat /proc/cmdline)"
+		echo "   - Check rootdelay= (did the system wait long enough?)"
+		echo "   - Check root= (did the system wait for the right device?)"
+		echo " - Missing modules (cat /proc/modules; ls /dev)"
+		panic "ALERT!  ${ROOT} does not exist.  Dropping to a shell!"
+	done
+}
+
+mount_ubuntu_overlay() {
+	source=$1
+	target=$2
+
+	if [ -d ${source} ]; then
+		OLD_PWD=$PWD
+		cd ${source}
+
+		for overlay in `find . -type f`; do
+			[ -f ${target}/${overlay} ] && mount --bind ${source}/${overlay} ${target}/${overlay}
+		done
+
+		cd $OLD_PWD
+	fi
+}
+
+
+sync_dirs() {
+	base=$1
+	source=$2
+	target=$3
+
+	OLD_PWD=$PWD
+	cd $base
+
+	for file in $source/*
+	do
+		# Skip empty directories
+		[ ! -e "$base/$file" ] && continue
+
+		# If the target already exists as a file or link, there's nothing we can do
+		[ -e "$target/$file" -o -L "$target/$file" ] && [ ! -d "$target/$file" ] && continue
+
+		# If the target doesn't exist, just copy it over
+		if [ ! -e "$target/$file" -a ! -L "$target/$file" ]; then
+			cp -Ra "$base/$file" "$target/$file"
+			continue
+		fi
+
+		# That leaves us with directories and a recursive call
+		[ -d $file ] && sync_dirs $base $file $target
+	done
+
+	cd $OLD_PWD
+}
+
+process_ubuntu()
+{
+	cache_dir="$1"
+	fw_image="$2"
+
+	# Loop-mounted flipped model
+	if [ -e /tmpmnt/system.img ]; then
+		# Transition .developer_mode to .writable_image
+		[ -e /tmpmnt/.developer_mode ] && mv /tmpmnt/.developer_mode /tmpmnt/.writable_image
+
+		# Prepare the root filesystem
+		# NOTE: We mount it read-write in all cases, then remount read-only.
+		#       This is to workaround a behaviour change in busybox which now
+		#       uses read-only loops if the fs is initially mounted read-only.
+		#       An alternative implementation would be to add losetup support
+		#       to busybox and do the mount in two steps (rw loop, ro fs).
+		mount -o loop,rw /tmpmnt/system.img ${rootmnt}
+		if [ -e /tmpmnt/.writable_image ]; then
+			echo "initrd: mounting system.img (image developer mode)" >/dev/kmsg || true
+			mountroot_status="$?"
+		else
+			echo "initrd: mounting system.img (user mode)" >/dev/kmsg || true
+			mount -o remount,ro ${rootmnt}
+			mountroot_status="$?"
+		fi
+		mount --move /tmpmnt ${rootmnt}/userdata
+
+		# Mount the android system partition to a temporary location
+		mkdir -p /android-system
+		mount -o loop,ro ${rootmnt}/var/lib/lxc/android/system.img /android-system
+
+		# Get device information
+		device=$(grep ^ro.product.device= /android-system/build.prop |sed -e 's/.*=//')
+		[ -z "$device" ] && device="unknown"
+		echo "initrd: device is $device" >/dev/kmsg || true
+
+		# Mount some tmpfs
+		mkdir -p ${rootmnt}/android
+		mount -o rw,size=4096 -t tmpfs none ${rootmnt}/android
+		mount -o rw,nosuid,noexec,relatime,mode=755 -t tmpfs tmpfs ${rootmnt}/run
+
+		# Create some needed paths on tmpfs
+		mkdir -p ${rootmnt}/android/data ${rootmnt}/android/system ${rootmnt}/android/cache
+
+		# Prepare the fstab
+		FSTAB=${rootmnt}/etc/fstab
+		touch ${rootmnt}/run/image.fstab
+		mount -o bind ${rootmnt}/run/image.fstab $FSTAB || panic "drop to adb"
+		echo "/dev/root / rootfs defaults,ro 0 1" >> $FSTAB
+
+		# Process the list of bind-mounts
+		# (but don't mount them, mountall will do it)
+		cat ${rootmnt}/etc/system-image/writable-paths | while read line; do
+			set -- $line
+			# Skip invalid/commented entries
+			([ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ] || [ -z "$5" ]) && continue
+			[ "$1" = "#" ] && continue
+
+			# Skip invalid mount points
+			dstpath="${rootmnt}/$1"
+			[ ! -e "$dstpath" ] && continue
+
+			if [ "$3" = "temporary" ]; then
+				# Temporary entries are simple, just mount a tmpfs
+				echo "tmpfs $1 tmpfs $5 0 0" >> $FSTAB
+			elif [ "$3" = "persistent" ] || [ "$3" = "synced" ]; then
+				# Figure out the source path
+				if [ "$2" = "auto" ]; then
+					srcpath="${rootmnt}/userdata/system-data/$1"
+					path="/userdata/system-data/$1"
+				else
+					srcpath="${rootmnt}/userdata/$2"
+					path="/userdata/$2"
+				fi
+
+				if [ ! -e "$srcpath" ]; then
+					# Process new persistent or synced paths
+					dstown=$(stat -c "%u:%g" $dstpath)
+					dstmode=$(stat -c "%a" $dstpath)
+					mkdir -p ${srcpath%/*}
+					if [ ! -d "$dstpath" ]; then
+						# Deal with redirected files
+						if [ "$4" = "transition" ]; then
+							cp -a $dstpath $srcpath
+						else
+							touch $srcpath
+							chown $dstown $srcpath
+							chmod $dstmode $srcpath
+						fi
+					else
+						# Deal with redirected directories
+						if [ "$4" = "transition" ] || [ "$3" = "synced" ]; then
+							cp -aR $dstpath $srcpath
+						else
+							mkdir $srcpath
+							chown $dstown $srcpath
+							chmod $dstmode $srcpath
+						fi
+					fi
+				elif [ "$3" = "synced" ]; then
+					# Process existing synced paths
+					sync_dirs $dstpath . $srcpath
+				fi
+
+				# Write the fstab entry
+				if [ "$5" = "none" ]; then
+					echo "$path $1 none bind 0 0" >> $FSTAB
+				else
+					echo "$path $1 none bind,$5 0 0" >> $FSTAB
+				fi
+			else
+				continue
+			fi
+		done
+
+		# Extract the fstab from the android initrd
+		# NOTE: we should find a faster way of doing that or cache it
+		OLD_CWD=$(pwd)
+#		cd /android-initrd
+#		cat /android-system/boot/android-ramdisk.img | gzip -d | cpio -i fstab*
+		mount -n -t tmpfs tmpfs ${rootmnt}/var/lib/lxc/android/rootfs
+		cd ${rootmnt}/var/lib/lxc/android/rootfs
+		cat /android-system/boot/android-ramdisk.img | gzip -d | cpio -i
+		cd $OLD_CWD
+
+		# Mount all the Android partitions
+		cat ${rootmnt}/var/lib/lxc/android/rootfs/fstab* | while read line; do
+			set -- $line
+
+			# Skip any unwanted entry
+			echo $1 | egrep -q "^#" && continue
+			([ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] || [ -z "$4" ]) && continue
+			([ "$2" = "/system" ] || [ "$2" = "/data" ] || [ "$2" = "/cache" ]) && continue
+			# Skip firmware if custom fw_image is present
+			([ -n "$fw_image" ] && [ "$2" = "/firmware" ]) && continue
+
+			label=$(echo $1 | awk -F/ '{print $NF}')
+			[ -z "$label" ] && continue
+
+			echo "initrd: checking mount label $label" >/dev/kmsg || true
+
+			for dir in by-partlabel by-name by-label by-path by-uuid by-partuuid by-id; do
+				path="/dev/disk/$dir/$label"
+				[ -e "$path" ] && break
+			done
+
+			# MTD based devices, such as the emulator
+			if [ ! -e "$path" ] && echo $label | egrep -q "^mtdblock"; then
+				path="/dev/$label"
+			fi
+
+			[ ! -e "$path" ] && continue
+
+			mkdir -p ${rootmnt}/android/$2
+			echo "initrd: mounting $path as ${rootmnt}/android/$2" >/dev/kmsg || true
+			mount $path ${rootmnt}/android/$2 -t $3 -o $4
+		done
+
+		# system is a special case
+		echo "initrd: mounting ${rootmnt}/var/lib/lxc/android/system.img as ${rootmnt}/android/system" >/dev/kmsg || true
+		mount --move /android-system ${rootmnt}/android/system
+
+		# cache is a special case
+		echo "initrd: mounting ${cache_dir} as ${rootmnt}/android/cache" >/dev/kmsg || true
+		mount -o bind ${cache_dir} ${rootmnt}/android/cache
+
+		# mount fw image if present
+		if [ -n "$fw_image" ]; then
+			echo "initrd: mounting ${fw_image} as ${rootmnt}/android/firmware" > /dev/kmsg || true
+			mkdir -p ${rootmnt}/android/firmware
+			mount -o loop,ro,shortname=lower,uid=1000,gid=1000,dmask=227,fmask=337 -t vfat ${fw_image} ${rootmnt}/android/firmware
+		fi
+
+		# Ubuntu overlay available in the Android system image (hardware specific configs)
+		mount_ubuntu_overlay ${rootmnt}/android/system/ubuntu ${rootmnt}
+
+		# Apply device-specific udev rules
+		if [ ! -f ${rootmnt}/android/system/ubuntu/lib/udev/rules.d/70-android.rules ] && [ "$device" != "unknown" ]; then
+			mount --bind ${rootmnt}/usr/lib/lxc-android-config/70-$device.rules ${rootmnt}/lib/udev/rules.d/70-android.rules
+		fi
+
+		# Bind-mount /lib/modules from Android
+		[ -e ${rootmnt}/android/system/lib/modules ] && mount --bind ${rootmnt}/android/system/lib/modules ${rootmnt}/lib/modules
+
+		# Bind-mount /var/lib/ureadahead if available on persistent storage
+		# this is required because ureadahead runs before mountall
+		if [ -e ${rootmnt}/userdata/system-data/var/lib/ureadahead ] && \
+				[ -e ${rootmnt}/var/lib/ureadahead ]; then
+			mount --bind ${rootmnt}/userdata/system-data/var/lib/ureadahead ${rootmnt}/var/lib/ureadahead
+		fi
+
+		# Setup the swap device
+		[ -e ${rootmnt}/userdata/SWAP.img ] && swapon ${rootmnt}/userdata/SWAP.img
+
+		# Apply customized content
+		for user in ${rootmnt}/userdata/user-data/*
+		do
+			if [ -d ${rootmnt}/custom/home ] && [ ! -e "$user/.customized" ]; then
+				echo "initrd: copying custom content tp " >/dev/kmsg || true
+				cp -Rap ${rootmnt}/custom/home/* "$user/"
+				cp -Rap ${rootmnt}/custom/home/.[a-zA-Z0-9]* "$user/"
+				touch "$user/.customized"
+				dstown=$(stat -c "%u:%g" "$user")
+				chown -R $dstown "$user/"
+			fi
+		done
+
+	# Old flipped model
+	elif [ -d /tmpmnt/ubuntu ]; then
+		mount --bind /tmpmnt/ubuntu ${rootmnt}
+		mountroot_status="$?"
+
+	# Possibly a re-partitioned device
+	else
+		echo "initrd: Couldn't find a system partition." >/dev/kmsg || true
+		panic "Couldn't find a system partition. Spawning adbd ..."
+	fi
+}
+
+mountroot()
+{
+	pre_mountroot
+
+	# Make sure the device has been created by udev before we try to mount
+	udevadm settle
+
+	# Get the root filesystem type if not set
+	if [ -z "${ROOTFSTYPE}" ]; then
+		[ -n "${FSTYPE}" ] || FSTYPE=$(blkid -s TYPE -o value "${ROOT}")
+		ROOTFSTYPE="${FSTYPE}"
+	else
+		FSTYPE=${ROOTFSTYPE}
+	fi
+	
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-premount"
+	run_scripts /scripts/local-premount
+	[ "$quiet" != "y" ] && log_end_msg
+
+	if [ "${readonly}" = "y" ] && \
+	   [ -z "$LOOP" ]; then
+		roflag=-r
+	else
+		roflag=-w
+	fi
+
+	# FIXME This has no error checking
+	[ -n "${FSTYPE}" ] && modprobe ${FSTYPE}
+
+	# FIXME This has no error checking
+	# Mount root
+	mount ${roflag} ${FSTYPE:+-t ${FSTYPE} }${ROOTFLAGS} ${ROOT} ${rootmnt}
+	mountroot_status="$?"
+	if [ "$LOOP" ]; then
+		if [ "$mountroot_status" != 0 ]; then
+			if [ ${FSTYPE} = ntfs ] || [ ${FSTYPE} = vfat ]; then
+				panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+			fi
+		fi
+	
+		mkdir -p /host
+		mount -o move ${rootmnt} /host
+
+		if [ ! -d "/host/${LOOP}" ]; then
+		    panic "LOOP folder does not exit on the device, ${LOOP}"
+		fi
+
+		# Get the loop filesystem type if not set
+		if [ -z "${LOOPFSTYPE}" ]; then
+			panic "LOOPFSTYPE was not set!"
+		else
+			FSTYPE="${LOOPFSTYPE}"
+		fi
+
+		if [ "$FSTYPE" = "unknown" ]; then
+			panic "LOOPFSTYPE was set to unknown!"
+		fi
+
+		if [ ${readonly} = y ]; then
+			roflag=-r
+		else
+			roflag=-w
+		fi
+
+		# FIXME This has no error checking
+		modprobe loop
+		modprobe ${FSTYPE}
+
+		mkdir -p /tmpmnt
+		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "/host/${LOOP}/data.img" /tmpmnt
+
+		mkdir -p $ /android-cache
+		mount ${roflag} -o loop -t ${FSTYPE} ${LOOPFLAGS} "/host/${LOOP}/cache.img" /android-cache
+
+		if [ -f "/host/${LOOP}/firmware.img" ]; then
+			fw_image="/host/${LOOP}/firmware.img"
+		fi
+
+		echo "initrd: mounted all loops" >/dev/kmsg || true
+
+		process_ubuntu "/android-cache" "$fw_image"
+		
+		echo "process_ubuntu complete" >/dev/kmsg || true
+
+		mkdir -p ${rootmnt}/android/realdata
+		mount -o move /host ${rootmnt}/android/realdata
+	elif [ "$ROOTSUBDIR" ]; then
+		if [ "$mountroot_status" != 0 ]; then
+			panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+		fi
+
+		mkdir -p /host
+		mount -o move ${rootmnt} /host
+		
+		if [ ! -d "/host/$ROOTSUBDIR" ]; then
+		    panic "Failed to bind folder ${ROOTSUBDIR} as root: folder does not exist."
+		fi
+
+		if [ ! -d "/host/$ROOTSUBDIR/data" ]; then
+		    panic "Failed to bind folder ${ROOTSUBDIR}/data: folder does not exist."
+		fi
+
+		mkdir -p /tmpmnt
+		mount -o bind "/host/$ROOTSUBDIR/data" /tmpmnt
+
+		if [ -f "/host/${ROOTSUBDIR}/firmware.img" ]; then
+			fw_image="/host/${ROOTSUBDIR}/firmware.img"
+		fi
+
+		process_ubuntu "/host/$ROOTSUBDIR/cache" "$fw_image"
+
+		mkdir -p ${rootmnt}/android/realdata
+		mount -o move /host ${rootmnt}/android/realdata
+	fi
+
+	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-bottom"
+	run_scripts /scripts/local-bottom
+	[ "$quiet" != "y" ] && log_end_msg
+}
diff --git a/installer/README.md b/installer/README.md
index 9e70800..40c91c8 100755
--- a/installer/README.md
+++ b/installer/README.md
@@ -1,45 +1,45 @@
-# MultiROM reference installer
-This is a reference installer file structure.
-It should be used only for Linux
-based ROMs, where classic update.zip format is unsuitable.
-
-## Installation file
-The installation file itself is a ZIP archive, renamed to `*.mrom` so that
-recovery can know what is just ZIP archive and what is MultiROM
-installer
-file.
-I recommend not to use compression when making this ZIP, the installation
-will be faster and the ROM is already compressed in .tar.gz files.
-
-While this format should be versatile enough, feel free to contact me if you
-need something changed - if it is reasonable, there will be no problem
-adding changes you need.
-
-### Content
-* **manifest.txt** - File with info for the recovery. Read the comments in that
-                     file to know more.
-
-* **rom** - Folder with tar.gz archives containing each of the ROM base folders
-            (e.g. `root.tar.gz`, `system.tar.gz`, ...). These can be split to
-            multiple files (and should be, if the file is bigger than ~800 MB).
-            Pattern is name_XX.tar.gz, so for example `root_00.tar.gz` and
-            `root_01.tar.gz`. Numbering __must__ start at 00!
-            Command `tar --numeric-owner --overwrite -xf` is used to extract
-            these tar files.
-
-* **root_dir** - Content of this folder will be copied to root of the ROM
-                 folder - `/sdcard/multirom/roms/*rom_name*`. It can contain
-                 `rom_info.txt` if it's Linux ROM or the `boot` folder and/or
-                 `boot.img` if it's Android-based ROM.
-
-* **pre_install, post_install** - Sh scripts in these folders will be ran
-                before/after the installation. They must return success return
-                code else the installation is aborted. Path to root
-                folder/folder where images are mounted is
-                passed as argument to this script, script can then cd to one of
-                the base folders and do whatever it wants to. Scripts are ran
-                in alphabetical order (use numbers, `01_script.sh`, `02_script.sh`).
-                **All** files from both directories are extracted to `/tmp/script/`,
-                which means you can put e.g. binary blobs in there and copy them
-                to proper place in the sh scripts or pack some binaries needed
-                by the scripts (e.g. gnutar, remember to set chmod before running them).
+# MultiROM reference installer
+This is a reference installer file structure.
+It should be used only for Linux
+based ROMs, where classic update.zip format is unsuitable.
+
+## Installation file
+The installation file itself is a ZIP archive, renamed to `*.mrom` so that
+recovery can know what is just ZIP archive and what is MultiROM
+installer
+file.
+I recommend not to use compression when making this ZIP, the installation
+will be faster and the ROM is already compressed in .tar.gz files.
+
+While this format should be versatile enough, feel free to contact me if you
+need something changed - if it is reasonable, there will be no problem
+adding changes you need.
+
+### Content
+* **manifest.txt** - File with info for the recovery. Read the comments in that
+                     file to know more.
+
+* **rom** - Folder with tar.gz archives containing each of the ROM base folders
+            (e.g. `root.tar.gz`, `system.tar.gz`, ...). These can be split to
+            multiple files (and should be, if the file is bigger than ~800 MB).
+            Pattern is name_XX.tar.gz, so for example `root_00.tar.gz` and
+            `root_01.tar.gz`. Numbering __must__ start at 00!
+            Command `tar --numeric-owner --overwrite -xf` is used to extract
+            these tar files.
+
+* **root_dir** - Content of this folder will be copied to root of the ROM
+                 folder - `/sdcard/multirom/roms/*rom_name*`. It can contain
+                 `rom_info.txt` if it's Linux ROM or the `boot` folder and/or
+                 `boot.img` if it's Android-based ROM.
+
+* **pre_install, post_install** - Sh scripts in these folders will be ran
+                before/after the installation. They must return success return
+                code else the installation is aborted. Path to root
+                folder/folder where images are mounted is
+                passed as argument to this script, script can then cd to one of
+                the base folders and do whatever it wants to. Scripts are ran
+                in alphabetical order (use numbers, `01_script.sh`, `02_script.sh`).
+                **All** files from both directories are extracted to `/tmp/script/`,
+                which means you can put e.g. binary blobs in there and copy them
+                to proper place in the sh scripts or pack some binaries needed
+                by the scripts (e.g. gnutar, remember to set chmod before running them).
diff --git a/installer/manifest.txt b/installer/manifest.txt
index 9df6022..b45799c 100755
--- a/installer/manifest.txt
+++ b/installer/manifest.txt
@@ -1,49 +1,49 @@
-# This file contains info for recovery installation process
-# Should be placed in root of installation zip file and must be
-# named "manifest.txt".
-# Make sure you got the syntax correct, as the parser is probably pretty
-# dumb. Lines with comments must start with #. Beware the whitespaces.
-# If you need to use " character in string, just use it, no need to escape it
-# MultiROM searches for first and last " on the line.
-# These comments should not be deleted.
-
-# Manifest version
-manifest_ver="1"
-
-# Min MultiROM version
-min_mrom_ver="5"
-
-# Supported devices codenames. These are checked against
-# ro.product.device property
-devices="grouper tilapia"
-
-# ROM name. If not specified, name of the installation file is used,
-# which is recommmended. Don't use spaces.
-#rom_name="Generic_ROM"
-
-# Installation text, it is displayed in recovery during installation.
-# Use \n to make newlines
-install_text="Generic ROM 1.2.3.4\nWelcome to Generic ROM!\n\n This installation process may take a while"
-
-# Enable installation to internal ext4 memory
-enable_internal="1"
-
-# USB flash drive installation, set to empty string to disable.
-# You can install to either subdirectory or ext4 disk image.
-# Subdirectory is prefered.
-# usb_dir_fs - list of supported fs types
-# usb_img_fs - list of supported underlaying fs types, images are always ext4
-usb_dir_fs="ext2 ext3 ext4"
-usb_img_fs="vfat ntfs"
-
-# ROM base folders - the ones in root of ROM folder.
-# There can only be maximum of 5 base folders!
-# If USB drive with filesystem for images is used, each of these is ext4 image
-# If this is a Linux ROM, you usually want just "root". If it is Android-based,
-# you probably want "cache", "system" and "data"
-# Specify also min and default size of the image created for USB drives
-# in megabytes. Min value is used to check free space if it is not installed
-# to image.
-# Syntax: name:MIN:DEFAULT name2:MIN:DEFAULT ...
-# Example: base_folders="data:50:1024 system:450:640 cache:50:450"
-base_folders="root:1000:1500"
+# This file contains info for recovery installation process
+# Should be placed in root of installation zip file and must be
+# named "manifest.txt".
+# Make sure you got the syntax correct, as the parser is probably pretty
+# dumb. Lines with comments must start with #. Beware the whitespaces.
+# If you need to use " character in string, just use it, no need to escape it
+# MultiROM searches for first and last " on the line.
+# These comments should not be deleted.
+
+# Manifest version
+manifest_ver="1"
+
+# Min MultiROM version
+min_mrom_ver="5"
+
+# Supported devices codenames. These are checked against
+# ro.product.device property
+devices="grouper tilapia"
+
+# ROM name. If not specified, name of the installation file is used,
+# which is recommmended. Don't use spaces.
+#rom_name="Generic_ROM"
+
+# Installation text, it is displayed in recovery during installation.
+# Use \n to make newlines
+install_text="Generic ROM 1.2.3.4\nWelcome to Generic ROM!\n\n This installation process may take a while"
+
+# Enable installation to internal ext4 memory
+enable_internal="1"
+
+# USB flash drive installation, set to empty string to disable.
+# You can install to either subdirectory or ext4 disk image.
+# Subdirectory is prefered.
+# usb_dir_fs - list of supported fs types
+# usb_img_fs - list of supported underlaying fs types, images are always ext4
+usb_dir_fs="ext2 ext3 ext4"
+usb_img_fs="vfat ntfs"
+
+# ROM base folders - the ones in root of ROM folder.
+# There can only be maximum of 5 base folders!
+# If USB drive with filesystem for images is used, each of these is ext4 image
+# If this is a Linux ROM, you usually want just "root". If it is Android-based,
+# you probably want "cache", "system" and "data"
+# Specify also min and default size of the image created for USB drives
+# in megabytes. Min value is used to check free space if it is not installed
+# to image.
+# Syntax: name:MIN:DEFAULT name2:MIN:DEFAULT ...
+# Example: base_folders="data:50:1024 system:450:640 cache:50:450"
+base_folders="root:1000:1500"
diff --git a/kexec-tools b/kexec-tools
--- a/kexec-tools
+++ b/kexec-tools
@@ -1 +1 @@
-Subproject commit 9a4b1f3bf6c578a5418ad6071a745fff4430207d
+Subproject commit 9a4b1f3bf6c578a5418ad6071a745fff4430207d-dirty
diff --git a/kexec.c b/kexec.c
index 5b64381..42265ec 100755
--- a/kexec.c
+++ b/kexec.c
@@ -1,116 +1,116 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-
-#include <malloc.h>
-
-#include "kexec.h"
-#include "lib/containers.h"
-#include "lib/log.h"
-#include "lib/util.h"
-
-// kexec --load-hardboot ./zImage --command-line="$(cat /proc/cmdline)" --mem-min=0xA0000000 --initrd=./rd.img
-// --mem-min should be somewhere in System RAM (see /proc/iomem). Location just above kernel seems to work fine.
-// It must not conflict with vmalloc ram. Vmalloc area seems to be allocated from top of System RAM.
-
-void kexec_init(struct kexec *k, const char *path)
-{
-    k->args = NULL;
-    kexec_add_arg(k, path);
-}
-
-void kexec_destroy(struct kexec *k)
-{
-    list_clear(&k->args, &free);
-}
-
-int kexec_load_exec(struct kexec *k)
-{
-    int i, len;
-
-    INFO("Loading kexec:\n");
-    for(i = 0; k->args && k->args[i]; ++i)
-    {
-        len = strlen(k->args[i]);
-
-        if(len < 480)
-            INFO("    %s\n", k->args[i]);
-        else
-        {
-            char buff[481];
-            char *itr;
-            const char *end = k->args[i]+len;
-            int chunk = 0;
-
-            for(itr = k->args[i]; itr < end; itr += chunk)
-            {
-                chunk = imin(480, end - itr);
-
-                memcpy(buff, itr, chunk);
-                buff[chunk] = 0;
-
-                INFO("    %s\n", buff);
-            }
-        }
-    }
-
-    if(run_cmd(k->args) == 0)
-        return 0;
-    else
-    {
-        ERROR("kexec call failed, re-running it to get info:\n");
-        char *r = run_get_stdout(k->args);
-        if(!r)
-            ERROR("run_get_stdout returned NULL!\n");
-
-        char *p = strtok(r, "\n\r");
-        while(p)
-        {
-            ERROR("  %s\n", p);
-            p = strtok(NULL, "\n\r");
-        }
-        free(r);
-
-        return -1;
-    }
-}
-
-void kexec_add_arg(struct kexec *k, const char *arg)
-{
-    list_add(&k->args, strdup(arg));
-}
-
-void kexec_add_arg_prefix(struct kexec *k, const char *prefix, const char *value)
-{
-    int len = strlen(prefix) + strlen(value) + 1;
-    char *arg = malloc(len);
-    snprintf(arg, len, "%s%s", prefix, value);
-
-    list_add(&k->args, arg);
-}
-
-void kexec_add_kernel(struct kexec *k, const char *path, int hardboot)
-{
-    if(hardboot)
-        kexec_add_arg(k, "--load-hardboot");
-    else
-        kexec_add_arg(k, "-l");
-    kexec_add_arg(k, path);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include <malloc.h>
+
+#include "kexec.h"
+#include "lib/containers.h"
+#include "lib/log.h"
+#include "lib/util.h"
+
+// kexec --load-hardboot ./zImage --command-line="$(cat /proc/cmdline)" --mem-min=0xA0000000 --initrd=./rd.img
+// --mem-min should be somewhere in System RAM (see /proc/iomem). Location just above kernel seems to work fine.
+// It must not conflict with vmalloc ram. Vmalloc area seems to be allocated from top of System RAM.
+
+void kexec_init(struct kexec *k, const char *path)
+{
+    k->args = NULL;
+    kexec_add_arg(k, path);
+}
+
+void kexec_destroy(struct kexec *k)
+{
+    list_clear(&k->args, &free);
+}
+
+int kexec_load_exec(struct kexec *k)
+{
+    int i, len;
+
+    INFO("Loading kexec:\n");
+    for(i = 0; k->args && k->args[i]; ++i)
+    {
+        len = strlen(k->args[i]);
+
+        if(len < 480)
+            INFO("    %s\n", k->args[i]);
+        else
+        {
+            char buff[481];
+            char *itr;
+            const char *end = k->args[i]+len;
+            int chunk = 0;
+
+            for(itr = k->args[i]; itr < end; itr += chunk)
+            {
+                chunk = imin(480, end - itr);
+
+                memcpy(buff, itr, chunk);
+                buff[chunk] = 0;
+
+                INFO("    %s\n", buff);
+            }
+        }
+    }
+
+    if(run_cmd(k->args) == 0)
+        return 0;
+    else
+    {
+        ERROR("kexec call failed, re-running it to get info:\n");
+        char *r = run_get_stdout(k->args);
+        if(!r)
+            ERROR("run_get_stdout returned NULL!\n");
+
+        char *p = strtok(r, "\n\r");
+        while(p)
+        {
+            ERROR("  %s\n", p);
+            p = strtok(NULL, "\n\r");
+        }
+        free(r);
+
+        return -1;
+    }
+}
+
+void kexec_add_arg(struct kexec *k, const char *arg)
+{
+    list_add(&k->args, strdup(arg));
+}
+
+void kexec_add_arg_prefix(struct kexec *k, const char *prefix, const char *value)
+{
+    int len = strlen(prefix) + strlen(value) + 1;
+    char *arg = malloc(len);
+    snprintf(arg, len, "%s%s", prefix, value);
+
+    list_add(&k->args, arg);
+}
+
+void kexec_add_kernel(struct kexec *k, const char *path, int hardboot)
+{
+    if(hardboot)
+        kexec_add_arg(k, "--load-hardboot");
+    else
+        kexec_add_arg(k, "-l");
+    kexec_add_arg(k, path);
+}
diff --git a/kexec.h b/kexec.h
index d09ef83..f1f8877 100755
--- a/kexec.h
+++ b/kexec.h
@@ -1,33 +1,33 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KEXEC_H
-#define KEXEC_H
-
-struct kexec
-{
-    char **args;
-};
-
-void kexec_init(struct kexec *k, const char *path);
-void kexec_destroy(struct kexec *k);
-int kexec_load_exec(struct kexec *k);
-void kexec_add_arg(struct kexec *k, const char *arg);
-void kexec_add_arg_prefix(struct kexec *k, const char *prefix, const char *value);
-void kexec_add_kernel(struct kexec *k, const char *path, int hardboot);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KEXEC_H
+#define KEXEC_H
+
+struct kexec
+{
+    char **args;
+};
+
+void kexec_init(struct kexec *k, const char *path);
+void kexec_destroy(struct kexec *k);
+int kexec_load_exec(struct kexec *k);
+void kexec_add_arg(struct kexec *k, const char *arg);
+void kexec_add_arg_prefix(struct kexec *k, const char *prefix, const char *value);
+void kexec_add_kernel(struct kexec *k, const char *path, int hardboot);
+
+#endif
diff --git a/lib/Android.mk b/lib/Android.mk
index daa2423..e04a16f 100755
--- a/lib/Android.mk
+++ b/lib/Android.mk
@@ -1,167 +1,167 @@
-LOCAL_PATH:= $(call my-dir)
-
-common_SRC_FILES := \
-    animation.c \
-    button.c \
-    colors.c \
-    containers.c \
-    framebuffer.c \
-    framebuffer_generic.c \
-    framebuffer_png.c \
-    framebuffer_truetype.c \
-    fstab.c \
-    inject.c \
-    input.c \
-    listview.c \
-    keyboard.c \
-    mrom_data.c \
-    notification_card.c \
-    progressdots.c \
-    tabview.c \
-    touch_tracker.c \
-    util.c \
-    workers.c \
-
-common_C_INCLUDES := $(multirom_local_path)/lib \
-    external/libpng \
-    external/zlib \
-    external/freetype/include \
-    system/extras/libbootimg/include \
-
-# With these, GCC optimizes aggressively enough so full-screen alpha blending
-# is quick enough to be done in an animation
-common_C_FLAGS := -O3 -funsafe-math-optimizations
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-ifeq ($(MR_INPUT_TYPE),)
-    MR_INPUT_TYPE := type_b
-endif
-common_SRC_FILES += input_$(MR_INPUT_TYPE).c
-
-ifeq ($(MR_USE_QCOM_OVERLAY),true)
-    common_C_FLAGS += -DMR_USE_QCOM_OVERLAY
-    common_SRC_FILES += framebuffer_qcom_overlay.c
-ifneq ($(MR_QCOM_OVERLAY_HEADER),)
-    common_C_FLAGS += -DMR_QCOM_OVERLAY_HEADER=\"../../../../$(MR_QCOM_OVERLAY_HEADER)\"
-else
-    $(error MR_USE_QCOM_OVERLAY is true but MR_QCOM_OVERLAY_HEADER was not specified!)
-endif
-ifneq ($(MR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT),)
-    common_C_FLAGS += -DMR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT=$(MR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT)
-endif
-ifeq ($(MR_QCOM_OVERLAY_USE_VSYNC),true)
-    common_C_FLAGS += -DMR_QCOM_OVERLAY_USE_VSYNC
-endif
-endif
-
-
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := libmultirom_static
-LOCAL_MODULE_TAGS := eng
-LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
-LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
-LOCAL_CFLAGS += $(common_C_FLAGS)
-LOCAL_C_INCLUDES += $(common_C_INCLUDES)
-LOCAL_SRC_FILES := $(common_SRC_FILES)
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-include $(multirom_local_path)/device_defines.mk
-
-include $(BUILD_STATIC_LIBRARY)
-
-
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := libmultirom
-LOCAL_MODULE_TAGS := eng
-LOCAL_SHARED_LIBRARIES := libcutils libc libm libpng libz libft2
-LOCAL_CFLAGS += $(common_C_FLAGS)
-LOCAL_SRC_FILES := $(common_SRC_FILES)
-LOCAL_C_INCLUDES += $(common_C_INCLUDES)
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-include $(multirom_local_path)/device_defines.mk
-
-include $(BUILD_SHARED_LIBRARY)
-
-
-
-# We need static libtruetype but it isn't in standard android makefile :(
-LOCAL_PATH := external/freetype/
-include $(CLEAR_VARS)
-
-# compile in ARM mode, since the glyph loader/renderer is a hotspot
-# when loading complex pages in the browser
-#
-LOCAL_ARM_MODE := arm
-
-LOCAL_SRC_FILES := \
-    src/base/ftbbox.c \
-    src/base/ftbitmap.c \
-    src/base/ftfstype.c \
-    src/base/ftglyph.c \
-    src/base/ftlcdfil.c \
-    src/base/ftstroke.c \
-    src/base/fttype1.c \
-    src/base/ftbase.c \
-    src/base/ftsystem.c \
-    src/base/ftinit.c \
-    src/base/ftgasp.c \
-    src/raster/raster.c \
-    src/sfnt/sfnt.c \
-    src/smooth/smooth.c \
-    src/autofit/autofit.c \
-    src/truetype/truetype.c \
-    src/cff/cff.c \
-    src/psnames/psnames.c \
-    src/pshinter/pshinter.c
-
-ifeq ($(shell if [ -e "$(ANDROID_BUILD_TOP)/external/freetype/src/gzip/ftgzip.c" ]; then echo "hasgzip"; fi),hasgzip)
-LOCAL_SRC_FILES += src/gzip/ftgzip.c
-endif
-
-ifeq ($(shell if [ -e "$(ANDROID_BUILD_TOP)/external/freetype/src/base/ftxf86.c" ]; then echo "found"; fi),found)
-    LOCAL_SRC_FILES += src/base/ftxf86.c
-else
-    LOCAL_SRC_FILES += \
-        src/base/ftfntfmt.c \
-        src/base/ftmm.c
-endif
-
-LOCAL_C_INCLUDES += \
-    $(LOCAL_PATH)/builds \
-    $(LOCAL_PATH)/include \
-    external/libpng \
-    external/zlib
-
-LOCAL_CFLAGS += -W -Wall
-LOCAL_CFLAGS += -fPIC -DPIC
-LOCAL_CFLAGS += "-DDARWIN_NO_CARBON"
-LOCAL_CFLAGS += "-DFT2_BUILD_LIBRARY"
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-LOCAL_STATIC_LIBRARIES += libpng libz
-
-# the following is for testing only, and should not be used in final builds
-# of the product
-#LOCAL_CFLAGS += "-DTT_CONFIG_OPTION_BYTECODE_INTERPRETER"
-
-LOCAL_CFLAGS += -O2
-
-LOCAL_MODULE:= libft2_mrom_static
-include $(BUILD_STATIC_LIBRARY)
+LOCAL_PATH:= $(call my-dir)
+
+common_SRC_FILES := \
+    animation.c \
+    button.c \
+    colors.c \
+    containers.c \
+    framebuffer.c \
+    framebuffer_generic.c \
+    framebuffer_png.c \
+    framebuffer_truetype.c \
+    fstab.c \
+    inject.c \
+    input.c \
+    listview.c \
+    keyboard.c \
+    mrom_data.c \
+    notification_card.c \
+    progressdots.c \
+    tabview.c \
+    touch_tracker.c \
+    util.c \
+    workers.c \
+
+common_C_INCLUDES := $(multirom_local_path)/lib \
+    external/libpng \
+    external/zlib \
+    external/freetype/include \
+    system/extras/libbootimg/include \
+
+# With these, GCC optimizes aggressively enough so full-screen alpha blending
+# is quick enough to be done in an animation
+common_C_FLAGS := -O3 -funsafe-math-optimizations
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+ifeq ($(MR_INPUT_TYPE),)
+    MR_INPUT_TYPE := type_b
+endif
+common_SRC_FILES += input_$(MR_INPUT_TYPE).c
+
+ifeq ($(MR_USE_QCOM_OVERLAY),true)
+    common_C_FLAGS += -DMR_USE_QCOM_OVERLAY
+    common_SRC_FILES += framebuffer_qcom_overlay.c
+ifneq ($(MR_QCOM_OVERLAY_HEADER),)
+    common_C_FLAGS += -DMR_QCOM_OVERLAY_HEADER=\"../../../../$(MR_QCOM_OVERLAY_HEADER)\"
+else
+    $(error MR_USE_QCOM_OVERLAY is true but MR_QCOM_OVERLAY_HEADER was not specified!)
+endif
+ifneq ($(MR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT),)
+    common_C_FLAGS += -DMR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT=$(MR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT)
+endif
+ifeq ($(MR_QCOM_OVERLAY_USE_VSYNC),true)
+    common_C_FLAGS += -DMR_QCOM_OVERLAY_USE_VSYNC
+endif
+endif
+
+
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libmultirom_static
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
+LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
+LOCAL_CFLAGS += $(common_C_FLAGS)
+LOCAL_C_INCLUDES += $(common_C_INCLUDES)
+LOCAL_SRC_FILES := $(common_SRC_FILES)
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+include $(multirom_local_path)/device_defines.mk
+
+include $(BUILD_STATIC_LIBRARY)
+
+
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE := libmultirom
+LOCAL_MODULE_TAGS := eng
+LOCAL_SHARED_LIBRARIES := libcutils libc libm libpng libz libft2
+LOCAL_CFLAGS += $(common_C_FLAGS)
+LOCAL_SRC_FILES := $(common_SRC_FILES)
+LOCAL_C_INCLUDES += $(common_C_INCLUDES)
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+include $(multirom_local_path)/device_defines.mk
+
+include $(BUILD_SHARED_LIBRARY)
+
+
+
+# We need static libtruetype but it isn't in standard android makefile :(
+LOCAL_PATH := external/freetype/
+include $(CLEAR_VARS)
+
+# compile in ARM mode, since the glyph loader/renderer is a hotspot
+# when loading complex pages in the browser
+#
+LOCAL_ARM_MODE := arm
+
+LOCAL_SRC_FILES := \
+    src/base/ftbbox.c \
+    src/base/ftbitmap.c \
+    src/base/ftfstype.c \
+    src/base/ftglyph.c \
+    src/base/ftlcdfil.c \
+    src/base/ftstroke.c \
+    src/base/fttype1.c \
+    src/base/ftbase.c \
+    src/base/ftsystem.c \
+    src/base/ftinit.c \
+    src/base/ftgasp.c \
+    src/raster/raster.c \
+    src/sfnt/sfnt.c \
+    src/smooth/smooth.c \
+    src/autofit/autofit.c \
+    src/truetype/truetype.c \
+    src/cff/cff.c \
+    src/psnames/psnames.c \
+    src/pshinter/pshinter.c
+
+ifeq ($(shell if [ -e "$(ANDROID_BUILD_TOP)/external/freetype/src/gzip/ftgzip.c" ]; then echo "hasgzip"; fi),hasgzip)
+LOCAL_SRC_FILES += src/gzip/ftgzip.c
+endif
+
+ifeq ($(shell if [ -e "$(ANDROID_BUILD_TOP)/external/freetype/src/base/ftxf86.c" ]; then echo "found"; fi),found)
+    LOCAL_SRC_FILES += src/base/ftxf86.c
+else
+    LOCAL_SRC_FILES += \
+        src/base/ftfntfmt.c \
+        src/base/ftmm.c
+endif
+
+LOCAL_C_INCLUDES += \
+    $(LOCAL_PATH)/builds \
+    $(LOCAL_PATH)/include \
+    external/libpng \
+    external/zlib
+
+LOCAL_CFLAGS += -W -Wall
+LOCAL_CFLAGS += -fPIC -DPIC
+LOCAL_CFLAGS += "-DDARWIN_NO_CARBON"
+LOCAL_CFLAGS += "-DFT2_BUILD_LIBRARY"
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+LOCAL_STATIC_LIBRARIES += libpng libz
+
+# the following is for testing only, and should not be used in final builds
+# of the product
+#LOCAL_CFLAGS += "-DTT_CONFIG_OPTION_BYTECODE_INTERPRETER"
+
+LOCAL_CFLAGS += -O2
+
+LOCAL_MODULE:= libft2_mrom_static
+include $(BUILD_STATIC_LIBRARY)
diff --git a/lib/animation.c b/lib/animation.c
index 234033c..1400559 100755
--- a/lib/animation.c
+++ b/lib/animation.c
@@ -1,504 +1,504 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <pthread.h>
-#include <math.h>
-
-#include <malloc.h>
-
-#include "log.h"
-#include "workers.h"
-#include "animation.h"
-#include "util.h"
-#include "framebuffer.h"
-#include "containers.h"
-
-struct anim_list_it
-{
-    int anim_type;
-    anim_header *anim;
-
-    struct anim_list_it *prev;
-    struct anim_list_it *next;
-};
-
-struct anim_list
-{
-    struct anim_list_it *first;
-    struct anim_list_it *last;
-
-    struct anim_list_it **inactive_ctx;
-
-    int running;
-    float duration_coef;
-    volatile int in_update_loop;
-    pthread_mutex_t mutex;
-};
-
-static struct anim_list_it EMPTY_CONTEXT;
-
-static struct anim_list anim_list = {
-    .first = NULL,
-    .last = NULL,
-    .inactive_ctx = NULL,
-    .running = 0,
-    .duration_coef = 1.f,
-    .in_update_loop = 0,
-    .mutex = PTHREAD_MUTEX_INITIALIZER,
-};
-
-static void anim_list_append(struct anim_list_it *it)
-{
-    pthread_mutex_lock(&anim_list.mutex);
-    if(!anim_list.first)
-    {
-        anim_list.first = anim_list.last = it;
-        pthread_mutex_unlock(&anim_list.mutex);
-        return;
-    }
-
-    it->prev = anim_list.last;
-    anim_list.last->next = it;
-    anim_list.last = it;
-    pthread_mutex_unlock(&anim_list.mutex);
-}
-
-// anim_list.mutex must be locked
-static void anim_list_rm(struct anim_list_it *it)
-{
-    if(it->prev)
-        it->prev->next = it->next;
-    else
-        anim_list.first = it->next;
-
-    if(it->next)
-        it->next->prev = it->prev;
-    else
-        anim_list.last = it->prev;
-}
-
-// anim_list.mutex must be locked
-static void anim_list_clear(void)
-{
-    struct anim_list_it *it, *next;
-    for(next = anim_list.first; next; )
-    {
-        it = next;
-        next = next->next;
-
-        free(it->anim);
-        free(it);
-    }
-    anim_list.first = anim_list.last = NULL;
-}
-
-#define OVERSHOOT_TENSION 2.f
-static float anim_interpolate(int type, float input)
-{
-    switch(type)
-    {
-        default:
-        case INTERPOLATOR_LINEAR:
-            return input;
-        case INTERPOLATOR_DECELERATE:
-            return (1.f - (1.f - input) * (1.f - input));
-        case INTERPOLATOR_ACCELERATE:
-            return input * input;
-        case INTERPOLATOR_OVERSHOOT:
-            input -= 1.f;
-            return (input * input * ((OVERSHOOT_TENSION+1.f) * input + OVERSHOOT_TENSION) + 1.f);
-        case INTERPOLATOR_ACCEL_DECEL:
-            return (float)(cos((input + 1) * M_PI) / 2.0f) + 0.5f;
-    }
-}
-
-static inline void anim_int_step(int *prop, int *start, int *last, int *target, float interpolated)
-{
-    if(*target != -1)
-    {
-        const int diff = *prop - *last;
-        *start += diff;
-        *prop = *start + (int)((*target) * interpolated);
-        *last = *prop;
-    }
-}
-
-static inline int item_anim_is_on_screen(item_anim *anim)
-{
-    fb_item_header *it = anim->item;
-    return it->x + it->w > 0 && it->x < (int)fb_width &&
-            it->y + it->h > 0 && it->y < (int)fb_height;
-}
-
-static void item_anim_step(item_anim *anim, float interpolated, int *need_draw)
-{
-    int outside = !item_anim_is_on_screen(anim);
-
-    fb_item_header *fb_it = anim->item;
-    anim_int_step(&fb_it->x, &anim->start[0], &anim->last[0], &anim->targetX, interpolated);
-    anim_int_step(&fb_it->y, &anim->start[1], &anim->last[1], &anim->targetY, interpolated);
-    anim_int_step(&fb_it->w, &anim->start[2], &anim->last[2], &anim->targetW, interpolated);
-    anim_int_step(&fb_it->h, &anim->start[3], &anim->last[3], &anim->targetH, interpolated);
-
-    if(!(*need_draw) && (!outside || item_anim_is_on_screen(anim)))
-        *need_draw = 1;
-}
-
-static void item_anim_on_start(item_anim *anim)
-{
-    fb_item_header *fb_it = anim->item;
-    anim->start[0] = anim->last[0] = fb_it->x;
-    anim->start[1] = anim->last[1] = fb_it->y;
-    anim->start[2] = anim->last[2] = fb_it->w;
-    anim->start[3] = anim->last[3] = fb_it->h;
-
-    if(anim->targetX != -1)
-        anim->targetX -= fb_it->x;
-    if(anim->targetY != -1)
-        anim->targetY -= fb_it->y;
-    if(anim->targetW != -1)
-        anim->targetW -= fb_it->w;
-    if(anim->targetH != -1)
-        anim->targetH -= fb_it->h;
-}
-
-static void item_anim_on_finished(item_anim *anim)
-{
-    if(anim->destroy_item_when_finished)
-        fb_remove_item(anim->item);
-}
-
-static void call_anim_step(call_anim *anim, float interpolated)
-{
-    if(anim->callback)
-        anim->callback(anim->data, interpolated);
-}
-
-static int anim_update(uint32_t diff, void *data)
-{
-    struct anim_list *list = data;
-    struct anim_list_it *it;
-    anim_header *anim;
-    float normalized, interpolated;
-    int need_draw = 0;
-
-    pthread_mutex_lock(&list->mutex);
-    list->in_update_loop = 1;
-
-    for(it = list->first; it; )
-    {
-        anim = it->anim;
-
-        // Handle offset
-        if(anim->start_offset)
-        {
-            if(anim->start_offset > diff)
-                anim->start_offset -= diff;
-            else
-                anim->start_offset = 0;
-            it = it->next;
-            continue;
-        }
-
-        // calculate interpolation
-        anim->elapsed += diff;
-        if(anim->elapsed >= anim->duration)
-            normalized = 1.f;
-        else
-            normalized = ((float)anim->elapsed)/anim->duration;
-
-        interpolated = anim_interpolate(anim->interpolator, normalized);
-
-        // Handle animation step
-        switch(it->anim_type)
-        {
-            case ANIM_TYPE_ITEM:
-                item_anim_step((item_anim*)anim, interpolated, &need_draw);
-                break;
-            case ANIM_TYPE_CALLBACK:
-                call_anim_step((call_anim*)anim, interpolated);
-                break;
-        }
-
-        if(anim->on_step_call)
-        {
-            pthread_mutex_unlock(&list->mutex);
-            anim->on_step_call(anim->on_step_data, interpolated);
-            pthread_mutex_lock(&list->mutex);
-        }
-
-        // remove complete animations
-        if(anim->elapsed >= anim->duration)
-        {
-            if(anim->on_finished_call)
-            {
-                pthread_mutex_unlock(&list->mutex);
-                anim->on_finished_call(anim->on_finished_data);
-                pthread_mutex_lock(&list->mutex);
-            }
-
-            switch(it->anim_type)
-            {
-                case ANIM_TYPE_ITEM:
-                    pthread_mutex_unlock(&list->mutex);
-                    item_anim_on_finished((item_anim*)anim);
-                    pthread_mutex_lock(&list->mutex);
-                    break;
-            }
-
-            struct anim_list_it *to_remove = it;
-            it = it->next;
-            anim_list_rm(to_remove);
-            free(to_remove->anim);
-            free(to_remove);
-        }
-        else
-            it = it->next;
-    }
-
-    if(need_draw)
-        fb_request_draw();
-
-    list->in_update_loop = 0;
-    pthread_mutex_unlock(&list->mutex);
-
-    return 0;
-}
-
-static uint32_t anim_generate_id(void)
-{
-    static uint32_t id = 0;
-    uint32_t res = id++;
-    if(res == ANIM_INVALID_ID)
-        res = id++;
-    return res;
-}
-
-void anim_init(float duration_coef)
-{
-    if(anim_list.running)
-        return;
-
-    anim_list.running = 1;
-    anim_list.duration_coef = duration_coef;
-    workers_add(&anim_update, &anim_list);
-}
-
-void anim_stop(int wait_for_finished)
-{
-    if(!anim_list.running)
-        return;
-
-    anim_list.running = 0;
-    while(wait_for_finished)
-    {
-        pthread_mutex_lock(&anim_list.mutex);
-        if(!anim_list.first)
-        {
-            pthread_mutex_unlock(&anim_list.mutex);
-            break;
-        }
-        pthread_mutex_unlock(&anim_list.mutex);
-        usleep(10000);
-    }
-
-    workers_remove(&anim_update, &anim_list);
-
-    pthread_mutex_lock(&anim_list.mutex);
-    anim_list_clear();
-    pthread_mutex_unlock(&anim_list.mutex);
-}
-
-void anim_cancel(uint32_t id, int only_not_started)
-{
-    if(!anim_list.running)
-        return;
-
-    struct anim_list_it *it;
-
-    pthread_mutex_lock(&anim_list.mutex);
-    for(it = anim_list.first; it; )
-    {
-        if(it->anim->id == id && (!only_not_started || it->anim->start_offset == 0))
-        {
-            anim_list_rm(it);
-            free(it->anim);
-            free(it);
-            break;
-        }
-        else
-            it = it->next;
-    }
-    pthread_mutex_unlock(&anim_list.mutex);
-}
-
-void anim_cancel_for(void *fb_item, int only_not_started)
-{
-    if(!anim_list.running)
-        return;
-
-    if(anim_list.in_update_loop && pthread_equal(pthread_self(), workers_get_thread_id()))
-        return;
-
-    struct anim_list_it *it, *to_remove;
-    anim_header *anim;
-
-    pthread_mutex_lock(&anim_list.mutex);
-    for(it = anim_list.first; it; )
-    {
-        anim = it->anim;
-
-        if(!anim->cancel_check || (only_not_started && anim->start_offset == 0))
-        {
-            it = it->next;
-            continue;
-        }
-
-        if(anim->cancel_check(anim->cancel_check_data, fb_item))
-        {
-            to_remove = it;
-            it = it->next;
-            anim_list_rm(to_remove);
-            free(to_remove->anim);
-            free(to_remove);
-        }
-        else
-            it = it->next;
-    }
-    pthread_mutex_unlock(&anim_list.mutex);
-}
-
-void anim_push_context(void)
-{
-    pthread_mutex_lock(&anim_list.mutex);
-    if(anim_list.first)
-    {
-        list_add(&anim_list.inactive_ctx, anim_list.first);
-        anim_list.first = anim_list.last = NULL;
-    }
-    else
-    {
-        list_add(&anim_list.inactive_ctx, &EMPTY_CONTEXT);
-    }
-    pthread_mutex_unlock(&anim_list.mutex);
-}
-
-void anim_pop_context(void)
-{
-    pthread_mutex_lock(&anim_list.mutex);
-    if(!anim_list.inactive_ctx)
-    {
-        pthread_mutex_unlock(&anim_list.mutex);
-        return;
-    }
-
-    if(anim_list.first)
-        anim_list_clear();
-
-    const int idx = list_item_count(anim_list.inactive_ctx)-1;
-    struct anim_list_it *last_active_ctx = anim_list.inactive_ctx[idx];
-    if(last_active_ctx != &EMPTY_CONTEXT)
-    {
-        anim_list.first = last_active_ctx;
-        while(last_active_ctx->next)
-            last_active_ctx = last_active_ctx->next;
-        anim_list.last = last_active_ctx;
-    }
-    list_rm_at(&anim_list.inactive_ctx, idx, NULL);
-    pthread_mutex_unlock(&anim_list.mutex);
-}
-
-int anim_item_cancel_check(void *item_my, void *item_destroyed)
-{
-    return item_my == item_destroyed;
-}
-
-item_anim *item_anim_create(void *fb_item, int duration, int interpolator)
-{
-    item_anim *anim = mzalloc(sizeof(item_anim));
-    anim->id = anim_generate_id();
-    anim->item = fb_item;
-    anim->duration = duration * anim_list.duration_coef;
-    anim->interpolator = interpolator;
-    anim->cancel_check_data = fb_item;
-    anim->cancel_check = anim_item_cancel_check;
-    anim->targetX = -1;
-    anim->targetY = -1;
-    anim->targetW = -1;
-    anim->targetH = -1;
-    return anim;
-}
-
-void item_anim_add(item_anim *anim)
-{
-    if(!anim_list.running)
-    {
-        free(anim);
-        return;
-    }
-
-    item_anim_on_start(anim);
-
-    struct anim_list_it *it = mzalloc(sizeof(struct anim_list_it));
-    it->anim_type = ANIM_TYPE_ITEM;
-    it->anim = (anim_header*)anim;
-    anim_list_append(it);
-}
-
-void item_anim_add_after(item_anim *anim)
-{
-    struct anim_list_it *it;
-    pthread_mutex_lock(&anim_list.mutex);
-    for(it = anim_list.first; it; it = it->next)
-    {
-        if(it->anim_type == ANIM_TYPE_ITEM && ((item_anim*)it->anim)->item == anim->item)
-        {
-            const int u = it->anim->start_offset + it->anim->duration - it->anim->elapsed;
-            anim->start_offset = imax(anim->start_offset, u);
-        }
-    }
-    pthread_mutex_unlock(&anim_list.mutex);
-
-    item_anim_add(anim);
-}
-
-call_anim *call_anim_create(void *data, call_anim_callback callback, int duration, int interpolator)
-{
-    call_anim *anim = mzalloc(sizeof(call_anim));
-    anim->id = anim_generate_id();
-    anim->data = data;
-    anim->callback = callback;
-    anim->duration = duration * anim_list.duration_coef;
-    anim->interpolator = interpolator;
-    return anim;
-}
-
-void call_anim_add(call_anim *anim)
-{
-    if(!anim_list.running)
-    {
-        free(anim);
-        return;
-    }
-
-    struct anim_list_it *it = mzalloc(sizeof(struct anim_list_it));
-    it->anim_type = ANIM_TYPE_CALLBACK;
-    it->anim = (anim_header*)anim;
-    anim_list_append(it);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <math.h>
+
+#include <malloc.h>
+
+#include "log.h"
+#include "workers.h"
+#include "animation.h"
+#include "util.h"
+#include "framebuffer.h"
+#include "containers.h"
+
+struct anim_list_it
+{
+    int anim_type;
+    anim_header *anim;
+
+    struct anim_list_it *prev;
+    struct anim_list_it *next;
+};
+
+struct anim_list
+{
+    struct anim_list_it *first;
+    struct anim_list_it *last;
+
+    struct anim_list_it **inactive_ctx;
+
+    int running;
+    float duration_coef;
+    volatile int in_update_loop;
+    pthread_mutex_t mutex;
+};
+
+static struct anim_list_it EMPTY_CONTEXT;
+
+static struct anim_list anim_list = {
+    .first = NULL,
+    .last = NULL,
+    .inactive_ctx = NULL,
+    .running = 0,
+    .duration_coef = 1.f,
+    .in_update_loop = 0,
+    .mutex = PTHREAD_MUTEX_INITIALIZER,
+};
+
+static void anim_list_append(struct anim_list_it *it)
+{
+    pthread_mutex_lock(&anim_list.mutex);
+    if(!anim_list.first)
+    {
+        anim_list.first = anim_list.last = it;
+        pthread_mutex_unlock(&anim_list.mutex);
+        return;
+    }
+
+    it->prev = anim_list.last;
+    anim_list.last->next = it;
+    anim_list.last = it;
+    pthread_mutex_unlock(&anim_list.mutex);
+}
+
+// anim_list.mutex must be locked
+static void anim_list_rm(struct anim_list_it *it)
+{
+    if(it->prev)
+        it->prev->next = it->next;
+    else
+        anim_list.first = it->next;
+
+    if(it->next)
+        it->next->prev = it->prev;
+    else
+        anim_list.last = it->prev;
+}
+
+// anim_list.mutex must be locked
+static void anim_list_clear(void)
+{
+    struct anim_list_it *it, *next;
+    for(next = anim_list.first; next; )
+    {
+        it = next;
+        next = next->next;
+
+        free(it->anim);
+        free(it);
+    }
+    anim_list.first = anim_list.last = NULL;
+}
+
+#define OVERSHOOT_TENSION 2.f
+static float anim_interpolate(int type, float input)
+{
+    switch(type)
+    {
+        default:
+        case INTERPOLATOR_LINEAR:
+            return input;
+        case INTERPOLATOR_DECELERATE:
+            return (1.f - (1.f - input) * (1.f - input));
+        case INTERPOLATOR_ACCELERATE:
+            return input * input;
+        case INTERPOLATOR_OVERSHOOT:
+            input -= 1.f;
+            return (input * input * ((OVERSHOOT_TENSION+1.f) * input + OVERSHOOT_TENSION) + 1.f);
+        case INTERPOLATOR_ACCEL_DECEL:
+            return (float)(cos((input + 1) * M_PI) / 2.0f) + 0.5f;
+    }
+}
+
+static inline void anim_int_step(int *prop, int *start, int *last, int *target, float interpolated)
+{
+    if(*target != -1)
+    {
+        const int diff = *prop - *last;
+        *start += diff;
+        *prop = *start + (int)((*target) * interpolated);
+        *last = *prop;
+    }
+}
+
+static inline int item_anim_is_on_screen(item_anim *anim)
+{
+    fb_item_header *it = anim->item;
+    return it->x + it->w > 0 && it->x < (int)fb_width &&
+            it->y + it->h > 0 && it->y < (int)fb_height;
+}
+
+static void item_anim_step(item_anim *anim, float interpolated, int *need_draw)
+{
+    int outside = !item_anim_is_on_screen(anim);
+
+    fb_item_header *fb_it = anim->item;
+    anim_int_step(&fb_it->x, &anim->start[0], &anim->last[0], &anim->targetX, interpolated);
+    anim_int_step(&fb_it->y, &anim->start[1], &anim->last[1], &anim->targetY, interpolated);
+    anim_int_step(&fb_it->w, &anim->start[2], &anim->last[2], &anim->targetW, interpolated);
+    anim_int_step(&fb_it->h, &anim->start[3], &anim->last[3], &anim->targetH, interpolated);
+
+    if(!(*need_draw) && (!outside || item_anim_is_on_screen(anim)))
+        *need_draw = 1;
+}
+
+static void item_anim_on_start(item_anim *anim)
+{
+    fb_item_header *fb_it = anim->item;
+    anim->start[0] = anim->last[0] = fb_it->x;
+    anim->start[1] = anim->last[1] = fb_it->y;
+    anim->start[2] = anim->last[2] = fb_it->w;
+    anim->start[3] = anim->last[3] = fb_it->h;
+
+    if(anim->targetX != -1)
+        anim->targetX -= fb_it->x;
+    if(anim->targetY != -1)
+        anim->targetY -= fb_it->y;
+    if(anim->targetW != -1)
+        anim->targetW -= fb_it->w;
+    if(anim->targetH != -1)
+        anim->targetH -= fb_it->h;
+}
+
+static void item_anim_on_finished(item_anim *anim)
+{
+    if(anim->destroy_item_when_finished)
+        fb_remove_item(anim->item);
+}
+
+static void call_anim_step(call_anim *anim, float interpolated)
+{
+    if(anim->callback)
+        anim->callback(anim->data, interpolated);
+}
+
+static int anim_update(uint32_t diff, void *data)
+{
+    struct anim_list *list = data;
+    struct anim_list_it *it;
+    anim_header *anim;
+    float normalized, interpolated;
+    int need_draw = 0;
+
+    pthread_mutex_lock(&list->mutex);
+    list->in_update_loop = 1;
+
+    for(it = list->first; it; )
+    {
+        anim = it->anim;
+
+        // Handle offset
+        if(anim->start_offset)
+        {
+            if(anim->start_offset > diff)
+                anim->start_offset -= diff;
+            else
+                anim->start_offset = 0;
+            it = it->next;
+            continue;
+        }
+
+        // calculate interpolation
+        anim->elapsed += diff;
+        if(anim->elapsed >= anim->duration)
+            normalized = 1.f;
+        else
+            normalized = ((float)anim->elapsed)/anim->duration;
+
+        interpolated = anim_interpolate(anim->interpolator, normalized);
+
+        // Handle animation step
+        switch(it->anim_type)
+        {
+            case ANIM_TYPE_ITEM:
+                item_anim_step((item_anim*)anim, interpolated, &need_draw);
+                break;
+            case ANIM_TYPE_CALLBACK:
+                call_anim_step((call_anim*)anim, interpolated);
+                break;
+        }
+
+        if(anim->on_step_call)
+        {
+            pthread_mutex_unlock(&list->mutex);
+            anim->on_step_call(anim->on_step_data, interpolated);
+            pthread_mutex_lock(&list->mutex);
+        }
+
+        // remove complete animations
+        if(anim->elapsed >= anim->duration)
+        {
+            if(anim->on_finished_call)
+            {
+                pthread_mutex_unlock(&list->mutex);
+                anim->on_finished_call(anim->on_finished_data);
+                pthread_mutex_lock(&list->mutex);
+            }
+
+            switch(it->anim_type)
+            {
+                case ANIM_TYPE_ITEM:
+                    pthread_mutex_unlock(&list->mutex);
+                    item_anim_on_finished((item_anim*)anim);
+                    pthread_mutex_lock(&list->mutex);
+                    break;
+            }
+
+            struct anim_list_it *to_remove = it;
+            it = it->next;
+            anim_list_rm(to_remove);
+            free(to_remove->anim);
+            free(to_remove);
+        }
+        else
+            it = it->next;
+    }
+
+    if(need_draw)
+        fb_request_draw();
+
+    list->in_update_loop = 0;
+    pthread_mutex_unlock(&list->mutex);
+
+    return 0;
+}
+
+static uint32_t anim_generate_id(void)
+{
+    static uint32_t id = 0;
+    uint32_t res = id++;
+    if(res == ANIM_INVALID_ID)
+        res = id++;
+    return res;
+}
+
+void anim_init(float duration_coef)
+{
+    if(anim_list.running)
+        return;
+
+    anim_list.running = 1;
+    anim_list.duration_coef = duration_coef;
+    workers_add(&anim_update, &anim_list);
+}
+
+void anim_stop(int wait_for_finished)
+{
+    if(!anim_list.running)
+        return;
+
+    anim_list.running = 0;
+    while(wait_for_finished)
+    {
+        pthread_mutex_lock(&anim_list.mutex);
+        if(!anim_list.first)
+        {
+            pthread_mutex_unlock(&anim_list.mutex);
+            break;
+        }
+        pthread_mutex_unlock(&anim_list.mutex);
+        usleep(10000);
+    }
+
+    workers_remove(&anim_update, &anim_list);
+
+    pthread_mutex_lock(&anim_list.mutex);
+    anim_list_clear();
+    pthread_mutex_unlock(&anim_list.mutex);
+}
+
+void anim_cancel(uint32_t id, int only_not_started)
+{
+    if(!anim_list.running)
+        return;
+
+    struct anim_list_it *it;
+
+    pthread_mutex_lock(&anim_list.mutex);
+    for(it = anim_list.first; it; )
+    {
+        if(it->anim->id == id && (!only_not_started || it->anim->start_offset == 0))
+        {
+            anim_list_rm(it);
+            free(it->anim);
+            free(it);
+            break;
+        }
+        else
+            it = it->next;
+    }
+    pthread_mutex_unlock(&anim_list.mutex);
+}
+
+void anim_cancel_for(void *fb_item, int only_not_started)
+{
+    if(!anim_list.running)
+        return;
+
+    if(anim_list.in_update_loop && pthread_equal(pthread_self(), workers_get_thread_id()))
+        return;
+
+    struct anim_list_it *it, *to_remove;
+    anim_header *anim;
+
+    pthread_mutex_lock(&anim_list.mutex);
+    for(it = anim_list.first; it; )
+    {
+        anim = it->anim;
+
+        if(!anim->cancel_check || (only_not_started && anim->start_offset == 0))
+        {
+            it = it->next;
+            continue;
+        }
+
+        if(anim->cancel_check(anim->cancel_check_data, fb_item))
+        {
+            to_remove = it;
+            it = it->next;
+            anim_list_rm(to_remove);
+            free(to_remove->anim);
+            free(to_remove);
+        }
+        else
+            it = it->next;
+    }
+    pthread_mutex_unlock(&anim_list.mutex);
+}
+
+void anim_push_context(void)
+{
+    pthread_mutex_lock(&anim_list.mutex);
+    if(anim_list.first)
+    {
+        list_add(&anim_list.inactive_ctx, anim_list.first);
+        anim_list.first = anim_list.last = NULL;
+    }
+    else
+    {
+        list_add(&anim_list.inactive_ctx, &EMPTY_CONTEXT);
+    }
+    pthread_mutex_unlock(&anim_list.mutex);
+}
+
+void anim_pop_context(void)
+{
+    pthread_mutex_lock(&anim_list.mutex);
+    if(!anim_list.inactive_ctx)
+    {
+        pthread_mutex_unlock(&anim_list.mutex);
+        return;
+    }
+
+    if(anim_list.first)
+        anim_list_clear();
+
+    const int idx = list_item_count(anim_list.inactive_ctx)-1;
+    struct anim_list_it *last_active_ctx = anim_list.inactive_ctx[idx];
+    if(last_active_ctx != &EMPTY_CONTEXT)
+    {
+        anim_list.first = last_active_ctx;
+        while(last_active_ctx->next)
+            last_active_ctx = last_active_ctx->next;
+        anim_list.last = last_active_ctx;
+    }
+    list_rm_at(&anim_list.inactive_ctx, idx, NULL);
+    pthread_mutex_unlock(&anim_list.mutex);
+}
+
+int anim_item_cancel_check(void *item_my, void *item_destroyed)
+{
+    return item_my == item_destroyed;
+}
+
+item_anim *item_anim_create(void *fb_item, int duration, int interpolator)
+{
+    item_anim *anim = mzalloc(sizeof(item_anim));
+    anim->id = anim_generate_id();
+    anim->item = fb_item;
+    anim->duration = duration * anim_list.duration_coef;
+    anim->interpolator = interpolator;
+    anim->cancel_check_data = fb_item;
+    anim->cancel_check = anim_item_cancel_check;
+    anim->targetX = -1;
+    anim->targetY = -1;
+    anim->targetW = -1;
+    anim->targetH = -1;
+    return anim;
+}
+
+void item_anim_add(item_anim *anim)
+{
+    if(!anim_list.running)
+    {
+        free(anim);
+        return;
+    }
+
+    item_anim_on_start(anim);
+
+    struct anim_list_it *it = mzalloc(sizeof(struct anim_list_it));
+    it->anim_type = ANIM_TYPE_ITEM;
+    it->anim = (anim_header*)anim;
+    anim_list_append(it);
+}
+
+void item_anim_add_after(item_anim *anim)
+{
+    struct anim_list_it *it;
+    pthread_mutex_lock(&anim_list.mutex);
+    for(it = anim_list.first; it; it = it->next)
+    {
+        if(it->anim_type == ANIM_TYPE_ITEM && ((item_anim*)it->anim)->item == anim->item)
+        {
+            const int u = it->anim->start_offset + it->anim->duration - it->anim->elapsed;
+            anim->start_offset = imax(anim->start_offset, u);
+        }
+    }
+    pthread_mutex_unlock(&anim_list.mutex);
+
+    item_anim_add(anim);
+}
+
+call_anim *call_anim_create(void *data, call_anim_callback callback, int duration, int interpolator)
+{
+    call_anim *anim = mzalloc(sizeof(call_anim));
+    anim->id = anim_generate_id();
+    anim->data = data;
+    anim->callback = callback;
+    anim->duration = duration * anim_list.duration_coef;
+    anim->interpolator = interpolator;
+    return anim;
+}
+
+void call_anim_add(call_anim *anim)
+{
+    if(!anim_list.running)
+    {
+        free(anim);
+        return;
+    }
+
+    struct anim_list_it *it = mzalloc(sizeof(struct anim_list_it));
+    it->anim_type = ANIM_TYPE_CALLBACK;
+    it->anim = (anim_header*)anim;
+    anim_list_append(it);
+}
diff --git a/lib/animation.h b/lib/animation.h
index a9b7f0c..ccc57eb 100755
--- a/lib/animation.h
+++ b/lib/animation.h
@@ -1,99 +1,99 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef ANIMATION_H
-#define ANIMATION_H
-
-enum
-{
-    ANIM_TYPE_ITEM,
-    ANIM_TYPE_CALLBACK,
-};
-
-enum
-{
-    INTERPOLATOR_LINEAR,
-    INTERPOLATOR_DECELERATE,
-    INTERPOLATOR_ACCELERATE,
-    INTERPOLATOR_OVERSHOOT,
-    INTERPOLATOR_ACCEL_DECEL,
-};
-
-typedef void (*animation_callback)(void*); // data
-typedef void (*animation_callback_step)(void*, float); // data, interpolated
-typedef int (*animation_cancel_check)(void*, void*); // data, item
-
-#define ANIM_INVALID_ID UINT32_MAX
-
-#define ANIM_HEADER \
-    uint32_t id; \
-    uint32_t start_offset; \
-    uint32_t duration; \
-    uint32_t elapsed; \
-    int interpolator; \
-    void *on_finished_data; \
-    animation_callback on_finished_call; \
-    void *on_step_data; \
-    animation_callback_step on_step_call; \
-    void *cancel_check_data; \
-    animation_cancel_check cancel_check;
-
-typedef struct 
-{
-    ANIM_HEADER
-} anim_header;
-
-typedef struct
-{
-    ANIM_HEADER
-    void *item;
-
-    int destroy_item_when_finished;
-
-    int start[4];
-    int last[4];
-
-    int targetX, targetY;
-    int targetW, targetH;
-} item_anim;
-
-typedef void (*call_anim_callback)(void*, float); // data, interpolated
-typedef struct
-{
-    ANIM_HEADER
-
-    call_anim_callback callback;
-    void *data;
-} call_anim;
-
-void anim_init(float duration_coef);
-void anim_stop(int wait_for_finished);
-void anim_cancel(uint32_t id, int only_not_started);
-void anim_cancel_for(void *fb_item, int only_not_started);
-void anim_push_context(void);
-void anim_pop_context(void);
-int anim_item_cancel_check(void *item_my, void *item_destroyed);
-
-item_anim *item_anim_create(void *fb_item, int duration, int interpolator);
-void item_anim_add(item_anim *anim);
-void item_anim_add_after(item_anim *anim);
-
-call_anim *call_anim_create(void *data, call_anim_callback callback, int duration, int interpolator);
-void call_anim_add(call_anim *anim);
-
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef ANIMATION_H
+#define ANIMATION_H
+
+enum
+{
+    ANIM_TYPE_ITEM,
+    ANIM_TYPE_CALLBACK,
+};
+
+enum
+{
+    INTERPOLATOR_LINEAR,
+    INTERPOLATOR_DECELERATE,
+    INTERPOLATOR_ACCELERATE,
+    INTERPOLATOR_OVERSHOOT,
+    INTERPOLATOR_ACCEL_DECEL,
+};
+
+typedef void (*animation_callback)(void*); // data
+typedef void (*animation_callback_step)(void*, float); // data, interpolated
+typedef int (*animation_cancel_check)(void*, void*); // data, item
+
+#define ANIM_INVALID_ID UINT32_MAX
+
+#define ANIM_HEADER \
+    uint32_t id; \
+    uint32_t start_offset; \
+    uint32_t duration; \
+    uint32_t elapsed; \
+    int interpolator; \
+    void *on_finished_data; \
+    animation_callback on_finished_call; \
+    void *on_step_data; \
+    animation_callback_step on_step_call; \
+    void *cancel_check_data; \
+    animation_cancel_check cancel_check;
+
+typedef struct 
+{
+    ANIM_HEADER
+} anim_header;
+
+typedef struct
+{
+    ANIM_HEADER
+    void *item;
+
+    int destroy_item_when_finished;
+
+    int start[4];
+    int last[4];
+
+    int targetX, targetY;
+    int targetW, targetH;
+} item_anim;
+
+typedef void (*call_anim_callback)(void*, float); // data, interpolated
+typedef struct
+{
+    ANIM_HEADER
+
+    call_anim_callback callback;
+    void *data;
+} call_anim;
+
+void anim_init(float duration_coef);
+void anim_stop(int wait_for_finished);
+void anim_cancel(uint32_t id, int only_not_started);
+void anim_cancel_for(void *fb_item, int only_not_started);
+void anim_push_context(void);
+void anim_pop_context(void);
+int anim_item_cancel_check(void *item_my, void *item_destroyed);
+
+item_anim *item_anim_create(void *fb_item, int duration, int interpolator);
+void item_anim_add(item_anim *anim);
+void item_anim_add_after(item_anim *anim);
+
+call_anim *call_anim_create(void *data, call_anim_callback callback, int duration, int interpolator);
+void call_anim_add(call_anim *anim);
+
+
+#endif
diff --git a/lib/atomics.h b/lib/atomics.h
index 856e5d4..c233c23 100755
--- a/lib/atomics.h
+++ b/lib/atomics.h
@@ -1,30 +1,30 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef ATOMICS_H
-#define ATOMICS_H
-
-#if (PLATFORM_SDK_VERSION >= 21)
-#include <stdatomic.h>
-#else
-#include <sys/atomics.h>
-typedef struct { volatile int __val; } atomic_int;
-#define ATOMIC_VAR_INIT(value) { .__val = value }
-#define atomic_compare_exchange_strong(valptr, oldval, newval) (!__atomic_cmpxchg((oldval)->__val, newval, &((valptr)->__val)))
-#endif
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef ATOMICS_H
+#define ATOMICS_H
+
+#if (PLATFORM_SDK_VERSION >= 21)
+#include <stdatomic.h>
+#else
+#include <sys/atomics.h>
+typedef struct { volatile int __val; } atomic_int;
+#define ATOMIC_VAR_INIT(value) { .__val = value }
+#define atomic_compare_exchange_strong(valptr, oldval, newval) (!__atomic_cmpxchg((oldval)->__val, newval, &((valptr)->__val)))
+#endif
+
+#endif
diff --git a/lib/button.c b/lib/button.c
index d84fbaa..5547c2f 100755
--- a/lib/button.c
+++ b/lib/button.c
@@ -1,223 +1,223 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-
-#include <malloc.h>
-
-#include "button.h"
-#include "input.h"
-#include "util.h"
-#include "colors.h"
-#include "log.h"
-#include "containers.h"
-
-void button_init_ui(button *b, const char *text, int size)
-{
-    b->touch_id = -1;
-
-    if(text != NULL)
-    {
-        b->c[CLR_NORMAL][0] = C_HIGHLIGHT_BG;
-        b->c[CLR_NORMAL][1] = C_HIGHLIGHT_TEXT;
-        b->c[CLR_HOVER][0] = C_HIGHLIGHT_HOVER;
-        b->c[CLR_HOVER][1] = C_HIGHLIGHT_TEXT;
-        b->c[CLR_DIS][0] = GRAY;
-        b->c[CLR_DIS][1] = WHITE;
-        b->c[CLR_CHECK][0] = C_HIGHLIGHT_BG;
-        b->c[CLR_CHECK][1] = C_HIGHLIGHT_TEXT;
-
-        b->rect = fb_add_rect_lvl(b->level_off + LEVEL_RECT, b->x, b->y, b->w, b->h, b->c[CLR_NORMAL][0]);
-
-        fb_text_proto *p = fb_text_create(0, 0, b->c[CLR_NORMAL][1], size, text);
-        p->level = b->level_off + LEVEL_TEXT;
-        p->style = STYLE_MEDIUM;
-        b->text = fb_text_finalize(p);
-        center_text(b->text, b->x, b->y, b->w, b->h);
-    }
-    else
-    {
-        b->text = NULL;
-        b->rect = NULL;
-    }
-
-    add_touch_handler(&button_touch_handler, b);
-}
-
-void button_destroy(button *b)
-{
-    rm_touch_handler(&button_touch_handler, b);
-    keyaction_remove(&button_keyaction_call, b);
-
-    if(b->text)
-    {
-        fb_rm_rect(b->rect);
-        fb_rm_text(b->text);
-    }
-
-    free(b);
-}
-
-void button_move(button *b, int x, int y)
-{
-    b->x = x;
-    b->y = y;
-
-    if(b->text)
-    {
-        b->rect->x = x;
-        b->rect->y = y;
-
-        center_text(b->text, b->x, b->y, b->w, b->h);
-    }
-}
-
-void button_set_hover(button *b, int hover)
-{
-    if((hover == 1) == ((b->flags & BTN_HOVER) != 0))
-        return;
-
-    if(hover)
-        b->flags |= BTN_HOVER;
-    else
-        b->flags &= ~(BTN_HOVER);
-
-    if(b->text)
-    {
-        button_update_colors(b);
-        fb_request_draw();
-    }
-}
-
-void button_enable(button *b, int enable)
-{
-    if(enable)
-        b->flags &= ~(BTN_DISABLED);
-    else
-    {
-        b->flags |= BTN_DISABLED;
-        b->flags &= ~(BTN_HOVER);
-    }
-
-    if(b->text)
-    {
-        button_update_colors(b);
-        fb_request_draw();
-    }
-}
-
-int button_touch_handler(touch_event *ev, void *data)
-{
-    button *b = (button*)data;
-
-    if(b->flags & BTN_DISABLED)
-        return -1;
-
-    if(b->touch_id == -1 && (ev->changed & TCHNG_ADDED) && !ev->consumed)
-    {
-        if(!in_rect(ev->x, ev->y, b->x, b->y, b->w, b->h))
-            return -1;
-
-        b->touch_id = ev->id;
-    }
-
-    if(b->touch_id != ev->id)
-        return -1;
-
-    if(ev->changed & TCHNG_POS)
-        button_set_hover(b, in_rect(ev->x, ev->y, b->x, b->y, b->w, b->h));
-
-    if(ev->changed & TCHNG_REMOVED)
-    {
-        if((b->flags & BTN_HOVER) && b->clicked)
-            (*b->clicked)(b->clicked_data);
-        button_set_hover(b, 0);
-        b->touch_id = -1;
-    }
-
-    return 0;
-}
-
-void button_set_color(button *b, int idx, int text, uint32_t color)
-{
-    b->c[idx][text] = color;
-    button_update_colors(b);
-}
-
-void button_update_colors(button *b)
-{
-    int state = CLR_NORMAL;
-    if(b->flags & BTN_DISABLED)
-        state = CLR_DIS;
-    else if(b->flags & BTN_HOVER)
-        state = CLR_HOVER;
-    else if(b->flags & BTN_CHECKED)
-        state = CLR_CHECK;
-
-    if(b->text)
-    {
-        b->rect->color = b->c[state][0];
-        fb_text_set_color(b->text, b->c[state][1]);
-    }
-}
-
-void button_set_checked(button *b, int checked)
-{
-    if((checked == 1) == ((b->flags & BTN_CHECKED) != 0))
-        return;
-
-    if(checked)
-        b->flags |= BTN_CHECKED;
-    else
-        b->flags &= ~(BTN_CHECKED);
-
-    button_update_colors(b);
-    fb_request_draw();
-}
-
-int button_keyaction_call(void *data, int act)
-{
-    button *b = data;
-    switch(act)
-    {
-        case KEYACT_UP:
-        case KEYACT_DOWN:
-        case KEYACT_CLEAR:
-        {
-            if(act != KEYACT_CLEAR && b->keyact_frame == NULL)
-            {
-                fb_add_rect_notfilled(b->level_off + LEVEL_RECT, b->x, b->y, b->w, b->h, C_KEYACT_FRAME, KEYACT_FRAME_W, &b->keyact_frame);
-                fb_request_draw();
-                return 0;
-            }
-            else
-            {
-                list_clear(&b->keyact_frame, &fb_remove_item);
-                fb_request_draw();
-                return (act == KEYACT_CLEAR) ? 0 : 1;
-            }
-        }
-        case KEYACT_CONFIRM:
-        {
-            if(b->clicked && !(b->flags & BTN_DISABLED))
-                (*b->clicked)(b->clicked_data);
-            return 0;
-        }
-        default:
-            return 0;
-    }
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+
+#include <malloc.h>
+
+#include "button.h"
+#include "input.h"
+#include "util.h"
+#include "colors.h"
+#include "log.h"
+#include "containers.h"
+
+void button_init_ui(button *b, const char *text, int size)
+{
+    b->touch_id = -1;
+
+    if(text != NULL)
+    {
+        b->c[CLR_NORMAL][0] = C_HIGHLIGHT_BG;
+        b->c[CLR_NORMAL][1] = C_HIGHLIGHT_TEXT;
+        b->c[CLR_HOVER][0] = C_HIGHLIGHT_HOVER;
+        b->c[CLR_HOVER][1] = C_HIGHLIGHT_TEXT;
+        b->c[CLR_DIS][0] = GRAY;
+        b->c[CLR_DIS][1] = WHITE;
+        b->c[CLR_CHECK][0] = C_HIGHLIGHT_BG;
+        b->c[CLR_CHECK][1] = C_HIGHLIGHT_TEXT;
+
+        b->rect = fb_add_rect_lvl(b->level_off + LEVEL_RECT, b->x, b->y, b->w, b->h, b->c[CLR_NORMAL][0]);
+
+        fb_text_proto *p = fb_text_create(0, 0, b->c[CLR_NORMAL][1], size, text);
+        p->level = b->level_off + LEVEL_TEXT;
+        p->style = STYLE_MEDIUM;
+        b->text = fb_text_finalize(p);
+        center_text(b->text, b->x, b->y, b->w, b->h);
+    }
+    else
+    {
+        b->text = NULL;
+        b->rect = NULL;
+    }
+
+    add_touch_handler(&button_touch_handler, b);
+}
+
+void button_destroy(button *b)
+{
+    rm_touch_handler(&button_touch_handler, b);
+    keyaction_remove(&button_keyaction_call, b);
+
+    if(b->text)
+    {
+        fb_rm_rect(b->rect);
+        fb_rm_text(b->text);
+    }
+
+    free(b);
+}
+
+void button_move(button *b, int x, int y)
+{
+    b->x = x;
+    b->y = y;
+
+    if(b->text)
+    {
+        b->rect->x = x;
+        b->rect->y = y;
+
+        center_text(b->text, b->x, b->y, b->w, b->h);
+    }
+}
+
+void button_set_hover(button *b, int hover)
+{
+    if((hover == 1) == ((b->flags & BTN_HOVER) != 0))
+        return;
+
+    if(hover)
+        b->flags |= BTN_HOVER;
+    else
+        b->flags &= ~(BTN_HOVER);
+
+    if(b->text)
+    {
+        button_update_colors(b);
+        fb_request_draw();
+    }
+}
+
+void button_enable(button *b, int enable)
+{
+    if(enable)
+        b->flags &= ~(BTN_DISABLED);
+    else
+    {
+        b->flags |= BTN_DISABLED;
+        b->flags &= ~(BTN_HOVER);
+    }
+
+    if(b->text)
+    {
+        button_update_colors(b);
+        fb_request_draw();
+    }
+}
+
+int button_touch_handler(touch_event *ev, void *data)
+{
+    button *b = (button*)data;
+
+    if(b->flags & BTN_DISABLED)
+        return -1;
+
+    if(b->touch_id == -1 && (ev->changed & TCHNG_ADDED) && !ev->consumed)
+    {
+        if(!in_rect(ev->x, ev->y, b->x, b->y, b->w, b->h))
+            return -1;
+
+        b->touch_id = ev->id;
+    }
+
+    if(b->touch_id != ev->id)
+        return -1;
+
+    if(ev->changed & TCHNG_POS)
+        button_set_hover(b, in_rect(ev->x, ev->y, b->x, b->y, b->w, b->h));
+
+    if(ev->changed & TCHNG_REMOVED)
+    {
+        if((b->flags & BTN_HOVER) && b->clicked)
+            (*b->clicked)(b->clicked_data);
+        button_set_hover(b, 0);
+        b->touch_id = -1;
+    }
+
+    return 0;
+}
+
+void button_set_color(button *b, int idx, int text, uint32_t color)
+{
+    b->c[idx][text] = color;
+    button_update_colors(b);
+}
+
+void button_update_colors(button *b)
+{
+    int state = CLR_NORMAL;
+    if(b->flags & BTN_DISABLED)
+        state = CLR_DIS;
+    else if(b->flags & BTN_HOVER)
+        state = CLR_HOVER;
+    else if(b->flags & BTN_CHECKED)
+        state = CLR_CHECK;
+
+    if(b->text)
+    {
+        b->rect->color = b->c[state][0];
+        fb_text_set_color(b->text, b->c[state][1]);
+    }
+}
+
+void button_set_checked(button *b, int checked)
+{
+    if((checked == 1) == ((b->flags & BTN_CHECKED) != 0))
+        return;
+
+    if(checked)
+        b->flags |= BTN_CHECKED;
+    else
+        b->flags &= ~(BTN_CHECKED);
+
+    button_update_colors(b);
+    fb_request_draw();
+}
+
+int button_keyaction_call(void *data, int act)
+{
+    button *b = data;
+    switch(act)
+    {
+        case KEYACT_UP:
+        case KEYACT_DOWN:
+        case KEYACT_CLEAR:
+        {
+            if(act != KEYACT_CLEAR && b->keyact_frame == NULL)
+            {
+                fb_add_rect_notfilled(b->level_off + LEVEL_RECT, b->x, b->y, b->w, b->h, C_KEYACT_FRAME, KEYACT_FRAME_W, &b->keyact_frame);
+                fb_request_draw();
+                return 0;
+            }
+            else
+            {
+                list_clear(&b->keyact_frame, &fb_remove_item);
+                fb_request_draw();
+                return (act == KEYACT_CLEAR) ? 0 : 1;
+            }
+        }
+        case KEYACT_CONFIRM:
+        {
+            if(b->clicked && !(b->flags & BTN_DISABLED))
+                (*b->clicked)(b->clicked_data);
+            return 0;
+        }
+        default:
+            return 0;
+    }
+}
diff --git a/lib/button.h b/lib/button.h
index 9cda22f..cc09ad7 100755
--- a/lib/button.h
+++ b/lib/button.h
@@ -1,70 +1,70 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef BUTTON_H
-#define BUTTON_H
-
-#include "framebuffer.h"
-#include "input.h"
-
-enum
-{
-    BTN_HOVER         = 0x01,
-    BTN_DISABLED      = 0x02,
-    BTN_CHECKED       = 0x04,
-};
-
-enum
-{
-    CLR_NORMAL        = 0,
-    CLR_HOVER,
-    CLR_DIS,
-    CLR_CHECK,
-
-    CLR_MAX
-};
-
-typedef struct
-{
-    FB_ITEM_HEAD
-
-    fb_img *text;
-    fb_rect *rect;
-    fb_rect **keyact_frame;
-    int level_off;
-
-    uint32_t c[CLR_MAX][2];
-
-    int flags;
-    int touch_id;
-
-    void *clicked_data;
-    void (*clicked)(void*); // clicked_data
-} button;
-
-void button_init_ui(button *b, const char *text, int size);
-void button_destroy(button *b);
-void button_move(button *b, int x, int y);
-void button_set_hover(button *b, int hover);
-void button_enable(button *b, int enable);
-void button_set_checked(button *b, int checked);
-void button_set_color(button *b, int idx, int text, uint32_t color);
-void button_update_colors(button *b);
-int button_touch_handler(touch_event *ev, void *data);
-int button_keyaction_call(void *data, int act);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef BUTTON_H
+#define BUTTON_H
+
+#include "framebuffer.h"
+#include "input.h"
+
+enum
+{
+    BTN_HOVER         = 0x01,
+    BTN_DISABLED      = 0x02,
+    BTN_CHECKED       = 0x04,
+};
+
+enum
+{
+    CLR_NORMAL        = 0,
+    CLR_HOVER,
+    CLR_DIS,
+    CLR_CHECK,
+
+    CLR_MAX
+};
+
+typedef struct
+{
+    FB_ITEM_HEAD
+
+    fb_img *text;
+    fb_rect *rect;
+    fb_rect **keyact_frame;
+    int level_off;
+
+    uint32_t c[CLR_MAX][2];
+
+    int flags;
+    int touch_id;
+
+    void *clicked_data;
+    void (*clicked)(void*); // clicked_data
+} button;
+
+void button_init_ui(button *b, const char *text, int size);
+void button_destroy(button *b);
+void button_move(button *b, int x, int y);
+void button_set_hover(button *b, int hover);
+void button_enable(button *b, int enable);
+void button_set_checked(button *b, int checked);
+void button_set_color(button *b, int idx, int text, uint32_t color);
+void button_update_colors(button *b);
+int button_touch_handler(touch_event *ev, void *data);
+int button_keyaction_call(void *data, int act);
+
+#endif
diff --git a/lib/colors.c b/lib/colors.c
index be17935..ccf687d 100755
--- a/lib/colors.c
+++ b/lib/colors.c
@@ -1,162 +1,162 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "colors.h"
-#include "util.h"
-
-static const struct mrom_color_theme color_themes[] = {
-    // 0 - red/white, default
-    {
-        .background = 0xFFDCDCDC,
-        .highlight_bg = 0xFFF72F2F,
-        .highlight_hover = 0xFFF85555,
-        .highlight_text = 0xFFFFFFFF,
-        .text = 0xFF000000,
-        .text_secondary = 0xFF4D4D4D,
-        .ncard_bg = 0xFF37474F,
-        .ncard_text = 0xFFFFFFFF,
-        .ncard_text_secondary = 0xFFE6E6E6,
-        .ncard_shadow = 0x54000000,
-        .rom_highlight = 0xFFFFFFFF,
-        .rom_highlight_shadow = 0x54000000,
-        .keyaction_frame = 0xFF0000FF,
-        .btn_fake_shadow = 0xFFA1A1A1,
-    },
-    // 1 - orange/white
-    {
-        .background = 0xFFDCDCDC,
-        .highlight_bg = 0xFFFF5722,
-        .highlight_hover = 0xFFFF8A65,
-        .highlight_text = 0xFFFFFFFF,
-        .text = 0xFF000000,
-        .text_secondary = 0xFF4D4D4D,
-        .ncard_bg = 0xFF37474F,
-        .ncard_text = 0xFFFFFFFF,
-        .ncard_text_secondary = 0xFFE6E6E6,
-        .ncard_shadow = 0x54000000,
-        .rom_highlight = 0xFFFFFFFF,
-        .rom_highlight_shadow = 0x54000000,
-        .keyaction_frame = 0xFFFF0000,
-        .btn_fake_shadow = 0xFFA1A1A1,
-    },
-    // 2 - blue/white
-    {
-        .background = 0xFFDCDCDC,
-        .highlight_bg = 0xFF5677FC,
-        .highlight_hover = 0xFF91A7FF,
-        .highlight_text = 0xFFFFFFFF,
-        .text = 0xFF000000,
-        .text_secondary = 0xFF4D4D4D,
-        .ncard_bg = 0xFF37474F,
-        .ncard_text = 0xFFFFFFFF,
-        .ncard_text_secondary = 0xFFE6E6E6,
-        .ncard_shadow = 0x54000000,
-        .rom_highlight = 0xFFFFFFFF,
-        .rom_highlight_shadow = 0x54000000,
-        .keyaction_frame = 0xFFFF0000,
-        .btn_fake_shadow = 0xFFA1A1A1,
-    },
-    // 3 - purple/white
-    {
-        .background = 0xFFDCDCDC,
-        .highlight_bg = 0xFF673AB7,
-        .highlight_hover = 0xFF9575CD,
-        .highlight_text = 0xFFFFFFFF,
-        .text = 0xFF000000,
-        .text_secondary = 0xFF4D4D4D,
-        .ncard_bg = 0xFF37474F,
-        .ncard_text = 0xFFFFFFFF,
-        .ncard_text_secondary = 0xFFE6E6E6,
-        .ncard_shadow = 0x54000000,
-        .rom_highlight = 0xFFFFFFFF,
-        .rom_highlight_shadow = 0x54000000,
-        .keyaction_frame = 0xFFFF0000,
-        .btn_fake_shadow = 0xFFA1A1A1,
-    },
-    // 4 - green/white
-    {
-        .background = 0xFFDCDCDC,
-        .highlight_bg = 0xFF259B24,
-        .highlight_hover = 0xFF72D572,
-        .highlight_text = 0xFFFFFFFF,
-        .text = 0xFF000000,
-        .text_secondary = 0xFF4D4D4D,
-        .ncard_bg = 0xFF37474F,
-        .ncard_text = 0xFFFFFFFF,
-        .ncard_text_secondary = 0xFFE6E6E6,
-        .ncard_shadow = 0x54000000,
-        .rom_highlight = 0xFFFFFFFF,
-        .rom_highlight_shadow = 0x54000000,
-        .keyaction_frame = 0xFFFF0000,
-        .btn_fake_shadow = 0xFFA1A1A1,
-    },
-    // 5 - dark blue
-    {
-        .background = 0xFF263238,
-        .highlight_bg = 0xFF607D8B,
-        .highlight_hover = 0xFF90A4AE,
-        .highlight_text = 0xFFFFFFFF,
-        .text = 0xFFFFFFFF,
-        .text_secondary = 0xFFE6E6E6,
-        .ncard_bg = 0xFF37474F,
-        .ncard_text = 0xFFFFFFFF,
-        .ncard_text_secondary = 0xFFE6E6E6,
-        .ncard_shadow = 0x54000000,
-        .rom_highlight = 0xFF607D8B,
-        .rom_highlight_shadow = 0x54000000,
-        .keyaction_frame = 0xFFFF0000,
-        .btn_fake_shadow = 0xFF1C2529,
-    },
-    // 6 - dark blue/black
-    {
-        .background = 0xFF000000,
-        .highlight_bg = 0xFF263238,
-        .highlight_hover = 0xFF607D8B,
-        .highlight_text = 0xFFFFFFFF,
-        .text = 0xFFFFFFFF,
-        .text_secondary = 0xFFE6E6E6,
-        .ncard_bg = 0xFF37474F,
-        .ncard_text = 0xFFFFFFFF,
-        .ncard_text_secondary = 0xFFE6E6E6,
-        .ncard_shadow = 0x54424242,
-        .rom_highlight = 0xFF263238,
-        .rom_highlight_shadow = 0x54424242,
-        .keyaction_frame = 0xFFFF0000,
-        .btn_fake_shadow = 0x00000000,
-    },
-};
-
-const struct mrom_color_theme *color_theme = &color_themes[0];
-
-void colors_select(size_t color_theme_idx)
-{
-    if(color_theme_idx >= ARRAY_SIZE(color_themes))
-        return;
-    color_theme = &color_themes[color_theme_idx];
-}
-
-const struct mrom_color_theme *colors_get(size_t color_theme_idx)
-{
-    if(color_theme_idx >= ARRAY_SIZE(color_themes))
-        return NULL;
-    return &color_themes[color_theme_idx];
-}
-
-int colors_count(void)
-{
-    return ARRAY_SIZE(color_themes);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "colors.h"
+#include "util.h"
+
+static const struct mrom_color_theme color_themes[] = {
+    // 0 - red/white, default
+    {
+        .background = 0xFFDCDCDC,
+        .highlight_bg = 0xFFF72F2F,
+        .highlight_hover = 0xFFF85555,
+        .highlight_text = 0xFFFFFFFF,
+        .text = 0xFF000000,
+        .text_secondary = 0xFF4D4D4D,
+        .ncard_bg = 0xFF37474F,
+        .ncard_text = 0xFFFFFFFF,
+        .ncard_text_secondary = 0xFFE6E6E6,
+        .ncard_shadow = 0x54000000,
+        .rom_highlight = 0xFFFFFFFF,
+        .rom_highlight_shadow = 0x54000000,
+        .keyaction_frame = 0xFF0000FF,
+        .btn_fake_shadow = 0xFFA1A1A1,
+    },
+    // 1 - orange/white
+    {
+        .background = 0xFFDCDCDC,
+        .highlight_bg = 0xFFFF5722,
+        .highlight_hover = 0xFFFF8A65,
+        .highlight_text = 0xFFFFFFFF,
+        .text = 0xFF000000,
+        .text_secondary = 0xFF4D4D4D,
+        .ncard_bg = 0xFF37474F,
+        .ncard_text = 0xFFFFFFFF,
+        .ncard_text_secondary = 0xFFE6E6E6,
+        .ncard_shadow = 0x54000000,
+        .rom_highlight = 0xFFFFFFFF,
+        .rom_highlight_shadow = 0x54000000,
+        .keyaction_frame = 0xFFFF0000,
+        .btn_fake_shadow = 0xFFA1A1A1,
+    },
+    // 2 - blue/white
+    {
+        .background = 0xFFDCDCDC,
+        .highlight_bg = 0xFF5677FC,
+        .highlight_hover = 0xFF91A7FF,
+        .highlight_text = 0xFFFFFFFF,
+        .text = 0xFF000000,
+        .text_secondary = 0xFF4D4D4D,
+        .ncard_bg = 0xFF37474F,
+        .ncard_text = 0xFFFFFFFF,
+        .ncard_text_secondary = 0xFFE6E6E6,
+        .ncard_shadow = 0x54000000,
+        .rom_highlight = 0xFFFFFFFF,
+        .rom_highlight_shadow = 0x54000000,
+        .keyaction_frame = 0xFFFF0000,
+        .btn_fake_shadow = 0xFFA1A1A1,
+    },
+    // 3 - purple/white
+    {
+        .background = 0xFFDCDCDC,
+        .highlight_bg = 0xFF673AB7,
+        .highlight_hover = 0xFF9575CD,
+        .highlight_text = 0xFFFFFFFF,
+        .text = 0xFF000000,
+        .text_secondary = 0xFF4D4D4D,
+        .ncard_bg = 0xFF37474F,
+        .ncard_text = 0xFFFFFFFF,
+        .ncard_text_secondary = 0xFFE6E6E6,
+        .ncard_shadow = 0x54000000,
+        .rom_highlight = 0xFFFFFFFF,
+        .rom_highlight_shadow = 0x54000000,
+        .keyaction_frame = 0xFFFF0000,
+        .btn_fake_shadow = 0xFFA1A1A1,
+    },
+    // 4 - green/white
+    {
+        .background = 0xFFDCDCDC,
+        .highlight_bg = 0xFF259B24,
+        .highlight_hover = 0xFF72D572,
+        .highlight_text = 0xFFFFFFFF,
+        .text = 0xFF000000,
+        .text_secondary = 0xFF4D4D4D,
+        .ncard_bg = 0xFF37474F,
+        .ncard_text = 0xFFFFFFFF,
+        .ncard_text_secondary = 0xFFE6E6E6,
+        .ncard_shadow = 0x54000000,
+        .rom_highlight = 0xFFFFFFFF,
+        .rom_highlight_shadow = 0x54000000,
+        .keyaction_frame = 0xFFFF0000,
+        .btn_fake_shadow = 0xFFA1A1A1,
+    },
+    // 5 - dark blue
+    {
+        .background = 0xFF263238,
+        .highlight_bg = 0xFF607D8B,
+        .highlight_hover = 0xFF90A4AE,
+        .highlight_text = 0xFFFFFFFF,
+        .text = 0xFFFFFFFF,
+        .text_secondary = 0xFFE6E6E6,
+        .ncard_bg = 0xFF37474F,
+        .ncard_text = 0xFFFFFFFF,
+        .ncard_text_secondary = 0xFFE6E6E6,
+        .ncard_shadow = 0x54000000,
+        .rom_highlight = 0xFF607D8B,
+        .rom_highlight_shadow = 0x54000000,
+        .keyaction_frame = 0xFFFF0000,
+        .btn_fake_shadow = 0xFF1C2529,
+    },
+    // 6 - dark blue/black
+    {
+        .background = 0xFF000000,
+        .highlight_bg = 0xFF263238,
+        .highlight_hover = 0xFF607D8B,
+        .highlight_text = 0xFFFFFFFF,
+        .text = 0xFFFFFFFF,
+        .text_secondary = 0xFFE6E6E6,
+        .ncard_bg = 0xFF37474F,
+        .ncard_text = 0xFFFFFFFF,
+        .ncard_text_secondary = 0xFFE6E6E6,
+        .ncard_shadow = 0x54424242,
+        .rom_highlight = 0xFF263238,
+        .rom_highlight_shadow = 0x54424242,
+        .keyaction_frame = 0xFFFF0000,
+        .btn_fake_shadow = 0x00000000,
+    },
+};
+
+const struct mrom_color_theme *color_theme = &color_themes[0];
+
+void colors_select(size_t color_theme_idx)
+{
+    if(color_theme_idx >= ARRAY_SIZE(color_themes))
+        return;
+    color_theme = &color_themes[color_theme_idx];
+}
+
+const struct mrom_color_theme *colors_get(size_t color_theme_idx)
+{
+    if(color_theme_idx >= ARRAY_SIZE(color_themes))
+        return NULL;
+    return &color_themes[color_theme_idx];
+}
+
+int colors_count(void)
+{
+    return ARRAY_SIZE(color_themes);
+}
diff --git a/lib/colors.h b/lib/colors.h
index a53641c..1e55bd7 100755
--- a/lib/colors.h
+++ b/lib/colors.h
@@ -1,61 +1,61 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MROM_COLORS_H
-#define MROM_COLORS_H
-
-#include <stdint.h>
-
-struct mrom_color_theme
-{
-    uint32_t background;
-    uint32_t highlight_bg;
-    uint32_t highlight_hover;
-    uint32_t highlight_text;
-    uint32_t text;
-    uint32_t text_secondary;
-    uint32_t ncard_bg;
-    uint32_t ncard_text;
-    uint32_t ncard_text_secondary;
-    uint32_t ncard_shadow;
-    uint32_t rom_highlight;
-    uint32_t rom_highlight_shadow;
-    uint32_t keyaction_frame;
-    uint32_t btn_fake_shadow;
-};
-
-extern const struct mrom_color_theme *color_theme;
-#define C_BACKGROUND (color_theme->background)
-#define C_HIGHLIGHT_BG (color_theme->highlight_bg)
-#define C_HIGHLIGHT_HOVER (color_theme->highlight_hover)
-#define C_HIGHLIGHT_TEXT (color_theme->highlight_text)
-#define C_TEXT (color_theme->text)
-#define C_TEXT_SECONDARY (color_theme->text_secondary)
-#define C_NCARD_BG (color_theme->ncard_bg)
-#define C_NCARD_TEXT (color_theme->ncard_text)
-#define C_NCARD_TEXT_SECONDARY (color_theme->ncard_text_secondary)
-#define C_NCARD_SHADOW (color_theme->ncard_shadow)
-#define C_ROM_HIGHLIGHT (color_theme->rom_highlight)
-#define C_ROM_HIGHLIGHT_SHADOW (color_theme->rom_highlight_shadow)
-#define C_KEYACT_FRAME (color_theme->keyaction_frame)
-#define C_BTN_FAKE_SHADOW (color_theme->btn_fake_shadow)
-
-void colors_select(size_t color_theme_idx);
-const struct mrom_color_theme *colors_get(size_t color_theme_idx);
-int colors_count(void);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MROM_COLORS_H
+#define MROM_COLORS_H
+
+#include <stdint.h>
+
+struct mrom_color_theme
+{
+    uint32_t background;
+    uint32_t highlight_bg;
+    uint32_t highlight_hover;
+    uint32_t highlight_text;
+    uint32_t text;
+    uint32_t text_secondary;
+    uint32_t ncard_bg;
+    uint32_t ncard_text;
+    uint32_t ncard_text_secondary;
+    uint32_t ncard_shadow;
+    uint32_t rom_highlight;
+    uint32_t rom_highlight_shadow;
+    uint32_t keyaction_frame;
+    uint32_t btn_fake_shadow;
+};
+
+extern const struct mrom_color_theme *color_theme;
+#define C_BACKGROUND (color_theme->background)
+#define C_HIGHLIGHT_BG (color_theme->highlight_bg)
+#define C_HIGHLIGHT_HOVER (color_theme->highlight_hover)
+#define C_HIGHLIGHT_TEXT (color_theme->highlight_text)
+#define C_TEXT (color_theme->text)
+#define C_TEXT_SECONDARY (color_theme->text_secondary)
+#define C_NCARD_BG (color_theme->ncard_bg)
+#define C_NCARD_TEXT (color_theme->ncard_text)
+#define C_NCARD_TEXT_SECONDARY (color_theme->ncard_text_secondary)
+#define C_NCARD_SHADOW (color_theme->ncard_shadow)
+#define C_ROM_HIGHLIGHT (color_theme->rom_highlight)
+#define C_ROM_HIGHLIGHT_SHADOW (color_theme->rom_highlight_shadow)
+#define C_KEYACT_FRAME (color_theme->keyaction_frame)
+#define C_BTN_FAKE_SHADOW (color_theme->btn_fake_shadow)
+
+void colors_select(size_t color_theme_idx);
+const struct mrom_color_theme *colors_get(size_t color_theme_idx);
+int colors_count(void);
+
+#endif
diff --git a/lib/containers.c b/lib/containers.c
index ca06089..51dc233 100755
--- a/lib/containers.c
+++ b/lib/containers.c
@@ -1,391 +1,391 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <malloc.h>
-
-#include "containers.h"
-#include "util.h"
-
-int list_item_count(listItself list)
-{
-    void **l = (void**)list;
-    int i = 0;
-    while(l && l[i])
-        ++i;
-    return i;
-}
-
-int list_size(listItself list)
-{
-    return list_item_count(list)+1;
-}
-
-void list_add(ptrToList list_p, void *item)
-{
-    void ***list = (void***)list_p;
-
-    int i = 0;
-    while(*list && (*list)[i])
-        ++i;
-    i += 2; // NULL and the new item
-
-    *list = realloc(*list, i*sizeof(item));
-
-    (*list)[--i] = NULL;
-    (*list)[--i] = item;
-}
-
-void list_add_at(ptrToList list_p, int idx, void *item)
-{
-    void ***list = (void***)list_p;
-    int size = list_size(*list);
-    int i;
-
-    *list = realloc(*list, (size+1)*sizeof(void*));
-
-    if(idx < 0)
-        idx = 0;
-    else if(idx >= size)
-        idx = size - 1;
-
-    for(i = idx + 1; i < size; ++i)
-        (*list)[i] = (*list)[i-1];
-
-    (*list)[idx] = item;
-    (*list)[i] = NULL;
-}
-
-int list_add_from_list(ptrToList list_p, listItself src_p)
-{
-    void **src = (void**)src_p;
-    void ***list = (void***)list_p;
-    int i, len_src = 0, len_list = 0;
-
-    while(src && src[len_src])
-        ++len_src;
-
-    if(len_src == 0)
-        return 0;
-
-    while(*list && (*list)[len_list])
-        ++len_list;
-
-    ++len_src; // for NULL
-    *list = realloc(*list, (len_list+len_src)*sizeof(void*));
-
-    for(i = 0; i < len_src; ++i)
-        (*list)[i+len_list] = src[i];
-    return len_src-1;
-}
-
-int list_rm_opt(ptrToList list_p, void *item, callback destroy_callback_p, int reorder)
-{
-    void ***list = (void***)list_p;
-    callbackPtr destroy_callback = (callbackPtr)destroy_callback_p;
-
-    int size = list_size(*list);
-
-    int i;
-    for(i = 0; *list && (*list)[i]; ++i)
-    {
-        if((*list)[i] != item)
-            continue;
-
-        if(destroy_callback)
-            (*destroy_callback)(item);
-
-        --size;
-        if(size == 1)
-        {
-            free(*list);
-            *list = NULL;
-            return 0;
-        }
-
-        if(i != size-1)
-        {
-            if(reorder)
-                (*list)[i] = (*list)[size-1];
-            else
-            {
-                for(; *list && (*list)[i]; ++i)
-                    (*list)[i] = (*list)[i+1];
-            }
-        }
-
-        *list= realloc(*list, size*sizeof(item));
-        (*list)[size-1] = NULL;
-        return 0;
-    }
-    return -1;
-}
-
-int list_rm(ptrToList list_p, void *item, callback destroy_callback_p)
-{
-    return list_rm_opt(list_p, item, destroy_callback_p, 1);
-}
-
-int list_rm_noreorder(ptrToList list_p, void *item, callback destroy_callback_p)
-{
-    return list_rm_opt(list_p, item, destroy_callback_p, 0);
-}
-
-listItself list_rm_at(ptrToList list_p, int idx, callback destroy_callback_p)
-{
-    void ***list = (void***)list_p;
-    callbackPtr destroy_callback = (callbackPtr)destroy_callback_p;
-
-    int size = list_size(*list);
-    if(idx < 0 || idx >= size-1)
-        return NULL;
-
-    void *item = (*list)[idx];
-    if(destroy_callback)
-        (*destroy_callback)(item);
-
-    --size;
-    if(size == 1)
-    {
-        free(*list);
-        *list = NULL;
-        return NULL;
-    }
-
-    int i = idx;
-    for(; i < size; ++i)
-        (*list)[i] = (*list)[i+1];
-
-    *list = realloc(*list, size*sizeof(item));
-    return *list + idx;
-}
-
-void list_clear(ptrToList list_p, callback destroy_callback_p)
-{
-    void ***list = (void***)list_p;
-    callbackPtr destroy_callback = (callbackPtr)destroy_callback_p;
-
-    if(*list == NULL)
-        return;
-
-    if(destroy_callback)
-    {
-        int i;
-        for(i = 0; *list && (*list)[i]; ++i)
-            (*destroy_callback)((*list)[i]);
-    }
-
-    free(*list);
-    *list = NULL;
-}
-
-int list_copy(ptrToList dest_p, listItself src)
-{
-    void **source = (void**)src;
-    void ***dest = (void***)dest_p;
-
-    if(!source)
-        return 0;
-
-    if(*dest)
-        return -1;
-
-    int size = list_size(source);
-    *dest = calloc(size, sizeof(*source));
-
-    int i;
-    for(i = 0; source[i]; ++i)
-        (*dest)[i] = source[i];
-    return 0;
-}
-
-int list_move(ptrToList dest_p, ptrToList source_p)
-{
-    void ***source = (void***)source_p;
-    void ***dest = (void***)dest_p;
-
-    if(!source)
-        return 0;
-
-    if(*dest)
-        return -1;
-
-    *dest = *source;
-    *source = NULL;
-    return 0;
-}
-
-void list_swap(ptrToList a_p, ptrToList b_p)
-{
-    void ***a = (void***)a_p;
-    void ***b = (void***)b_p;
-    void **tmp = *a;
-    *a = *b;
-    *b = tmp;
-}
-
-map *map_create(void)
-{
-    map *m = mzalloc(sizeof(map));
-    return m;
-}
-
-void map_destroy(map *m, void (*destroy_callback)(void*))
-{
-    if(!m)
-        return;
-
-    list_clear(&m->keys, &free);
-    list_clear(&m->values, destroy_callback);
-    free(m);
-}
-
-void map_add(map *m, const char *key, void *val, void (*destroy_callback)(void*))
-{
-    int idx = map_find(m, key);
-    if(idx >= 0)
-    {
-        if(destroy_callback)
-            (*destroy_callback)(m->values[idx]);
-        m->values[idx] = val;
-    }
-    else
-        map_add_not_exist(m, key, val);
-}
-
-void map_add_not_exist(map *m, const char *key, void *val)
-{
-    list_add(&m->keys, strdup(key));
-    list_add(&m->values, val);
-    ++m->size;
-}
-
-void map_rm(map *m, const char *key, void (*destroy_callback)(void*))
-{
-    int idx = map_find(m, key);
-    if(idx < 0)
-        return;
-
-    list_rm_at(&m->keys, idx, &free);
-    list_rm_at(&m->values, idx, destroy_callback);
-    --m->size;
-}
-
-int map_find(map *m, const char *key)
-{
-    int i;
-    for(i = 0; m->keys && m->keys[i]; ++i)
-        if(strcmp(m->keys[i], key) == 0)
-            return i;
-    return -1;
-}
-
-void *map_get_val(map *m, const char *key)
-{
-    int idx = map_find(m, key);
-    if(idx < 0)
-        return NULL;
-    return m->values[idx];
-}
-
-void *map_get_ref(map *m, const char *key)
-{
-    int idx = map_find(m, key);
-    if(idx < 0)
-        return NULL;
-    return &m->values[idx];
-}
-
-
-
-imap *imap_create(void)
-{
-    return mzalloc(sizeof(imap));
-}
-
-void imap_destroy(imap *m, void (*destroy_callback)(void*))
-{
-    if(!m)
-        return;
-
-    list_clear(&m->values, destroy_callback);
-    free(m->keys);
-    free(m);
-}
-
-void imap_add(imap *m, int key, void *val, void (*destroy_callback)(void*))
-{
-    int idx = imap_find(m, key);
-    if(idx >= 0)
-    {
-        if(destroy_callback)
-            (*destroy_callback)(m->values[idx]);
-        m->values[idx] = val;
-    }
-    else
-        imap_add_not_exist(m, key, val);
-}
-
-void imap_add_not_exist(imap *m, int key, void *val)
-{
-    m->keys = realloc(m->keys, sizeof(int)*(m->size+1));
-    m->keys[m->size++] = key;
-
-    list_add(&m->values, val);
-}
-
-void imap_rm(imap *m, int key, void (*destroy_callback)(void*))
-{
-    size_t i;
-    int idx = imap_find(m, key);
-    if(idx < 0)
-        return;
-
-    for(i = idx; i < m->size-1; ++i)
-        m->keys[i] = m->keys[i+1];
-
-    --m->size;
-    m->keys = realloc(m->keys, sizeof(int)*m->size);
-    list_rm_at(&m->values, idx, destroy_callback);
-}
-
-int imap_find(imap *m, int key)
-{
-    size_t i;
-    for(i = 0; i < m->size; ++i)
-        if(key == m->keys[i])
-            return i;
-    return -1;
-}
-
-void *imap_get_val(imap *m, int key)
-{
-    int idx = imap_find(m, key);
-    if(idx < 0)
-        return NULL;
-    return m->values[idx];
-}
-
-void *imap_get_ref(imap *m, int key)
-{
-    int idx = imap_find(m, key);
-    if(idx < 0)
-        return NULL;
-    return &m->values[idx];
-}
-
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <malloc.h>
+
+#include "containers.h"
+#include "util.h"
+
+int list_item_count(listItself list)
+{
+    void **l = (void**)list;
+    int i = 0;
+    while(l && l[i])
+        ++i;
+    return i;
+}
+
+int list_size(listItself list)
+{
+    return list_item_count(list)+1;
+}
+
+void list_add(ptrToList list_p, void *item)
+{
+    void ***list = (void***)list_p;
+
+    int i = 0;
+    while(*list && (*list)[i])
+        ++i;
+    i += 2; // NULL and the new item
+
+    *list = realloc(*list, i*sizeof(item));
+
+    (*list)[--i] = NULL;
+    (*list)[--i] = item;
+}
+
+void list_add_at(ptrToList list_p, int idx, void *item)
+{
+    void ***list = (void***)list_p;
+    int size = list_size(*list);
+    int i;
+
+    *list = realloc(*list, (size+1)*sizeof(void*));
+
+    if(idx < 0)
+        idx = 0;
+    else if(idx >= size)
+        idx = size - 1;
+
+    for(i = idx + 1; i < size; ++i)
+        (*list)[i] = (*list)[i-1];
+
+    (*list)[idx] = item;
+    (*list)[i] = NULL;
+}
+
+int list_add_from_list(ptrToList list_p, listItself src_p)
+{
+    void **src = (void**)src_p;
+    void ***list = (void***)list_p;
+    int i, len_src = 0, len_list = 0;
+
+    while(src && src[len_src])
+        ++len_src;
+
+    if(len_src == 0)
+        return 0;
+
+    while(*list && (*list)[len_list])
+        ++len_list;
+
+    ++len_src; // for NULL
+    *list = realloc(*list, (len_list+len_src)*sizeof(void*));
+
+    for(i = 0; i < len_src; ++i)
+        (*list)[i+len_list] = src[i];
+    return len_src-1;
+}
+
+int list_rm_opt(ptrToList list_p, void *item, callback destroy_callback_p, int reorder)
+{
+    void ***list = (void***)list_p;
+    callbackPtr destroy_callback = (callbackPtr)destroy_callback_p;
+
+    int size = list_size(*list);
+
+    int i;
+    for(i = 0; *list && (*list)[i]; ++i)
+    {
+        if((*list)[i] != item)
+            continue;
+
+        if(destroy_callback)
+            (*destroy_callback)(item);
+
+        --size;
+        if(size == 1)
+        {
+            free(*list);
+            *list = NULL;
+            return 0;
+        }
+
+        if(i != size-1)
+        {
+            if(reorder)
+                (*list)[i] = (*list)[size-1];
+            else
+            {
+                for(; *list && (*list)[i]; ++i)
+                    (*list)[i] = (*list)[i+1];
+            }
+        }
+
+        *list= realloc(*list, size*sizeof(item));
+        (*list)[size-1] = NULL;
+        return 0;
+    }
+    return -1;
+}
+
+int list_rm(ptrToList list_p, void *item, callback destroy_callback_p)
+{
+    return list_rm_opt(list_p, item, destroy_callback_p, 1);
+}
+
+int list_rm_noreorder(ptrToList list_p, void *item, callback destroy_callback_p)
+{
+    return list_rm_opt(list_p, item, destroy_callback_p, 0);
+}
+
+listItself list_rm_at(ptrToList list_p, int idx, callback destroy_callback_p)
+{
+    void ***list = (void***)list_p;
+    callbackPtr destroy_callback = (callbackPtr)destroy_callback_p;
+
+    int size = list_size(*list);
+    if(idx < 0 || idx >= size-1)
+        return NULL;
+
+    void *item = (*list)[idx];
+    if(destroy_callback)
+        (*destroy_callback)(item);
+
+    --size;
+    if(size == 1)
+    {
+        free(*list);
+        *list = NULL;
+        return NULL;
+    }
+
+    int i = idx;
+    for(; i < size; ++i)
+        (*list)[i] = (*list)[i+1];
+
+    *list = realloc(*list, size*sizeof(item));
+    return *list + idx;
+}
+
+void list_clear(ptrToList list_p, callback destroy_callback_p)
+{
+    void ***list = (void***)list_p;
+    callbackPtr destroy_callback = (callbackPtr)destroy_callback_p;
+
+    if(*list == NULL)
+        return;
+
+    if(destroy_callback)
+    {
+        int i;
+        for(i = 0; *list && (*list)[i]; ++i)
+            (*destroy_callback)((*list)[i]);
+    }
+
+    free(*list);
+    *list = NULL;
+}
+
+int list_copy(ptrToList dest_p, listItself src)
+{
+    void **source = (void**)src;
+    void ***dest = (void***)dest_p;
+
+    if(!source)
+        return 0;
+
+    if(*dest)
+        return -1;
+
+    int size = list_size(source);
+    *dest = calloc(size, sizeof(*source));
+
+    int i;
+    for(i = 0; source[i]; ++i)
+        (*dest)[i] = source[i];
+    return 0;
+}
+
+int list_move(ptrToList dest_p, ptrToList source_p)
+{
+    void ***source = (void***)source_p;
+    void ***dest = (void***)dest_p;
+
+    if(!source)
+        return 0;
+
+    if(*dest)
+        return -1;
+
+    *dest = *source;
+    *source = NULL;
+    return 0;
+}
+
+void list_swap(ptrToList a_p, ptrToList b_p)
+{
+    void ***a = (void***)a_p;
+    void ***b = (void***)b_p;
+    void **tmp = *a;
+    *a = *b;
+    *b = tmp;
+}
+
+map *map_create(void)
+{
+    map *m = mzalloc(sizeof(map));
+    return m;
+}
+
+void map_destroy(map *m, void (*destroy_callback)(void*))
+{
+    if(!m)
+        return;
+
+    list_clear(&m->keys, &free);
+    list_clear(&m->values, destroy_callback);
+    free(m);
+}
+
+void map_add(map *m, const char *key, void *val, void (*destroy_callback)(void*))
+{
+    int idx = map_find(m, key);
+    if(idx >= 0)
+    {
+        if(destroy_callback)
+            (*destroy_callback)(m->values[idx]);
+        m->values[idx] = val;
+    }
+    else
+        map_add_not_exist(m, key, val);
+}
+
+void map_add_not_exist(map *m, const char *key, void *val)
+{
+    list_add(&m->keys, strdup(key));
+    list_add(&m->values, val);
+    ++m->size;
+}
+
+void map_rm(map *m, const char *key, void (*destroy_callback)(void*))
+{
+    int idx = map_find(m, key);
+    if(idx < 0)
+        return;
+
+    list_rm_at(&m->keys, idx, &free);
+    list_rm_at(&m->values, idx, destroy_callback);
+    --m->size;
+}
+
+int map_find(map *m, const char *key)
+{
+    int i;
+    for(i = 0; m->keys && m->keys[i]; ++i)
+        if(strcmp(m->keys[i], key) == 0)
+            return i;
+    return -1;
+}
+
+void *map_get_val(map *m, const char *key)
+{
+    int idx = map_find(m, key);
+    if(idx < 0)
+        return NULL;
+    return m->values[idx];
+}
+
+void *map_get_ref(map *m, const char *key)
+{
+    int idx = map_find(m, key);
+    if(idx < 0)
+        return NULL;
+    return &m->values[idx];
+}
+
+
+
+imap *imap_create(void)
+{
+    return mzalloc(sizeof(imap));
+}
+
+void imap_destroy(imap *m, void (*destroy_callback)(void*))
+{
+    if(!m)
+        return;
+
+    list_clear(&m->values, destroy_callback);
+    free(m->keys);
+    free(m);
+}
+
+void imap_add(imap *m, int key, void *val, void (*destroy_callback)(void*))
+{
+    int idx = imap_find(m, key);
+    if(idx >= 0)
+    {
+        if(destroy_callback)
+            (*destroy_callback)(m->values[idx]);
+        m->values[idx] = val;
+    }
+    else
+        imap_add_not_exist(m, key, val);
+}
+
+void imap_add_not_exist(imap *m, int key, void *val)
+{
+    m->keys = realloc(m->keys, sizeof(int)*(m->size+1));
+    m->keys[m->size++] = key;
+
+    list_add(&m->values, val);
+}
+
+void imap_rm(imap *m, int key, void (*destroy_callback)(void*))
+{
+    size_t i;
+    int idx = imap_find(m, key);
+    if(idx < 0)
+        return;
+
+    for(i = idx; i < m->size-1; ++i)
+        m->keys[i] = m->keys[i+1];
+
+    --m->size;
+    m->keys = realloc(m->keys, sizeof(int)*m->size);
+    list_rm_at(&m->values, idx, destroy_callback);
+}
+
+int imap_find(imap *m, int key)
+{
+    size_t i;
+    for(i = 0; i < m->size; ++i)
+        if(key == m->keys[i])
+            return i;
+    return -1;
+}
+
+void *imap_get_val(imap *m, int key)
+{
+    int idx = imap_find(m, key);
+    if(idx < 0)
+        return NULL;
+    return m->values[idx];
+}
+
+void *imap_get_ref(imap *m, int key)
+{
+    int idx = imap_find(m, key);
+    if(idx < 0)
+        return NULL;
+    return &m->values[idx];
+}
+
diff --git a/lib/containers.h b/lib/containers.h
index 2aef886..7764826 100755
--- a/lib/containers.h
+++ b/lib/containers.h
@@ -1,73 +1,73 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef CONTAINERS_H
-#define CONTAINERS_H
-
-// auto-conversion of pointer type occurs only for
-// void*, not for void** nor void***
-typedef void* ptrToList; // void ***
-typedef void* listItself; // void **
-typedef void* callback;
-typedef void(*callbackPtr)(void*);
-
-void list_add(ptrToList list_p, void *item);
-void list_add_at(ptrToList list_p, int idx, void *item);
-int list_add_from_list(ptrToList list_p, listItself src_p);
-int list_rm(ptrToList list_p, void *item, callback destroy_callback_p);
-int list_rm_noreorder(ptrToList list_p, void *item, callback destroy_callback_p);
-int list_rm_opt(ptrToList list_p, void *item, callback destroy_callback_p, int reorder);
-listItself list_rm_at(ptrToList list_p, int idx, callback destroy_callback_p); // returns pointer to the next item in list or NULL
-int list_size(listItself list);
-int list_item_count(listItself list);
-int list_copy(ptrToList dest_p, listItself src);
-int list_move(ptrToList dest_p, ptrToList source_p);
-void list_clear(ptrToList list_p, callback destroy_callback_p);
-void list_swap(ptrToList a_p, ptrToList b_p);
-
-typedef struct
-{
-    char **keys;
-    void **values;
-    size_t size;
-} map;
-
-map *map_create(void);
-void map_destroy(map *m, void (*destroy_callback)(void*));
-void map_add(map *m, const char *key, void *val, void (*destroy_callback)(void*));
-void map_add_not_exist(map *m, const char *key, void *val);
-void map_rm(map *m, const char *key, void (*destroy_callback)(void*));
-int map_find(map *m, const char *key);
-void *map_get_val(map *m, const char *key);
-void *map_get_ref(map *m, const char *key);
-
-typedef struct
-{
-    int *keys;
-    void **values;
-    size_t size;
-} imap;
-
-imap *imap_create(void);
-void imap_destroy(imap *m, void (*destroy_callback)(void*));
-void imap_add(imap *m, int key, void *val, void (*destroy_callback)(void*));
-void imap_add_not_exist(imap *m, int key, void *val);
-void imap_rm(imap *m, int key, void (*destroy_callback)(void*));
-int imap_find(imap *m, int key);
-void *imap_get_val(imap *m, int key);
-void *imap_get_ref(imap *m, int key);
-
-#endif
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONTAINERS_H
+#define CONTAINERS_H
+
+// auto-conversion of pointer type occurs only for
+// void*, not for void** nor void***
+typedef void* ptrToList; // void ***
+typedef void* listItself; // void **
+typedef void* callback;
+typedef void(*callbackPtr)(void*);
+
+void list_add(ptrToList list_p, void *item);
+void list_add_at(ptrToList list_p, int idx, void *item);
+int list_add_from_list(ptrToList list_p, listItself src_p);
+int list_rm(ptrToList list_p, void *item, callback destroy_callback_p);
+int list_rm_noreorder(ptrToList list_p, void *item, callback destroy_callback_p);
+int list_rm_opt(ptrToList list_p, void *item, callback destroy_callback_p, int reorder);
+listItself list_rm_at(ptrToList list_p, int idx, callback destroy_callback_p); // returns pointer to the next item in list or NULL
+int list_size(listItself list);
+int list_item_count(listItself list);
+int list_copy(ptrToList dest_p, listItself src);
+int list_move(ptrToList dest_p, ptrToList source_p);
+void list_clear(ptrToList list_p, callback destroy_callback_p);
+void list_swap(ptrToList a_p, ptrToList b_p);
+
+typedef struct
+{
+    char **keys;
+    void **values;
+    size_t size;
+} map;
+
+map *map_create(void);
+void map_destroy(map *m, void (*destroy_callback)(void*));
+void map_add(map *m, const char *key, void *val, void (*destroy_callback)(void*));
+void map_add_not_exist(map *m, const char *key, void *val);
+void map_rm(map *m, const char *key, void (*destroy_callback)(void*));
+int map_find(map *m, const char *key);
+void *map_get_val(map *m, const char *key);
+void *map_get_ref(map *m, const char *key);
+
+typedef struct
+{
+    int *keys;
+    void **values;
+    size_t size;
+} imap;
+
+imap *imap_create(void);
+void imap_destroy(imap *m, void (*destroy_callback)(void*));
+void imap_add(imap *m, int key, void *val, void (*destroy_callback)(void*));
+void imap_add_not_exist(imap *m, int key, void *val);
+void imap_rm(imap *m, int key, void (*destroy_callback)(void*));
+int imap_find(imap *m, int key);
+void *imap_get_val(imap *m, int key);
+void *imap_get_ref(imap *m, int key);
+
+#endif
diff --git a/lib/framebuffer.c b/lib/framebuffer.c
index 67db3a9..f51223a 100755
--- a/lib/framebuffer.c
+++ b/lib/framebuffer.c
@@ -1,1198 +1,1198 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <string.h>
-#include <signal.h>
-#include <assert.h>
-#include <linux/fb.h>
-#include <linux/kd.h>
-#include <cutils/memory.h>
-#include <pthread.h>
-#include <png.h>
-#include <math.h>
-
-#include <string.h>
-#include <malloc.h>
-
-#include "log.h"
-#include "framebuffer.h"
-#include "util.h"
-#include "containers.h"
-#include "animation.h"
-#include "listview.h"
-#include "atomics.h"
-#include "mrom_data.h"
-
-#if PIXEL_SIZE == 4
-#define fb_memset(dst, what, len) android_memset32(dst, what, len)
-#else
-#define fb_memset(dst, what, len) android_memset16(dst, what, len)
-#endif
-
-
-uint32_t fb_width = 0;
-uint32_t fb_height = 0;
-int fb_rotation = 0; // in degrees, clockwise
-
-fb_item_pos DEFAULT_FB_PARENT = {
-    .x = 0,
-    .y = 0,
-};
-
-static struct framebuffer fb;
-static int fb_frozen = 0;
-static int fb_force_generic = 0;
-
-static fb_context_t fb_ctx = {
-    .first_item = NULL,
-    .batch_started = 0,
-    .background_color = BLACK,
-    .mutex = PTHREAD_MUTEX_INITIALIZER
-};
-
-static fb_context_t **inactive_ctx = NULL;
-static uint8_t **fb_rot_helpers = NULL;
-static pthread_t fb_draw_thread;
-static pthread_mutex_t fb_update_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t fb_draw_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t fb_draw_cond = PTHREAD_COND_INITIALIZER;
-static atomic_int fb_draw_requested = ATOMIC_VAR_INIT(0);
-static volatile int fb_draw_run = 0;
-static void *fb_draw_thread_work(void*);
-
-static void fb_destroy_item(void *item); // private!
-static inline void fb_cpy_fb_with_rotation(px_type *dst, px_type *src);
-static inline void fb_rotate_90deg(px_type *dst, px_type *src);
-static inline void fb_rotate_270deg(px_type *dst, px_type *src);
-static inline void fb_rotate_180deg(px_type *dst, px_type *src);
-
-int fb_open_impl(void)
-{
-    struct fb_impl **itr;
-    struct fb_impl *impls[FB_IMPL_CNT];
-
-#define ADD_IMPL(ID, N) \
-    extern struct fb_impl fb_impl_ ## N; \
-    impls[ID] = &fb_impl_ ## N;
-
-    ADD_IMPL(FB_IMPL_GENERIC, generic);
-#ifdef MR_USE_QCOM_OVERLAY
-    ADD_IMPL(FB_IMPL_QCOM_OVERLAY, qcom_overlay);
-#endif
-
-    if(fb_force_generic)
-        itr = &impls[FB_IMPL_GENERIC];
-    else
-        itr = impls;
-
-    for(; *itr; ++itr)
-    {
-        if((*itr)->open(&fb) >= 0)
-        {
-            INFO("Framebuffer implementation: %s\n", (*itr)->name);
-            fb.impl = *itr;
-            return 0;
-        }
-    }
-
-    ERROR("All framebuffer implementations have failed to open!\n");
-    return -1;
-}
-
-int fb_open(int rotation)
-{
-    memset(&fb, 0, sizeof(struct framebuffer));
-
-    fb.fd = open("/dev/graphics/fb0", O_RDWR | O_CLOEXEC);
-    if (fb.fd < 0)
-        return -1;
-
-    if(ioctl(fb.fd, FBIOGET_VSCREENINFO, &fb.vi) < 0)
-        goto fail;
-
-    if(ioctl(fb.fd, FBIOGET_FSCREENINFO, &fb.fi) < 0)
-        goto fail;
-
-    /*
-     * No FBIOPUT_VSCREENINFO ioctl must be called here. Flo's display drivers
-     * contain a hack to set backlight while in recovery, which is triggered by
-     * this ioctl (and probably other things). The hack turns *something* on
-     * and it causes insane battery drain while in android (it eats at least
-     * five times more energy). The device enters deep sleep just fine, the dmesg
-     * says it was suspended, but it drains more energy. Qualcomm ION overlay
-     * framebuffer implementation works around this hack, because it doesn't
-     * require that ioctl (but we can't set pixel format without it, must use
-     * framebuffer's default format in "TARGET_RECOVERY_PIXEL_FORMAT" config
-     * value). This bug does not manifest when MultiROM isn't installed,
-     * because nothing sets FBIOPUT_VSCREENINFO during Android's boot,
-     * and well, you're not really supposed to stay long in recovery nor does
-     * it have "suspend" state.
-     *
-     * This ioctl call was moved to framebuffer_generic implementation.
-     */
-
-    if(fb_open_impl() < 0)
-        goto fail;
-
-    fb_frozen = 0;
-    fb_rotation = rotation;
-
-    if(fb_rotation%180 == 0)
-    {
-        fb_width = fb.vi.xres;
-        fb_height = fb.vi.yres;
-    }
-    else
-    {
-        fb_width = fb.vi.yres;
-        fb_height = fb.vi.xres;
-    }
-
-#ifdef RECOVERY_GRAPHICS_USE_LINELENGTH
-    fb.vi.xres_virtual = fb.fi.line_length / PIXEL_SIZE;
-#endif
-
-    fb.stride = (fb_rotation%180 == 0) ? fb.vi.xres_virtual : fb.vi.yres;
-    fb.size = fb.vi.xres_virtual*fb.vi.yres*PIXEL_SIZE;
-    fb.buffer = malloc(fb.size);
-    fb_memset(fb.buffer, fb_convert_color(BLACK), fb.size);
-
-#if 0
-    fb_dump_info();
-#endif
-
-    DEFAULT_FB_PARENT.w = fb_width;
-    DEFAULT_FB_PARENT.h = fb_height;
-
-    fb_set_brightness(MULTIROM_DEFAULT_BRIGHTNESS);
-
-    fb_update();
-
-    fb_draw_run = 1;
-    pthread_create(&fb_draw_thread, NULL, fb_draw_thread_work, NULL);
-    return 0;
-
-fail:
-    close(fb.fd);
-    return -1;
-}
-
-void fb_close(void)
-{
-    fb_draw_run = 0;
-    pthread_join(fb_draw_thread, NULL);
-
-    free(fb_rot_helpers);
-    fb_rot_helpers = NULL;
-
-    fb.impl->close(&fb);
-    fb.impl = NULL;
-
-    close(fb.fd);
-    free(fb.buffer);
-    fb.buffer = NULL;
-}
-
-void fb_dump_info(void)
-{
-    ERROR("Framebuffer:\n");
-    ERROR("fi.smem_len: %u\n", fb.fi.smem_len);
-    ERROR("fi.type: %u\n", fb.fi.type);
-    ERROR("fi.type_aux: %u\n", fb.fi.type_aux);
-    ERROR("fi.visual: %u\n", fb.fi.visual);
-    ERROR("fi.xpanstep: %u\n", fb.fi.xpanstep);
-    ERROR("fi.ypanstep: %u\n", fb.fi.ypanstep);
-    ERROR("fi.ywrapstep: %u\n", fb.fi.ywrapstep);
-    ERROR("fi.line_length: %u\n", fb.fi.line_length);
-    ERROR("fi.mmio_start: %p\n", (void*)fb.fi.mmio_start);
-    ERROR("fi.mmio_len: %u\n", fb.fi.mmio_len);
-    ERROR("fi.accel: %u\n", fb.fi.accel);
-    ERROR("vi.xres: %u\n", fb.vi.xres);
-    ERROR("vi.yres: %u\n", fb.vi.yres);
-    ERROR("vi.xres_virtual: %u\n", fb.vi.xres_virtual);
-    ERROR("vi.yres_virtual: %u\n", fb.vi.yres_virtual);
-    ERROR("vi.xoffset: %u\n", fb.vi.xoffset);
-    ERROR("vi.yoffset: %u\n", fb.vi.yoffset);
-    ERROR("vi.bits_per_pixel: %u\n", fb.vi.bits_per_pixel);
-    ERROR("vi.grayscale: %u\n", fb.vi.grayscale);
-    ERROR("vi.red: offset: %u len: %u msb_right: %u\n", fb.vi.red.offset, fb.vi.red.length, fb.vi.red.msb_right);
-    ERROR("vi.green: offset: %u len: %u msb_right: %u\n", fb.vi.green.offset, fb.vi.green.length, fb.vi.green.msb_right);
-    ERROR("vi.blue: offset: %u len: %u msb_right: %u\n", fb.vi.blue.offset, fb.vi.blue.length, fb.vi.blue.msb_right);
-    ERROR("vi.transp: offset: %u len: %u msb_right: %u\n", fb.vi.transp.offset, fb.vi.transp.length, fb.vi.transp.msb_right);
-    ERROR("vi.nonstd: %u\n", fb.vi.nonstd);
-    ERROR("vi.activate: %u\n", fb.vi.activate);
-    ERROR("vi.height: %u\n", fb.vi.height);
-    ERROR("vi.width: %u\n", fb.vi.width);
-    ERROR("vi.accel_flags: %u\n", fb.vi.accel_flags);
-}
-
-void fb_set_brightness(int val)
-{
-#ifdef TW_BRIGHTNESS_PATH
-    FILE *f = fopen(TW_BRIGHTNESS_PATH, "we");
-    if(!f)
-    {
-        ERROR("Failed to set brightness: %s!\n", strerror(errno));
-        return;
-    }
-    fprintf(f, "%d", val);
-    fclose(f);
-#endif
-}
-
-int fb_get_vi_xres(void)
-{
-    return fb.vi.xres;
-}
-
-int fb_get_vi_yres(void)
-{
-    return fb.vi.yres;
-}
-
-void fb_force_generic_impl(int force)
-{
-    fb_force_generic = force;
-}
-
-void fb_update(void)
-{
-    fb_cpy_fb_with_rotation(fb.impl->get_frame_dest(&fb), fb.buffer);
-    fb.impl->update(&fb);
-}
-
-void fb_cpy_fb_with_rotation(px_type *dst, px_type *src)
-{
-    switch(fb_rotation)
-    {
-        case 0:
-            memcpy(dst, src, fb.vi.xres_virtual * fb.vi.yres * PIXEL_SIZE);
-            break;
-        case 90:
-            fb_rotate_90deg(dst, src);
-            break;
-        case 180:
-            fb_rotate_180deg(dst, src);
-            break;
-        case 270:
-            fb_rotate_270deg(dst, src);
-            break;
-    }
-}
-
-void fb_rotate_90deg(px_type *dst, px_type *src)
-{
-    uint32_t i;
-    int32_t x;
-
-    if(!fb_rot_helpers)
-        fb_rot_helpers = malloc(fb_height*sizeof(px_type*));
-
-    px_type **helpers = (px_type**)fb_rot_helpers;
-
-    helpers[0] = src;
-    for(i = 1; i < fb_height; ++i)
-        helpers[i] = helpers[i-1] + fb.stride;
-
-    const int padding = fb.vi.xres_virtual - fb.vi.xres;
-    for(i = 0; i < fb_width; ++i)
-    {
-        for(x = fb_height-1; x >= 0; --x)
-            *dst++ = *(helpers[x]++);
-        dst += padding;
-    }
-}
-
-void fb_rotate_270deg(px_type *dst, px_type *src)
-{
-    if(!fb_rot_helpers)
-        fb_rot_helpers = malloc(fb_height*sizeof(px_type*));
-
-    uint32_t i, x;
-    px_type **helpers = (px_type**)fb_rot_helpers;
-
-    helpers[0] = src + fb_width-1;
-    for(i = 1; i < fb_height; ++i)
-        helpers[i] = helpers[i-1] + fb.stride;
-
-    const int padding = fb.vi.xres_virtual - fb.vi.xres;
-    for(i = 0; i < fb_width; ++i)
-    {
-        for(x = 0; x < fb_height; ++x)
-            *dst++ = *(helpers[x]--);
-        dst += padding;
-    }
-}
-
-void fb_rotate_180deg(px_type *dst, px_type *src)
-{
-    uint32_t i, x;
-    int len = fb.vi.xres_virtual * fb.vi.yres;
-    src += len;
-
-    const int padding = fb.vi.xres_virtual - fb.vi.xres;
-    for(i = 0; i < fb_height; ++i)
-    {
-        src -= padding;
-        for(x = 0; x < fb_width; ++x)
-            *dst++ = *(--src);
-        dst += padding;
-    }
-}
-
-int fb_clone(char **buff)
-{
-    int len = fb.size;
-    *buff = malloc(len);
-
-    pthread_mutex_lock(&fb_update_mutex);
-    memcpy(*buff, fb.buffer, len);
-    pthread_mutex_unlock(&fb_update_mutex);
-
-    return len;
-}
-
-void fb_fill(uint32_t color)
-{
-    fb_memset(fb.buffer, fb_convert_color(color), fb.size);
-}
-
-px_type fb_convert_color(uint32_t c)
-{
-#ifdef RECOVERY_BGRA
-    return c;
-#elif defined(RECOVERY_RGBX)
-    return (c & 0xFF000000) | ((c & 0xFF) << 16) | (c & 0xFF00) | ((c & 0xFF0000) >> 16);
-#elif defined(RECOVERY_ABGR)
-    //             A              B                   G                  R
-    return (c & 0xFF000000) | ((c & 0xFF) << 16) | (c & 0xFF00) | ((c & 0xFF0000) >> 16);
-#elif defined(RECOVERY_RGB_565)
-    const uint8_t alpha_pct = (((c >> 24) & 0xFF)*100) / 0xFF;
-    //            R                                G                              B
-    return (((c & 0xFF0000) >> 19) << 11) | (((c & 0xFF00) >> 10) << 5) | ((c & 0xFF) >> 3);
-#else
-#error "Unknown pixel format"
-#endif
-}
-
-uint32_t fb_convert_color_img(uint32_t clr)
-{
-    uint32_t c = fb_convert_color(clr);
-#if PIXEL_SIZE == 2
-    const uint8_t alpha_pct = (((clr >> 24) & 0xFF)*100) / 0xFF;
-    //      Alpha - RB                    Alpha - G
-    c |= (((alpha_pct*31)/100) << 16) | (((alpha_pct*63)/100) << 24);
-#endif
-    return c;
-}
-
-void fb_set_background(uint32_t color)
-{
-    fb_ctx.background_color = color;
-}
-
-void fb_batch_start(void)
-{
-    pthread_mutex_lock(&fb_ctx.mutex);
-    fb_ctx.batch_thread = pthread_self();
-    fb_ctx.batch_started = 1;
-}
-
-void fb_batch_end(void)
-{
-    fb_ctx.batch_started = 0;
-    pthread_mutex_unlock(&fb_ctx.mutex);
-}
-
-void fb_items_lock(void)
-{
-    if(!fb_ctx.batch_started || !pthread_equal(fb_ctx.batch_thread, pthread_self()))
-        pthread_mutex_lock(&fb_ctx.mutex);
-}
-
-void fb_items_unlock(void)
-{
-    if(!fb_ctx.batch_started || !pthread_equal(fb_ctx.batch_thread, pthread_self()))
-        pthread_mutex_unlock(&fb_ctx.mutex);
-}
-
-static void fb_ctx_put_it_before(fb_item_header *new_it, fb_item_header *next_it)
-{
-    if(next_it->prev)
-    {
-        next_it->prev->next = new_it;
-        new_it->prev = next_it->prev;
-    }
-    new_it->next = next_it;
-    next_it->prev = new_it;
-}
-
-static void fb_ctx_put_it_after(fb_item_header *new_it, fb_item_header *prev_it)
-{
-    if(prev_it->next)
-    {
-        prev_it->next->prev = new_it;
-        new_it->next = prev_it->next;
-    }
-    new_it->prev = prev_it;
-    prev_it->next = new_it;
-}
-
-void fb_ctx_add_item(void *item)
-{
-    fb_item_header *h = item;
-
-    fb_items_lock();
-
-    if(!fb_ctx.first_item)
-        fb_ctx.first_item = item;
-    else
-    {
-        fb_item_header *itr = fb_ctx.first_item;
-        while(1)
-        {
-            if(itr->level > h->level)
-            {
-                if(itr == fb_ctx.first_item)
-                    fb_ctx.first_item = h;
-                fb_ctx_put_it_before(h, itr);
-                itr = NULL;
-                break;
-            }
-
-            if(itr->next)
-                itr = itr->next;
-            else
-                break;
-        }
-
-        if(itr)
-            fb_ctx_put_it_after(h, itr);
-    }
-
-    fb_items_unlock();
-}
-
-void fb_ctx_rm_item(void *item)
-{
-    fb_item_header *h = item;
-
-    fb_items_lock();
-
-    if(!h->prev)
-        fb_ctx.first_item = h->next;
-    else
-        h->prev->next = h->next;
-
-    if(h->next)
-        h->next->prev = h->prev;
-
-    fb_items_unlock();
-}
-
-void fb_remove_item(void *item)
-{
-    switch(((fb_item_header*)item)->type)
-    {
-        case FB_IT_RECT:
-            fb_rm_rect((fb_rect*)item);
-            break;
-        case FB_IT_IMG:
-            fb_rm_img((fb_img*)item);
-            break;
-        case FB_IT_LISTVIEW:
-            listview_destroy((listview*)item);
-            break;
-        case FB_IT_LINE:
-            fb_rm_line((fb_line*)item);
-            break;
-    }
-}
-
-void fb_destroy_item(void *item)
-{
-    anim_cancel_for(item, 0);
-
-    switch(((fb_item_header*)item)->type)
-    {
-        case FB_IT_RECT:
-        case FB_IT_LINE:
-            break;
-        case FB_IT_IMG:
-        {
-            fb_img *i = (fb_img*)item;
-            switch(i->img_type)
-            {
-                case FB_IMG_TYPE_PNG:
-                    fb_png_release(i->data);
-                    break;
-                case FB_IMG_TYPE_GENERIC:
-                    free(i->data);
-                    break;
-                case FB_IMG_TYPE_TEXT:
-                    fb_text_destroy(i);
-                    break;
-                default:
-                    ERROR("fb_destroy_item(): unknown fb_img type %d\n", i->img_type);
-                    assert(0);
-                    break;
-            }
-            break;
-        }
-    }
-    free(item);
-}
-
-static inline void clamp_to_parent(void *it, int *min_x, int *max_x, int *min_y, int *max_y)
-{
-    fb_item_header *h = it;
-
-    int parent_x = h->parent->x;
-    int parent_y = h->parent->y;
-    int parent_w = h->parent->w;
-    int parent_h = h->parent->h;
-
-    if(h->parent != &DEFAULT_FB_PARENT)
-    {
-        if(parent_x < 0)
-        {
-            parent_w += parent_x;
-            parent_x = 0;
-        }
-        if(parent_y < 0)
-        {
-            parent_h += parent_y;
-            parent_y = 0;
-        }
-        parent_w = imin(parent_x + parent_w, fb_width) - parent_x;
-        parent_h = imin(parent_y + parent_h, fb_height) - parent_y;
-    }
-
-    *min_x = h->x >= parent_x ? 0 : parent_x - h->x;
-    *min_y = h->y >= parent_y ? 0 : parent_y - h->y;
-    *max_x = imin(h->w, parent_x + parent_w - h->x);
-    *max_y = imin(h->h, parent_y + parent_h - h->y);
-}
-
-void fb_draw_rect(fb_rect *r)
-{
-    const uint8_t alpha = (r->color >> 24) & 0xFF;
-    const uint8_t inv_alpha = 0xFF - ((r->color >> 24) & 0xFF);
-    const px_type color = fb_convert_color(r->color);
-
-    if(alpha == 0)
-        return;
-
-#if defined(RECOVERY_RGBX) || defined(RECOVERY_ABGR)
-    const uint32_t premult_color_rb = ((color & 0xFF00FF) * (alpha)) >> 8;
-    const uint32_t premult_color_g = ((color & 0x00FF00) * (alpha)) >> 8;
-#elif defined(RECOVERY_BGRA)
-    const uint32_t premult_color_rb = (((color >> 8) & 0xFF00FF) * (alpha)) >> 8;
-    const uint32_t premult_color_g = (((color >> 8) & 0x00FF00) * (alpha)) >> 8;
-#elif defined(RECOVERY_RGB_565)
-    const uint8_t alpha5b = (alpha >> 3) + 1;
-    const uint8_t alpha6b = (alpha >> 2) + 1;
-    const uint8_t inv_alpha5b = 32 - alpha5b;
-    const uint8_t inv_alpha6b = 64 - alpha6b;
-    const uint16_t premult_color_rb = ((color & 0xF81F) * alpha5b) >> 5;
-    const uint16_t premult_color_g = ((color & 0x7E0) * alpha6b) >> 6;
-#endif
-
-    int min_x, max_x, min_y, max_y;
-    clamp_to_parent(r, &min_x, &max_x, &min_y, &max_y);
-    const int rendered_w = max_x - min_x;
-
-    if(rendered_w <= 0)
-        return;
-
-    const int w = rendered_w*PIXEL_SIZE;
-
-    px_type *bits = fb.buffer + (fb.stride*(r->y + min_y)) + r->x + min_x;
-
-    int i, x;
-    uint8_t *comps_bits;
-    const uint8_t *comps_clr = (uint8_t*)&color;
-    for(i = min_y; i < max_y; ++i)
-    {
-        if(alpha == 0xFF)
-        {
-            fb_memset(bits, color, w);
-            bits += fb.stride;
-        }
-        // Do the blending
-        else
-        {
-#ifdef MR_DISABLE_ALPHA
-            fb_memset(bits, color, w);
-            bits += fb.stride;
-#else
-            for(x = 0; x < rendered_w; ++x)
-            {
-  #ifdef RECOVERY_RGBX || defined(RECOVERY_ABGR)
-                const uint32_t rb = (premult_color_rb & 0xFF00FF) + ((inv_alpha * (*bits & 0xFF00FF)) >> 8);
-                const uint32_t g = (premult_color_g & 0x00FF00) + ((inv_alpha * (*bits & 0x00FF00)) >> 8);
-                *bits = 0xFF000000 | (rb & 0xFF00FF) | (g & 0x00FF00);
-  #elif defined(RECOVERY_BGRA)
-                const uint32_t rb = (premult_color_rb & 0xFF00FF) + ((inv_alpha * ((*bits >> 8) & 0xFF00FF)) >> 8);
-                const uint32_t g = (premult_color_g & 0x00FF00) + ((inv_alpha * ((*bits >> 8) & 0x00FF00)) >> 8);
-                *bits = 0xFF000000 | (rb & 0xFF00FF) | (g & 0x00FF00);
-  #elif defined(RECOVERY_RGB_565)
-                const uint16_t rb = (premult_color_rb & 0xF81F) + ((inv_alpha5b * (*bits & 0xF81F)) >> 5);
-                const uint16_t g = (premult_color_g & 0x7E0) + ((inv_alpha6b * (*bits & 0x7E0)) >> 6);
-                *bits = (rb & 0xF81F) | (g & 0x7E0);
-  #else
-    #error "No alpha blending implementation for this format!"
-  #endif
-                ++bits;
-            }
-            bits += fb.stride - rendered_w;
-#endif // MR_DISABLE_ALPHA
-        }
-    }
-}
-
-static inline int blend_png(int value1, int value2, int alpha) {
-    int r = (0xFF-alpha)*value1 + alpha*value2;
-    return (r+1 + (r >> 8)) >> 8; // divide by 255
-}
-
-void fb_draw_img(fb_img *i)
-{
-    int y, x;
-    const int w = i->w*PIXEL_SIZE;
-    uint8_t alpha;
-    uint8_t *comps_img, *comps_bits;
-
-#if PIXEL_SIZE == 4
-    const uint8_t max_alpha = 0xFF;
-#elif PIXEL_SIZE == 2
-    const uint8_t max_alpha = 31;
-#endif
-
-    int min_x, max_x, min_y, max_y;
-    clamp_to_parent(i, &min_x, &max_x, &min_y, &max_y);
-    const int rendered_w = max_x - min_x;
-
-    if(rendered_w <= 0)
-        return;
-
-    px_type *bits = fb.buffer + (fb.stride*(i->y + min_y)) + i->x + min_x;
-    px_type *img = (px_type*)(((uint32_t*)i->data) + (min_y * i->w) + min_x);
-
-    for(y = min_y; y < max_y; ++y)
-    {
-        for(x = min_x; x < max_x; ++x)
-        {
-            // Colors, 0xAABBGGRR
-#if PIXEL_SIZE == 4
-            alpha = PX_GET_A(*img);
-#elif PIXEL_SIZE == 2
-            alpha = ((uint8_t*)img)[2];
-#endif
-            // fully opaque
-            if(alpha == max_alpha)
-            {
-                *bits = *img;
-            }
-            // do the blending
-            else if(alpha != 0x00)
-            {
-#ifdef MR_DISABLE_ALPHA
-                *bits = *img;
-#else
-  #if PIXEL_SIZE == 4
-                comps_bits = (uint8_t*)bits;
-                comps_img = (uint8_t*)img;
-                comps_bits[PX_IDX_R] = blend_png(comps_bits[PX_IDX_R], comps_img[PX_IDX_R], comps_img[PX_IDX_A]);
-                comps_bits[PX_IDX_G] = blend_png(comps_bits[PX_IDX_G], comps_img[PX_IDX_G], comps_img[PX_IDX_A]);
-                comps_bits[PX_IDX_B] = blend_png(comps_bits[PX_IDX_B], comps_img[PX_IDX_B], comps_img[PX_IDX_A]);
-                comps_bits[PX_IDX_A] = 0xFF;
-  #else
-                const uint8_t alpha5b = alpha;
-                const uint8_t alpha6b = ((uint8_t*)img)[3];
-                *bits = (((31-alpha5b)*(*bits & 0x1F)            + (alpha5b*(*img & 0x1F))) / 31) |
-                        ((((63-alpha6b)*((*bits & 0x7E0) >> 5)   + (alpha6b*((*img & 0x7E0) >> 5))) / 63) << 5) |
-                        ((((31-alpha5b)*((*bits & 0xF800) >> 11) + (alpha5b*((*img & 0xF800) >> 11))) / 31) << 11);
-  #endif // PIXEL_SIZE
-#endif // MR_DISABLE_ALPHA
-            }
-
-            ++bits;
-#if PIXEL_SIZE == 4
-            ++img;
-#elif PIXEL_SIZE == 2
-            img += 2;
-#endif
-        }
-        bits += fb.stride - rendered_w;
-        img = (px_type*)(((uint32_t*)img) + (i->w - rendered_w));
-    }
-}
-
-// from http://members.chello.at/~easyfilter/bresenham.html
-void fb_draw_line(fb_line *l)
-{
-    const px_type px = fb_convert_color(l->color);
-
-    int x0 = imin(imax(l->x, l->parent->x), l->parent->x + l->parent->w);
-    int x1 = imin(imax(l->x2, l->parent->x), l->parent->x + l->parent->w);
-    int y0 = imin(imax(l->y, l->parent->y), l->parent->y + l->parent->h);
-    int y1 = imin(imax(l->y2, l->parent->y), l->parent->y + l->parent->h);
-
-    int dx = abs(x1-x0);
-    int dy = abs(y1-y0);
-    const int sx = x0 < x1 ? 1 : -1;
-    const int sy = y0 < y1 ? 1 : -1;
-
-    int err;
-    double e2 = sqrt((double)(dx*dx) + (double)(dy*dy));
-
-    if(e2 == 0.0)
-        return;
-
-    dx *= 255/e2;
-    dy *= 255/e2;
-    double th = 255*((double)(l->thickness - 1));
-
-    if(dx < dy)
-    {
-        x1 = (e2+th/2) / dy;
-        err = x1*dy - th/2;
-        for(x0 -= x1*sx; ; y0 += sy)
-        {
-            x1 = x0;
-            for(e2 = dy-err-th; e2+dy < 255; e2 += dy)
-            {
-                x1 += sx;
-                *(fb.buffer + fb.stride*y0 + x1) = px;
-            }
-            if(y0 == y1)
-                break;
-            err += dx;
-            if(err > 255)
-            {
-                err -= dy;
-                x0 += sx;
-            }
-        }
-    }
-    else
-    {
-        y1 = (e2 + th/2) / dx;
-        err = y1*dx - th/2;
-        for(y0 -= y1*sy; ; x0 += sx)
-        {
-            y1 = y0;
-            for(e2 = dx - err - th; e2+dx < 255; e2 += dx)
-            {
-                y1 += sy;
-                *(fb.buffer + fb.stride*y1 + x0) = px;
-            }
-
-            if(x0 == x1)
-                break;
-            err += dy;
-            if(err > 255)
-            {
-                err -= dx;
-                y0 += sy;
-            }
-        }
-    }
-}
-
-int fb_generate_item_id(void)
-{
-    fb_items_lock();
-    static int id = 0;
-    int res = id++;
-    fb_items_unlock();
-
-    return res;
-}
-
-fb_rect *fb_add_rect_lvl(int level, int x, int y, int w, int h, uint32_t color)
-{
-    fb_rect *r = mzalloc(sizeof(fb_rect));
-    r->id = fb_generate_item_id();
-    r->type = FB_IT_RECT;
-    r->parent = &DEFAULT_FB_PARENT;
-    r->level = level;
-
-    r->x = x;
-    r->y = y;
-
-    r->w = w;
-    r->h = h;
-    r->color = color;
-
-    fb_ctx_add_item(r);
-    return r;
-}
-
-void fb_add_rect_notfilled(int level, int x, int y, int w, int h, uint32_t color, int thickness, fb_rect ***list)
-{
-    fb_rect *r;
-    // top
-    r = fb_add_rect_lvl(level, x, y, w, thickness, color);
-    list_add(list, r);
-
-    // right
-    r = fb_add_rect_lvl(level, x + w - thickness, y, thickness, h, color);
-    list_add(list, r);
-
-    // bottom
-    r = fb_add_rect_lvl(level, x, y + h - thickness, w, thickness, color);
-    list_add(list, r);
-
-    // left
-    r = fb_add_rect_lvl(level, x, y, thickness, h, color);
-    list_add(list, r);
-}
-
-fb_img *fb_add_img(int level, int x, int y, int w, int h, int img_type, px_type *data)
-{
-    fb_img *result = mzalloc(sizeof(fb_img));
-    result->id = fb_generate_item_id();
-    result->type = FB_IT_IMG;
-    result->parent = &DEFAULT_FB_PARENT;
-    result->level = level;
-    result->x = x;
-    result->y = y;
-    result->img_type = img_type;
-    result->data = data;
-    result->w = w;
-    result->h = h;
-
-    fb_ctx_add_item(result);
-    return result;
-}
-
-fb_img* fb_add_png_img_lvl(int level, int x, int y, int w, int h, const char *path)
-{
-    px_type *data = NULL;
-    if(strncmp(path, ":/", 2) == 0)
-    {
-        const int full_path_len = strlen(path) + strlen(mrom_dir()) + 4;
-        char *full_path = malloc(full_path_len);
-        snprintf(full_path, full_path_len, "%s/res%s", mrom_dir(), path+1);
-        data = fb_png_get(full_path, w, h);
-        free(full_path);
-    }
-    else
-        data = fb_png_get(path, w, h);
-    if(!data)
-        return NULL;
-
-    return fb_add_img(level, x, y, w, h, FB_IMG_TYPE_PNG, data);
-}
-
-fb_circle *fb_add_circle_lvl(int level, int x, int y, int radius, uint32_t color)
-{
-    const int diameter = radius*2 + 1;
-    uint32_t *data = mzalloc(diameter * diameter * 4);
-    uint32_t px = fb_convert_color_img(color);
-
-    int rx, ry;
-    const int radius_check = radius*radius + radius*0.8;
-
-    for(ry = -radius; ry <= radius; ++ry)
-        for(rx = -radius; rx <= radius; ++rx)
-            if(rx*rx+ry*ry <= radius_check)
-                *(data + diameter*(radius + ry) + (radius+rx)) = px;
-
-    return fb_add_img(level, x, y, diameter, diameter, FB_IMG_TYPE_GENERIC, data);
-}
-
-fb_line *fb_add_line_lvl(int level, int x1, int y1, int x2, int y2, int thickness, uint32_t color)
-{
-    fb_line *res = mzalloc(sizeof(fb_line));
-    res->id = fb_generate_item_id();
-    res->type = FB_IT_LINE;
-    res->parent = &DEFAULT_FB_PARENT;
-    res->level = level;
-    res->x = x1;
-    res->y = y1;
-    res->x2 = x2;
-    res->y2 = y2;
-    res->thickness = thickness;
-    res->color = color;
-    fb_ctx_add_item(res);
-    return res;
-}
-
-void fb_rm_rect(fb_rect *r)
-{
-    if(!r)
-        return;
-
-    fb_ctx_rm_item(r);
-    fb_destroy_item(r);
-}
-
-void fb_rm_text(fb_img *i)
-{
-    fb_rm_img(i);
-}
-
-void fb_rm_img(fb_img *i)
-{
-    if(!i)
-        return;
-
-    fb_ctx_rm_item(i);
-    fb_destroy_item(i);
-}
-
-void fb_rm_circle(fb_circle *c)
-{
-    fb_rm_img(c);
-}
-
-void fb_rm_line(fb_line *l)
-{
-    if(!l)
-        return;
-
-    fb_ctx_rm_item(l);
-    fb_destroy_item(l);
-}
-
-void fb_clear(void)
-{
-    pthread_mutex_lock(&fb_ctx.mutex);
-    fb_item_header *it, *next;
-    for(it = fb_ctx.first_item; it; it = next)
-    {
-        next = it->next;
-        fb_destroy_item(it);
-    }
-    fb_ctx.first_item = NULL;
-    pthread_mutex_unlock(&fb_ctx.mutex);
-
-    fb_png_drop_unused();
-    fb_text_drop_cache_unused();
-}
-
-static void fb_draw(void)
-{
-    uint32_t i;
-    fb_item_header *it;
-
-    fb_fill(fb_ctx.background_color);
-
-    fb_batch_start();
-    for(it = fb_ctx.first_item; it; it = it->next)
-    {
-        switch(it->type)
-        {
-            case FB_IT_RECT:
-                fb_draw_rect((fb_rect*)it);
-                break;
-            case FB_IT_IMG:
-                fb_draw_img((fb_img*)it);
-                break;
-            case FB_IT_LISTVIEW:
-                listview_update_ui_args((listview*)it, 1, 1);
-                break;
-            case FB_IT_LINE:
-                fb_draw_line((fb_line*)it);
-                break;
-        }
-    }
-    fb_batch_end();
-
-    pthread_mutex_lock(&fb_update_mutex);
-    fb_update();
-    pthread_mutex_unlock(&fb_update_mutex);
-}
-
-void fb_freeze(int freeze)
-{
-    if(freeze)
-        ++fb_frozen;
-    else
-        --fb_frozen;
-
-    // wait for last draw to finish or prevent new draw
-    if(fb_frozen == 1)
-    {
-        atomic_int expected = ATOMIC_VAR_INIT(1);
-        pthread_mutex_lock(&fb_draw_mutex);
-        int res = atomic_compare_exchange_strong(&fb_draw_requested, &expected, 0);
-        pthread_mutex_unlock(&fb_draw_mutex);
-    }
-}
-
-void fb_push_context(void)
-{
-    fb_context_t *ctx = mzalloc(sizeof(fb_context_t));
-
-    pthread_mutex_lock(&fb_ctx.mutex);
-    ctx->first_item = fb_ctx.first_item;
-    ctx->background_color = fb_ctx.background_color;
-    fb_ctx.first_item = NULL;
-    pthread_mutex_unlock(&fb_ctx.mutex);
-
-    list_add(&inactive_ctx, ctx);
-}
-
-void fb_pop_context(void)
-{
-    if(!inactive_ctx)
-        return;
-
-    fb_clear();
-
-    int idx = list_item_count(inactive_ctx)-1;
-    fb_context_t *ctx = inactive_ctx[idx];
-
-    pthread_mutex_lock(&fb_ctx.mutex);
-    fb_ctx.first_item = ctx->first_item;
-    fb_ctx.background_color = ctx->background_color;
-    pthread_mutex_unlock(&fb_ctx.mutex);
-
-    list_rm_noreorder(&inactive_ctx, ctx, &free);
-
-    fb_request_draw();
-}
-
-#define SLEEP_CONST 16
-void *fb_draw_thread_work(UNUSED void *cookie)
-{
-    struct timespec last, curr;
-    uint32_t diff = 0, prevSleepTime = 0;
-    clock_gettime(CLOCK_MONOTONIC, &last);
-
-    atomic_int expected = ATOMIC_VAR_INIT(1);
-
-    while(fb_draw_run)
-    {
-        clock_gettime(CLOCK_MONOTONIC, &curr);
-        diff = timespec_diff(&last, &curr);
-
-        expected.__val = 1; // might be reseted by atomic_compare_exchange_strong
-        pthread_mutex_lock(&fb_draw_mutex);
-        if(atomic_compare_exchange_strong(&fb_draw_requested, &expected, 0))
-        {
-            fb_draw();
-            pthread_cond_broadcast(&fb_draw_cond);
-            pthread_mutex_unlock(&fb_draw_mutex);
-        }
-        else
-        {
-            pthread_mutex_unlock(&fb_draw_mutex);
-#ifdef MR_CONTINUOUS_FB_UPDATE
-            pthread_mutex_lock(&fb_update_mutex);
-            fb_update();
-            pthread_mutex_unlock(&fb_update_mutex);
-#endif
-        }
-
-
-        last = curr;
-        if(diff <= SLEEP_CONST+prevSleepTime)
-        {
-            prevSleepTime = SLEEP_CONST+prevSleepTime-diff;
-            usleep(prevSleepTime*1000);
-        }
-        else
-            prevSleepTime = 0;
-    }
-    return NULL;
-}
-
-void fb_request_draw(void)
-{
-    if(!fb_frozen)
-    {
-        atomic_int expected = ATOMIC_VAR_INIT(0);
-        atomic_compare_exchange_strong(&fb_draw_requested, &expected, 1);
-    }
-}
-
-void fb_force_draw(void)
-{
-    atomic_int expected = ATOMIC_VAR_INIT(0);
-
-    pthread_mutex_lock(&fb_draw_mutex);
-    atomic_compare_exchange_strong(&fb_draw_requested, &expected, 1);
-    pthread_cond_wait(&fb_draw_cond, &fb_draw_mutex);
-    pthread_mutex_unlock(&fb_draw_mutex);
-}
-
-int fb_save_screenshot(void)
-{
-    char *r;
-    int c, media_rw_id;
-    char dir[256];
-    char path[256];
-
-    strcpy(dir, mrom_dir());
-    r = strrchr(dir, '/');
-    if(!r)
-    {
-        ERROR("Failed to determine path to save a screenshot!\n");
-        return -1;
-    }
-    *r = 0;
-    strcat(dir, "/Pictures/Screenshots");
-    mkdir_recursive_with_perms(path, 0775, "media_rw", "media_rw");
-
-    for(c = 0; c < 999; ++c)
-    {
-        snprintf(path, sizeof(path), "%s/mrom_screenshot_%03d.png", dir, c);
-        if(access(path, F_OK) < 0)
-            break;
-    }
-
-    pthread_mutex_lock(&fb_draw_mutex);
-    if(fb_png_save_img(path, fb_width, fb_height, fb.stride, fb.buffer) >= 0)
-    {
-        media_rw_id = decode_uid("media_rw");
-        if(media_rw_id != -1)
-            chown(path, (uid_t)media_rw_id, (gid_t)media_rw_id);
-        chmod(path, 0664);
-
-        INFO("Screenshot saved to %s\n", path);
-
-        fb_fill(WHITE);
-        pthread_mutex_lock(&fb_update_mutex);
-        fb_update();
-        usleep(100000);
-        pthread_mutex_unlock(&fb_update_mutex);
-        pthread_mutex_unlock(&fb_draw_mutex);
-
-        fb_request_draw();
-        return 0;
-    }
-    else
-    {
-        pthread_mutex_unlock(&fb_draw_mutex);
-        ERROR("Failed to take screenshot!\n");
-        return -1;
-    }
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <string.h>
+#include <signal.h>
+#include <assert.h>
+#include <linux/fb.h>
+#include <linux/kd.h>
+#include <cutils/memory.h>
+#include <pthread.h>
+#include <png.h>
+#include <math.h>
+
+#include <string.h>
+#include <malloc.h>
+
+#include "log.h"
+#include "framebuffer.h"
+#include "util.h"
+#include "containers.h"
+#include "animation.h"
+#include "listview.h"
+#include "atomics.h"
+#include "mrom_data.h"
+
+#if PIXEL_SIZE == 4
+#define fb_memset(dst, what, len) android_memset32(dst, what, len)
+#else
+#define fb_memset(dst, what, len) android_memset16(dst, what, len)
+#endif
+
+
+uint32_t fb_width = 0;
+uint32_t fb_height = 0;
+int fb_rotation = 0; // in degrees, clockwise
+
+fb_item_pos DEFAULT_FB_PARENT = {
+    .x = 0,
+    .y = 0,
+};
+
+static struct framebuffer fb;
+static int fb_frozen = 0;
+static int fb_force_generic = 0;
+
+static fb_context_t fb_ctx = {
+    .first_item = NULL,
+    .batch_started = 0,
+    .background_color = BLACK,
+    .mutex = PTHREAD_MUTEX_INITIALIZER
+};
+
+static fb_context_t **inactive_ctx = NULL;
+static uint8_t **fb_rot_helpers = NULL;
+static pthread_t fb_draw_thread;
+static pthread_mutex_t fb_update_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t fb_draw_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t fb_draw_cond = PTHREAD_COND_INITIALIZER;
+static atomic_int fb_draw_requested = ATOMIC_VAR_INIT(0);
+static volatile int fb_draw_run = 0;
+static void *fb_draw_thread_work(void*);
+
+static void fb_destroy_item(void *item); // private!
+static inline void fb_cpy_fb_with_rotation(px_type *dst, px_type *src);
+static inline void fb_rotate_90deg(px_type *dst, px_type *src);
+static inline void fb_rotate_270deg(px_type *dst, px_type *src);
+static inline void fb_rotate_180deg(px_type *dst, px_type *src);
+
+int fb_open_impl(void)
+{
+    struct fb_impl **itr;
+    struct fb_impl *impls[FB_IMPL_CNT];
+
+#define ADD_IMPL(ID, N) \
+    extern struct fb_impl fb_impl_ ## N; \
+    impls[ID] = &fb_impl_ ## N;
+
+    ADD_IMPL(FB_IMPL_GENERIC, generic);
+#ifdef MR_USE_QCOM_OVERLAY
+    ADD_IMPL(FB_IMPL_QCOM_OVERLAY, qcom_overlay);
+#endif
+
+    if(fb_force_generic)
+        itr = &impls[FB_IMPL_GENERIC];
+    else
+        itr = impls;
+
+    for(; *itr; ++itr)
+    {
+        if((*itr)->open(&fb) >= 0)
+        {
+            INFO("Framebuffer implementation: %s\n", (*itr)->name);
+            fb.impl = *itr;
+            return 0;
+        }
+    }
+
+    ERROR("All framebuffer implementations have failed to open!\n");
+    return -1;
+}
+
+int fb_open(int rotation)
+{
+    memset(&fb, 0, sizeof(struct framebuffer));
+
+    fb.fd = open("/dev/graphics/fb0", O_RDWR | O_CLOEXEC);
+    if (fb.fd < 0)
+        return -1;
+
+    if(ioctl(fb.fd, FBIOGET_VSCREENINFO, &fb.vi) < 0)
+        goto fail;
+
+    if(ioctl(fb.fd, FBIOGET_FSCREENINFO, &fb.fi) < 0)
+        goto fail;
+
+    /*
+     * No FBIOPUT_VSCREENINFO ioctl must be called here. Flo's display drivers
+     * contain a hack to set backlight while in recovery, which is triggered by
+     * this ioctl (and probably other things). The hack turns *something* on
+     * and it causes insane battery drain while in android (it eats at least
+     * five times more energy). The device enters deep sleep just fine, the dmesg
+     * says it was suspended, but it drains more energy. Qualcomm ION overlay
+     * framebuffer implementation works around this hack, because it doesn't
+     * require that ioctl (but we can't set pixel format without it, must use
+     * framebuffer's default format in "TARGET_RECOVERY_PIXEL_FORMAT" config
+     * value). This bug does not manifest when MultiROM isn't installed,
+     * because nothing sets FBIOPUT_VSCREENINFO during Android's boot,
+     * and well, you're not really supposed to stay long in recovery nor does
+     * it have "suspend" state.
+     *
+     * This ioctl call was moved to framebuffer_generic implementation.
+     */
+
+    if(fb_open_impl() < 0)
+        goto fail;
+
+    fb_frozen = 0;
+    fb_rotation = rotation;
+
+    if(fb_rotation%180 == 0)
+    {
+        fb_width = fb.vi.xres;
+        fb_height = fb.vi.yres;
+    }
+    else
+    {
+        fb_width = fb.vi.yres;
+        fb_height = fb.vi.xres;
+    }
+
+#ifdef RECOVERY_GRAPHICS_USE_LINELENGTH
+    fb.vi.xres_virtual = fb.fi.line_length / PIXEL_SIZE;
+#endif
+
+    fb.stride = (fb_rotation%180 == 0) ? fb.vi.xres_virtual : fb.vi.yres;
+    fb.size = fb.vi.xres_virtual*fb.vi.yres*PIXEL_SIZE;
+    fb.buffer = malloc(fb.size);
+    fb_memset(fb.buffer, fb_convert_color(BLACK), fb.size);
+
+#if 0
+    fb_dump_info();
+#endif
+
+    DEFAULT_FB_PARENT.w = fb_width;
+    DEFAULT_FB_PARENT.h = fb_height;
+
+    fb_set_brightness(MULTIROM_DEFAULT_BRIGHTNESS);
+
+    fb_update();
+
+    fb_draw_run = 1;
+    pthread_create(&fb_draw_thread, NULL, fb_draw_thread_work, NULL);
+    return 0;
+
+fail:
+    close(fb.fd);
+    return -1;
+}
+
+void fb_close(void)
+{
+    fb_draw_run = 0;
+    pthread_join(fb_draw_thread, NULL);
+
+    free(fb_rot_helpers);
+    fb_rot_helpers = NULL;
+
+    fb.impl->close(&fb);
+    fb.impl = NULL;
+
+    close(fb.fd);
+    free(fb.buffer);
+    fb.buffer = NULL;
+}
+
+void fb_dump_info(void)
+{
+    ERROR("Framebuffer:\n");
+    ERROR("fi.smem_len: %u\n", fb.fi.smem_len);
+    ERROR("fi.type: %u\n", fb.fi.type);
+    ERROR("fi.type_aux: %u\n", fb.fi.type_aux);
+    ERROR("fi.visual: %u\n", fb.fi.visual);
+    ERROR("fi.xpanstep: %u\n", fb.fi.xpanstep);
+    ERROR("fi.ypanstep: %u\n", fb.fi.ypanstep);
+    ERROR("fi.ywrapstep: %u\n", fb.fi.ywrapstep);
+    ERROR("fi.line_length: %u\n", fb.fi.line_length);
+    ERROR("fi.mmio_start: %p\n", (void*)fb.fi.mmio_start);
+    ERROR("fi.mmio_len: %u\n", fb.fi.mmio_len);
+    ERROR("fi.accel: %u\n", fb.fi.accel);
+    ERROR("vi.xres: %u\n", fb.vi.xres);
+    ERROR("vi.yres: %u\n", fb.vi.yres);
+    ERROR("vi.xres_virtual: %u\n", fb.vi.xres_virtual);
+    ERROR("vi.yres_virtual: %u\n", fb.vi.yres_virtual);
+    ERROR("vi.xoffset: %u\n", fb.vi.xoffset);
+    ERROR("vi.yoffset: %u\n", fb.vi.yoffset);
+    ERROR("vi.bits_per_pixel: %u\n", fb.vi.bits_per_pixel);
+    ERROR("vi.grayscale: %u\n", fb.vi.grayscale);
+    ERROR("vi.red: offset: %u len: %u msb_right: %u\n", fb.vi.red.offset, fb.vi.red.length, fb.vi.red.msb_right);
+    ERROR("vi.green: offset: %u len: %u msb_right: %u\n", fb.vi.green.offset, fb.vi.green.length, fb.vi.green.msb_right);
+    ERROR("vi.blue: offset: %u len: %u msb_right: %u\n", fb.vi.blue.offset, fb.vi.blue.length, fb.vi.blue.msb_right);
+    ERROR("vi.transp: offset: %u len: %u msb_right: %u\n", fb.vi.transp.offset, fb.vi.transp.length, fb.vi.transp.msb_right);
+    ERROR("vi.nonstd: %u\n", fb.vi.nonstd);
+    ERROR("vi.activate: %u\n", fb.vi.activate);
+    ERROR("vi.height: %u\n", fb.vi.height);
+    ERROR("vi.width: %u\n", fb.vi.width);
+    ERROR("vi.accel_flags: %u\n", fb.vi.accel_flags);
+}
+
+void fb_set_brightness(int val)
+{
+#ifdef TW_BRIGHTNESS_PATH
+    FILE *f = fopen(TW_BRIGHTNESS_PATH, "we");
+    if(!f)
+    {
+        ERROR("Failed to set brightness: %s!\n", strerror(errno));
+        return;
+    }
+    fprintf(f, "%d", val);
+    fclose(f);
+#endif
+}
+
+int fb_get_vi_xres(void)
+{
+    return fb.vi.xres;
+}
+
+int fb_get_vi_yres(void)
+{
+    return fb.vi.yres;
+}
+
+void fb_force_generic_impl(int force)
+{
+    fb_force_generic = force;
+}
+
+void fb_update(void)
+{
+    fb_cpy_fb_with_rotation(fb.impl->get_frame_dest(&fb), fb.buffer);
+    fb.impl->update(&fb);
+}
+
+void fb_cpy_fb_with_rotation(px_type *dst, px_type *src)
+{
+    switch(fb_rotation)
+    {
+        case 0:
+            memcpy(dst, src, fb.vi.xres_virtual * fb.vi.yres * PIXEL_SIZE);
+            break;
+        case 90:
+            fb_rotate_90deg(dst, src);
+            break;
+        case 180:
+            fb_rotate_180deg(dst, src);
+            break;
+        case 270:
+            fb_rotate_270deg(dst, src);
+            break;
+    }
+}
+
+void fb_rotate_90deg(px_type *dst, px_type *src)
+{
+    uint32_t i;
+    int32_t x;
+
+    if(!fb_rot_helpers)
+        fb_rot_helpers = malloc(fb_height*sizeof(px_type*));
+
+    px_type **helpers = (px_type**)fb_rot_helpers;
+
+    helpers[0] = src;
+    for(i = 1; i < fb_height; ++i)
+        helpers[i] = helpers[i-1] + fb.stride;
+
+    const int padding = fb.vi.xres_virtual - fb.vi.xres;
+    for(i = 0; i < fb_width; ++i)
+    {
+        for(x = fb_height-1; x >= 0; --x)
+            *dst++ = *(helpers[x]++);
+        dst += padding;
+    }
+}
+
+void fb_rotate_270deg(px_type *dst, px_type *src)
+{
+    if(!fb_rot_helpers)
+        fb_rot_helpers = malloc(fb_height*sizeof(px_type*));
+
+    uint32_t i, x;
+    px_type **helpers = (px_type**)fb_rot_helpers;
+
+    helpers[0] = src + fb_width-1;
+    for(i = 1; i < fb_height; ++i)
+        helpers[i] = helpers[i-1] + fb.stride;
+
+    const int padding = fb.vi.xres_virtual - fb.vi.xres;
+    for(i = 0; i < fb_width; ++i)
+    {
+        for(x = 0; x < fb_height; ++x)
+            *dst++ = *(helpers[x]--);
+        dst += padding;
+    }
+}
+
+void fb_rotate_180deg(px_type *dst, px_type *src)
+{
+    uint32_t i, x;
+    int len = fb.vi.xres_virtual * fb.vi.yres;
+    src += len;
+
+    const int padding = fb.vi.xres_virtual - fb.vi.xres;
+    for(i = 0; i < fb_height; ++i)
+    {
+        src -= padding;
+        for(x = 0; x < fb_width; ++x)
+            *dst++ = *(--src);
+        dst += padding;
+    }
+}
+
+int fb_clone(char **buff)
+{
+    int len = fb.size;
+    *buff = malloc(len);
+
+    pthread_mutex_lock(&fb_update_mutex);
+    memcpy(*buff, fb.buffer, len);
+    pthread_mutex_unlock(&fb_update_mutex);
+
+    return len;
+}
+
+void fb_fill(uint32_t color)
+{
+    fb_memset(fb.buffer, fb_convert_color(color), fb.size);
+}
+
+px_type fb_convert_color(uint32_t c)
+{
+#ifdef RECOVERY_BGRA
+    return c;
+#elif defined(RECOVERY_RGBX)
+    return (c & 0xFF000000) | ((c & 0xFF) << 16) | (c & 0xFF00) | ((c & 0xFF0000) >> 16);
+#elif defined(RECOVERY_ABGR)
+    //             A              B                   G                  R
+    return (c & 0xFF000000) | ((c & 0xFF) << 16) | (c & 0xFF00) | ((c & 0xFF0000) >> 16);
+#elif defined(RECOVERY_RGB_565)
+    const uint8_t alpha_pct = (((c >> 24) & 0xFF)*100) / 0xFF;
+    //            R                                G                              B
+    return (((c & 0xFF0000) >> 19) << 11) | (((c & 0xFF00) >> 10) << 5) | ((c & 0xFF) >> 3);
+#else
+#error "Unknown pixel format"
+#endif
+}
+
+uint32_t fb_convert_color_img(uint32_t clr)
+{
+    uint32_t c = fb_convert_color(clr);
+#if PIXEL_SIZE == 2
+    const uint8_t alpha_pct = (((clr >> 24) & 0xFF)*100) / 0xFF;
+    //      Alpha - RB                    Alpha - G
+    c |= (((alpha_pct*31)/100) << 16) | (((alpha_pct*63)/100) << 24);
+#endif
+    return c;
+}
+
+void fb_set_background(uint32_t color)
+{
+    fb_ctx.background_color = color;
+}
+
+void fb_batch_start(void)
+{
+    pthread_mutex_lock(&fb_ctx.mutex);
+    fb_ctx.batch_thread = pthread_self();
+    fb_ctx.batch_started = 1;
+}
+
+void fb_batch_end(void)
+{
+    fb_ctx.batch_started = 0;
+    pthread_mutex_unlock(&fb_ctx.mutex);
+}
+
+void fb_items_lock(void)
+{
+    if(!fb_ctx.batch_started || !pthread_equal(fb_ctx.batch_thread, pthread_self()))
+        pthread_mutex_lock(&fb_ctx.mutex);
+}
+
+void fb_items_unlock(void)
+{
+    if(!fb_ctx.batch_started || !pthread_equal(fb_ctx.batch_thread, pthread_self()))
+        pthread_mutex_unlock(&fb_ctx.mutex);
+}
+
+static void fb_ctx_put_it_before(fb_item_header *new_it, fb_item_header *next_it)
+{
+    if(next_it->prev)
+    {
+        next_it->prev->next = new_it;
+        new_it->prev = next_it->prev;
+    }
+    new_it->next = next_it;
+    next_it->prev = new_it;
+}
+
+static void fb_ctx_put_it_after(fb_item_header *new_it, fb_item_header *prev_it)
+{
+    if(prev_it->next)
+    {
+        prev_it->next->prev = new_it;
+        new_it->next = prev_it->next;
+    }
+    new_it->prev = prev_it;
+    prev_it->next = new_it;
+}
+
+void fb_ctx_add_item(void *item)
+{
+    fb_item_header *h = item;
+
+    fb_items_lock();
+
+    if(!fb_ctx.first_item)
+        fb_ctx.first_item = item;
+    else
+    {
+        fb_item_header *itr = fb_ctx.first_item;
+        while(1)
+        {
+            if(itr->level > h->level)
+            {
+                if(itr == fb_ctx.first_item)
+                    fb_ctx.first_item = h;
+                fb_ctx_put_it_before(h, itr);
+                itr = NULL;
+                break;
+            }
+
+            if(itr->next)
+                itr = itr->next;
+            else
+                break;
+        }
+
+        if(itr)
+            fb_ctx_put_it_after(h, itr);
+    }
+
+    fb_items_unlock();
+}
+
+void fb_ctx_rm_item(void *item)
+{
+    fb_item_header *h = item;
+
+    fb_items_lock();
+
+    if(!h->prev)
+        fb_ctx.first_item = h->next;
+    else
+        h->prev->next = h->next;
+
+    if(h->next)
+        h->next->prev = h->prev;
+
+    fb_items_unlock();
+}
+
+void fb_remove_item(void *item)
+{
+    switch(((fb_item_header*)item)->type)
+    {
+        case FB_IT_RECT:
+            fb_rm_rect((fb_rect*)item);
+            break;
+        case FB_IT_IMG:
+            fb_rm_img((fb_img*)item);
+            break;
+        case FB_IT_LISTVIEW:
+            listview_destroy((listview*)item);
+            break;
+        case FB_IT_LINE:
+            fb_rm_line((fb_line*)item);
+            break;
+    }
+}
+
+void fb_destroy_item(void *item)
+{
+    anim_cancel_for(item, 0);
+
+    switch(((fb_item_header*)item)->type)
+    {
+        case FB_IT_RECT:
+        case FB_IT_LINE:
+            break;
+        case FB_IT_IMG:
+        {
+            fb_img *i = (fb_img*)item;
+            switch(i->img_type)
+            {
+                case FB_IMG_TYPE_PNG:
+                    fb_png_release(i->data);
+                    break;
+                case FB_IMG_TYPE_GENERIC:
+                    free(i->data);
+                    break;
+                case FB_IMG_TYPE_TEXT:
+                    fb_text_destroy(i);
+                    break;
+                default:
+                    ERROR("fb_destroy_item(): unknown fb_img type %d\n", i->img_type);
+                    assert(0);
+                    break;
+            }
+            break;
+        }
+    }
+    free(item);
+}
+
+static inline void clamp_to_parent(void *it, int *min_x, int *max_x, int *min_y, int *max_y)
+{
+    fb_item_header *h = it;
+
+    int parent_x = h->parent->x;
+    int parent_y = h->parent->y;
+    int parent_w = h->parent->w;
+    int parent_h = h->parent->h;
+
+    if(h->parent != &DEFAULT_FB_PARENT)
+    {
+        if(parent_x < 0)
+        {
+            parent_w += parent_x;
+            parent_x = 0;
+        }
+        if(parent_y < 0)
+        {
+            parent_h += parent_y;
+            parent_y = 0;
+        }
+        parent_w = imin(parent_x + parent_w, fb_width) - parent_x;
+        parent_h = imin(parent_y + parent_h, fb_height) - parent_y;
+    }
+
+    *min_x = h->x >= parent_x ? 0 : parent_x - h->x;
+    *min_y = h->y >= parent_y ? 0 : parent_y - h->y;
+    *max_x = imin(h->w, parent_x + parent_w - h->x);
+    *max_y = imin(h->h, parent_y + parent_h - h->y);
+}
+
+void fb_draw_rect(fb_rect *r)
+{
+    const uint8_t alpha = (r->color >> 24) & 0xFF;
+    const uint8_t inv_alpha = 0xFF - ((r->color >> 24) & 0xFF);
+    const px_type color = fb_convert_color(r->color);
+
+    if(alpha == 0)
+        return;
+
+#if defined(RECOVERY_RGBX) || defined(RECOVERY_ABGR)
+    const uint32_t premult_color_rb = ((color & 0xFF00FF) * (alpha)) >> 8;
+    const uint32_t premult_color_g = ((color & 0x00FF00) * (alpha)) >> 8;
+#elif defined(RECOVERY_BGRA)
+    const uint32_t premult_color_rb = (((color >> 8) & 0xFF00FF) * (alpha)) >> 8;
+    const uint32_t premult_color_g = (((color >> 8) & 0x00FF00) * (alpha)) >> 8;
+#elif defined(RECOVERY_RGB_565)
+    const uint8_t alpha5b = (alpha >> 3) + 1;
+    const uint8_t alpha6b = (alpha >> 2) + 1;
+    const uint8_t inv_alpha5b = 32 - alpha5b;
+    const uint8_t inv_alpha6b = 64 - alpha6b;
+    const uint16_t premult_color_rb = ((color & 0xF81F) * alpha5b) >> 5;
+    const uint16_t premult_color_g = ((color & 0x7E0) * alpha6b) >> 6;
+#endif
+
+    int min_x, max_x, min_y, max_y;
+    clamp_to_parent(r, &min_x, &max_x, &min_y, &max_y);
+    const int rendered_w = max_x - min_x;
+
+    if(rendered_w <= 0)
+        return;
+
+    const int w = rendered_w*PIXEL_SIZE;
+
+    px_type *bits = fb.buffer + (fb.stride*(r->y + min_y)) + r->x + min_x;
+
+    int i, x;
+    uint8_t *comps_bits;
+    const uint8_t *comps_clr = (uint8_t*)&color;
+    for(i = min_y; i < max_y; ++i)
+    {
+        if(alpha == 0xFF)
+        {
+            fb_memset(bits, color, w);
+            bits += fb.stride;
+        }
+        // Do the blending
+        else
+        {
+#ifdef MR_DISABLE_ALPHA
+            fb_memset(bits, color, w);
+            bits += fb.stride;
+#else
+            for(x = 0; x < rendered_w; ++x)
+            {
+  #ifdef RECOVERY_RGBX || defined(RECOVERY_ABGR)
+                const uint32_t rb = (premult_color_rb & 0xFF00FF) + ((inv_alpha * (*bits & 0xFF00FF)) >> 8);
+                const uint32_t g = (premult_color_g & 0x00FF00) + ((inv_alpha * (*bits & 0x00FF00)) >> 8);
+                *bits = 0xFF000000 | (rb & 0xFF00FF) | (g & 0x00FF00);
+  #elif defined(RECOVERY_BGRA)
+                const uint32_t rb = (premult_color_rb & 0xFF00FF) + ((inv_alpha * ((*bits >> 8) & 0xFF00FF)) >> 8);
+                const uint32_t g = (premult_color_g & 0x00FF00) + ((inv_alpha * ((*bits >> 8) & 0x00FF00)) >> 8);
+                *bits = 0xFF000000 | (rb & 0xFF00FF) | (g & 0x00FF00);
+  #elif defined(RECOVERY_RGB_565)
+                const uint16_t rb = (premult_color_rb & 0xF81F) + ((inv_alpha5b * (*bits & 0xF81F)) >> 5);
+                const uint16_t g = (premult_color_g & 0x7E0) + ((inv_alpha6b * (*bits & 0x7E0)) >> 6);
+                *bits = (rb & 0xF81F) | (g & 0x7E0);
+  #else
+    #error "No alpha blending implementation for this format!"
+  #endif
+                ++bits;
+            }
+            bits += fb.stride - rendered_w;
+#endif // MR_DISABLE_ALPHA
+        }
+    }
+}
+
+static inline int blend_png(int value1, int value2, int alpha) {
+    int r = (0xFF-alpha)*value1 + alpha*value2;
+    return (r+1 + (r >> 8)) >> 8; // divide by 255
+}
+
+void fb_draw_img(fb_img *i)
+{
+    int y, x;
+    const int w = i->w*PIXEL_SIZE;
+    uint8_t alpha;
+    uint8_t *comps_img, *comps_bits;
+
+#if PIXEL_SIZE == 4
+    const uint8_t max_alpha = 0xFF;
+#elif PIXEL_SIZE == 2
+    const uint8_t max_alpha = 31;
+#endif
+
+    int min_x, max_x, min_y, max_y;
+    clamp_to_parent(i, &min_x, &max_x, &min_y, &max_y);
+    const int rendered_w = max_x - min_x;
+
+    if(rendered_w <= 0)
+        return;
+
+    px_type *bits = fb.buffer + (fb.stride*(i->y + min_y)) + i->x + min_x;
+    px_type *img = (px_type*)(((uint32_t*)i->data) + (min_y * i->w) + min_x);
+
+    for(y = min_y; y < max_y; ++y)
+    {
+        for(x = min_x; x < max_x; ++x)
+        {
+            // Colors, 0xAABBGGRR
+#if PIXEL_SIZE == 4
+            alpha = PX_GET_A(*img);
+#elif PIXEL_SIZE == 2
+            alpha = ((uint8_t*)img)[2];
+#endif
+            // fully opaque
+            if(alpha == max_alpha)
+            {
+                *bits = *img;
+            }
+            // do the blending
+            else if(alpha != 0x00)
+            {
+#ifdef MR_DISABLE_ALPHA
+                *bits = *img;
+#else
+  #if PIXEL_SIZE == 4
+                comps_bits = (uint8_t*)bits;
+                comps_img = (uint8_t*)img;
+                comps_bits[PX_IDX_R] = blend_png(comps_bits[PX_IDX_R], comps_img[PX_IDX_R], comps_img[PX_IDX_A]);
+                comps_bits[PX_IDX_G] = blend_png(comps_bits[PX_IDX_G], comps_img[PX_IDX_G], comps_img[PX_IDX_A]);
+                comps_bits[PX_IDX_B] = blend_png(comps_bits[PX_IDX_B], comps_img[PX_IDX_B], comps_img[PX_IDX_A]);
+                comps_bits[PX_IDX_A] = 0xFF;
+  #else
+                const uint8_t alpha5b = alpha;
+                const uint8_t alpha6b = ((uint8_t*)img)[3];
+                *bits = (((31-alpha5b)*(*bits & 0x1F)            + (alpha5b*(*img & 0x1F))) / 31) |
+                        ((((63-alpha6b)*((*bits & 0x7E0) >> 5)   + (alpha6b*((*img & 0x7E0) >> 5))) / 63) << 5) |
+                        ((((31-alpha5b)*((*bits & 0xF800) >> 11) + (alpha5b*((*img & 0xF800) >> 11))) / 31) << 11);
+  #endif // PIXEL_SIZE
+#endif // MR_DISABLE_ALPHA
+            }
+
+            ++bits;
+#if PIXEL_SIZE == 4
+            ++img;
+#elif PIXEL_SIZE == 2
+            img += 2;
+#endif
+        }
+        bits += fb.stride - rendered_w;
+        img = (px_type*)(((uint32_t*)img) + (i->w - rendered_w));
+    }
+}
+
+// from http://members.chello.at/~easyfilter/bresenham.html
+void fb_draw_line(fb_line *l)
+{
+    const px_type px = fb_convert_color(l->color);
+
+    int x0 = imin(imax(l->x, l->parent->x), l->parent->x + l->parent->w);
+    int x1 = imin(imax(l->x2, l->parent->x), l->parent->x + l->parent->w);
+    int y0 = imin(imax(l->y, l->parent->y), l->parent->y + l->parent->h);
+    int y1 = imin(imax(l->y2, l->parent->y), l->parent->y + l->parent->h);
+
+    int dx = abs(x1-x0);
+    int dy = abs(y1-y0);
+    const int sx = x0 < x1 ? 1 : -1;
+    const int sy = y0 < y1 ? 1 : -1;
+
+    int err;
+    double e2 = sqrt((double)(dx*dx) + (double)(dy*dy));
+
+    if(e2 == 0.0)
+        return;
+
+    dx *= 255/e2;
+    dy *= 255/e2;
+    double th = 255*((double)(l->thickness - 1));
+
+    if(dx < dy)
+    {
+        x1 = (e2+th/2) / dy;
+        err = x1*dy - th/2;
+        for(x0 -= x1*sx; ; y0 += sy)
+        {
+            x1 = x0;
+            for(e2 = dy-err-th; e2+dy < 255; e2 += dy)
+            {
+                x1 += sx;
+                *(fb.buffer + fb.stride*y0 + x1) = px;
+            }
+            if(y0 == y1)
+                break;
+            err += dx;
+            if(err > 255)
+            {
+                err -= dy;
+                x0 += sx;
+            }
+        }
+    }
+    else
+    {
+        y1 = (e2 + th/2) / dx;
+        err = y1*dx - th/2;
+        for(y0 -= y1*sy; ; x0 += sx)
+        {
+            y1 = y0;
+            for(e2 = dx - err - th; e2+dx < 255; e2 += dx)
+            {
+                y1 += sy;
+                *(fb.buffer + fb.stride*y1 + x0) = px;
+            }
+
+            if(x0 == x1)
+                break;
+            err += dy;
+            if(err > 255)
+            {
+                err -= dx;
+                y0 += sy;
+            }
+        }
+    }
+}
+
+int fb_generate_item_id(void)
+{
+    fb_items_lock();
+    static int id = 0;
+    int res = id++;
+    fb_items_unlock();
+
+    return res;
+}
+
+fb_rect *fb_add_rect_lvl(int level, int x, int y, int w, int h, uint32_t color)
+{
+    fb_rect *r = mzalloc(sizeof(fb_rect));
+    r->id = fb_generate_item_id();
+    r->type = FB_IT_RECT;
+    r->parent = &DEFAULT_FB_PARENT;
+    r->level = level;
+
+    r->x = x;
+    r->y = y;
+
+    r->w = w;
+    r->h = h;
+    r->color = color;
+
+    fb_ctx_add_item(r);
+    return r;
+}
+
+void fb_add_rect_notfilled(int level, int x, int y, int w, int h, uint32_t color, int thickness, fb_rect ***list)
+{
+    fb_rect *r;
+    // top
+    r = fb_add_rect_lvl(level, x, y, w, thickness, color);
+    list_add(list, r);
+
+    // right
+    r = fb_add_rect_lvl(level, x + w - thickness, y, thickness, h, color);
+    list_add(list, r);
+
+    // bottom
+    r = fb_add_rect_lvl(level, x, y + h - thickness, w, thickness, color);
+    list_add(list, r);
+
+    // left
+    r = fb_add_rect_lvl(level, x, y, thickness, h, color);
+    list_add(list, r);
+}
+
+fb_img *fb_add_img(int level, int x, int y, int w, int h, int img_type, px_type *data)
+{
+    fb_img *result = mzalloc(sizeof(fb_img));
+    result->id = fb_generate_item_id();
+    result->type = FB_IT_IMG;
+    result->parent = &DEFAULT_FB_PARENT;
+    result->level = level;
+    result->x = x;
+    result->y = y;
+    result->img_type = img_type;
+    result->data = data;
+    result->w = w;
+    result->h = h;
+
+    fb_ctx_add_item(result);
+    return result;
+}
+
+fb_img* fb_add_png_img_lvl(int level, int x, int y, int w, int h, const char *path)
+{
+    px_type *data = NULL;
+    if(strncmp(path, ":/", 2) == 0)
+    {
+        const int full_path_len = strlen(path) + strlen(mrom_dir()) + 4;
+        char *full_path = malloc(full_path_len);
+        snprintf(full_path, full_path_len, "%s/res%s", mrom_dir(), path+1);
+        data = fb_png_get(full_path, w, h);
+        free(full_path);
+    }
+    else
+        data = fb_png_get(path, w, h);
+    if(!data)
+        return NULL;
+
+    return fb_add_img(level, x, y, w, h, FB_IMG_TYPE_PNG, data);
+}
+
+fb_circle *fb_add_circle_lvl(int level, int x, int y, int radius, uint32_t color)
+{
+    const int diameter = radius*2 + 1;
+    uint32_t *data = mzalloc(diameter * diameter * 4);
+    uint32_t px = fb_convert_color_img(color);
+
+    int rx, ry;
+    const int radius_check = radius*radius + radius*0.8;
+
+    for(ry = -radius; ry <= radius; ++ry)
+        for(rx = -radius; rx <= radius; ++rx)
+            if(rx*rx+ry*ry <= radius_check)
+                *(data + diameter*(radius + ry) + (radius+rx)) = px;
+
+    return fb_add_img(level, x, y, diameter, diameter, FB_IMG_TYPE_GENERIC, data);
+}
+
+fb_line *fb_add_line_lvl(int level, int x1, int y1, int x2, int y2, int thickness, uint32_t color)
+{
+    fb_line *res = mzalloc(sizeof(fb_line));
+    res->id = fb_generate_item_id();
+    res->type = FB_IT_LINE;
+    res->parent = &DEFAULT_FB_PARENT;
+    res->level = level;
+    res->x = x1;
+    res->y = y1;
+    res->x2 = x2;
+    res->y2 = y2;
+    res->thickness = thickness;
+    res->color = color;
+    fb_ctx_add_item(res);
+    return res;
+}
+
+void fb_rm_rect(fb_rect *r)
+{
+    if(!r)
+        return;
+
+    fb_ctx_rm_item(r);
+    fb_destroy_item(r);
+}
+
+void fb_rm_text(fb_img *i)
+{
+    fb_rm_img(i);
+}
+
+void fb_rm_img(fb_img *i)
+{
+    if(!i)
+        return;
+
+    fb_ctx_rm_item(i);
+    fb_destroy_item(i);
+}
+
+void fb_rm_circle(fb_circle *c)
+{
+    fb_rm_img(c);
+}
+
+void fb_rm_line(fb_line *l)
+{
+    if(!l)
+        return;
+
+    fb_ctx_rm_item(l);
+    fb_destroy_item(l);
+}
+
+void fb_clear(void)
+{
+    pthread_mutex_lock(&fb_ctx.mutex);
+    fb_item_header *it, *next;
+    for(it = fb_ctx.first_item; it; it = next)
+    {
+        next = it->next;
+        fb_destroy_item(it);
+    }
+    fb_ctx.first_item = NULL;
+    pthread_mutex_unlock(&fb_ctx.mutex);
+
+    fb_png_drop_unused();
+    fb_text_drop_cache_unused();
+}
+
+static void fb_draw(void)
+{
+    uint32_t i;
+    fb_item_header *it;
+
+    fb_fill(fb_ctx.background_color);
+
+    fb_batch_start();
+    for(it = fb_ctx.first_item; it; it = it->next)
+    {
+        switch(it->type)
+        {
+            case FB_IT_RECT:
+                fb_draw_rect((fb_rect*)it);
+                break;
+            case FB_IT_IMG:
+                fb_draw_img((fb_img*)it);
+                break;
+            case FB_IT_LISTVIEW:
+                listview_update_ui_args((listview*)it, 1, 1);
+                break;
+            case FB_IT_LINE:
+                fb_draw_line((fb_line*)it);
+                break;
+        }
+    }
+    fb_batch_end();
+
+    pthread_mutex_lock(&fb_update_mutex);
+    fb_update();
+    pthread_mutex_unlock(&fb_update_mutex);
+}
+
+void fb_freeze(int freeze)
+{
+    if(freeze)
+        ++fb_frozen;
+    else
+        --fb_frozen;
+
+    // wait for last draw to finish or prevent new draw
+    if(fb_frozen == 1)
+    {
+        atomic_int expected = ATOMIC_VAR_INIT(1);
+        pthread_mutex_lock(&fb_draw_mutex);
+        int res = atomic_compare_exchange_strong(&fb_draw_requested, &expected, 0);
+        pthread_mutex_unlock(&fb_draw_mutex);
+    }
+}
+
+void fb_push_context(void)
+{
+    fb_context_t *ctx = mzalloc(sizeof(fb_context_t));
+
+    pthread_mutex_lock(&fb_ctx.mutex);
+    ctx->first_item = fb_ctx.first_item;
+    ctx->background_color = fb_ctx.background_color;
+    fb_ctx.first_item = NULL;
+    pthread_mutex_unlock(&fb_ctx.mutex);
+
+    list_add(&inactive_ctx, ctx);
+}
+
+void fb_pop_context(void)
+{
+    if(!inactive_ctx)
+        return;
+
+    fb_clear();
+
+    int idx = list_item_count(inactive_ctx)-1;
+    fb_context_t *ctx = inactive_ctx[idx];
+
+    pthread_mutex_lock(&fb_ctx.mutex);
+    fb_ctx.first_item = ctx->first_item;
+    fb_ctx.background_color = ctx->background_color;
+    pthread_mutex_unlock(&fb_ctx.mutex);
+
+    list_rm_noreorder(&inactive_ctx, ctx, &free);
+
+    fb_request_draw();
+}
+
+#define SLEEP_CONST 16
+void *fb_draw_thread_work(UNUSED void *cookie)
+{
+    struct timespec last, curr;
+    uint32_t diff = 0, prevSleepTime = 0;
+    clock_gettime(CLOCK_MONOTONIC, &last);
+
+    atomic_int expected = ATOMIC_VAR_INIT(1);
+
+    while(fb_draw_run)
+    {
+        clock_gettime(CLOCK_MONOTONIC, &curr);
+        diff = timespec_diff(&last, &curr);
+
+        expected.__val = 1; // might be reseted by atomic_compare_exchange_strong
+        pthread_mutex_lock(&fb_draw_mutex);
+        if(atomic_compare_exchange_strong(&fb_draw_requested, &expected, 0))
+        {
+            fb_draw();
+            pthread_cond_broadcast(&fb_draw_cond);
+            pthread_mutex_unlock(&fb_draw_mutex);
+        }
+        else
+        {
+            pthread_mutex_unlock(&fb_draw_mutex);
+#ifdef MR_CONTINUOUS_FB_UPDATE
+            pthread_mutex_lock(&fb_update_mutex);
+            fb_update();
+            pthread_mutex_unlock(&fb_update_mutex);
+#endif
+        }
+
+
+        last = curr;
+        if(diff <= SLEEP_CONST+prevSleepTime)
+        {
+            prevSleepTime = SLEEP_CONST+prevSleepTime-diff;
+            usleep(prevSleepTime*1000);
+        }
+        else
+            prevSleepTime = 0;
+    }
+    return NULL;
+}
+
+void fb_request_draw(void)
+{
+    if(!fb_frozen)
+    {
+        atomic_int expected = ATOMIC_VAR_INIT(0);
+        atomic_compare_exchange_strong(&fb_draw_requested, &expected, 1);
+    }
+}
+
+void fb_force_draw(void)
+{
+    atomic_int expected = ATOMIC_VAR_INIT(0);
+
+    pthread_mutex_lock(&fb_draw_mutex);
+    atomic_compare_exchange_strong(&fb_draw_requested, &expected, 1);
+    pthread_cond_wait(&fb_draw_cond, &fb_draw_mutex);
+    pthread_mutex_unlock(&fb_draw_mutex);
+}
+
+int fb_save_screenshot(void)
+{
+    char *r;
+    int c, media_rw_id;
+    char dir[256];
+    char path[256];
+
+    strcpy(dir, mrom_dir());
+    r = strrchr(dir, '/');
+    if(!r)
+    {
+        ERROR("Failed to determine path to save a screenshot!\n");
+        return -1;
+    }
+    *r = 0;
+    strcat(dir, "/Pictures/Screenshots");
+    mkdir_recursive_with_perms(path, 0775, "media_rw", "media_rw");
+
+    for(c = 0; c < 999; ++c)
+    {
+        snprintf(path, sizeof(path), "%s/mrom_screenshot_%03d.png", dir, c);
+        if(access(path, F_OK) < 0)
+            break;
+    }
+
+    pthread_mutex_lock(&fb_draw_mutex);
+    if(fb_png_save_img(path, fb_width, fb_height, fb.stride, fb.buffer) >= 0)
+    {
+        media_rw_id = decode_uid("media_rw");
+        if(media_rw_id != -1)
+            chown(path, (uid_t)media_rw_id, (gid_t)media_rw_id);
+        chmod(path, 0664);
+
+        INFO("Screenshot saved to %s\n", path);
+
+        fb_fill(WHITE);
+        pthread_mutex_lock(&fb_update_mutex);
+        fb_update();
+        usleep(100000);
+        pthread_mutex_unlock(&fb_update_mutex);
+        pthread_mutex_unlock(&fb_draw_mutex);
+
+        fb_request_draw();
+        return 0;
+    }
+    else
+    {
+        pthread_mutex_unlock(&fb_draw_mutex);
+        ERROR("Failed to take screenshot!\n");
+        return -1;
+    }
+}
diff --git a/lib/framebuffer.h b/lib/framebuffer.h
index 11e08cf..66fa3f3 100755
--- a/lib/framebuffer.h
+++ b/lib/framebuffer.h
@@ -1,338 +1,338 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef H_FRAMEBUFFER
-#define H_FRAMEBUFFER
-
-#include <linux/fb.h>
-#include <stdarg.h>
-#include <pthread.h>
-
-#if defined(RECOVERY_BGRA) || defined(RECOVERY_RGBX) || defined(RECOVERY_ABGR)
-#define PIXEL_SIZE 4
-typedef uint32_t px_type;
-#else
-#define PIXEL_SIZE 2
-#ifndef RECOVERY_RGB_565
-  #define RECOVERY_RGB_565
-#endif
-typedef uint16_t px_type;
-#endif
-
-#ifdef RECOVERY_BGRA
-#define PX_IDX_A 3
-#define PX_IDX_R 2
-#define PX_IDX_G 1
-#define PX_IDX_B 0
-#define PX_GET_R(px) ((px & 0xFF0000) >> 16)
-#define PX_GET_G(px) ((px & 0xFF00) >> 8)
-#define PX_GET_B(px) ((px & 0xFF))
-#define PX_GET_A(px) ((px & 0xFF000000) >> 24)
-#elif defined(RECOVERY_RGBX)
-#define PX_IDX_A 3
-#define PX_IDX_R 0
-#define PX_IDX_G 1
-#define PX_IDX_B 2
-#define PX_GET_R(px) (px & 0xFF)
-#define PX_GET_G(px) ((px & 0xFF00) >> 8)
-#define PX_GET_B(px) ((px & 0xFF0000) >> 16)
-#define PX_GET_A(px) ((px & 0xFF000000) >> 24)
-#elif defined(RECOVERY_RGB_565)
-#define PX_GET_R(px) ((((((px & 0xF800) >> 11)*100)/31)*0xFF)/100)
-#define PX_GET_G(px) ((((((px & 0x7E0) >> 5)*100)/63)*0xFF)/100)
-#define PX_GET_B(px) (((((px & 0x1F)*100)/31)*0xFF)/100)
-#define PX_GET_A(px) (0xFF)
-#elif defined(RECOVERY_ABGR)
-#define PX_IDX_A 3
-#define PX_IDX_R 0
-#define PX_IDX_G 1
-#define PX_IDX_B 2
-#define PX_GET_R(px) ((px & 0xFF))
-#define PX_GET_G(px) ((px & 0xFF00) >> 8)
-#define PX_GET_B(px) ((px & 0xFF0000) >> 16)
-#define PX_GET_A(px) ((px & 0xFF000000) >> 24)
-#endif
-
-struct framebuffer {
-    px_type *buffer;
-    uint32_t size;
-    uint32_t stride;
-    int fd;
-    struct fb_fix_screeninfo fi;
-    struct fb_var_screeninfo vi;
-    struct fb_impl *impl;
-    void *impl_data;
-};
-
-struct fb_impl {
-    const char *name;
-    const int impl_id;
-
-    int (*open)(struct framebuffer *fb);
-    void (*close)(struct framebuffer *fb);
-    int (*update)(struct framebuffer *fb);
-    void *(*get_frame_dest)(struct framebuffer *fb);
-};
-
-enum
-{
-#ifdef MR_USE_QCOM_OVERLAY
-    FB_IMPL_QCOM_OVERLAY,
-#endif
-
-    FB_IMPL_GENERIC, // must be last
-
-    FB_IMPL_CNT
-};
-
-// Colors, 0xAARRGGBB
-#define BLACK     0xFF000000
-#define WHITE     0xFFFFFFFF
-#define LBLUE     0xFF0099CC
-#define LBLUE2    0xFFA8DFF4
-#define GRAYISH   0xFFBEBEBE
-#define GRAY      0xFF7F7F7F
-#define DRED      0xFFCC0000
-
-// Font sizes in 1/4 of a point
-enum
-{
-    SIZE_SMALL     = (7*4),
-    SIZE_NORMAL    = (10*4),
-    SIZE_BIG       = (13*4),
-    SIZE_EXTRA     = (15*4),
-};
-
-extern uint32_t fb_width;
-extern uint32_t fb_height;
-extern int fb_rotation;
-
-int fb_open(int rotation);
-int fb_open_impl(void);
-void fb_close(void);
-void fb_update(void);
-void fb_dump_info(void);
-int fb_get_vi_xres(void);
-int fb_get_vi_yres(void);
-void fb_force_generic_impl(int force);
-
-enum
-{
-    FB_IT_RECT,
-    FB_IT_IMG,
-    FB_IT_LISTVIEW,
-    FB_IT_LINE,
-};
-
-enum
-{
-    FB_IMG_TYPE_GENERIC,
-    FB_IMG_TYPE_PNG,
-    FB_IMG_TYPE_TEXT,
-};
-
-enum
-{
-    JUSTIFY_LEFT,
-    JUSTIFY_CENTER,
-    JUSTIFY_RIGHT,
-};
-
-enum
-{
-    STYLE_NORMAL,
-    STYLE_ITALIC,
-    STYLE_BOLD,
-    STYLE_BOLD_ITALIC,
-    STYLE_MEDIUM,
-    STYLE_CONDENSED,
-    STYLE_MONOSPACE,
-
-    STYLE_COUNT
-};
-
-enum
-{
-    LEVEL_LISTVIEW = 0,
-    LEVEL_RECT = 1,
-    LEVEL_CIRCLE = 1,
-    LEVEL_PNG  = 2,
-    LEVEL_LINE = 2,
-    LEVEL_TEXT = 3,
-};
-
-struct fb_item_header;
-
-#define FB_ITEM_POS \
-    int x, y; \
-    int w, h;
-
-typedef struct
-{
-    FB_ITEM_POS
-} fb_item_pos;
-
-extern fb_item_pos DEFAULT_FB_PARENT;
-
-#define FB_ITEM_HEAD \
-    FB_ITEM_POS \
-    int id; \
-    int type; \
-    int level; \
-    fb_item_pos *parent; \
-    struct fb_item_header *prev; \
-    struct fb_item_header *next;
-
-struct fb_item_header
-{
-    FB_ITEM_HEAD
-};
-typedef struct fb_item_header fb_item_header;
-
-typedef struct
-{
-    FB_ITEM_HEAD
-
-    uint32_t color;
-} fb_rect;
-
-/*
- * fb_img element draws pre-rendered image data, which can come for
- * example from a PNG file.
- * For RECOVERY_BGRA and RECOVERY_BGRX (4 bytes per px), data is just
- * array of pixels in selected px format.
- * For RECOVERY_RGB_565 (2 bytes per px), another 2 bytes with
- * alpha values are added after each pixel. So, one pixel is two uint16_t
- * entries in the result uint16_t array:
- * [0]: (R | (G << 5) | (B << 11))
- * [1]: (alphaForRB | (alphaForG << 8))
- * [2]: (R | (G << 5) | (B << 11))
- * [3]: (alphaForRB | (alphaForG << 8))
- * ...
- */
-typedef struct
-{
-    FB_ITEM_HEAD
-
-    int img_type;
-    px_type *data;
-    void *extra;
-} fb_img;
-
-typedef fb_img fb_text;
-typedef fb_img fb_circle;
-
-typedef struct
-{
-    FB_ITEM_HEAD;
-    int x2, y2;
-    int thickness;
-    uint32_t color;
-} fb_line;
-
-typedef struct
-{
-    uint32_t background_color;
-    fb_item_header *first_item;
-    pthread_mutex_t mutex;
-    volatile int batch_started;
-    volatile pthread_t batch_thread;
-} fb_context_t;
-
-typedef struct
-{
-    int x, y;
-    int level;
-    fb_item_pos *parent;
-    uint32_t color;
-    int size;
-    int justify;
-    int style;
-    char *text;
-    int wrap_w;
-} fb_text_proto;
-
-void fb_remove_item(void *item);
-int fb_generate_item_id(void);
-px_type fb_convert_color(uint32_t c);
-uint32_t fb_convert_color_img(uint32_t c);
-
-fb_img *fb_add_text(int x, int y, uint32_t color, int size, const char *fmt, ...);
-fb_text_proto *fb_text_create(int x, int y, uint32_t color, int size, const char *text);
-fb_img *fb_text_finalize(fb_text_proto *p);
-void fb_text_set_color(fb_img *img, uint32_t color);
-void fb_text_set_size(fb_img *img, int size);
-void fb_text_set_content(fb_img *img, const char *text);
-char *fb_text_get_content(fb_img *img);
-
-void fb_text_drop_cache_unused(void);
-void fb_text_destroy(fb_img *i);
-
-fb_rect *fb_add_rect_lvl(int level, int x, int y, int w, int h, uint32_t color);
-#define fb_add_rect(x, y, w, h, color) fb_add_rect_lvl(LEVEL_RECT, x, y, w, h, color)
-void fb_add_rect_notfilled(int level, int x, int y, int w, int h, uint32_t color, int thickness, fb_rect ***list);
-
-fb_img *fb_add_img(int level, int x, int y, int w, int h, int img_type, px_type *data);
-fb_img *fb_add_png_img_lvl(int level, int x, int y, int w, int h, const char *path);
-#define fb_add_png_img(x, y, w, h, path) fb_add_png_img_lvl(LEVEL_PNG, x, y, w, h, path)
-
-fb_circle *fb_add_circle_lvl(int level, int x, int y, int radius, uint32_t color);
-#define fb_add_circle(x, y, radius, color) fb_add_circle_lvl(LEVEL_CIRCLE, x, y, radius, color)
-
-fb_line *fb_add_line_lvl(int level, int x1, int y1, int x2, int y2, int thickness, uint32_t color);
-#define fb_add_line(x1, y1, x2, y2, thickness, color) fb_add_line_lvl(LEVEL_LINE, x1, y1, x2, y2, thickness, color)
-
-void fb_rm_text(fb_img *i);
-void fb_rm_rect(fb_rect *r);
-void fb_rm_img(fb_img *i);
-void fb_rm_circle(fb_circle *c);
-void fb_rm_line(fb_line *l);
-
-void fb_draw_rect(fb_rect *r);
-void fb_draw_img(fb_img *i);
-void fb_draw_line(fb_line *l);
-void fb_fill(uint32_t color);
-void fb_request_draw(void);
-void fb_force_draw(void);
-void fb_clear(void);
-void fb_freeze(int freeze);
-int fb_clone(char **buff);
-int fb_save_screenshot(void);
-void fb_set_brightness(int val);
-
-void fb_push_context(void);
-void fb_pop_context(void);
-
-void fb_batch_start(void);
-void fb_batch_end(void);
-
-void fb_ctx_add_item(void *item);
-void fb_ctx_rm_item(void *item);
-inline void fb_items_lock(void);
-inline void fb_items_unlock(void);
-void fb_set_background(uint32_t color);
-
-px_type *fb_png_get(const char *path, int w, int h);
-void fb_png_release(px_type *data);
-void fb_png_drop_unused(void);
-int fb_png_save_img(const char *path, int w, int h, int stride, px_type *data);
-
-inline void center_text(fb_img *text, int targetX, int targetY, int targetW, int targetH);
-
-int vt_set_mode(int graphics);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_FRAMEBUFFER
+#define H_FRAMEBUFFER
+
+#include <linux/fb.h>
+#include <stdarg.h>
+#include <pthread.h>
+
+#if defined(RECOVERY_BGRA) || defined(RECOVERY_RGBX) || defined(RECOVERY_ABGR)
+#define PIXEL_SIZE 4
+typedef uint32_t px_type;
+#else
+#define PIXEL_SIZE 2
+#ifndef RECOVERY_RGB_565
+  #define RECOVERY_RGB_565
+#endif
+typedef uint16_t px_type;
+#endif
+
+#ifdef RECOVERY_BGRA
+#define PX_IDX_A 3
+#define PX_IDX_R 2
+#define PX_IDX_G 1
+#define PX_IDX_B 0
+#define PX_GET_R(px) ((px & 0xFF0000) >> 16)
+#define PX_GET_G(px) ((px & 0xFF00) >> 8)
+#define PX_GET_B(px) ((px & 0xFF))
+#define PX_GET_A(px) ((px & 0xFF000000) >> 24)
+#elif defined(RECOVERY_RGBX)
+#define PX_IDX_A 3
+#define PX_IDX_R 0
+#define PX_IDX_G 1
+#define PX_IDX_B 2
+#define PX_GET_R(px) (px & 0xFF)
+#define PX_GET_G(px) ((px & 0xFF00) >> 8)
+#define PX_GET_B(px) ((px & 0xFF0000) >> 16)
+#define PX_GET_A(px) ((px & 0xFF000000) >> 24)
+#elif defined(RECOVERY_RGB_565)
+#define PX_GET_R(px) ((((((px & 0xF800) >> 11)*100)/31)*0xFF)/100)
+#define PX_GET_G(px) ((((((px & 0x7E0) >> 5)*100)/63)*0xFF)/100)
+#define PX_GET_B(px) (((((px & 0x1F)*100)/31)*0xFF)/100)
+#define PX_GET_A(px) (0xFF)
+#elif defined(RECOVERY_ABGR)
+#define PX_IDX_A 3
+#define PX_IDX_R 0
+#define PX_IDX_G 1
+#define PX_IDX_B 2
+#define PX_GET_R(px) ((px & 0xFF))
+#define PX_GET_G(px) ((px & 0xFF00) >> 8)
+#define PX_GET_B(px) ((px & 0xFF0000) >> 16)
+#define PX_GET_A(px) ((px & 0xFF000000) >> 24)
+#endif
+
+struct framebuffer {
+    px_type *buffer;
+    uint32_t size;
+    uint32_t stride;
+    int fd;
+    struct fb_fix_screeninfo fi;
+    struct fb_var_screeninfo vi;
+    struct fb_impl *impl;
+    void *impl_data;
+};
+
+struct fb_impl {
+    const char *name;
+    const int impl_id;
+
+    int (*open)(struct framebuffer *fb);
+    void (*close)(struct framebuffer *fb);
+    int (*update)(struct framebuffer *fb);
+    void *(*get_frame_dest)(struct framebuffer *fb);
+};
+
+enum
+{
+#ifdef MR_USE_QCOM_OVERLAY
+    FB_IMPL_QCOM_OVERLAY,
+#endif
+
+    FB_IMPL_GENERIC, // must be last
+
+    FB_IMPL_CNT
+};
+
+// Colors, 0xAARRGGBB
+#define BLACK     0xFF000000
+#define WHITE     0xFFFFFFFF
+#define LBLUE     0xFF0099CC
+#define LBLUE2    0xFFA8DFF4
+#define GRAYISH   0xFFBEBEBE
+#define GRAY      0xFF7F7F7F
+#define DRED      0xFFCC0000
+
+// Font sizes in 1/4 of a point
+enum
+{
+    SIZE_SMALL     = (7*4),
+    SIZE_NORMAL    = (10*4),
+    SIZE_BIG       = (13*4),
+    SIZE_EXTRA     = (15*4),
+};
+
+extern uint32_t fb_width;
+extern uint32_t fb_height;
+extern int fb_rotation;
+
+int fb_open(int rotation);
+int fb_open_impl(void);
+void fb_close(void);
+void fb_update(void);
+void fb_dump_info(void);
+int fb_get_vi_xres(void);
+int fb_get_vi_yres(void);
+void fb_force_generic_impl(int force);
+
+enum
+{
+    FB_IT_RECT,
+    FB_IT_IMG,
+    FB_IT_LISTVIEW,
+    FB_IT_LINE,
+};
+
+enum
+{
+    FB_IMG_TYPE_GENERIC,
+    FB_IMG_TYPE_PNG,
+    FB_IMG_TYPE_TEXT,
+};
+
+enum
+{
+    JUSTIFY_LEFT,
+    JUSTIFY_CENTER,
+    JUSTIFY_RIGHT,
+};
+
+enum
+{
+    STYLE_NORMAL,
+    STYLE_ITALIC,
+    STYLE_BOLD,
+    STYLE_BOLD_ITALIC,
+    STYLE_MEDIUM,
+    STYLE_CONDENSED,
+    STYLE_MONOSPACE,
+
+    STYLE_COUNT
+};
+
+enum
+{
+    LEVEL_LISTVIEW = 0,
+    LEVEL_RECT = 1,
+    LEVEL_CIRCLE = 1,
+    LEVEL_PNG  = 2,
+    LEVEL_LINE = 2,
+    LEVEL_TEXT = 3,
+};
+
+struct fb_item_header;
+
+#define FB_ITEM_POS \
+    int x, y; \
+    int w, h;
+
+typedef struct
+{
+    FB_ITEM_POS
+} fb_item_pos;
+
+extern fb_item_pos DEFAULT_FB_PARENT;
+
+#define FB_ITEM_HEAD \
+    FB_ITEM_POS \
+    int id; \
+    int type; \
+    int level; \
+    fb_item_pos *parent; \
+    struct fb_item_header *prev; \
+    struct fb_item_header *next;
+
+struct fb_item_header
+{
+    FB_ITEM_HEAD
+};
+typedef struct fb_item_header fb_item_header;
+
+typedef struct
+{
+    FB_ITEM_HEAD
+
+    uint32_t color;
+} fb_rect;
+
+/*
+ * fb_img element draws pre-rendered image data, which can come for
+ * example from a PNG file.
+ * For RECOVERY_BGRA and RECOVERY_BGRX (4 bytes per px), data is just
+ * array of pixels in selected px format.
+ * For RECOVERY_RGB_565 (2 bytes per px), another 2 bytes with
+ * alpha values are added after each pixel. So, one pixel is two uint16_t
+ * entries in the result uint16_t array:
+ * [0]: (R | (G << 5) | (B << 11))
+ * [1]: (alphaForRB | (alphaForG << 8))
+ * [2]: (R | (G << 5) | (B << 11))
+ * [3]: (alphaForRB | (alphaForG << 8))
+ * ...
+ */
+typedef struct
+{
+    FB_ITEM_HEAD
+
+    int img_type;
+    px_type *data;
+    void *extra;
+} fb_img;
+
+typedef fb_img fb_text;
+typedef fb_img fb_circle;
+
+typedef struct
+{
+    FB_ITEM_HEAD;
+    int x2, y2;
+    int thickness;
+    uint32_t color;
+} fb_line;
+
+typedef struct
+{
+    uint32_t background_color;
+    fb_item_header *first_item;
+    pthread_mutex_t mutex;
+    volatile int batch_started;
+    volatile pthread_t batch_thread;
+} fb_context_t;
+
+typedef struct
+{
+    int x, y;
+    int level;
+    fb_item_pos *parent;
+    uint32_t color;
+    int size;
+    int justify;
+    int style;
+    char *text;
+    int wrap_w;
+} fb_text_proto;
+
+void fb_remove_item(void *item);
+int fb_generate_item_id(void);
+px_type fb_convert_color(uint32_t c);
+uint32_t fb_convert_color_img(uint32_t c);
+
+fb_img *fb_add_text(int x, int y, uint32_t color, int size, const char *fmt, ...);
+fb_text_proto *fb_text_create(int x, int y, uint32_t color, int size, const char *text);
+fb_img *fb_text_finalize(fb_text_proto *p);
+void fb_text_set_color(fb_img *img, uint32_t color);
+void fb_text_set_size(fb_img *img, int size);
+void fb_text_set_content(fb_img *img, const char *text);
+char *fb_text_get_content(fb_img *img);
+
+void fb_text_drop_cache_unused(void);
+void fb_text_destroy(fb_img *i);
+
+fb_rect *fb_add_rect_lvl(int level, int x, int y, int w, int h, uint32_t color);
+#define fb_add_rect(x, y, w, h, color) fb_add_rect_lvl(LEVEL_RECT, x, y, w, h, color)
+void fb_add_rect_notfilled(int level, int x, int y, int w, int h, uint32_t color, int thickness, fb_rect ***list);
+
+fb_img *fb_add_img(int level, int x, int y, int w, int h, int img_type, px_type *data);
+fb_img *fb_add_png_img_lvl(int level, int x, int y, int w, int h, const char *path);
+#define fb_add_png_img(x, y, w, h, path) fb_add_png_img_lvl(LEVEL_PNG, x, y, w, h, path)
+
+fb_circle *fb_add_circle_lvl(int level, int x, int y, int radius, uint32_t color);
+#define fb_add_circle(x, y, radius, color) fb_add_circle_lvl(LEVEL_CIRCLE, x, y, radius, color)
+
+fb_line *fb_add_line_lvl(int level, int x1, int y1, int x2, int y2, int thickness, uint32_t color);
+#define fb_add_line(x1, y1, x2, y2, thickness, color) fb_add_line_lvl(LEVEL_LINE, x1, y1, x2, y2, thickness, color)
+
+void fb_rm_text(fb_img *i);
+void fb_rm_rect(fb_rect *r);
+void fb_rm_img(fb_img *i);
+void fb_rm_circle(fb_circle *c);
+void fb_rm_line(fb_line *l);
+
+void fb_draw_rect(fb_rect *r);
+void fb_draw_img(fb_img *i);
+void fb_draw_line(fb_line *l);
+void fb_fill(uint32_t color);
+void fb_request_draw(void);
+void fb_force_draw(void);
+void fb_clear(void);
+void fb_freeze(int freeze);
+int fb_clone(char **buff);
+int fb_save_screenshot(void);
+void fb_set_brightness(int val);
+
+void fb_push_context(void);
+void fb_pop_context(void);
+
+void fb_batch_start(void);
+void fb_batch_end(void);
+
+void fb_ctx_add_item(void *item);
+void fb_ctx_rm_item(void *item);
+inline void fb_items_lock(void);
+inline void fb_items_unlock(void);
+void fb_set_background(uint32_t color);
+
+px_type *fb_png_get(const char *path, int w, int h);
+void fb_png_release(px_type *data);
+void fb_png_drop_unused(void);
+int fb_png_save_img(const char *path, int w, int h, int stride, px_type *data);
+
+inline void center_text(fb_img *text, int targetX, int targetY, int targetW, int targetH);
+
+int vt_set_mode(int graphics);
+
+#endif
diff --git a/lib/framebuffer_generic.c b/lib/framebuffer_generic.c
index 44bf286..18e1b31 100755
--- a/lib/framebuffer_generic.c
+++ b/lib/framebuffer_generic.c
@@ -1,176 +1,176 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-#include <string.h>
-#include <linux/fb.h>
-
-#include "framebuffer.h"
-#include "log.h"
-#include "util.h"
-
-// only double-buffering is implemented, this define is just
-// for the code to know how many buffers we use
-#define NUM_BUFFERS 2
-
-struct fb_generic_data {
-    px_type *mapped[NUM_BUFFERS];
-    int active_buff;
-};
-
-static int impl_open(struct framebuffer *fb)
-{
-    fb->vi.bits_per_pixel = PIXEL_SIZE * 8;
-    INFO("Pixel format: %dx%d @ %dbpp\n", fb->vi.xres, fb->vi.yres, fb->vi.bits_per_pixel);
-
-#ifdef RECOVERY_BGRA
-    INFO("Pixel format: BGRA_8888\n");
-    fb->vi.red.offset     = 8;
-    fb->vi.red.length     = 8;
-    fb->vi.green.offset   = 16;
-    fb->vi.green.length   = 8;
-    fb->vi.blue.offset    = 24;
-    fb->vi.blue.length    = 8;
-    fb->vi.transp.offset  = 0;
-    fb->vi.transp.length  = 8;
-#elif  defined(RECOVERY_RGBX)
-    INFO("Pixel format: RGBX_8888\n");
-    fb->vi.red.offset     = 24;
-    fb->vi.red.length     = 8;
-    fb->vi.green.offset   = 16;
-    fb->vi.green.length   = 8;
-    fb->vi.blue.offset    = 8;
-    fb->vi.blue.length    = 8;
-    fb->vi.transp.offset  = 0;
-    fb->vi.transp.length  = 8;
-#elif defined(RECOVERY_RGB_565)
-    INFO("Pixel format: RGB_565\n");
-    fb->vi.blue.offset    = 0;
-    fb->vi.green.offset   = 5;
-    fb->vi.red.offset     = 11;
-    fb->vi.blue.length    = 5;
-    fb->vi.green.length   = 6;
-    fb->vi.red.length     = 5;
-    fb->vi.blue.msb_right = 0;
-    fb->vi.green.msb_right = 0;
-    fb->vi.red.msb_right = 0;
-    fb->vi.transp.offset  = 0;
-    fb->vi.transp.length  = 0;
-#elif defined(RECOVERY_ABGR)
-    INFO("Pixel format: ABGR_8888\n");
-    fb->vi.red.offset     = 0;
-    fb->vi.red.length     = 8;
-    fb->vi.green.offset   = 8;
-    fb->vi.green.length   = 8;
-    fb->vi.blue.offset    = 16;
-    fb->vi.blue.length    = 8;
-    fb->vi.transp.offset  = 24;
-    fb->vi.transp.length  = 8;
-#else
-#error "Unknown pixel format"
-#endif
-
-    fb->vi.vmode = FB_VMODE_NONINTERLACED;
-    fb->vi.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
-
-    // mmap and memset to 0 before setting the vi to prevent screen flickering during init
-    px_type *mapped = mmap(0, fb->fi.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb->fd, 0);
-
-    if (mapped == MAP_FAILED)
-        return -1;
-
-    memset(mapped, 0, fb->fi.smem_len);
-    munmap(mapped, fb->fi.smem_len);
-
-    if (ioctl(fb->fd, FBIOPUT_VSCREENINFO, &fb->vi) < 0)
-    {
-        ERROR("failed to set fb0 vi info");
-        return -1;
-    }
-
-    if (ioctl(fb->fd, FBIOGET_FSCREENINFO, &fb->fi) < 0)
-        return -1;
-
-    mapped = mmap(0, fb->fi.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb->fd, 0);
-
-    if (mapped == MAP_FAILED)
-        return -1;
-
-    struct fb_generic_data *data = mzalloc(sizeof(struct fb_generic_data));
-    data->mapped[0] = mapped;
-    data->mapped[1] = (px_type*) (((uint8_t*)mapped) + (fb->vi.yres * fb->fi.line_length));
-
-    fb->impl_data = data;
-
-#ifdef TW_SCREEN_BLANK_ON_BOOT
-    ioctl(fb->fd, FBIOBLANK, FB_BLANK_POWERDOWN);
-    ioctl(fb->fd, FBIOBLANK, FB_BLANK_UNBLANK);
-#endif
-
-    return 0;
-}
-
-static void impl_close(struct framebuffer *fb)
-{
-    struct fb_generic_data *data = fb->impl_data;
-    if(data)
-    {
-        munmap(data->mapped[0], fb->fi.smem_len);
-        free(data);
-        fb->impl_data = NULL;
-    }
-}
-
-static int impl_update(struct framebuffer *fb)
-{
-    struct fb_generic_data *data = fb->impl_data;
-
-    fb->vi.yres_virtual = fb->vi.yres * NUM_BUFFERS;
-    fb->vi.yoffset = data->active_buff * fb->vi.yres;
-
-    if (ioctl(fb->fd, FBIOPUT_VSCREENINFO, &fb->vi) < 0)
-    {
-        ERROR("active fb swap failed");
-        return -1;
-    }
-
-    return 0;
-}
-
-static void *impl_get_frame_dest(struct framebuffer *fb)
-{
-    struct fb_generic_data *data = fb->impl_data;
-    data->active_buff = !data->active_buff;
-    return data->mapped[data->active_buff];
-}
-
-const struct fb_impl fb_impl_generic = {
-    .name = "Generic",
-    .impl_id = FB_IMPL_GENERIC,
-
-    .open = impl_open,
-    .close = impl_close,
-    .update = impl_update,
-    .get_frame_dest = impl_get_frame_dest,
-};
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <linux/fb.h>
+
+#include "framebuffer.h"
+#include "log.h"
+#include "util.h"
+
+// only double-buffering is implemented, this define is just
+// for the code to know how many buffers we use
+#define NUM_BUFFERS 2
+
+struct fb_generic_data {
+    px_type *mapped[NUM_BUFFERS];
+    int active_buff;
+};
+
+static int impl_open(struct framebuffer *fb)
+{
+    fb->vi.bits_per_pixel = PIXEL_SIZE * 8;
+    INFO("Pixel format: %dx%d @ %dbpp\n", fb->vi.xres, fb->vi.yres, fb->vi.bits_per_pixel);
+
+#ifdef RECOVERY_BGRA
+    INFO("Pixel format: BGRA_8888\n");
+    fb->vi.red.offset     = 8;
+    fb->vi.red.length     = 8;
+    fb->vi.green.offset   = 16;
+    fb->vi.green.length   = 8;
+    fb->vi.blue.offset    = 24;
+    fb->vi.blue.length    = 8;
+    fb->vi.transp.offset  = 0;
+    fb->vi.transp.length  = 8;
+#elif  defined(RECOVERY_RGBX)
+    INFO("Pixel format: RGBX_8888\n");
+    fb->vi.red.offset     = 24;
+    fb->vi.red.length     = 8;
+    fb->vi.green.offset   = 16;
+    fb->vi.green.length   = 8;
+    fb->vi.blue.offset    = 8;
+    fb->vi.blue.length    = 8;
+    fb->vi.transp.offset  = 0;
+    fb->vi.transp.length  = 8;
+#elif defined(RECOVERY_RGB_565)
+    INFO("Pixel format: RGB_565\n");
+    fb->vi.blue.offset    = 0;
+    fb->vi.green.offset   = 5;
+    fb->vi.red.offset     = 11;
+    fb->vi.blue.length    = 5;
+    fb->vi.green.length   = 6;
+    fb->vi.red.length     = 5;
+    fb->vi.blue.msb_right = 0;
+    fb->vi.green.msb_right = 0;
+    fb->vi.red.msb_right = 0;
+    fb->vi.transp.offset  = 0;
+    fb->vi.transp.length  = 0;
+#elif defined(RECOVERY_ABGR)
+    INFO("Pixel format: ABGR_8888\n");
+    fb->vi.red.offset     = 0;
+    fb->vi.red.length     = 8;
+    fb->vi.green.offset   = 8;
+    fb->vi.green.length   = 8;
+    fb->vi.blue.offset    = 16;
+    fb->vi.blue.length    = 8;
+    fb->vi.transp.offset  = 24;
+    fb->vi.transp.length  = 8;
+#else
+#error "Unknown pixel format"
+#endif
+
+    fb->vi.vmode = FB_VMODE_NONINTERLACED;
+    fb->vi.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_FORCE;
+
+    // mmap and memset to 0 before setting the vi to prevent screen flickering during init
+    px_type *mapped = mmap(0, fb->fi.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb->fd, 0);
+
+    if (mapped == MAP_FAILED)
+        return -1;
+
+    memset(mapped, 0, fb->fi.smem_len);
+    munmap(mapped, fb->fi.smem_len);
+
+    if (ioctl(fb->fd, FBIOPUT_VSCREENINFO, &fb->vi) < 0)
+    {
+        ERROR("failed to set fb0 vi info");
+        return -1;
+    }
+
+    if (ioctl(fb->fd, FBIOGET_FSCREENINFO, &fb->fi) < 0)
+        return -1;
+
+    mapped = mmap(0, fb->fi.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb->fd, 0);
+
+    if (mapped == MAP_FAILED)
+        return -1;
+
+    struct fb_generic_data *data = mzalloc(sizeof(struct fb_generic_data));
+    data->mapped[0] = mapped;
+    data->mapped[1] = (px_type*) (((uint8_t*)mapped) + (fb->vi.yres * fb->fi.line_length));
+
+    fb->impl_data = data;
+
+#ifdef TW_SCREEN_BLANK_ON_BOOT
+    ioctl(fb->fd, FBIOBLANK, FB_BLANK_POWERDOWN);
+    ioctl(fb->fd, FBIOBLANK, FB_BLANK_UNBLANK);
+#endif
+
+    return 0;
+}
+
+static void impl_close(struct framebuffer *fb)
+{
+    struct fb_generic_data *data = fb->impl_data;
+    if(data)
+    {
+        munmap(data->mapped[0], fb->fi.smem_len);
+        free(data);
+        fb->impl_data = NULL;
+    }
+}
+
+static int impl_update(struct framebuffer *fb)
+{
+    struct fb_generic_data *data = fb->impl_data;
+
+    fb->vi.yres_virtual = fb->vi.yres * NUM_BUFFERS;
+    fb->vi.yoffset = data->active_buff * fb->vi.yres;
+
+    if (ioctl(fb->fd, FBIOPUT_VSCREENINFO, &fb->vi) < 0)
+    {
+        ERROR("active fb swap failed");
+        return -1;
+    }
+
+    return 0;
+}
+
+static void *impl_get_frame_dest(struct framebuffer *fb)
+{
+    struct fb_generic_data *data = fb->impl_data;
+    data->active_buff = !data->active_buff;
+    return data->mapped[data->active_buff];
+}
+
+const struct fb_impl fb_impl_generic = {
+    .name = "Generic",
+    .impl_id = FB_IMPL_GENERIC,
+
+    .open = impl_open,
+    .close = impl_close,
+    .update = impl_update,
+    .get_frame_dest = impl_get_frame_dest,
+};
diff --git a/lib/framebuffer_png.c b/lib/framebuffer_png.c
index a90b6bf..646b7d1 100755
--- a/lib/framebuffer_png.c
+++ b/lib/framebuffer_png.c
@@ -1,365 +1,365 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <errno.h>
-#include <string.h>
-#include <signal.h>
-#include <pthread.h>
-#include <png.h>
-
-#include "log.h"
-#include "framebuffer.h"
-#include "util.h"
-#include "containers.h"
-
-#if 0
-#define PNG_LOG(x...) INFO(x)
-#else
-#define PNG_LOG(x...) ;
-#endif
-
-struct png_cache_entry
-{
-    char *path;
-    px_type *data;
-    int width;
-    int height;
-    int refcnt;
-};
-
-static struct png_cache_entry **png_cache = NULL;
-
-// http://willperone.net/Code/codescaling.php
-static px_type *scale_png_img(px_type *fi_data, int orig_w, int orig_h, int new_w, int new_h)
-{
-    if(orig_w == new_w && orig_h == new_h)
-        return fi_data;
-
-    uint32_t *in = (uint32_t*)fi_data;
-#if PIXEL_SIZE == 2
-    // need another byte for alpha. Make it 4 to make it simpler
-    uint32_t *out = malloc(4 * new_w * new_h);
-#else
-    uint32_t *out = malloc(PIXEL_SIZE * new_w * new_h);
-#endif
-
-    const int YD = (orig_h / new_h) * orig_w - orig_w;
-    const int YR = orig_h % new_h;
-    const int XD = orig_w / new_w;
-    const int XR = orig_w % new_w;
-    int in_off = 0, out_off = 0;
-    int x, y, YE, XE;
-
-    for(y = new_h, YE = 0; y > 0; --y)
-    {
-        for(x = new_w, XE = 0; x > 0; --x)
-        {
-            out[out_off++] = in[in_off];
-            in_off += XD;
-            XE += XR;
-            if(XE >= new_w)
-            {
-                XE -= new_w;
-                ++in_off;
-            }
-        }
-        in_off += YD;
-        YE += YR;
-        if(YE >= new_h)
-        {
-            YE -= new_h;
-            in_off += orig_w;
-        }
-    }
-
-    free(fi_data);
-    return (px_type*)out;
-}
-
-static px_type *load_png(const char *path, int destW, int destH)
-{
-    FILE *fp;
-    unsigned char header[8];
-    png_structp png_ptr = NULL;
-    png_infop info_ptr = NULL;
-    uint32_t bytes_per_row;
-    px_type *data_dest = NULL, *data_itr;
-    size_t i, y;
-    int si, alpha;
-    int px_per_row;
-    uint32_t src_pix;
-    png_bytep *rows = NULL;
-
-    fp = fopen(path, "rbe");
-    if(!fp)
-        return NULL;
-
-    size_t bytesRead = fread(header, 1, sizeof(header), fp);
-    if (bytesRead != sizeof(header)) {
-        goto exit;
-    }
-
-    if (png_sig_cmp(header, 0, sizeof(header))) {
-        goto exit;
-    }
-
-    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-    if (!png_ptr) {
-        goto exit;
-    }
-
-    info_ptr = png_create_info_struct(png_ptr);
-    if (!info_ptr) {
-        goto exit;
-    }
-
-    if (setjmp(png_jmpbuf(png_ptr))) {
-        goto exit;
-    }
-
-    png_set_packing(png_ptr);
-
-    png_init_io(png_ptr, fp);
-    png_set_sig_bytes(png_ptr, sizeof(header));
-    png_read_info(png_ptr, info_ptr);
-
-    png_uint_32 width, height;
-    size_t stride, pixelSize;
-    int color_type, bit_depth, channels;
-
-    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
-            NULL, NULL, NULL);
-
-    channels = png_get_channels(png_ptr, info_ptr);
-    stride = 4 * width;
-    pixelSize = stride * height;
-
-    if (!(bit_depth == 8 &&
-          ((channels == 3 && color_type == PNG_COLOR_TYPE_RGB) ||
-           (channels == 4 && color_type == PNG_COLOR_TYPE_RGBA)))) {
-        goto exit;
-    }
-
-    if (color_type == PNG_COLOR_TYPE_PALETTE)
-        png_set_palette_to_rgb(png_ptr);
-
-    png_set_interlace_handling(png_ptr);
-    png_read_update_info(png_ptr, info_ptr);
-
-#if PIXEL_SIZE == 2
-    // need another byte for alpha. Make it 4 to make it simpler
-    data_dest = malloc(4 * width * height);
-#else
-    data_dest = malloc(PIXEL_SIZE * width * height);
-#endif
-    data_itr = data_dest;
-
-    bytes_per_row = png_get_rowbytes(png_ptr, info_ptr);
-    rows = malloc(sizeof(png_bytep)*height);
-    for(y = 0; y < height; ++y)
-        rows[y] = malloc(bytes_per_row);
-    png_read_image(png_ptr, rows);
-
-    for(y = 0; y < height; ++y)
-    {
-        for(i = 0, si = 0; i < width; ++i)
-        {
-            if(channels == 4)
-            {
-                src_pix = ((uint32_t*)rows[y])[i];
-                src_pix = (src_pix & 0xFF00FF00) | ((src_pix & 0xFF0000) >> 16) | ((src_pix & 0xFF) << 16);
-            }
-            else //if(channels == 3) - no other option
-            {
-                src_pix = (rows[y][si++] << 16);  // R
-                src_pix |= (rows[y][si++] << 8);  // G
-                src_pix |= (rows[y][si++]);       // B
-                src_pix |= 0xFF000000;             // A
-            }
-
-            *data_itr = (px_type)fb_convert_color(src_pix);
-            ++data_itr;
-#if PIXEL_SIZE == 2
-            // Store alpha value for 5 and 6 bit values in next two bytes
-            alpha = ((src_pix & 0xFF000000) >> 24);
-            ((uint8_t*)data_itr)[0] = ((((alpha*100)/0xFF)*31)/100);
-            ((uint8_t*)data_itr)[1] = ((((alpha*100)/0xFF)*63)/100);
-            ++data_itr;
-#endif
-        }
-        free(rows[y]);
-    }
-    free(rows);
-
-    data_dest = scale_png_img(data_dest, width, height, destW, destH);
-exit:
-    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
-    fclose(fp);
-
-    return data_dest;
-}
-
-static void destroy_png_cache_entry(void *entry)
-{
-    struct png_cache_entry *e = (struct png_cache_entry*)entry;
-    free(e->path);
-    free(e->data);
-    free(e);
-}
-
-px_type *fb_png_get(const char *path, int w, int h)
-{
-    // Try to find it in cache
-    struct png_cache_entry **itr;
-    for(itr = png_cache; itr && *itr; ++itr)
-    {
-        if((*itr)->width == w && (*itr)->height == h && strcmp(path, (*itr)->path) == 0)
-        {
-            ++(*itr)->refcnt;
-            PNG_LOG("PNG %s (%dx%d) %p found in cache, refcnt increased to %d\n", path, w, h, (*itr)->data, (*itr)->refcnt);
-            return (*itr)->data;
-        }
-    }
-
-    // not in cache yet, load and create cache entry
-    px_type *data = load_png(path, w, h);
-    if(!data)
-    {
-        PNG_LOG("PNG %s (%dx%d) failed to load\n", path, w, h);
-        return NULL;
-    }
-    PNG_LOG("PNG %s (%dx%d) loaded\n", path, w, h);
-
-    struct png_cache_entry *e = mzalloc(sizeof(struct png_cache_entry));
-    e->path = strdup(path);
-    e->data = data;
-    e->width = w;
-    e->height = h;
-    e->refcnt = 1;
-
-    list_add(&png_cache, e);
-    PNG_LOG("PNG %s (%dx%d) %p added into cache\n", path, w, h, data);
-    return data;
-}
-
-void fb_png_release(px_type *data)
-{
-    struct png_cache_entry **itr;
-    for(itr = png_cache; itr && *itr; ++itr)
-    {
-        if((*itr)->data == data)
-        {
-            --(*itr)->refcnt;
-            PNG_LOG("PNG %s (%dx%d) %p released, refcnt is %d\n", (*itr)->path, (*itr)->width, (*itr)->height, data, (*itr)->refcnt);
-            return;
-        }
-    }
-    PNG_LOG("PNG %p not found in cache!\n", data);
-}
-
-void fb_png_drop_unused(void)
-{
-    struct png_cache_entry **itr;
-    for(itr = png_cache; itr && *itr;)
-    {
-        if((*itr)->refcnt <= 0)
-        {
-            PNG_LOG("PNG %s (%dx%d) %p removed from cache\n", (*itr)->path, (*itr)->width, (*itr)->height, data);
-            list_rm(&png_cache, *itr, &destroy_png_cache_entry);
-            itr = png_cache;
-        }
-        else
-        {
-            ++itr;
-        }
-    }
-}
-
-static inline void convert_fb_px_to_rgb888(px_type src, uint8_t *dest)
-{
-    dest[0] = PX_GET_R(src);
-    dest[1] = PX_GET_G(src);
-    dest[2] = PX_GET_B(src);
-}
-
-int fb_png_save_img(const char *path, int w, int h, int stride, px_type *data)
-{
-    FILE *fp = NULL;
-    png_structp png_ptr = NULL;
-    png_infop info_ptr = NULL;
-    int res = -1;
-    int y, x;
-    uint8_t *row = NULL;
-    const int stride_leftover = stride - w;
-    const int w_png_bytes = w * 3;
-    px_type * volatile itr = data;
-
-    fp = fopen(path, "we");
-    if(!fp)
-    {
-        ERROR("Failed to open %s for writing\n", path);
-        return -1;
-    }
-
-    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-    if (!png_ptr)
-        goto exit;
-
-    info_ptr = png_create_info_struct(png_ptr);
-    if (info_ptr == NULL)
-        goto exit;
-
-    if (setjmp(png_jmpbuf(png_ptr)))
-        goto exit;
-
-    png_init_io(png_ptr, fp);
-    png_set_IHDR(png_ptr, info_ptr, w, h,
-         8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,
-         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
-    png_write_info(png_ptr, info_ptr);
-
-    row = malloc(w*3);
-    for(y = 0; y < h; ++y)
-    {
-        for(x = 0; x < w_png_bytes; x += 3)
-        {
-            convert_fb_px_to_rgb888(*itr, row + x);
-            ++itr;
-        }
-        itr += stride_leftover;
-
-        png_write_row(png_ptr, row);
-    }
-
-    png_write_end(png_ptr, NULL);
-    res = 0;
-exit:
-    if(info_ptr)
-        png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
-    if(png_ptr)
-        png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
-    if(fp)
-        fclose(fp);
-    if(row)
-        free(row);
-    return res;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <string.h>
+#include <signal.h>
+#include <pthread.h>
+#include <png.h>
+
+#include "log.h"
+#include "framebuffer.h"
+#include "util.h"
+#include "containers.h"
+
+#if 0
+#define PNG_LOG(x...) INFO(x)
+#else
+#define PNG_LOG(x...) ;
+#endif
+
+struct png_cache_entry
+{
+    char *path;
+    px_type *data;
+    int width;
+    int height;
+    int refcnt;
+};
+
+static struct png_cache_entry **png_cache = NULL;
+
+// http://willperone.net/Code/codescaling.php
+static px_type *scale_png_img(px_type *fi_data, int orig_w, int orig_h, int new_w, int new_h)
+{
+    if(orig_w == new_w && orig_h == new_h)
+        return fi_data;
+
+    uint32_t *in = (uint32_t*)fi_data;
+#if PIXEL_SIZE == 2
+    // need another byte for alpha. Make it 4 to make it simpler
+    uint32_t *out = malloc(4 * new_w * new_h);
+#else
+    uint32_t *out = malloc(PIXEL_SIZE * new_w * new_h);
+#endif
+
+    const int YD = (orig_h / new_h) * orig_w - orig_w;
+    const int YR = orig_h % new_h;
+    const int XD = orig_w / new_w;
+    const int XR = orig_w % new_w;
+    int in_off = 0, out_off = 0;
+    int x, y, YE, XE;
+
+    for(y = new_h, YE = 0; y > 0; --y)
+    {
+        for(x = new_w, XE = 0; x > 0; --x)
+        {
+            out[out_off++] = in[in_off];
+            in_off += XD;
+            XE += XR;
+            if(XE >= new_w)
+            {
+                XE -= new_w;
+                ++in_off;
+            }
+        }
+        in_off += YD;
+        YE += YR;
+        if(YE >= new_h)
+        {
+            YE -= new_h;
+            in_off += orig_w;
+        }
+    }
+
+    free(fi_data);
+    return (px_type*)out;
+}
+
+static px_type *load_png(const char *path, int destW, int destH)
+{
+    FILE *fp;
+    unsigned char header[8];
+    png_structp png_ptr = NULL;
+    png_infop info_ptr = NULL;
+    uint32_t bytes_per_row;
+    px_type *data_dest = NULL, *data_itr;
+    size_t i, y;
+    int si, alpha;
+    int px_per_row;
+    uint32_t src_pix;
+    png_bytep *rows = NULL;
+
+    fp = fopen(path, "rbe");
+    if(!fp)
+        return NULL;
+
+    size_t bytesRead = fread(header, 1, sizeof(header), fp);
+    if (bytesRead != sizeof(header)) {
+        goto exit;
+    }
+
+    if (png_sig_cmp(header, 0, sizeof(header))) {
+        goto exit;
+    }
+
+    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+    if (!png_ptr) {
+        goto exit;
+    }
+
+    info_ptr = png_create_info_struct(png_ptr);
+    if (!info_ptr) {
+        goto exit;
+    }
+
+    if (setjmp(png_jmpbuf(png_ptr))) {
+        goto exit;
+    }
+
+    png_set_packing(png_ptr);
+
+    png_init_io(png_ptr, fp);
+    png_set_sig_bytes(png_ptr, sizeof(header));
+    png_read_info(png_ptr, info_ptr);
+
+    png_uint_32 width, height;
+    size_t stride, pixelSize;
+    int color_type, bit_depth, channels;
+
+    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
+            NULL, NULL, NULL);
+
+    channels = png_get_channels(png_ptr, info_ptr);
+    stride = 4 * width;
+    pixelSize = stride * height;
+
+    if (!(bit_depth == 8 &&
+          ((channels == 3 && color_type == PNG_COLOR_TYPE_RGB) ||
+           (channels == 4 && color_type == PNG_COLOR_TYPE_RGBA)))) {
+        goto exit;
+    }
+
+    if (color_type == PNG_COLOR_TYPE_PALETTE)
+        png_set_palette_to_rgb(png_ptr);
+
+    png_set_interlace_handling(png_ptr);
+    png_read_update_info(png_ptr, info_ptr);
+
+#if PIXEL_SIZE == 2
+    // need another byte for alpha. Make it 4 to make it simpler
+    data_dest = malloc(4 * width * height);
+#else
+    data_dest = malloc(PIXEL_SIZE * width * height);
+#endif
+    data_itr = data_dest;
+
+    bytes_per_row = png_get_rowbytes(png_ptr, info_ptr);
+    rows = malloc(sizeof(png_bytep)*height);
+    for(y = 0; y < height; ++y)
+        rows[y] = malloc(bytes_per_row);
+    png_read_image(png_ptr, rows);
+
+    for(y = 0; y < height; ++y)
+    {
+        for(i = 0, si = 0; i < width; ++i)
+        {
+            if(channels == 4)
+            {
+                src_pix = ((uint32_t*)rows[y])[i];
+                src_pix = (src_pix & 0xFF00FF00) | ((src_pix & 0xFF0000) >> 16) | ((src_pix & 0xFF) << 16);
+            }
+            else //if(channels == 3) - no other option
+            {
+                src_pix = (rows[y][si++] << 16);  // R
+                src_pix |= (rows[y][si++] << 8);  // G
+                src_pix |= (rows[y][si++]);       // B
+                src_pix |= 0xFF000000;             // A
+            }
+
+            *data_itr = (px_type)fb_convert_color(src_pix);
+            ++data_itr;
+#if PIXEL_SIZE == 2
+            // Store alpha value for 5 and 6 bit values in next two bytes
+            alpha = ((src_pix & 0xFF000000) >> 24);
+            ((uint8_t*)data_itr)[0] = ((((alpha*100)/0xFF)*31)/100);
+            ((uint8_t*)data_itr)[1] = ((((alpha*100)/0xFF)*63)/100);
+            ++data_itr;
+#endif
+        }
+        free(rows[y]);
+    }
+    free(rows);
+
+    data_dest = scale_png_img(data_dest, width, height, destW, destH);
+exit:
+    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+    fclose(fp);
+
+    return data_dest;
+}
+
+static void destroy_png_cache_entry(void *entry)
+{
+    struct png_cache_entry *e = (struct png_cache_entry*)entry;
+    free(e->path);
+    free(e->data);
+    free(e);
+}
+
+px_type *fb_png_get(const char *path, int w, int h)
+{
+    // Try to find it in cache
+    struct png_cache_entry **itr;
+    for(itr = png_cache; itr && *itr; ++itr)
+    {
+        if((*itr)->width == w && (*itr)->height == h && strcmp(path, (*itr)->path) == 0)
+        {
+            ++(*itr)->refcnt;
+            PNG_LOG("PNG %s (%dx%d) %p found in cache, refcnt increased to %d\n", path, w, h, (*itr)->data, (*itr)->refcnt);
+            return (*itr)->data;
+        }
+    }
+
+    // not in cache yet, load and create cache entry
+    px_type *data = load_png(path, w, h);
+    if(!data)
+    {
+        PNG_LOG("PNG %s (%dx%d) failed to load\n", path, w, h);
+        return NULL;
+    }
+    PNG_LOG("PNG %s (%dx%d) loaded\n", path, w, h);
+
+    struct png_cache_entry *e = mzalloc(sizeof(struct png_cache_entry));
+    e->path = strdup(path);
+    e->data = data;
+    e->width = w;
+    e->height = h;
+    e->refcnt = 1;
+
+    list_add(&png_cache, e);
+    PNG_LOG("PNG %s (%dx%d) %p added into cache\n", path, w, h, data);
+    return data;
+}
+
+void fb_png_release(px_type *data)
+{
+    struct png_cache_entry **itr;
+    for(itr = png_cache; itr && *itr; ++itr)
+    {
+        if((*itr)->data == data)
+        {
+            --(*itr)->refcnt;
+            PNG_LOG("PNG %s (%dx%d) %p released, refcnt is %d\n", (*itr)->path, (*itr)->width, (*itr)->height, data, (*itr)->refcnt);
+            return;
+        }
+    }
+    PNG_LOG("PNG %p not found in cache!\n", data);
+}
+
+void fb_png_drop_unused(void)
+{
+    struct png_cache_entry **itr;
+    for(itr = png_cache; itr && *itr;)
+    {
+        if((*itr)->refcnt <= 0)
+        {
+            PNG_LOG("PNG %s (%dx%d) %p removed from cache\n", (*itr)->path, (*itr)->width, (*itr)->height, data);
+            list_rm(&png_cache, *itr, &destroy_png_cache_entry);
+            itr = png_cache;
+        }
+        else
+        {
+            ++itr;
+        }
+    }
+}
+
+static inline void convert_fb_px_to_rgb888(px_type src, uint8_t *dest)
+{
+    dest[0] = PX_GET_R(src);
+    dest[1] = PX_GET_G(src);
+    dest[2] = PX_GET_B(src);
+}
+
+int fb_png_save_img(const char *path, int w, int h, int stride, px_type *data)
+{
+    FILE *fp = NULL;
+    png_structp png_ptr = NULL;
+    png_infop info_ptr = NULL;
+    int res = -1;
+    int y, x;
+    uint8_t *row = NULL;
+    const int stride_leftover = stride - w;
+    const int w_png_bytes = w * 3;
+    px_type * volatile itr = data;
+
+    fp = fopen(path, "we");
+    if(!fp)
+    {
+        ERROR("Failed to open %s for writing\n", path);
+        return -1;
+    }
+
+    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+    if (!png_ptr)
+        goto exit;
+
+    info_ptr = png_create_info_struct(png_ptr);
+    if (info_ptr == NULL)
+        goto exit;
+
+    if (setjmp(png_jmpbuf(png_ptr)))
+        goto exit;
+
+    png_init_io(png_ptr, fp);
+    png_set_IHDR(png_ptr, info_ptr, w, h,
+         8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE,
+         PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
+    png_write_info(png_ptr, info_ptr);
+
+    row = malloc(w*3);
+    for(y = 0; y < h; ++y)
+    {
+        for(x = 0; x < w_png_bytes; x += 3)
+        {
+            convert_fb_px_to_rgb888(*itr, row + x);
+            ++itr;
+        }
+        itr += stride_leftover;
+
+        png_write_row(png_ptr, row);
+    }
+
+    png_write_end(png_ptr, NULL);
+    res = 0;
+exit:
+    if(info_ptr)
+        png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
+    if(png_ptr)
+        png_destroy_write_struct(&png_ptr, (png_infopp)NULL);
+    if(fp)
+        fclose(fp);
+    if(row)
+        free(row);
+    return res;
+}
diff --git a/lib/framebuffer_qcom_overlay.c b/lib/framebuffer_qcom_overlay.c
index 1c806a4..9814899 100755
--- a/lib/framebuffer_qcom_overlay.c
+++ b/lib/framebuffer_qcom_overlay.c
@@ -1,666 +1,666 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/ioctl.h>
-#include <string.h>
-#include <linux/fb.h>
-#include <poll.h>
-#include <errno.h>
-
-#include "framebuffer.h"
-#include "log.h"
-#include "util.h"
-
-#ifdef MR_QCOM_OVERLAY_HEADER
-#include MR_QCOM_OVERLAY_HEADER
-#endif
-
-#define ALIGN(x, align) (((x) + ((align)-1)) & ~((align)-1))
-#define MAX_DISPLAY_DIM  2048
-#define NUM_BUFFERS 3
-
-struct fb_qcom_overlay_mem_info {
-    uint8_t *mem_buf;
-    int size;
-    int ion_fd;
-    int mem_fd;
-    int offset;
-    struct ion_handle_data handle_data;
-};
-
-struct fb_qcom_vsync {
-    int fb_fd;
-    int enabled;
-    volatile int _run_thread;
-    pthread_t thread;
-    pthread_mutex_t mutex;
-    pthread_cond_t cond;
-    struct timespec time;
-};
-
-struct fb_qcom_overlay_data {
-    struct fb_qcom_overlay_mem_info mem_info[NUM_BUFFERS];
-    struct fb_qcom_vsync *vsync;
-    int active_mem;
-    int overlayL_id;
-    int overlayR_id;
-    int leftSplit;
-    int rightSplit;
-    int width;
-};
-
-#define VSYNC_PREFIX "VSYNC="
-
-#ifdef MR_QCOM_OVERLAY_USE_VSYNC
-static int fb_qcom_vsync_enable(struct fb_qcom_vsync *vs, int enable)
-{
-    clock_gettime(CLOCK_MONOTONIC, &vs->time);
-
-    if(vs->enabled != enable)
-    {
-        if(vs->fb_fd < 0 || ioctl(vs->fb_fd, MSMFB_OVERLAY_VSYNC_CTRL, &enable) < 0)
-        {
-            ERROR("Failed to set vsync status\n");
-            return -1;
-        }
-
-        vs->enabled = enable;
-    }
-
-    return 0;
-}
-
-static void *fb_qcom_vsync_thread_work(void *data)
-{
-    struct fb_qcom_vsync *vs = data;
-    int fd, err, len;
-    struct pollfd pfd;
-    struct timespec now;
-    uint64_t vsync_timestamp;
-    uint64_t now_timestamp;
-    char buff[64];
-
-    fd = open("/sys/class/graphics/fb0/vsync_event", O_RDONLY | O_CLOEXEC);
-    if(fd < 0)
-    {
-        ERROR("Unable to open vsync_event!\n");
-        return NULL;
-    }
-
-    read(fd, buff, sizeof(buff));
-    pfd.fd = fd;
-    pfd.events = POLLPRI | POLLERR;
-
-    while(vs->_run_thread)
-    {
-        err = poll(&pfd, 1, 10);
-        if(err <= 0)
-            continue;
-
-        if(pfd.revents & POLLPRI)
-        {
-            len = pread(pfd.fd, buff, sizeof(buff)-1, 0);
-            if(len > 0)
-            {
-                buff[len] = 0;
-                if(strncmp(buff, VSYNC_PREFIX, strlen(VSYNC_PREFIX)) == 0)
-                {
-                    vsync_timestamp = strtoull(buff + strlen(VSYNC_PREFIX), NULL, 10);
-                    clock_gettime(CLOCK_MONOTONIC, &now);
-                    now_timestamp = ((uint64_t)now.tv_sec) * 1000000000ULL + now.tv_nsec;
-                    if(vsync_timestamp > now_timestamp)
-                        usleep((vsync_timestamp - now_timestamp)/1000);
-
-                    pthread_cond_signal(&vs->cond);
-                }
-            }
-            else
-                ERROR("Unable to read from vsync_event!");
-        }
-
-        clock_gettime(CLOCK_MONOTONIC, &now);
-        if(timespec_diff(&vs->time, &now) >= 60)
-            fb_qcom_vsync_enable(vs, 0);
-    }
-
-    close(fd);
-    return NULL;
-}
-#endif // #ifdef MR_QCOM_OVERLAY_USE_VSYNC
-
-static struct fb_qcom_vsync *fb_qcom_vsync_init(int fb_fd)
-{
-    struct fb_qcom_vsync *res = mzalloc(sizeof(struct fb_qcom_vsync));
-    res->fb_fd = fb_fd;
-#ifdef MR_QCOM_OVERLAY_USE_VSYNC
-    res->_run_thread = 1;
-    pthread_mutex_init(&res->mutex, NULL);
-    pthread_cond_init(&res->cond, NULL);
-    pthread_create(&res->thread, NULL, &fb_qcom_vsync_thread_work, res);
-#endif
-    return res;
-}
-
-static void fb_qcom_vsync_destroy(struct fb_qcom_vsync *vs)
-{
-#ifdef MR_QCOM_OVERLAY_USE_VSYNC
-    pthread_mutex_lock(&vs->mutex);
-    vs->_run_thread = 0;
-    pthread_mutex_unlock(&vs->mutex);
-    pthread_join(vs->thread, NULL);
-    pthread_mutex_destroy(&vs->mutex);
-    pthread_cond_destroy(&vs->cond);
-#endif
-
-    free(vs);
-}
-
-static int fb_qcom_vsync_wait(UNUSED struct fb_qcom_vsync *vs)
-{
-#ifdef MR_QCOM_OVERLAY_USE_VSYNC
-    int res;
-    struct timespec ts;
-
-    pthread_mutex_lock(&vs->mutex);
-
-    if(!vs->_run_thread)
-    {
-        pthread_mutex_unlock(&vs->mutex);
-        return 0;
-    }
-
-    fb_qcom_vsync_enable(vs, 1);
-
-    clock_gettime(CLOCK_REALTIME, &ts);
-    ts.tv_nsec += 20*1000*1000;
-    if(ts.tv_nsec >= 1000000000)
-    {
-        ts.tv_nsec -= 1000000000;
-        ++ts.tv_sec;
-    }
-
-    res = pthread_cond_timedwait(&vs->cond, &vs->mutex, &ts);
-    pthread_mutex_unlock(&vs->mutex);
-
-    return res;
-#else
-    return 0;
-#endif
-}
-
-
-static int map_mdp_pixel_format()
-{
-    int format;
-#ifdef MR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT
-    format = MR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT;
-#else
-    /* We can't set format here because their IDs are different on aosp and CM kernels.
-     * There is literally just one line different between their headers, and it breaks it.
-     * MDP_FB_FORMAT works because it translates to MDP_IMGTYPE2_START, which is the same
-     * on both. It means it will take the format from the framebuffer. */
-    format = MDP_FB_FORMAT;
-#endif
-    return format;
-}
-
-static void setDisplaySplit(struct fb_qcom_overlay_data *data)
-{
-    char split[64] = { 0 };
-    FILE* fp = fopen("/sys/class/graphics/fb0/msm_fb_split", "re");
-    if(fp)
-    {
-        //Format "left right" space as delimiter
-        if(fread(split, sizeof(char), 64, fp))
-        {
-            data->leftSplit = atoi(split);
-            INFO("Left Split=%d\n",data->leftSplit);
-            char *rght = strpbrk(split, " ");
-            if(rght)
-                data->rightSplit = atoi(rght + 1);
-            INFO("Right Split=%d\n", data->rightSplit);
-        }
-        fclose(fp);
-    }
-}
-
-static int isDisplaySplit(struct fb_qcom_overlay_data *data)
-{
-    if(data->width > MAX_DISPLAY_DIM)
-        return 1;
-
-    //check if right split is set by driver
-    if(data->rightSplit)
-        return 1;
-
-    return 0;
-}
-
-static int free_ion_mem(struct fb_qcom_overlay_data *data)
-{
-    int ret = 0, i;
-    struct fb_qcom_overlay_mem_info *info;
-    for(i = 0; i < NUM_BUFFERS; ++i)
-    {
-        info = &data->mem_info[i];
-
-        if(info->mem_buf)
-            munmap(info->mem_buf, info->size);
-
-        if(info->ion_fd >= 0)
-        {
-            ret = ioctl(info->ion_fd, ION_IOC_FREE, &info->handle_data);
-            if(ret < 0)
-                ERROR("free_mem failed ");
-        }
-
-        if(info->mem_fd >= 0)
-            close(info->mem_fd);
-
-        if(info->ion_fd >= 0)
-            close(info->ion_fd);
-    }
-    return 0;
-}
-
-static int alloc_ion_mem(struct fb_qcom_overlay_data *data, unsigned int size)
-{
-    int result, i;
-    struct ion_fd_data fd_data;
-    struct ion_allocation_data ionAllocData;
-    struct fb_qcom_overlay_mem_info *info;
-
-    ionAllocData.flags = 0;
-    ionAllocData.len = size;
-    ionAllocData.align = sysconf(_SC_PAGESIZE);
-
-// are you kidding me -.-
-#if (PLATFORM_SDK_VERSION >= 21)
-    ionAllocData.heap_id_mask =
-#else
-    ionAllocData.heap_mask =
-#endif
-            ION_HEAP(ION_IOMMU_HEAP_ID) |
-            ION_HEAP(21); // ION_SYSTEM_CONTIG_HEAP_ID
-
-    for(i = 0; i < NUM_BUFFERS; ++i)
-    {
-        info = &data->mem_info[i];
-
-        info->ion_fd = open("/dev/ion", O_RDWR|O_DSYNC|O_CLOEXEC);
-        if(info->ion_fd < 0)
-        {
-            ERROR("ERROR: Can't open ion ");
-            return -errno;
-        }
-
-        result = ioctl(info->ion_fd, ION_IOC_ALLOC,  &ionAllocData);
-        if(result)
-        {
-            ERROR("ION_IOC_ALLOC Failed ");
-            close(info->ion_fd);
-            return result;
-        }
-
-        fd_data.handle = ionAllocData.handle;
-        info->handle_data.handle = ionAllocData.handle;
-        result = ioctl(info->ion_fd, ION_IOC_MAP, &fd_data);
-        if(result)
-        {
-            ERROR("ION_IOC_MAP Failed ");
-            free_ion_mem(data);
-            return result;
-        }
-        info->mem_buf = (uint8_t*)mmap(NULL, size, PROT_READ |
-                    PROT_WRITE, MAP_SHARED, fd_data.fd, 0);
-        info->mem_fd = fd_data.fd;
-
-        if(info->mem_buf == MAP_FAILED)
-        {
-            ERROR("ERROR: mem_buf MAP_FAILED ");
-            info->mem_buf = NULL;
-            free_ion_mem(data);
-            return -ENOMEM;
-        }
-
-        info->offset = 0;
-    }
-
-    return 0;
-}
-
-
-static int allocate_overlay(struct fb_qcom_overlay_data *data, int fd, int width, int height)
-{
-    int ret = 0;
-
-    if(!isDisplaySplit(data))
-    {
-        // Check if overlay is already allocated
-        if(data->overlayL_id == MSMFB_NEW_REQUEST)
-        {
-            struct mdp_overlay overlayL;
-
-            memset(&overlayL, 0 , sizeof (struct mdp_overlay));
-
-            /* Fill Overlay Data */
-            overlayL.src.width  = ALIGN(width, 32);
-            overlayL.src.height = height;
-            overlayL.src.format = map_mdp_pixel_format();
-            overlayL.src_rect.w = width;
-            overlayL.src_rect.h = height;
-            overlayL.dst_rect.w = width;
-            overlayL.dst_rect.h = height;
-            overlayL.alpha = 0xFF;
-            overlayL.transp_mask = MDP_TRANSP_NOP;
-            overlayL.id = MSMFB_NEW_REQUEST;
-            ret = ioctl(fd, MSMFB_OVERLAY_SET, &overlayL);
-            if(ret < 0)
-            {
-                ERROR("Overlay Set Failed");
-                return ret;
-            }
-            data->overlayL_id = overlayL.id;
-        }
-    }
-    else
-    {
-        float xres = data->width;
-        int lSplit = data->leftSplit;
-        float lSplitRatio = lSplit / xres;
-        float lCropWidth = width * lSplitRatio;
-        int lWidth = lSplit;
-        int rWidth = width - lSplit;
-
-        if(data->overlayL_id == MSMFB_NEW_REQUEST)
-        {
-            struct mdp_overlay overlayL;
-
-            memset(&overlayL, 0 , sizeof (struct mdp_overlay));
-
-            /* Fill OverlayL Data */
-            overlayL.src.width  = ALIGN(width, 32);
-            overlayL.src.height = height;
-            overlayL.src.format = map_mdp_pixel_format();
-            overlayL.src_rect.x = 0;
-            overlayL.src_rect.y = 0;
-            overlayL.src_rect.w = lCropWidth;
-            overlayL.src_rect.h = height;
-            overlayL.dst_rect.x = 0;
-            overlayL.dst_rect.y = 0;
-            overlayL.dst_rect.w = lWidth;
-            overlayL.dst_rect.h = height;
-            overlayL.alpha = 0xFF;
-            overlayL.transp_mask = MDP_TRANSP_NOP;
-            overlayL.id = MSMFB_NEW_REQUEST;
-            ret = ioctl(fd, MSMFB_OVERLAY_SET, &overlayL);
-            if(ret < 0)
-            {
-                ERROR("OverlayL Set Failed");
-                return ret;
-            }
-            data->overlayL_id = overlayL.id;
-        }
-
-        if(data->overlayR_id == MSMFB_NEW_REQUEST)
-        {
-            struct mdp_overlay overlayR;
-
-            memset(&overlayR, 0 , sizeof (struct mdp_overlay));
-
-            /* Fill OverlayR Data */
-            overlayR.src.width  = ALIGN(width, 32);
-            overlayR.src.height = height;
-            overlayR.src.format = map_mdp_pixel_format();
-            overlayR.src_rect.x = lCropWidth;
-            overlayR.src_rect.y = 0;
-            overlayR.src_rect.w = width - lCropWidth;
-            overlayR.src_rect.h = height;
-            overlayR.dst_rect.x = 0;
-            overlayR.dst_rect.y = 0;
-            overlayR.dst_rect.w = rWidth;
-            overlayR.dst_rect.h = height;
-            overlayR.alpha = 0xFF;
-            overlayR.flags = MDSS_MDP_RIGHT_MIXER;
-            overlayR.transp_mask = MDP_TRANSP_NOP;
-            overlayR.id = MSMFB_NEW_REQUEST;
-            ret = ioctl(fd, MSMFB_OVERLAY_SET, &overlayR);
-            if(ret < 0)
-            {
-                ERROR("OverlayR Set Failed");
-                return ret;
-            }
-            data->overlayR_id = overlayR.id;
-        }
-    }
-
-    return 0;
-}
-
-static int free_overlay(struct fb_qcom_overlay_data *data, int fd)
-{
-    int ret = 0;
-    struct mdp_display_commit ext_commit;
-
-    if(!isDisplaySplit(data))
-    {
-        if(data->overlayL_id != MSMFB_NEW_REQUEST)
-        {
-            ret = ioctl(fd, MSMFB_OVERLAY_UNSET, &data->overlayL_id);
-            if(ret)
-            {
-                ERROR("OverlayL Unset Failed");
-                data->overlayL_id = MSMFB_NEW_REQUEST;
-                return ret;
-            }
-        }
-    }
-    else
-    {
-        if(data->overlayL_id != MSMFB_NEW_REQUEST)
-        {
-            ret = ioctl(fd, MSMFB_OVERLAY_UNSET, &data->overlayL_id);
-            if(ret)
-            {
-                ERROR("OverlayL Unset Failed");
-                data->overlayL_id = MSMFB_NEW_REQUEST;
-                return ret;
-            }
-        }
-
-        if(data->overlayR_id != MSMFB_NEW_REQUEST)
-        {
-            ret = ioctl(fd, MSMFB_OVERLAY_UNSET, &data->overlayR_id);
-            if(ret)
-            {
-                ERROR("OverlayR Unset Failed");
-                data->overlayR_id = MSMFB_NEW_REQUEST;
-                return ret;
-            }
-        }
-    }
-
-    memset(&ext_commit, 0, sizeof(struct mdp_display_commit));
-    ext_commit.flags = MDP_DISPLAY_COMMIT_OVERLAY;
-
-    data->overlayL_id = MSMFB_NEW_REQUEST;
-    data->overlayR_id = MSMFB_NEW_REQUEST;
-
-    ret = ioctl(fd, MSMFB_DISPLAY_COMMIT, &ext_commit);
-    if(ret < 0)
-    {
-        ERROR("Clear MSMFB_DISPLAY_COMMIT failed!");
-        return ret;
-    }
-
-    return 0;
-}
-
-static int impl_open(struct framebuffer *fb)
-{
-    struct fb_qcom_overlay_data *data = mzalloc(sizeof(struct fb_qcom_overlay_data));
-    data->overlayL_id = MSMFB_NEW_REQUEST;
-    data->overlayR_id = MSMFB_NEW_REQUEST;
-    data->width = fb->vi.xres;
-    data->leftSplit = data->width / 2;
-
-    setDisplaySplit(data);
-
-#ifdef TW_SCREEN_BLANK_ON_BOOT
-    ioctl(fb->fd, FBIOBLANK, FB_BLANK_POWERDOWN);
-    ioctl(fb->fd, FBIOBLANK, FB_BLANK_UNBLANK);
-#endif
-
-    if(alloc_ion_mem(data, fb->fi.line_length * fb->vi.yres) < 0)
-        goto fail;
-
-    if(allocate_overlay(data, fb->fd, fb->vi.xres, fb->vi.yres) < 0)
-    {
-        free_ion_mem(data);
-        goto fail;
-    }
-
-    data->vsync = fb_qcom_vsync_init(fb->fd);
-
-    fb->impl_data = data;
-    return 0;
-
-fail:
-    free(data);
-    return -1;
-}
-
-static void impl_close(struct framebuffer *fb)
-{
-    struct fb_qcom_overlay_data *data = fb->impl_data;
-    fb_qcom_vsync_destroy(data->vsync);
-    free_overlay(data, fb->fd);
-    free_ion_mem(data);
-    free(data);
-    fb->impl_data = NULL;
-}
-
-static int impl_update(struct framebuffer *fb)
-{
-    int ret = 0;
-    struct msmfb_overlay_data ovdataL, ovdataR;
-    struct mdp_display_commit ext_commit;
-    struct fb_qcom_overlay_data *data = fb->impl_data;
-    struct fb_qcom_overlay_mem_info *info = &data->mem_info[data->active_mem];
-
-    if(!isDisplaySplit(data))
-    {
-        if(data->overlayL_id == MSMFB_NEW_REQUEST)
-        {
-            ERROR("display_frame failed, no overlay\n");
-            return -EINVAL;
-        }
-
-        memset(&ovdataL, 0, sizeof(struct msmfb_overlay_data));
-
-        ovdataL.id = data->overlayL_id;
-        ovdataL.data.flags = 0;
-        ovdataL.data.offset = info->offset;
-        ovdataL.data.memory_id = info->mem_fd;
-        ret = ioctl(fb->fd, MSMFB_OVERLAY_PLAY, &ovdataL);
-        if(ret < 0)
-        {
-            ERROR("overlay_display_frame failed, overlay play Failed\n");
-            return -1;
-        }
-    }
-    else
-    {
-        if(data->overlayL_id == MSMFB_NEW_REQUEST)
-        {
-            ERROR("display_frame failed, no overlayL \n");
-            return -EINVAL;
-        }
-
-        memset(&ovdataL, 0, sizeof(struct msmfb_overlay_data));
-
-        ovdataL.id = data->overlayL_id;
-        ovdataL.data.flags = 0;
-        ovdataL.data.offset = info->offset;
-        ovdataL.data.memory_id = info->mem_fd;
-        ret = ioctl(fb->fd, MSMFB_OVERLAY_PLAY, &ovdataL);
-        if(ret < 0)
-        {
-            ERROR("overlay_display_frame failed, overlayL play Failed\n");
-            return ret;
-        }
-
-        if(data->overlayR_id == MSMFB_NEW_REQUEST)
-        {
-            ERROR("display_frame failed, no overlayR \n");
-            return -EINVAL;
-        }
-
-        memset(&ovdataR, 0, sizeof(struct msmfb_overlay_data));
-
-        ovdataR.id = data->overlayR_id;
-        ovdataR.data.flags = 0;
-        ovdataR.data.offset = info->offset;
-        ovdataR.data.memory_id = info->mem_fd;
-        ret = ioctl(fb->fd, MSMFB_OVERLAY_PLAY, &ovdataR);
-        if(ret < 0)
-        {
-            ERROR("overlay_display_frame failed, overlayR play Failed\n");
-            return ret;
-        }
-    }
-
-    memset(&ext_commit, 0, sizeof(struct mdp_display_commit));
-    ext_commit.flags = MDP_DISPLAY_COMMIT_OVERLAY;
-
-    fb_qcom_vsync_wait(data->vsync);
-
-    ret = ioctl(fb->fd, MSMFB_DISPLAY_COMMIT, &ext_commit);
-    if(ret < 0)
-    {
-        ERROR("overlay_display_frame failed, overlay commit Failed\n!");
-        return -1;
-    }
-
-    if(++data->active_mem >= NUM_BUFFERS)
-        data->active_mem = 0;
-
-    return ret;
-}
-
-static void *impl_get_frame_dest(struct framebuffer *fb)
-{
-    struct fb_qcom_overlay_data *data = fb->impl_data;
-    return data->mem_info[data->active_mem].mem_buf;
-}
-
-const struct fb_impl fb_impl_qcom_overlay = {
-    .name = "Qualcomm ION overlay",
-    .impl_id = FB_IMPL_QCOM_OVERLAY,
-
-    .open = impl_open,
-    .close = impl_close,
-    .update = impl_update,
-    .get_frame_dest = impl_get_frame_dest,
-};
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <linux/fb.h>
+#include <poll.h>
+#include <errno.h>
+
+#include "framebuffer.h"
+#include "log.h"
+#include "util.h"
+
+#ifdef MR_QCOM_OVERLAY_HEADER
+#include MR_QCOM_OVERLAY_HEADER
+#endif
+
+#define ALIGN(x, align) (((x) + ((align)-1)) & ~((align)-1))
+#define MAX_DISPLAY_DIM  2048
+#define NUM_BUFFERS 3
+
+struct fb_qcom_overlay_mem_info {
+    uint8_t *mem_buf;
+    int size;
+    int ion_fd;
+    int mem_fd;
+    int offset;
+    struct ion_handle_data handle_data;
+};
+
+struct fb_qcom_vsync {
+    int fb_fd;
+    int enabled;
+    volatile int _run_thread;
+    pthread_t thread;
+    pthread_mutex_t mutex;
+    pthread_cond_t cond;
+    struct timespec time;
+};
+
+struct fb_qcom_overlay_data {
+    struct fb_qcom_overlay_mem_info mem_info[NUM_BUFFERS];
+    struct fb_qcom_vsync *vsync;
+    int active_mem;
+    int overlayL_id;
+    int overlayR_id;
+    int leftSplit;
+    int rightSplit;
+    int width;
+};
+
+#define VSYNC_PREFIX "VSYNC="
+
+#ifdef MR_QCOM_OVERLAY_USE_VSYNC
+static int fb_qcom_vsync_enable(struct fb_qcom_vsync *vs, int enable)
+{
+    clock_gettime(CLOCK_MONOTONIC, &vs->time);
+
+    if(vs->enabled != enable)
+    {
+        if(vs->fb_fd < 0 || ioctl(vs->fb_fd, MSMFB_OVERLAY_VSYNC_CTRL, &enable) < 0)
+        {
+            ERROR("Failed to set vsync status\n");
+            return -1;
+        }
+
+        vs->enabled = enable;
+    }
+
+    return 0;
+}
+
+static void *fb_qcom_vsync_thread_work(void *data)
+{
+    struct fb_qcom_vsync *vs = data;
+    int fd, err, len;
+    struct pollfd pfd;
+    struct timespec now;
+    uint64_t vsync_timestamp;
+    uint64_t now_timestamp;
+    char buff[64];
+
+    fd = open("/sys/class/graphics/fb0/vsync_event", O_RDONLY | O_CLOEXEC);
+    if(fd < 0)
+    {
+        ERROR("Unable to open vsync_event!\n");
+        return NULL;
+    }
+
+    read(fd, buff, sizeof(buff));
+    pfd.fd = fd;
+    pfd.events = POLLPRI | POLLERR;
+
+    while(vs->_run_thread)
+    {
+        err = poll(&pfd, 1, 10);
+        if(err <= 0)
+            continue;
+
+        if(pfd.revents & POLLPRI)
+        {
+            len = pread(pfd.fd, buff, sizeof(buff)-1, 0);
+            if(len > 0)
+            {
+                buff[len] = 0;
+                if(strncmp(buff, VSYNC_PREFIX, strlen(VSYNC_PREFIX)) == 0)
+                {
+                    vsync_timestamp = strtoull(buff + strlen(VSYNC_PREFIX), NULL, 10);
+                    clock_gettime(CLOCK_MONOTONIC, &now);
+                    now_timestamp = ((uint64_t)now.tv_sec) * 1000000000ULL + now.tv_nsec;
+                    if(vsync_timestamp > now_timestamp)
+                        usleep((vsync_timestamp - now_timestamp)/1000);
+
+                    pthread_cond_signal(&vs->cond);
+                }
+            }
+            else
+                ERROR("Unable to read from vsync_event!");
+        }
+
+        clock_gettime(CLOCK_MONOTONIC, &now);
+        if(timespec_diff(&vs->time, &now) >= 60)
+            fb_qcom_vsync_enable(vs, 0);
+    }
+
+    close(fd);
+    return NULL;
+}
+#endif // #ifdef MR_QCOM_OVERLAY_USE_VSYNC
+
+static struct fb_qcom_vsync *fb_qcom_vsync_init(int fb_fd)
+{
+    struct fb_qcom_vsync *res = mzalloc(sizeof(struct fb_qcom_vsync));
+    res->fb_fd = fb_fd;
+#ifdef MR_QCOM_OVERLAY_USE_VSYNC
+    res->_run_thread = 1;
+    pthread_mutex_init(&res->mutex, NULL);
+    pthread_cond_init(&res->cond, NULL);
+    pthread_create(&res->thread, NULL, &fb_qcom_vsync_thread_work, res);
+#endif
+    return res;
+}
+
+static void fb_qcom_vsync_destroy(struct fb_qcom_vsync *vs)
+{
+#ifdef MR_QCOM_OVERLAY_USE_VSYNC
+    pthread_mutex_lock(&vs->mutex);
+    vs->_run_thread = 0;
+    pthread_mutex_unlock(&vs->mutex);
+    pthread_join(vs->thread, NULL);
+    pthread_mutex_destroy(&vs->mutex);
+    pthread_cond_destroy(&vs->cond);
+#endif
+
+    free(vs);
+}
+
+static int fb_qcom_vsync_wait(UNUSED struct fb_qcom_vsync *vs)
+{
+#ifdef MR_QCOM_OVERLAY_USE_VSYNC
+    int res;
+    struct timespec ts;
+
+    pthread_mutex_lock(&vs->mutex);
+
+    if(!vs->_run_thread)
+    {
+        pthread_mutex_unlock(&vs->mutex);
+        return 0;
+    }
+
+    fb_qcom_vsync_enable(vs, 1);
+
+    clock_gettime(CLOCK_REALTIME, &ts);
+    ts.tv_nsec += 20*1000*1000;
+    if(ts.tv_nsec >= 1000000000)
+    {
+        ts.tv_nsec -= 1000000000;
+        ++ts.tv_sec;
+    }
+
+    res = pthread_cond_timedwait(&vs->cond, &vs->mutex, &ts);
+    pthread_mutex_unlock(&vs->mutex);
+
+    return res;
+#else
+    return 0;
+#endif
+}
+
+
+static int map_mdp_pixel_format()
+{
+    int format;
+#ifdef MR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT
+    format = MR_QCOM_OVERLAY_CUSTOM_PIXEL_FORMAT;
+#else
+    /* We can't set format here because their IDs are different on aosp and CM kernels.
+     * There is literally just one line different between their headers, and it breaks it.
+     * MDP_FB_FORMAT works because it translates to MDP_IMGTYPE2_START, which is the same
+     * on both. It means it will take the format from the framebuffer. */
+    format = MDP_FB_FORMAT;
+#endif
+    return format;
+}
+
+static void setDisplaySplit(struct fb_qcom_overlay_data *data)
+{
+    char split[64] = { 0 };
+    FILE* fp = fopen("/sys/class/graphics/fb0/msm_fb_split", "re");
+    if(fp)
+    {
+        //Format "left right" space as delimiter
+        if(fread(split, sizeof(char), 64, fp))
+        {
+            data->leftSplit = atoi(split);
+            INFO("Left Split=%d\n",data->leftSplit);
+            char *rght = strpbrk(split, " ");
+            if(rght)
+                data->rightSplit = atoi(rght + 1);
+            INFO("Right Split=%d\n", data->rightSplit);
+        }
+        fclose(fp);
+    }
+}
+
+static int isDisplaySplit(struct fb_qcom_overlay_data *data)
+{
+    if(data->width > MAX_DISPLAY_DIM)
+        return 1;
+
+    //check if right split is set by driver
+    if(data->rightSplit)
+        return 1;
+
+    return 0;
+}
+
+static int free_ion_mem(struct fb_qcom_overlay_data *data)
+{
+    int ret = 0, i;
+    struct fb_qcom_overlay_mem_info *info;
+    for(i = 0; i < NUM_BUFFERS; ++i)
+    {
+        info = &data->mem_info[i];
+
+        if(info->mem_buf)
+            munmap(info->mem_buf, info->size);
+
+        if(info->ion_fd >= 0)
+        {
+            ret = ioctl(info->ion_fd, ION_IOC_FREE, &info->handle_data);
+            if(ret < 0)
+                ERROR("free_mem failed ");
+        }
+
+        if(info->mem_fd >= 0)
+            close(info->mem_fd);
+
+        if(info->ion_fd >= 0)
+            close(info->ion_fd);
+    }
+    return 0;
+}
+
+static int alloc_ion_mem(struct fb_qcom_overlay_data *data, unsigned int size)
+{
+    int result, i;
+    struct ion_fd_data fd_data;
+    struct ion_allocation_data ionAllocData;
+    struct fb_qcom_overlay_mem_info *info;
+
+    ionAllocData.flags = 0;
+    ionAllocData.len = size;
+    ionAllocData.align = sysconf(_SC_PAGESIZE);
+
+// are you kidding me -.-
+#if (PLATFORM_SDK_VERSION >= 21)
+    ionAllocData.heap_id_mask =
+#else
+    ionAllocData.heap_mask =
+#endif
+            ION_HEAP(ION_IOMMU_HEAP_ID) |
+            ION_HEAP(21); // ION_SYSTEM_CONTIG_HEAP_ID
+
+    for(i = 0; i < NUM_BUFFERS; ++i)
+    {
+        info = &data->mem_info[i];
+
+        info->ion_fd = open("/dev/ion", O_RDWR|O_DSYNC|O_CLOEXEC);
+        if(info->ion_fd < 0)
+        {
+            ERROR("ERROR: Can't open ion ");
+            return -errno;
+        }
+
+        result = ioctl(info->ion_fd, ION_IOC_ALLOC,  &ionAllocData);
+        if(result)
+        {
+            ERROR("ION_IOC_ALLOC Failed ");
+            close(info->ion_fd);
+            return result;
+        }
+
+        fd_data.handle = ionAllocData.handle;
+        info->handle_data.handle = ionAllocData.handle;
+        result = ioctl(info->ion_fd, ION_IOC_MAP, &fd_data);
+        if(result)
+        {
+            ERROR("ION_IOC_MAP Failed ");
+            free_ion_mem(data);
+            return result;
+        }
+        info->mem_buf = (uint8_t*)mmap(NULL, size, PROT_READ |
+                    PROT_WRITE, MAP_SHARED, fd_data.fd, 0);
+        info->mem_fd = fd_data.fd;
+
+        if(info->mem_buf == MAP_FAILED)
+        {
+            ERROR("ERROR: mem_buf MAP_FAILED ");
+            info->mem_buf = NULL;
+            free_ion_mem(data);
+            return -ENOMEM;
+        }
+
+        info->offset = 0;
+    }
+
+    return 0;
+}
+
+
+static int allocate_overlay(struct fb_qcom_overlay_data *data, int fd, int width, int height)
+{
+    int ret = 0;
+
+    if(!isDisplaySplit(data))
+    {
+        // Check if overlay is already allocated
+        if(data->overlayL_id == MSMFB_NEW_REQUEST)
+        {
+            struct mdp_overlay overlayL;
+
+            memset(&overlayL, 0 , sizeof (struct mdp_overlay));
+
+            /* Fill Overlay Data */
+            overlayL.src.width  = ALIGN(width, 32);
+            overlayL.src.height = height;
+            overlayL.src.format = map_mdp_pixel_format();
+            overlayL.src_rect.w = width;
+            overlayL.src_rect.h = height;
+            overlayL.dst_rect.w = width;
+            overlayL.dst_rect.h = height;
+            overlayL.alpha = 0xFF;
+            overlayL.transp_mask = MDP_TRANSP_NOP;
+            overlayL.id = MSMFB_NEW_REQUEST;
+            ret = ioctl(fd, MSMFB_OVERLAY_SET, &overlayL);
+            if(ret < 0)
+            {
+                ERROR("Overlay Set Failed");
+                return ret;
+            }
+            data->overlayL_id = overlayL.id;
+        }
+    }
+    else
+    {
+        float xres = data->width;
+        int lSplit = data->leftSplit;
+        float lSplitRatio = lSplit / xres;
+        float lCropWidth = width * lSplitRatio;
+        int lWidth = lSplit;
+        int rWidth = width - lSplit;
+
+        if(data->overlayL_id == MSMFB_NEW_REQUEST)
+        {
+            struct mdp_overlay overlayL;
+
+            memset(&overlayL, 0 , sizeof (struct mdp_overlay));
+
+            /* Fill OverlayL Data */
+            overlayL.src.width  = ALIGN(width, 32);
+            overlayL.src.height = height;
+            overlayL.src.format = map_mdp_pixel_format();
+            overlayL.src_rect.x = 0;
+            overlayL.src_rect.y = 0;
+            overlayL.src_rect.w = lCropWidth;
+            overlayL.src_rect.h = height;
+            overlayL.dst_rect.x = 0;
+            overlayL.dst_rect.y = 0;
+            overlayL.dst_rect.w = lWidth;
+            overlayL.dst_rect.h = height;
+            overlayL.alpha = 0xFF;
+            overlayL.transp_mask = MDP_TRANSP_NOP;
+            overlayL.id = MSMFB_NEW_REQUEST;
+            ret = ioctl(fd, MSMFB_OVERLAY_SET, &overlayL);
+            if(ret < 0)
+            {
+                ERROR("OverlayL Set Failed");
+                return ret;
+            }
+            data->overlayL_id = overlayL.id;
+        }
+
+        if(data->overlayR_id == MSMFB_NEW_REQUEST)
+        {
+            struct mdp_overlay overlayR;
+
+            memset(&overlayR, 0 , sizeof (struct mdp_overlay));
+
+            /* Fill OverlayR Data */
+            overlayR.src.width  = ALIGN(width, 32);
+            overlayR.src.height = height;
+            overlayR.src.format = map_mdp_pixel_format();
+            overlayR.src_rect.x = lCropWidth;
+            overlayR.src_rect.y = 0;
+            overlayR.src_rect.w = width - lCropWidth;
+            overlayR.src_rect.h = height;
+            overlayR.dst_rect.x = 0;
+            overlayR.dst_rect.y = 0;
+            overlayR.dst_rect.w = rWidth;
+            overlayR.dst_rect.h = height;
+            overlayR.alpha = 0xFF;
+            overlayR.flags = MDSS_MDP_RIGHT_MIXER;
+            overlayR.transp_mask = MDP_TRANSP_NOP;
+            overlayR.id = MSMFB_NEW_REQUEST;
+            ret = ioctl(fd, MSMFB_OVERLAY_SET, &overlayR);
+            if(ret < 0)
+            {
+                ERROR("OverlayR Set Failed");
+                return ret;
+            }
+            data->overlayR_id = overlayR.id;
+        }
+    }
+
+    return 0;
+}
+
+static int free_overlay(struct fb_qcom_overlay_data *data, int fd)
+{
+    int ret = 0;
+    struct mdp_display_commit ext_commit;
+
+    if(!isDisplaySplit(data))
+    {
+        if(data->overlayL_id != MSMFB_NEW_REQUEST)
+        {
+            ret = ioctl(fd, MSMFB_OVERLAY_UNSET, &data->overlayL_id);
+            if(ret)
+            {
+                ERROR("OverlayL Unset Failed");
+                data->overlayL_id = MSMFB_NEW_REQUEST;
+                return ret;
+            }
+        }
+    }
+    else
+    {
+        if(data->overlayL_id != MSMFB_NEW_REQUEST)
+        {
+            ret = ioctl(fd, MSMFB_OVERLAY_UNSET, &data->overlayL_id);
+            if(ret)
+            {
+                ERROR("OverlayL Unset Failed");
+                data->overlayL_id = MSMFB_NEW_REQUEST;
+                return ret;
+            }
+        }
+
+        if(data->overlayR_id != MSMFB_NEW_REQUEST)
+        {
+            ret = ioctl(fd, MSMFB_OVERLAY_UNSET, &data->overlayR_id);
+            if(ret)
+            {
+                ERROR("OverlayR Unset Failed");
+                data->overlayR_id = MSMFB_NEW_REQUEST;
+                return ret;
+            }
+        }
+    }
+
+    memset(&ext_commit, 0, sizeof(struct mdp_display_commit));
+    ext_commit.flags = MDP_DISPLAY_COMMIT_OVERLAY;
+
+    data->overlayL_id = MSMFB_NEW_REQUEST;
+    data->overlayR_id = MSMFB_NEW_REQUEST;
+
+    ret = ioctl(fd, MSMFB_DISPLAY_COMMIT, &ext_commit);
+    if(ret < 0)
+    {
+        ERROR("Clear MSMFB_DISPLAY_COMMIT failed!");
+        return ret;
+    }
+
+    return 0;
+}
+
+static int impl_open(struct framebuffer *fb)
+{
+    struct fb_qcom_overlay_data *data = mzalloc(sizeof(struct fb_qcom_overlay_data));
+    data->overlayL_id = MSMFB_NEW_REQUEST;
+    data->overlayR_id = MSMFB_NEW_REQUEST;
+    data->width = fb->vi.xres;
+    data->leftSplit = data->width / 2;
+
+    setDisplaySplit(data);
+
+#ifdef TW_SCREEN_BLANK_ON_BOOT
+    ioctl(fb->fd, FBIOBLANK, FB_BLANK_POWERDOWN);
+    ioctl(fb->fd, FBIOBLANK, FB_BLANK_UNBLANK);
+#endif
+
+    if(alloc_ion_mem(data, fb->fi.line_length * fb->vi.yres) < 0)
+        goto fail;
+
+    if(allocate_overlay(data, fb->fd, fb->vi.xres, fb->vi.yres) < 0)
+    {
+        free_ion_mem(data);
+        goto fail;
+    }
+
+    data->vsync = fb_qcom_vsync_init(fb->fd);
+
+    fb->impl_data = data;
+    return 0;
+
+fail:
+    free(data);
+    return -1;
+}
+
+static void impl_close(struct framebuffer *fb)
+{
+    struct fb_qcom_overlay_data *data = fb->impl_data;
+    fb_qcom_vsync_destroy(data->vsync);
+    free_overlay(data, fb->fd);
+    free_ion_mem(data);
+    free(data);
+    fb->impl_data = NULL;
+}
+
+static int impl_update(struct framebuffer *fb)
+{
+    int ret = 0;
+    struct msmfb_overlay_data ovdataL, ovdataR;
+    struct mdp_display_commit ext_commit;
+    struct fb_qcom_overlay_data *data = fb->impl_data;
+    struct fb_qcom_overlay_mem_info *info = &data->mem_info[data->active_mem];
+
+    if(!isDisplaySplit(data))
+    {
+        if(data->overlayL_id == MSMFB_NEW_REQUEST)
+        {
+            ERROR("display_frame failed, no overlay\n");
+            return -EINVAL;
+        }
+
+        memset(&ovdataL, 0, sizeof(struct msmfb_overlay_data));
+
+        ovdataL.id = data->overlayL_id;
+        ovdataL.data.flags = 0;
+        ovdataL.data.offset = info->offset;
+        ovdataL.data.memory_id = info->mem_fd;
+        ret = ioctl(fb->fd, MSMFB_OVERLAY_PLAY, &ovdataL);
+        if(ret < 0)
+        {
+            ERROR("overlay_display_frame failed, overlay play Failed\n");
+            return -1;
+        }
+    }
+    else
+    {
+        if(data->overlayL_id == MSMFB_NEW_REQUEST)
+        {
+            ERROR("display_frame failed, no overlayL \n");
+            return -EINVAL;
+        }
+
+        memset(&ovdataL, 0, sizeof(struct msmfb_overlay_data));
+
+        ovdataL.id = data->overlayL_id;
+        ovdataL.data.flags = 0;
+        ovdataL.data.offset = info->offset;
+        ovdataL.data.memory_id = info->mem_fd;
+        ret = ioctl(fb->fd, MSMFB_OVERLAY_PLAY, &ovdataL);
+        if(ret < 0)
+        {
+            ERROR("overlay_display_frame failed, overlayL play Failed\n");
+            return ret;
+        }
+
+        if(data->overlayR_id == MSMFB_NEW_REQUEST)
+        {
+            ERROR("display_frame failed, no overlayR \n");
+            return -EINVAL;
+        }
+
+        memset(&ovdataR, 0, sizeof(struct msmfb_overlay_data));
+
+        ovdataR.id = data->overlayR_id;
+        ovdataR.data.flags = 0;
+        ovdataR.data.offset = info->offset;
+        ovdataR.data.memory_id = info->mem_fd;
+        ret = ioctl(fb->fd, MSMFB_OVERLAY_PLAY, &ovdataR);
+        if(ret < 0)
+        {
+            ERROR("overlay_display_frame failed, overlayR play Failed\n");
+            return ret;
+        }
+    }
+
+    memset(&ext_commit, 0, sizeof(struct mdp_display_commit));
+    ext_commit.flags = MDP_DISPLAY_COMMIT_OVERLAY;
+
+    fb_qcom_vsync_wait(data->vsync);
+
+    ret = ioctl(fb->fd, MSMFB_DISPLAY_COMMIT, &ext_commit);
+    if(ret < 0)
+    {
+        ERROR("overlay_display_frame failed, overlay commit Failed\n!");
+        return -1;
+    }
+
+    if(++data->active_mem >= NUM_BUFFERS)
+        data->active_mem = 0;
+
+    return ret;
+}
+
+static void *impl_get_frame_dest(struct framebuffer *fb)
+{
+    struct fb_qcom_overlay_data *data = fb->impl_data;
+    return data->mem_info[data->active_mem].mem_buf;
+}
+
+const struct fb_impl fb_impl_qcom_overlay = {
+    .name = "Qualcomm ION overlay",
+    .impl_id = FB_IMPL_QCOM_OVERLAY,
+
+    .open = impl_open,
+    .close = impl_close,
+    .update = impl_update,
+    .get_frame_dest = impl_get_frame_dest,
+};
diff --git a/lib/framebuffer_truetype.c b/lib/framebuffer_truetype.c
index ba2ed89..95349d7 100755
--- a/lib/framebuffer_truetype.c
+++ b/lib/framebuffer_truetype.c
@@ -1,832 +1,832 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <errno.h>
-#include <string.h>
-#include <ctype.h>
-#include <ft2build.h>
-#include FT_FREETYPE_H
-#include FT_GLYPH_H
-
-#include "log.h"
-#include "framebuffer.h"
-#include "util.h"
-#include "containers.h"
-#include "mrom_data.h"
-
-#define LINE_SPACING 1.15
-
-#if 0
-#define TT_LOG(fmt, x...) INFO("TT: "fmt, ##x)
-#else
-#define TT_LOG(x...) ;
-#endif
-
-static const char *FONT_FILES[STYLE_COUNT] = {
-    "Roboto-Regular.ttf",     // STYLE_NORMAL
-    "Roboto-Italic.ttf",      // STYLE_ITALIC
-    "Roboto-Bold.ttf",        // STYLE_BOLD
-    "Roboto-BoldItalic.ttf",  // STYLE_BOLD_ITALIC
-    "Roboto-Medium.ttf",      // STYLE_MEDIUM
-    "RobotoCondensed-Regular.ttf", // STYLE_CONDENSED
-    "OxygenMono-Regular.ttf", // STYLE_MONOSPACE
-};
-
-struct glyphs_entry
-{
-    FT_Face face;
-    imap *glyphs;
-};
-
-struct strings_entry
-{
-    px_type *data;
-    int w, h;
-    int baseline;
-    int refcnt;
-    px_type color;
-};
-
-struct text_cache
-{
-    imap *glyphs[STYLE_COUNT];
-    imap *strings;
-    FT_Library ft_lib;
-};
-
-static struct text_cache cache = {
-    .glyphs = { 0 },
-    .strings = 0,
-    .ft_lib = NULL
-};
-
-struct text_line
-{
-    char *text; // doesn't end with \0
-    int len;
-    int w, h, base;
-    int offX, offY;
-    FT_Vector *pos;
-};
-
-typedef struct
-{
-    char *text;
-    px_type color;
-    int size;
-    int justify;
-    int style;
-    int baseline;
-    int wrap_w;
-} text_extra;
-
-static int convert_ft_bitmap(FT_BitmapGlyph bit, px_type color, px_type *res_data, int stride, struct text_line *line, FT_Vector *pos)
-{
-    int x, y;
-    uint8_t *buff;
-    px_type *res_itr;
-
-    if(bit->bitmap.pixel_mode != FT_PIXEL_MODE_GRAY)
-    {
-        ERROR("Unsupported pixel mode in FT_BitmapGlyph %d\n", bit->bitmap.pixel_mode);
-        return -1;
-    }
-
-    //INFO("Bitmap w %d baseline %d pos [%d; %d] left %d top %d rows %d cols %d pitch %d\n", line->w, line->base, pos->x, pos->y, bit->left, bit->top, bit->bitmap.rows, bit->bitmap.width, bit->bitmap.pitch);
-
-    buff = (uint8_t*)bit->bitmap.buffer;
-    res_itr = (px_type*)(((uint32_t*)res_data) + (line->offY + line->base - bit->top)*stride + (line->offX + pos->x + bit->left));
-
-    // FIXME: if bit->left is negative and everything else is 0 (e.g. letter 'j' in Roboto-Regular),
-    // the result might end up being before the buffer - I'm not sure how to properly handle this.
-    if(res_itr < res_data)
-        res_itr = res_data;
-
-    for(y = 0; y < bit->bitmap.rows; ++y)
-    {
-        for(x = 0; x < bit->bitmap.width; ++x)
-        {
-#if PIXEL_SIZE == 4
-            *res_itr++ = color | (buff[x] << ((PX_IDX_A*8)));
-#else
-            *res_itr++ = color;
-            ((uint8_t*)res_itr)[0] = ((((buff[x]*100)/0xFF)*31)/100);
-            ((uint8_t*)res_itr)[1] = ((((buff[x]*100)/0xFF)*63)/100);
-            ++res_itr;
-#endif
-        }
-        buff += bit->bitmap.pitch;
-        res_itr = (px_type*)(((uint32_t*)res_itr) + stride - bit->bitmap.width);
-    }
-    return 0;
-}
-
-static struct glyphs_entry *get_cache_for_size(int style, const int size)
-{
-    int error;
-    struct glyphs_entry *res;
-
-    if(!cache.ft_lib)
-    {
-        error = FT_Init_FreeType(&cache.ft_lib);
-        if(error)
-        {
-            ERROR("libtruetype init failed with %d\n", error);
-            return NULL;
-        }
-    }
-
-    if(!cache.glyphs[style])
-        cache.glyphs[style] = imap_create();
-
-retry_load:
-    res = imap_get_val(cache.glyphs[style], size);
-    if(!res)
-    {
-        char buff[128];
-        res = mzalloc(sizeof(struct glyphs_entry));
-        snprintf(buff, sizeof(buff), "%s/res/%s", mrom_dir(), FONT_FILES[style]);
-        error = FT_New_Face(cache.ft_lib, buff, 0, &res->face);
-        if(error)
-        {
-            ERROR("font style %d load failed with %d\n", style, error);
-            free(res);
-
-            if(style != STYLE_NORMAL)
-            {
-                ERROR("Retrying with STYLE_NORMAL instead.");
-                style = STYLE_NORMAL;
-                goto retry_load;
-            }
-
-            return NULL;
-        }
-
-        error = FT_Set_Char_Size(res->face, 0, size*16, MR_DPI_FONT, MR_DPI_FONT);
-        if(error)
-        {
-            ERROR("failed to set font size with %d\n", error);
-            FT_Done_Face(res->face);
-            free(res);
-            return NULL;
-        }
-
-        res->glyphs = imap_create();
-        imap_add_not_exist(cache.glyphs[style], size, res);
-    }
-
-    return res;
-}
-
-static struct strings_entry *get_cache_for_string(text_extra *ex)
-{
-    if(!cache.strings)
-        return NULL;
-
-    map *c = imap_get_val(cache.strings, ex->size);
-    if(!c)
-        return NULL;
-
-    struct strings_entry *sen = map_get_val(c, ex->text);
-    if(sen && sen->color == ex->color)
-        return sen;
-    return NULL;
-}
-
-static void add_to_strings(fb_img *img)
-{
-    text_extra *ex = img->extra;
-
-    if(!cache.strings)
-        cache.strings = imap_create();
-
-    map *c = imap_get_val(cache.strings, ex->size);
-    if(!c)
-    {
-        c = map_create();
-        imap_add_not_exist(cache.strings, ex->size, c);
-    }
-    else if(map_find(c, ex->text) != -1)
-    {
-        return;
-    }
-
-    struct strings_entry *sen = mzalloc(sizeof(struct strings_entry));
-    sen->data = img->data;
-    sen->refcnt = 1;
-    sen->w = img->w;
-    sen->h = img->h;
-    sen->color = ex->color;
-    sen->baseline = ex->baseline;
-    map_add_not_exist(c, ex->text, sen);
-
-    TT_LOG("CACHE: add %02d 0x%08X\n", ex->size, (uint32_t)img->data);
-}
-
-static int unlink_from_caches(text_extra *ex)
-{
-    struct glyphs_entry *en;
-    struct strings_entry *sen;
-
-    sen = get_cache_for_string(ex);
-    if(sen)
-    {
-        --sen->refcnt;
-        TT_LOG("CACHE: drop %02d 0x%08X\n", ex->size, (uint32_t)sen->data);
-        return 1;
-    }
-    return 0;
-}
-
-static int measure_line(struct text_line *line, struct glyphs_entry **gen, int8_t *style_map, text_extra *ex)
-{
-    int i, penX, penY, idx, prev_idx, error, last_space, wrapped;
-    FT_Vector delta;
-    FT_Glyph glyph;
-    struct glyphs_entry *en;
-    FT_BBox bbox, glyph_bbox;
-    bbox.yMin = LONG_MAX;
-    bbox.yMax = LONG_MIN;
-
-    penX = penY = prev_idx = last_space = wrapped = 0;
-
-    // Load glyphs and their positions
-    for(i = 0; i < line->len; ++i, ++style_map)
-    {
-        if(*style_map == -1)
-            continue;
-
-        en = gen[*style_map];
-        idx = FT_Get_Char_Index(en->face, line->text[i]);
-
-        if(FT_HAS_KERNING(en->face) && prev_idx && idx)
-        {
-            FT_Get_Kerning(en->face, prev_idx, idx, FT_KERNING_DEFAULT, &delta);
-            penX += delta.x >> 6;
-        }
-
-        if(ex->wrap_w && penX >= ex->wrap_w)
-        {
-            if(last_space == 0)
-                last_space = i-1;
-            line->len = last_space + 1;
-            if(i-1 != last_space)
-                penX = line->pos[last_space+1].x;
-            wrapped = 1;
-            break;
-        }
-
-        if(isspace(line->text[i]))
-            last_space = i;
-
-        glyph = imap_get_val(en->glyphs, (int)line->text[i]);
-        if(!glyph)
-        {
-            error = FT_Load_Glyph(en->face, idx, FT_LOAD_DEFAULT);
-            if(error)
-                continue;
-
-            error = FT_Get_Glyph(en->face->glyph, &glyph);
-            if(error)
-                continue;
-
-            imap_add_not_exist(en->glyphs, (int)line->text[i], glyph);
-        }
-
-        FT_Glyph_Get_CBox(glyph, ft_glyph_bbox_pixels, &glyph_bbox);
-        bbox.yMin = imin(bbox.yMin, glyph_bbox.yMin);
-        bbox.yMax = imax(bbox.yMax, glyph_bbox.yMax);
-
-        line->pos[i].x = penX;
-        line->pos[i].y = penY;
-
-        penX += glyph->advance.x >> 16;
-        prev_idx = idx;
-    }
-
-    if(bbox.yMin > bbox.yMax)
-        bbox.yMin = bbox.yMax = 0;
-
-    line->w = penX;
-    line->h = bbox.yMax - bbox.yMin;
-    line->base = bbox.yMax;
-    return wrapped;
-}
-
-static void render_line(struct text_line *line, struct glyphs_entry **gen, int8_t *style_map, px_type *res_data, int stride, px_type converted_color)
-{
-    int i, error;
-    FT_Glyph *image;
-    FT_BitmapGlyph bit;
-    struct glyphs_entry *en;
-
-    for(i = 0; i < line->len; ++i, ++style_map)
-    {
-        if(*style_map == -1)
-            continue;
-
-        image = imap_get_ref(gen[*style_map]->glyphs, (int)line->text[i]); // pre-cached from measure_line()
-        error = FT_Glyph_To_Bitmap(image, FT_RENDER_MODE_NORMAL, NULL, 1);
-        if(error == 0)
-        {
-            bit = (FT_BitmapGlyph)(*image);
-            convert_ft_bitmap(bit, converted_color, res_data, stride, line, &line->pos[i]);
-        }
-    }
-}
-
-static void destroy_line(struct text_line *line)
-{
-    free(line->pos);
-    free(line);
-}
-
-static int8_t *build_style_map(text_extra *ex, int8_t **style_map, struct glyphs_entry **gen)
-{
-    static const char style_char_map[STYLE_COUNT] = {
-        0,    // STYLE_NORMAL
-        'i',  // STYLE_ITALIC
-        'b',  // STYLE_BOLD
-        'y',  // STYLE_BOLD_ITALIC
-        'm',  // STYLE_MEDIUM
-        'c',  // STYLE_CONDENSED
-        's',  // STYLE_MONOSPACE
-    };
-
-    char *s, *e, *r;
-    int span_start = 0, span_end;
-    const int len = strlen(ex->text);
-    int cur_style = ex->style;
-
-    gen[cur_style] = get_cache_for_size(cur_style, ex->size);
-    if(!gen[cur_style])
-        return NULL;
-
-    int8_t *styles = malloc(len);
-    memset(styles, cur_style, len);
-
-    e = ex->text;
-    while((s = strchr(e, '<')) && (e = strchr(s, '>')))
-    {
-        ++s;
-        switch(e - s)
-        {
-            case 1:
-            {
-                if(cur_style != ex->style)
-                    break;
-
-                r = memchr(style_char_map, *s, STYLE_COUNT);
-                if(!r)
-                    break;
-                cur_style = r - style_char_map;
-                span_start = (e + 1) - ex->text;
-                memset(styles + ((s-1) - ex->text), -1, 3);
-                break;
-            }
-            case 2:
-            {
-                if(cur_style == ex->style || s[0] != '/')
-                    break;
-
-                r = memchr(style_char_map, s[1], STYLE_COUNT);
-                if(!r || (r - style_char_map) != cur_style)
-                    break;
-
-                if(!gen[cur_style] && !(gen[cur_style] = get_cache_for_size(cur_style, ex->size)))
-                    goto fail;
-
-                span_end = (s-1) - ex->text;
-                memset(styles + span_start, cur_style, span_end - span_start);
-                memset(styles + span_end, -1, 4);
-                cur_style = ex->style;
-                break;
-            }
-        }
-        ++e;
-    }
-
-
-    *style_map = styles;
-    return styles;
-
-fail:
-    free(styles);
-    return NULL;
-}
-
-static void fb_text_render(fb_img *img)
-{
-    int maxW, maxH, totalH, i, lineH, lines_cnt;
-    struct glyphs_entry *gen[STYLE_COUNT] = { 0 };
-    struct strings_entry *sen;
-    struct text_line **lines = NULL;
-    char *start, *end;
-    px_type *res_data;
-    text_extra *ex = img->extra;
-    int8_t *style_map = NULL;
-
-    sen = get_cache_for_string(ex);
-    if(sen)
-    {
-        img->w = sen->w;
-        img->h = sen->h;
-        img->data = sen->data;
-        ex->baseline = sen->baseline;
-        ++sen->refcnt;
-
-        TT_LOG("CACHE: use %02d 0x%08X\n", ex->size, (uint32_t)sen->data);
-        TT_LOG("Getting string %dx%d %s from cache\n", img->w, img->h, ex->text);
-        return;
-    }
-
-    if(!build_style_map(ex, &style_map, gen))
-    {
-        TT_LOG("Failed to build style map for string %s\n", ex->text);
-        return;
-    }
-
-    TT_LOG("Rendering string %s\n", ex->text);
-
-    maxW = maxH = lines_cnt = 0;
-    start = ex->text;
-    while(start && *start)
-    {
-        struct text_line *line = mzalloc(sizeof(struct text_line));
-        line->text = start;
-
-        end = strchr(start, '\n');
-        if(end == NULL)
-        {
-            line->len = strlen(start);
-            start = NULL;
-        }
-        else
-        {
-            line->len = end - start;
-            start = ++end;
-        }
-
-        line->pos = mzalloc(sizeof(FT_Vector)*line->len);
-
-        if(measure_line(line, gen, style_map + (line->text - ex->text), ex))
-            start = line->text + line->len;
-
-        maxW = imax(maxW, line->w);
-        maxH = imax(maxH, line->h);
-
-        list_add(&lines, line);
-        ++lines_cnt;
-    }
-
-    lineH = maxH * LINE_SPACING;
-    totalH = 0;
-    for(i = 0; i < lines_cnt; ++i)
-    {
-        switch(ex->justify)
-        {
-            case JUSTIFY_LEFT:
-                break;
-            case JUSTIFY_CENTER:
-                lines[i]->offX = maxW/2 - lines[i]->w/2;
-                break;
-            case JUSTIFY_RIGHT:
-                lines[i]->offX = maxW - lines[i]->w;
-                break;
-        }
-        lines[i]->offY = totalH;
-        totalH += lineH;
-        ex->baseline = lines[i]->offY + lines[i]->base;
-    }
-
-    if(lines_cnt > 1)
-        ex->baseline /= 2;
-
-    img->w = img->h = 0;
-
-    // always 4 bytes per pixel cause of fb_img data structure
-    img->data = mzalloc(maxW*totalH*4);
-
-    for(i = 0; i < lines_cnt; ++i)
-        render_line(lines[i], gen, style_map + (lines[i]->text - ex->text), img->data, maxW, ex->color);
-
-    img->w = maxW;
-    img->h = totalH;
-
-    add_to_strings(img);
-
-    list_clear(&lines, &destroy_line);
-    free(style_map);
-}
-
-fb_img *fb_add_text(int x, int y, uint32_t color, int size, const char *fmt, ...)
-{
-    int ret;
-    fb_img *res;
-    fb_text_proto *p;
-    char txt[512] = { 0 };
-    char *buff = txt;
-    va_list ap;
-
-    txt[0] = 0;
-
-    va_start(ap, fmt);
-    ret = vsnprintf(txt, sizeof(txt), fmt, ap);
-    if(ret >= (int)sizeof(txt))
-    {
-        buff = malloc(ret+1);
-        vsnprintf(buff, ret+1, fmt, ap);
-    }
-    va_end(ap);
-
-    p = fb_text_create(x, y, color, size, buff);
-    res = fb_text_finalize(p);
-
-    if(ret >= (int)sizeof(txt))
-        free(buff);
-    return res;
-}
-
-fb_text_proto *fb_text_create(int x, int y, uint32_t color, int size, const char *text)
-{
-    fb_text_proto *p = mzalloc(sizeof(fb_text_proto));
-    p->x = x;
-    p->y = y;
-    p->level = LEVEL_TEXT;
-    p->parent = &DEFAULT_FB_PARENT;
-    p->color = color;
-    p->size = size;
-    p->style = STYLE_NORMAL;
-    if(text)
-        p->text = strdup(text);
-    return p;
-}
-
-fb_img *fb_text_finalize(fb_text_proto *p)
-{
-    fb_img *result = mzalloc(sizeof(fb_img));
-    result->id = fb_generate_item_id();
-    result->type = FB_IT_IMG;
-    result->parent = p->parent;
-    result->level = p->level;
-    result->x = p->x;
-    result->y = p->y;
-    result->img_type = FB_IMG_TYPE_TEXT;
-    result->data = NULL;
-    result->extra = mzalloc(sizeof(text_extra));
-
-    text_extra *extras = result->extra;
-    // set color's alpha to 0 because data from the font will act as alpha
-    extras->color = fb_convert_color(p->color & ~(0xFF << 24));
-    extras->size = p->size;
-    extras->justify = p->justify;
-    extras->style = p->style;
-    extras->text = p->text;
-    extras->wrap_w = p->wrap_w;
-
-    free(p);
-
-    fb_text_render(result);
-    fb_ctx_add_item(result);
-
-    return result;
-}
-
-void fb_text_set_color(fb_img *img, uint32_t color)
-{
-    text_extra *extras = img->extra;
-    int copy = 0;
-    const px_type converted_color = fb_convert_color(color & ~(0xFF << 24));
-
-    if(extras->color == converted_color)
-        return;
-
-    struct strings_entry *sen = get_cache_for_string(extras);
-    if(sen)
-    {
-        if(sen->refcnt == 1)
-            sen->color = converted_color;
-        else
-        {
-            copy = 1;
-            --sen->refcnt;
-        }
-    }
-
-    extras->color = converted_color;
-
-    fb_items_lock();
-
-    px_type *itr = img->data;
-    if(copy)
-    {
-        img->data = malloc(img->w*img->h*4);
-        memcpy(img->data, itr, img->w*img->h*4);
-        itr = img->data;
-    }
-
-    const px_type *end = (px_type*)(((uint32_t*)itr) + img->w * img->h);
-    int alpha;
-
-    while(itr != end)
-    {
-#if PIXEL_SIZE == 4
-        alpha = *itr & (0xFF << PX_IDX_A*8);
-        if(alpha != 0)
-            *itr = converted_color | alpha;
-        ++itr;
-#else
-        if(itr[1] != 0)
-            *itr = converted_color;
-        itr += 2;
-#endif
-    }
-
-    fb_items_unlock();
-}
-
-void fb_text_set_size(fb_img *img, int size)
-{
-    text_extra *ex = img->extra;
-
-    if(size == ex->size)
-        return;
-
-    fb_items_lock();
-    if(unlink_from_caches(ex) == 0)
-    {
-        img->w = img->h = 0;
-        free(img->data);
-        img->data = NULL;
-    }
-
-    ex->size = size;
-    fb_text_render(img);
-    fb_items_unlock();
-}
-
-void fb_text_set_content(fb_img *img, const char *text)
-{
-    text_extra *ex = img->extra;
-
-    if(text == ex->text)
-        return;
-
-    fb_items_lock();
-    if(unlink_from_caches(ex) == 0)
-    {
-        img->w = img->h = 0;
-        free(img->data);
-        img->data = NULL;
-    }
-
-    ex->text = realloc(ex->text, strlen(text)+1);
-    strcpy(ex->text, text);
-    fb_text_render(img);
-    fb_items_unlock();
-}
-
-char *fb_text_get_content(fb_img *img)
-{
-    text_extra *ex = img->extra;
-    return ex->text;
-}
-
-inline void center_text(fb_img *text, int targetX, int targetY, int targetW, int targetH)
-{
-    text_extra *ex = text->extra;
-
-    if(targetX != -1 || targetW != -1)
-        text->x = targetX + (targetW/2 - text->w/2);
-
-    if(targetY != -1 || targetH != -1)
-        text->y = targetY + (targetH/2 - ex->baseline/2);
-}
-
-void fb_text_destroy(fb_img *i)
-{
-    text_extra *ex = i->extra;
-
-    struct strings_entry *sen = get_cache_for_string(ex);
-    if(sen)
-    {
-        TT_LOG("CACHE: drop %02d 0x%08X\n", ex->size, (uint32_t)sen->data);
-        --sen->refcnt;
-    }
-    else
-    {
-        TT_LOG("CACHE: free %02d 0x%08X\n", ex->size, (uint32_t)i->data);
-        free(i->data);
-    }
-
-    free(ex->text);
-    free(ex);
-    // fb_img is freed in fb_destroy_item
-}
-
-static int drop_glyphs_cache(imap *g_cache)
-{
-    size_t i;
-    for(i = 0; i < g_cache->size;)
-    {
-        const int key = g_cache->keys[i];
-        struct glyphs_entry *en = g_cache->values[i];
-        imap_destroy(en->glyphs, (void*)&FT_Done_Glyph);
-        FT_Done_Face(en->face);
-        imap_rm(g_cache, key, &free);
-    }
-    return g_cache->size == 0;
-}
-
-static int drop_strings_cache(imap *s_cache)
-{
-    size_t i, x;
-    for(i = 0; i < s_cache->size; )
-    {
-        const int key = s_cache->keys[i];
-        map *size_c = s_cache->values[i];
-        TT_LOG("Dropping unused string caches for size %d\n", key);
-
-        for(x = 0; x < size_c->size; )
-        {
-            char *s_key = size_c->keys[x];
-            struct strings_entry *sen = size_c->values[x];
-
-            TT_LOG("strings_entry size %d str \"%s\" has refcnt %d\n", key, s_key, sen->refcnt);
-            if(sen->refcnt == 0)
-            {
-                free(sen->data);
-                map_rm(size_c, s_key, &free);
-            }
-            else
-                ++x;
-        }
-
-        if(size_c->size == 0)
-        {
-            TT_LOG("Removing string cache for size %d\n", key);
-            map_destroy(size_c, &free);
-            imap_rm(s_cache, key, NULL);
-        }
-        else
-            ++i;
-    }
-    return s_cache->size == 0;
-}
-
-void fb_text_drop_cache_unused(void)
-{
-    size_t s;
-    int free_ft_lib = 1;
-
-    for(s = 0; s < STYLE_COUNT; ++s)
-    {
-        if(cache.glyphs[s])
-        {
-            if(drop_glyphs_cache(cache.glyphs[s]))
-            {
-                TT_LOG("Whole glyph cache was freed.\n");
-                imap_destroy(cache.glyphs[s], NULL);
-                cache.glyphs[s] = NULL;
-            }
-            else
-                free_ft_lib = 0;
-        }
-    }
-
-    if(cache.strings)
-    {
-        if(drop_strings_cache(cache.strings))
-        {
-            TT_LOG("Whole string cache was freed.\n");
-            imap_destroy(cache.strings, NULL);
-            cache.strings = NULL;
-        }
-    }
-
-    if(free_ft_lib && cache.ft_lib)
-    {
-        TT_LOG("Freeing libfreetype\n");
-        FT_Done_FreeType(cache.ft_lib);
-        cache.ft_lib = NULL;
-    }
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <string.h>
+#include <ctype.h>
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+
+#include "log.h"
+#include "framebuffer.h"
+#include "util.h"
+#include "containers.h"
+#include "mrom_data.h"
+
+#define LINE_SPACING 1.15
+
+#if 0
+#define TT_LOG(fmt, x...) INFO("TT: "fmt, ##x)
+#else
+#define TT_LOG(x...) ;
+#endif
+
+static const char *FONT_FILES[STYLE_COUNT] = {
+    "Roboto-Regular.ttf",     // STYLE_NORMAL
+    "Roboto-Italic.ttf",      // STYLE_ITALIC
+    "Roboto-Bold.ttf",        // STYLE_BOLD
+    "Roboto-BoldItalic.ttf",  // STYLE_BOLD_ITALIC
+    "Roboto-Medium.ttf",      // STYLE_MEDIUM
+    "RobotoCondensed-Regular.ttf", // STYLE_CONDENSED
+    "OxygenMono-Regular.ttf", // STYLE_MONOSPACE
+};
+
+struct glyphs_entry
+{
+    FT_Face face;
+    imap *glyphs;
+};
+
+struct strings_entry
+{
+    px_type *data;
+    int w, h;
+    int baseline;
+    int refcnt;
+    px_type color;
+};
+
+struct text_cache
+{
+    imap *glyphs[STYLE_COUNT];
+    imap *strings;
+    FT_Library ft_lib;
+};
+
+static struct text_cache cache = {
+    .glyphs = { 0 },
+    .strings = 0,
+    .ft_lib = NULL
+};
+
+struct text_line
+{
+    char *text; // doesn't end with \0
+    int len;
+    int w, h, base;
+    int offX, offY;
+    FT_Vector *pos;
+};
+
+typedef struct
+{
+    char *text;
+    px_type color;
+    int size;
+    int justify;
+    int style;
+    int baseline;
+    int wrap_w;
+} text_extra;
+
+static int convert_ft_bitmap(FT_BitmapGlyph bit, px_type color, px_type *res_data, int stride, struct text_line *line, FT_Vector *pos)
+{
+    int x, y;
+    uint8_t *buff;
+    px_type *res_itr;
+
+    if(bit->bitmap.pixel_mode != FT_PIXEL_MODE_GRAY)
+    {
+        ERROR("Unsupported pixel mode in FT_BitmapGlyph %d\n", bit->bitmap.pixel_mode);
+        return -1;
+    }
+
+    //INFO("Bitmap w %d baseline %d pos [%d; %d] left %d top %d rows %d cols %d pitch %d\n", line->w, line->base, pos->x, pos->y, bit->left, bit->top, bit->bitmap.rows, bit->bitmap.width, bit->bitmap.pitch);
+
+    buff = (uint8_t*)bit->bitmap.buffer;
+    res_itr = (px_type*)(((uint32_t*)res_data) + (line->offY + line->base - bit->top)*stride + (line->offX + pos->x + bit->left));
+
+    // FIXME: if bit->left is negative and everything else is 0 (e.g. letter 'j' in Roboto-Regular),
+    // the result might end up being before the buffer - I'm not sure how to properly handle this.
+    if(res_itr < res_data)
+        res_itr = res_data;
+
+    for(y = 0; y < bit->bitmap.rows; ++y)
+    {
+        for(x = 0; x < bit->bitmap.width; ++x)
+        {
+#if PIXEL_SIZE == 4
+            *res_itr++ = color | (buff[x] << ((PX_IDX_A*8)));
+#else
+            *res_itr++ = color;
+            ((uint8_t*)res_itr)[0] = ((((buff[x]*100)/0xFF)*31)/100);
+            ((uint8_t*)res_itr)[1] = ((((buff[x]*100)/0xFF)*63)/100);
+            ++res_itr;
+#endif
+        }
+        buff += bit->bitmap.pitch;
+        res_itr = (px_type*)(((uint32_t*)res_itr) + stride - bit->bitmap.width);
+    }
+    return 0;
+}
+
+static struct glyphs_entry *get_cache_for_size(int style, const int size)
+{
+    int error;
+    struct glyphs_entry *res;
+
+    if(!cache.ft_lib)
+    {
+        error = FT_Init_FreeType(&cache.ft_lib);
+        if(error)
+        {
+            ERROR("libtruetype init failed with %d\n", error);
+            return NULL;
+        }
+    }
+
+    if(!cache.glyphs[style])
+        cache.glyphs[style] = imap_create();
+
+retry_load:
+    res = imap_get_val(cache.glyphs[style], size);
+    if(!res)
+    {
+        char buff[128];
+        res = mzalloc(sizeof(struct glyphs_entry));
+        snprintf(buff, sizeof(buff), "%s/res/%s", mrom_dir(), FONT_FILES[style]);
+        error = FT_New_Face(cache.ft_lib, buff, 0, &res->face);
+        if(error)
+        {
+            ERROR("font style %d load failed with %d\n", style, error);
+            free(res);
+
+            if(style != STYLE_NORMAL)
+            {
+                ERROR("Retrying with STYLE_NORMAL instead.");
+                style = STYLE_NORMAL;
+                goto retry_load;
+            }
+
+            return NULL;
+        }
+
+        error = FT_Set_Char_Size(res->face, 0, size*16, MR_DPI_FONT, MR_DPI_FONT);
+        if(error)
+        {
+            ERROR("failed to set font size with %d\n", error);
+            FT_Done_Face(res->face);
+            free(res);
+            return NULL;
+        }
+
+        res->glyphs = imap_create();
+        imap_add_not_exist(cache.glyphs[style], size, res);
+    }
+
+    return res;
+}
+
+static struct strings_entry *get_cache_for_string(text_extra *ex)
+{
+    if(!cache.strings)
+        return NULL;
+
+    map *c = imap_get_val(cache.strings, ex->size);
+    if(!c)
+        return NULL;
+
+    struct strings_entry *sen = map_get_val(c, ex->text);
+    if(sen && sen->color == ex->color)
+        return sen;
+    return NULL;
+}
+
+static void add_to_strings(fb_img *img)
+{
+    text_extra *ex = img->extra;
+
+    if(!cache.strings)
+        cache.strings = imap_create();
+
+    map *c = imap_get_val(cache.strings, ex->size);
+    if(!c)
+    {
+        c = map_create();
+        imap_add_not_exist(cache.strings, ex->size, c);
+    }
+    else if(map_find(c, ex->text) != -1)
+    {
+        return;
+    }
+
+    struct strings_entry *sen = mzalloc(sizeof(struct strings_entry));
+    sen->data = img->data;
+    sen->refcnt = 1;
+    sen->w = img->w;
+    sen->h = img->h;
+    sen->color = ex->color;
+    sen->baseline = ex->baseline;
+    map_add_not_exist(c, ex->text, sen);
+
+    TT_LOG("CACHE: add %02d 0x%08X\n", ex->size, (uint32_t)img->data);
+}
+
+static int unlink_from_caches(text_extra *ex)
+{
+    struct glyphs_entry *en;
+    struct strings_entry *sen;
+
+    sen = get_cache_for_string(ex);
+    if(sen)
+    {
+        --sen->refcnt;
+        TT_LOG("CACHE: drop %02d 0x%08X\n", ex->size, (uint32_t)sen->data);
+        return 1;
+    }
+    return 0;
+}
+
+static int measure_line(struct text_line *line, struct glyphs_entry **gen, int8_t *style_map, text_extra *ex)
+{
+    int i, penX, penY, idx, prev_idx, error, last_space, wrapped;
+    FT_Vector delta;
+    FT_Glyph glyph;
+    struct glyphs_entry *en;
+    FT_BBox bbox, glyph_bbox;
+    bbox.yMin = LONG_MAX;
+    bbox.yMax = LONG_MIN;
+
+    penX = penY = prev_idx = last_space = wrapped = 0;
+
+    // Load glyphs and their positions
+    for(i = 0; i < line->len; ++i, ++style_map)
+    {
+        if(*style_map == -1)
+            continue;
+
+        en = gen[*style_map];
+        idx = FT_Get_Char_Index(en->face, line->text[i]);
+
+        if(FT_HAS_KERNING(en->face) && prev_idx && idx)
+        {
+            FT_Get_Kerning(en->face, prev_idx, idx, FT_KERNING_DEFAULT, &delta);
+            penX += delta.x >> 6;
+        }
+
+        if(ex->wrap_w && penX >= ex->wrap_w)
+        {
+            if(last_space == 0)
+                last_space = i-1;
+            line->len = last_space + 1;
+            if(i-1 != last_space)
+                penX = line->pos[last_space+1].x;
+            wrapped = 1;
+            break;
+        }
+
+        if(isspace(line->text[i]))
+            last_space = i;
+
+        glyph = imap_get_val(en->glyphs, (int)line->text[i]);
+        if(!glyph)
+        {
+            error = FT_Load_Glyph(en->face, idx, FT_LOAD_DEFAULT);
+            if(error)
+                continue;
+
+            error = FT_Get_Glyph(en->face->glyph, &glyph);
+            if(error)
+                continue;
+
+            imap_add_not_exist(en->glyphs, (int)line->text[i], glyph);
+        }
+
+        FT_Glyph_Get_CBox(glyph, ft_glyph_bbox_pixels, &glyph_bbox);
+        bbox.yMin = imin(bbox.yMin, glyph_bbox.yMin);
+        bbox.yMax = imax(bbox.yMax, glyph_bbox.yMax);
+
+        line->pos[i].x = penX;
+        line->pos[i].y = penY;
+
+        penX += glyph->advance.x >> 16;
+        prev_idx = idx;
+    }
+
+    if(bbox.yMin > bbox.yMax)
+        bbox.yMin = bbox.yMax = 0;
+
+    line->w = penX;
+    line->h = bbox.yMax - bbox.yMin;
+    line->base = bbox.yMax;
+    return wrapped;
+}
+
+static void render_line(struct text_line *line, struct glyphs_entry **gen, int8_t *style_map, px_type *res_data, int stride, px_type converted_color)
+{
+    int i, error;
+    FT_Glyph *image;
+    FT_BitmapGlyph bit;
+    struct glyphs_entry *en;
+
+    for(i = 0; i < line->len; ++i, ++style_map)
+    {
+        if(*style_map == -1)
+            continue;
+
+        image = imap_get_ref(gen[*style_map]->glyphs, (int)line->text[i]); // pre-cached from measure_line()
+        error = FT_Glyph_To_Bitmap(image, FT_RENDER_MODE_NORMAL, NULL, 1);
+        if(error == 0)
+        {
+            bit = (FT_BitmapGlyph)(*image);
+            convert_ft_bitmap(bit, converted_color, res_data, stride, line, &line->pos[i]);
+        }
+    }
+}
+
+static void destroy_line(struct text_line *line)
+{
+    free(line->pos);
+    free(line);
+}
+
+static int8_t *build_style_map(text_extra *ex, int8_t **style_map, struct glyphs_entry **gen)
+{
+    static const char style_char_map[STYLE_COUNT] = {
+        0,    // STYLE_NORMAL
+        'i',  // STYLE_ITALIC
+        'b',  // STYLE_BOLD
+        'y',  // STYLE_BOLD_ITALIC
+        'm',  // STYLE_MEDIUM
+        'c',  // STYLE_CONDENSED
+        's',  // STYLE_MONOSPACE
+    };
+
+    char *s, *e, *r;
+    int span_start = 0, span_end;
+    const int len = strlen(ex->text);
+    int cur_style = ex->style;
+
+    gen[cur_style] = get_cache_for_size(cur_style, ex->size);
+    if(!gen[cur_style])
+        return NULL;
+
+    int8_t *styles = malloc(len);
+    memset(styles, cur_style, len);
+
+    e = ex->text;
+    while((s = strchr(e, '<')) && (e = strchr(s, '>')))
+    {
+        ++s;
+        switch(e - s)
+        {
+            case 1:
+            {
+                if(cur_style != ex->style)
+                    break;
+
+                r = memchr(style_char_map, *s, STYLE_COUNT);
+                if(!r)
+                    break;
+                cur_style = r - style_char_map;
+                span_start = (e + 1) - ex->text;
+                memset(styles + ((s-1) - ex->text), -1, 3);
+                break;
+            }
+            case 2:
+            {
+                if(cur_style == ex->style || s[0] != '/')
+                    break;
+
+                r = memchr(style_char_map, s[1], STYLE_COUNT);
+                if(!r || (r - style_char_map) != cur_style)
+                    break;
+
+                if(!gen[cur_style] && !(gen[cur_style] = get_cache_for_size(cur_style, ex->size)))
+                    goto fail;
+
+                span_end = (s-1) - ex->text;
+                memset(styles + span_start, cur_style, span_end - span_start);
+                memset(styles + span_end, -1, 4);
+                cur_style = ex->style;
+                break;
+            }
+        }
+        ++e;
+    }
+
+
+    *style_map = styles;
+    return styles;
+
+fail:
+    free(styles);
+    return NULL;
+}
+
+static void fb_text_render(fb_img *img)
+{
+    int maxW, maxH, totalH, i, lineH, lines_cnt;
+    struct glyphs_entry *gen[STYLE_COUNT] = { 0 };
+    struct strings_entry *sen;
+    struct text_line **lines = NULL;
+    char *start, *end;
+    px_type *res_data;
+    text_extra *ex = img->extra;
+    int8_t *style_map = NULL;
+
+    sen = get_cache_for_string(ex);
+    if(sen)
+    {
+        img->w = sen->w;
+        img->h = sen->h;
+        img->data = sen->data;
+        ex->baseline = sen->baseline;
+        ++sen->refcnt;
+
+        TT_LOG("CACHE: use %02d 0x%08X\n", ex->size, (uint32_t)sen->data);
+        TT_LOG("Getting string %dx%d %s from cache\n", img->w, img->h, ex->text);
+        return;
+    }
+
+    if(!build_style_map(ex, &style_map, gen))
+    {
+        TT_LOG("Failed to build style map for string %s\n", ex->text);
+        return;
+    }
+
+    TT_LOG("Rendering string %s\n", ex->text);
+
+    maxW = maxH = lines_cnt = 0;
+    start = ex->text;
+    while(start && *start)
+    {
+        struct text_line *line = mzalloc(sizeof(struct text_line));
+        line->text = start;
+
+        end = strchr(start, '\n');
+        if(end == NULL)
+        {
+            line->len = strlen(start);
+            start = NULL;
+        }
+        else
+        {
+            line->len = end - start;
+            start = ++end;
+        }
+
+        line->pos = mzalloc(sizeof(FT_Vector)*line->len);
+
+        if(measure_line(line, gen, style_map + (line->text - ex->text), ex))
+            start = line->text + line->len;
+
+        maxW = imax(maxW, line->w);
+        maxH = imax(maxH, line->h);
+
+        list_add(&lines, line);
+        ++lines_cnt;
+    }
+
+    lineH = maxH * LINE_SPACING;
+    totalH = 0;
+    for(i = 0; i < lines_cnt; ++i)
+    {
+        switch(ex->justify)
+        {
+            case JUSTIFY_LEFT:
+                break;
+            case JUSTIFY_CENTER:
+                lines[i]->offX = maxW/2 - lines[i]->w/2;
+                break;
+            case JUSTIFY_RIGHT:
+                lines[i]->offX = maxW - lines[i]->w;
+                break;
+        }
+        lines[i]->offY = totalH;
+        totalH += lineH;
+        ex->baseline = lines[i]->offY + lines[i]->base;
+    }
+
+    if(lines_cnt > 1)
+        ex->baseline /= 2;
+
+    img->w = img->h = 0;
+
+    // always 4 bytes per pixel cause of fb_img data structure
+    img->data = mzalloc(maxW*totalH*4);
+
+    for(i = 0; i < lines_cnt; ++i)
+        render_line(lines[i], gen, style_map + (lines[i]->text - ex->text), img->data, maxW, ex->color);
+
+    img->w = maxW;
+    img->h = totalH;
+
+    add_to_strings(img);
+
+    list_clear(&lines, &destroy_line);
+    free(style_map);
+}
+
+fb_img *fb_add_text(int x, int y, uint32_t color, int size, const char *fmt, ...)
+{
+    int ret;
+    fb_img *res;
+    fb_text_proto *p;
+    char txt[512] = { 0 };
+    char *buff = txt;
+    va_list ap;
+
+    txt[0] = 0;
+
+    va_start(ap, fmt);
+    ret = vsnprintf(txt, sizeof(txt), fmt, ap);
+    if(ret >= (int)sizeof(txt))
+    {
+        buff = malloc(ret+1);
+        vsnprintf(buff, ret+1, fmt, ap);
+    }
+    va_end(ap);
+
+    p = fb_text_create(x, y, color, size, buff);
+    res = fb_text_finalize(p);
+
+    if(ret >= (int)sizeof(txt))
+        free(buff);
+    return res;
+}
+
+fb_text_proto *fb_text_create(int x, int y, uint32_t color, int size, const char *text)
+{
+    fb_text_proto *p = mzalloc(sizeof(fb_text_proto));
+    p->x = x;
+    p->y = y;
+    p->level = LEVEL_TEXT;
+    p->parent = &DEFAULT_FB_PARENT;
+    p->color = color;
+    p->size = size;
+    p->style = STYLE_NORMAL;
+    if(text)
+        p->text = strdup(text);
+    return p;
+}
+
+fb_img *fb_text_finalize(fb_text_proto *p)
+{
+    fb_img *result = mzalloc(sizeof(fb_img));
+    result->id = fb_generate_item_id();
+    result->type = FB_IT_IMG;
+    result->parent = p->parent;
+    result->level = p->level;
+    result->x = p->x;
+    result->y = p->y;
+    result->img_type = FB_IMG_TYPE_TEXT;
+    result->data = NULL;
+    result->extra = mzalloc(sizeof(text_extra));
+
+    text_extra *extras = result->extra;
+    // set color's alpha to 0 because data from the font will act as alpha
+    extras->color = fb_convert_color(p->color & ~(0xFF << 24));
+    extras->size = p->size;
+    extras->justify = p->justify;
+    extras->style = p->style;
+    extras->text = p->text;
+    extras->wrap_w = p->wrap_w;
+
+    free(p);
+
+    fb_text_render(result);
+    fb_ctx_add_item(result);
+
+    return result;
+}
+
+void fb_text_set_color(fb_img *img, uint32_t color)
+{
+    text_extra *extras = img->extra;
+    int copy = 0;
+    const px_type converted_color = fb_convert_color(color & ~(0xFF << 24));
+
+    if(extras->color == converted_color)
+        return;
+
+    struct strings_entry *sen = get_cache_for_string(extras);
+    if(sen)
+    {
+        if(sen->refcnt == 1)
+            sen->color = converted_color;
+        else
+        {
+            copy = 1;
+            --sen->refcnt;
+        }
+    }
+
+    extras->color = converted_color;
+
+    fb_items_lock();
+
+    px_type *itr = img->data;
+    if(copy)
+    {
+        img->data = malloc(img->w*img->h*4);
+        memcpy(img->data, itr, img->w*img->h*4);
+        itr = img->data;
+    }
+
+    const px_type *end = (px_type*)(((uint32_t*)itr) + img->w * img->h);
+    int alpha;
+
+    while(itr != end)
+    {
+#if PIXEL_SIZE == 4
+        alpha = *itr & (0xFF << PX_IDX_A*8);
+        if(alpha != 0)
+            *itr = converted_color | alpha;
+        ++itr;
+#else
+        if(itr[1] != 0)
+            *itr = converted_color;
+        itr += 2;
+#endif
+    }
+
+    fb_items_unlock();
+}
+
+void fb_text_set_size(fb_img *img, int size)
+{
+    text_extra *ex = img->extra;
+
+    if(size == ex->size)
+        return;
+
+    fb_items_lock();
+    if(unlink_from_caches(ex) == 0)
+    {
+        img->w = img->h = 0;
+        free(img->data);
+        img->data = NULL;
+    }
+
+    ex->size = size;
+    fb_text_render(img);
+    fb_items_unlock();
+}
+
+void fb_text_set_content(fb_img *img, const char *text)
+{
+    text_extra *ex = img->extra;
+
+    if(text == ex->text)
+        return;
+
+    fb_items_lock();
+    if(unlink_from_caches(ex) == 0)
+    {
+        img->w = img->h = 0;
+        free(img->data);
+        img->data = NULL;
+    }
+
+    ex->text = realloc(ex->text, strlen(text)+1);
+    strcpy(ex->text, text);
+    fb_text_render(img);
+    fb_items_unlock();
+}
+
+char *fb_text_get_content(fb_img *img)
+{
+    text_extra *ex = img->extra;
+    return ex->text;
+}
+
+inline void center_text(fb_img *text, int targetX, int targetY, int targetW, int targetH)
+{
+    text_extra *ex = text->extra;
+
+    if(targetX != -1 || targetW != -1)
+        text->x = targetX + (targetW/2 - text->w/2);
+
+    if(targetY != -1 || targetH != -1)
+        text->y = targetY + (targetH/2 - ex->baseline/2);
+}
+
+void fb_text_destroy(fb_img *i)
+{
+    text_extra *ex = i->extra;
+
+    struct strings_entry *sen = get_cache_for_string(ex);
+    if(sen)
+    {
+        TT_LOG("CACHE: drop %02d 0x%08X\n", ex->size, (uint32_t)sen->data);
+        --sen->refcnt;
+    }
+    else
+    {
+        TT_LOG("CACHE: free %02d 0x%08X\n", ex->size, (uint32_t)i->data);
+        free(i->data);
+    }
+
+    free(ex->text);
+    free(ex);
+    // fb_img is freed in fb_destroy_item
+}
+
+static int drop_glyphs_cache(imap *g_cache)
+{
+    size_t i;
+    for(i = 0; i < g_cache->size;)
+    {
+        const int key = g_cache->keys[i];
+        struct glyphs_entry *en = g_cache->values[i];
+        imap_destroy(en->glyphs, (void*)&FT_Done_Glyph);
+        FT_Done_Face(en->face);
+        imap_rm(g_cache, key, &free);
+    }
+    return g_cache->size == 0;
+}
+
+static int drop_strings_cache(imap *s_cache)
+{
+    size_t i, x;
+    for(i = 0; i < s_cache->size; )
+    {
+        const int key = s_cache->keys[i];
+        map *size_c = s_cache->values[i];
+        TT_LOG("Dropping unused string caches for size %d\n", key);
+
+        for(x = 0; x < size_c->size; )
+        {
+            char *s_key = size_c->keys[x];
+            struct strings_entry *sen = size_c->values[x];
+
+            TT_LOG("strings_entry size %d str \"%s\" has refcnt %d\n", key, s_key, sen->refcnt);
+            if(sen->refcnt == 0)
+            {
+                free(sen->data);
+                map_rm(size_c, s_key, &free);
+            }
+            else
+                ++x;
+        }
+
+        if(size_c->size == 0)
+        {
+            TT_LOG("Removing string cache for size %d\n", key);
+            map_destroy(size_c, &free);
+            imap_rm(s_cache, key, NULL);
+        }
+        else
+            ++i;
+    }
+    return s_cache->size == 0;
+}
+
+void fb_text_drop_cache_unused(void)
+{
+    size_t s;
+    int free_ft_lib = 1;
+
+    for(s = 0; s < STYLE_COUNT; ++s)
+    {
+        if(cache.glyphs[s])
+        {
+            if(drop_glyphs_cache(cache.glyphs[s]))
+            {
+                TT_LOG("Whole glyph cache was freed.\n");
+                imap_destroy(cache.glyphs[s], NULL);
+                cache.glyphs[s] = NULL;
+            }
+            else
+                free_ft_lib = 0;
+        }
+    }
+
+    if(cache.strings)
+    {
+        if(drop_strings_cache(cache.strings))
+        {
+            TT_LOG("Whole string cache was freed.\n");
+            imap_destroy(cache.strings, NULL);
+            cache.strings = NULL;
+        }
+    }
+
+    if(free_ft_lib && cache.ft_lib)
+    {
+        TT_LOG("Freeing libfreetype\n");
+        FT_Done_FreeType(cache.ft_lib);
+        cache.ft_lib = NULL;
+    }
+}
diff --git a/lib/fstab.c b/lib/fstab.c
index 298e33e..71d48e3 100755
--- a/lib/fstab.c
+++ b/lib/fstab.c
@@ -1,440 +1,440 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-#include <sys/mount.h>
-#include <unistd.h>
-#include <dirent.h>
-
-#include <malloc.h>
-
-#include "fstab.h"
-#include "util.h"
-#include "log.h"
-#include "containers.h"
-
-// flags from system/core/fs_mgr/fs_mgr.c
-struct flag_list {
-    const char *name;
-    unsigned flag;
-};
-
-static struct flag_list mount_flags[] = {
-    { "noatime",    MS_NOATIME },
-    { "noexec",     MS_NOEXEC },
-    { "nosuid",     MS_NOSUID },
-    { "nodev",      MS_NODEV },
-    { "nodiratime", MS_NODIRATIME },
-    { "ro",         MS_RDONLY },
-    { "rw",         0 },
-    { "remount",    MS_REMOUNT },
-    { "bind",       MS_BIND },
-    { "rec",        MS_REC },
-    { "unbindable", MS_UNBINDABLE },
-    { "private",    MS_PRIVATE },
-    { "slave",      MS_SLAVE },
-    { "shared",     MS_SHARED },
-    { "sync",       MS_SYNCHRONOUS },
-    { "defaults",   0 },
-    { 0,            0 },
-};
-
-struct fstab *fstab_create_empty(int version)
-{
-    struct fstab *t = mzalloc(sizeof(struct fstab));
-    t->version = version;
-    return t;
-}
-
-struct fstab *fstab_load(const char *path, int resolve_symlinks)
-{
-    FILE *f = fopen(path, "re");
-    if(!f)
-    {
-        ERROR("Failed to open fstab %s\n", path);
-        return NULL;
-    }
-
-    struct fstab *t = fstab_create_empty(-1);
-    const char *delim = " \t";
-    char *saveptr = NULL;
-    char *p;
-    char line[1024];
-    int len, is_dev_on_line = 0;
-    struct fstab_part *part = NULL;
-
-    t->path = strdup(path);
-
-    while((p = fgets(line, sizeof(line), f)))
-    {
-        len = strlen(line);
-        if(line[len-1] == '\n')
-            line[len-1] = 0;
-
-        while(isspace(*p))
-            ++p;
-
-        if(*p == '#' || *p == 0)
-            continue;
-
-        if(t->version == -1)
-            is_dev_on_line = (strstr(line, "/dev/") != NULL);
-
-        part = mzalloc(sizeof(struct fstab_part));
-
-        if(!(p = strtok_r(line, delim, &saveptr)))
-        {
-            ERROR("Error first token\n");
-            goto fail;
-        }
-
-        if(t->version == -1)
-        {
-            if(is_dev_on_line && strstr(p, "/dev/") != p)
-                t->version = 1;
-            else
-                t->version = 2;
-        }
-
-        if(t->version == 2)
-            part->device = resolve_symlinks ? readlink_recursive(p) : strdup(p);
-        else
-            part->path = strdup (p);
-
-        if(!(p = strtok_r(NULL, delim, &saveptr)))
-        {
-            ERROR("Error second token\n");
-            goto fail;
-        }
-
-        if(t->version == 2)
-            part->path = strdup(p);
-        else
-            part->type = strdup(p);
-
-        if(!(p = strtok_r(NULL, delim, &saveptr)))
-        {
-            ERROR("Error third token\n");
-            goto fail;
-        }
-
-        if(t->version == 2)
-            part->type = strdup(p);
-        else
-            part->device = resolve_symlinks ? readlink_recursive(p) : strdup(p);
-
-        if((p = strtok_r(NULL, delim, &saveptr)))
-        {
-            part->options_raw = strdup(p);
-            fstab_parse_options(p, part);
-        }
-
-        if((p = strtok_r(NULL, delim, &saveptr)))
-            part->options2 = strdup(p);
-
-        // Check device
-        if(!part->device)
-        {
-            if (strcmp(part->path, "/data") == 0 || strcmp(part->path, "/system") == 0 ||
-                strcmp(part->path, "/boot") == 0 || strcmp(part->path, "/cache") == 0)
-            {
-                ERROR("fstab: device for part %s does not exist!\n", part->path);
-            }
-            fstab_destroy_part(part);
-            part = NULL;
-            continue;
-        }
-
-        list_add(&t->parts, part);
-        ++t->count;
-        part = NULL;
-    }
-
-    fclose(f);
-    return t;
-
-fail:
-    fclose(f);
-    free(part);
-    fstab_destroy(t);
-    return NULL;
-}
-
-int fstab_save(struct fstab *f, const char *path)
-{
-    int i;
-    FILE *out;
-    struct fstab_part *p;
-
-    out = fopen(path, "we");
-    if(!f)
-    {
-        ERROR("fstab_save: failed to open %s!", path);
-        return -1;
-    }
-
-    for(i = 0; i < f->count; ++i)
-    {
-        p = f->parts[i];
-        if(p->disabled)
-            fputc('#', out);
-
-        if(f->version == 1)
-            fprintf(out, "%s\t%s\t%s\t", p->path, p->type, p->device);
-        else
-            fprintf(out, "%s\t%s\t%s\t", p->device, p->path, p->type);
-        fprintf(out, "%s\t%s\n", p->options_raw, p->options2);
-    }
-    fclose(out);
-    return 0;
-}
-
-void fstab_destroy(struct fstab *f)
-{
-    list_clear(&f->parts, fstab_destroy_part);
-    free(f->path);
-    free(f);
-}
-
-void fstab_destroy_part(struct fstab_part *p)
-{
-    free(p->path);
-    free(p->type);
-    free(p->device);
-    free(p->options);
-    free(p->options_raw);
-    free(p->options2);
-    free(p);
-}
-
-void fstab_dump(struct fstab *f)
-{
-    INFO("Dumping fstab:\n");
-    INFO("version: %d\n", f->version);
-    INFO("count: %d\n", f->count);
-
-    int i;
-    for(i = 0; i < f->count; ++i)
-    {
-        INFO("Partition %d:\n", i);
-        INFO("    path: %s\n", f->parts[i]->path);
-        INFO("    device: %s\n", f->parts[i]->device);
-        INFO("    type: %s\n", f->parts[i]->type);
-        INFO("    mountflags: 0x%lX\n", f->parts[i]->mountflags);
-        INFO("    options: %s\n", f->parts[i]->options);
-        INFO("    options2: %s\n", f->parts[i]->options2);
-    }
-}
-
-struct fstab_part *fstab_find_first_by_path(struct fstab *f, const char *path)
-{
-    int i;
-    for(i = 0; i < f->count; ++i)
-        if(strcmp(f->parts[i]->path, path) == 0)
-            return f->parts[i];
-
-    return NULL;
-}
-
-struct fstab_part *fstab_find_next_by_path(struct fstab *f, const char *path, struct fstab_part *prev)
-{
-    int i, found_prev = 0;
-    for(i = 0; i < f->count; ++i)
-    {
-        if(!found_prev)
-        {
-            if(f->parts[i] == prev)
-                found_prev = 1;
-        }
-        else if(strcmp(f->parts[i]->path, path) == 0)
-        {
-            return f->parts[i];
-        }
-    }
-    return NULL;
-}
-
-int fstab_disable_parts(struct fstab *f, const char *path)
-{
-    int i, cnt = 0;
-
-    for(i = 0; i < f->count; ++i)
-    {
-        if(strcmp(f->parts[i]->path, path) == 0)
-        {
-            f->parts[i]->disabled = 1;
-            ++cnt;
-        }
-    }
-
-    if(cnt == 0)
-    {
-        ERROR("Failed to disable partition %s, couldn't find it in fstab!\n", path);
-        return -1;
-    }
-    return cnt;
-}
-
-void fstab_parse_options(char *opt, struct fstab_part *part)
-{
-    int i;
-    char *p;
-    char *saveptr = NULL;
-
-    part->options = malloc(strlen(opt) + 2); // NULL and possible trailing comma
-    part->options[0] = 0;
-
-    p = strtok_r(opt, ",", &saveptr);
-    while(p)
-    {
-        for(i = 0; mount_flags[i].name; ++i)
-        {
-            if(strcmp(mount_flags[i].name, p) == 0)
-            {
-                part->mountflags |= mount_flags[i].flag;
-                break;
-            }
-        }
-
-        if(!mount_flags[i].name)
-        {
-            strcat(part->options, p);
-            strcat(part->options, ",");
-        }
-
-        p = strtok_r(NULL, ",", &saveptr);
-    }
-
-    int len = strlen(part->options);
-    if(len != 0)
-    {
-        part->options[len-1] = 0; // remove trailing comma
-        part->options = realloc(part->options, len);
-    }
-    else
-    {
-        free(part->options);
-        part->options = NULL;
-    }
-}
-
-struct fstab *fstab_auto_load(void)
-{
-    char path[64];
-    path[0] = 0;
-
-    if(access("/mrom.fstab", F_OK) >= 0)
-        strcpy(path, "/mrom.fstab");
-    else
-    {
-        DIR *d = opendir("/");
-        if(!d)
-        {
-            ERROR("Failed to open /\n");
-            return NULL;
-        }
-
-        struct dirent *dt;
-        while((dt = readdir(d)))
-        {
-            if(dt->d_type != DT_REG)
-                continue;
-
-            // For some reason, CM includes goldfish's fstab, ignore it
-            // (goldfish is the virtual device for emulator)
-            if(strcmp(dt->d_name, "fstab.goldfish") == 0)
-                continue;
-
-            if(strncmp(dt->d_name, "fstab.", sizeof("fstab.")-1) == 0)
-            {
-                strcpy(path, "/");
-                strcat(path, dt->d_name);
-
-                // try to find specifically fstab.device
-#ifdef TARGET_DEVICE
-                if(strcmp(dt->d_name, "fstab."TARGET_DEVICE) == 0)
-                    break;
-#endif
-            }
-        }
-        closedir(d);
-    }
-
-    if(path[0] == 0)
-    {
-        ERROR("Failed to find fstab!\n");
-        return NULL;
-    }
-
-    ERROR("Loading fstab \"%s\"...\n", path);
-    return fstab_load(path, 1);
-}
-
-void fstab_add_part(struct fstab *f, const char *dev, const char *path, const char *type, const char *options, const char *options2)
-{
-    struct fstab_part *p = mzalloc(sizeof(struct fstab_part));
-    p->path = strdup(path);
-    p->device = strdup(dev);
-    p->type = strdup(type);
-    p->options_raw = strdup(options);
-    fstab_parse_options(p->options_raw, p);
-    p->options2 = strdup(options2);
-
-    list_add(&f->parts, p);
-    ++f->count;
-}
-
-struct fstab_part *fstab_clone_part(struct fstab_part *p)
-{
-    struct fstab_part *new_p = mzalloc(sizeof(struct fstab_part));
-    memcpy(new_p, p, sizeof(struct fstab_part));
-
-    new_p->path = strdup(p->path);
-    new_p->device = strdup(p->device);
-    new_p->type = strdup(p->type);
-    new_p->options_raw = strdup(p->options_raw);
-    new_p->options = strdup(p->options);
-    new_p->options2 = strdup(p->options2);
-
-    return new_p;
-}
-
-void fstab_add_part_struct(struct fstab *f, struct fstab_part *p)
-{
-    list_add(&f->parts, p);
-    ++f->count;
-}
-
-void fstab_update_device(struct fstab *f, const char *oldDev, const char *newDev)
-{
-    int i;
-    char *tmp = strdup(oldDev);
-
-    for(i = 0; i < f->count; ++i)
-    {
-        if(strcmp(f->parts[i]->device, tmp) == 0)
-        {
-            f->parts[i]->device = realloc(f->parts[i]->device, strlen(newDev)+1);
-            strcpy(f->parts[i]->device, newDev);
-        }
-    }
-
-    free(tmp);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/mount.h>
+#include <unistd.h>
+#include <dirent.h>
+
+#include <malloc.h>
+
+#include "fstab.h"
+#include "util.h"
+#include "log.h"
+#include "containers.h"
+
+// flags from system/core/fs_mgr/fs_mgr.c
+struct flag_list {
+    const char *name;
+    unsigned flag;
+};
+
+static struct flag_list mount_flags[] = {
+    { "noatime",    MS_NOATIME },
+    { "noexec",     MS_NOEXEC },
+    { "nosuid",     MS_NOSUID },
+    { "nodev",      MS_NODEV },
+    { "nodiratime", MS_NODIRATIME },
+    { "ro",         MS_RDONLY },
+    { "rw",         0 },
+    { "remount",    MS_REMOUNT },
+    { "bind",       MS_BIND },
+    { "rec",        MS_REC },
+    { "unbindable", MS_UNBINDABLE },
+    { "private",    MS_PRIVATE },
+    { "slave",      MS_SLAVE },
+    { "shared",     MS_SHARED },
+    { "sync",       MS_SYNCHRONOUS },
+    { "defaults",   0 },
+    { 0,            0 },
+};
+
+struct fstab *fstab_create_empty(int version)
+{
+    struct fstab *t = mzalloc(sizeof(struct fstab));
+    t->version = version;
+    return t;
+}
+
+struct fstab *fstab_load(const char *path, int resolve_symlinks)
+{
+    FILE *f = fopen(path, "re");
+    if(!f)
+    {
+        ERROR("Failed to open fstab %s\n", path);
+        return NULL;
+    }
+
+    struct fstab *t = fstab_create_empty(-1);
+    const char *delim = " \t";
+    char *saveptr = NULL;
+    char *p;
+    char line[1024];
+    int len, is_dev_on_line = 0;
+    struct fstab_part *part = NULL;
+
+    t->path = strdup(path);
+
+    while((p = fgets(line, sizeof(line), f)))
+    {
+        len = strlen(line);
+        if(line[len-1] == '\n')
+            line[len-1] = 0;
+
+        while(isspace(*p))
+            ++p;
+
+        if(*p == '#' || *p == 0)
+            continue;
+
+        if(t->version == -1)
+            is_dev_on_line = (strstr(line, "/dev/") != NULL);
+
+        part = mzalloc(sizeof(struct fstab_part));
+
+        if(!(p = strtok_r(line, delim, &saveptr)))
+        {
+            ERROR("Error first token\n");
+            goto fail;
+        }
+
+        if(t->version == -1)
+        {
+            if(is_dev_on_line && strstr(p, "/dev/") != p)
+                t->version = 1;
+            else
+                t->version = 2;
+        }
+
+        if(t->version == 2)
+            part->device = resolve_symlinks ? readlink_recursive(p) : strdup(p);
+        else
+            part->path = strdup (p);
+
+        if(!(p = strtok_r(NULL, delim, &saveptr)))
+        {
+            ERROR("Error second token\n");
+            goto fail;
+        }
+
+        if(t->version == 2)
+            part->path = strdup(p);
+        else
+            part->type = strdup(p);
+
+        if(!(p = strtok_r(NULL, delim, &saveptr)))
+        {
+            ERROR("Error third token\n");
+            goto fail;
+        }
+
+        if(t->version == 2)
+            part->type = strdup(p);
+        else
+            part->device = resolve_symlinks ? readlink_recursive(p) : strdup(p);
+
+        if((p = strtok_r(NULL, delim, &saveptr)))
+        {
+            part->options_raw = strdup(p);
+            fstab_parse_options(p, part);
+        }
+
+        if((p = strtok_r(NULL, delim, &saveptr)))
+            part->options2 = strdup(p);
+
+        // Check device
+        if(!part->device)
+        {
+            if (strcmp(part->path, "/data") == 0 || strcmp(part->path, "/system") == 0 ||
+                strcmp(part->path, "/boot") == 0 || strcmp(part->path, "/cache") == 0)
+            {
+                ERROR("fstab: device for part %s does not exist!\n", part->path);
+            }
+            fstab_destroy_part(part);
+            part = NULL;
+            continue;
+        }
+
+        list_add(&t->parts, part);
+        ++t->count;
+        part = NULL;
+    }
+
+    fclose(f);
+    return t;
+
+fail:
+    fclose(f);
+    free(part);
+    fstab_destroy(t);
+    return NULL;
+}
+
+int fstab_save(struct fstab *f, const char *path)
+{
+    int i;
+    FILE *out;
+    struct fstab_part *p;
+
+    out = fopen(path, "we");
+    if(!f)
+    {
+        ERROR("fstab_save: failed to open %s!", path);
+        return -1;
+    }
+
+    for(i = 0; i < f->count; ++i)
+    {
+        p = f->parts[i];
+        if(p->disabled)
+            fputc('#', out);
+
+        if(f->version == 1)
+            fprintf(out, "%s\t%s\t%s\t", p->path, p->type, p->device);
+        else
+            fprintf(out, "%s\t%s\t%s\t", p->device, p->path, p->type);
+        fprintf(out, "%s\t%s\n", p->options_raw, p->options2);
+    }
+    fclose(out);
+    return 0;
+}
+
+void fstab_destroy(struct fstab *f)
+{
+    list_clear(&f->parts, fstab_destroy_part);
+    free(f->path);
+    free(f);
+}
+
+void fstab_destroy_part(struct fstab_part *p)
+{
+    free(p->path);
+    free(p->type);
+    free(p->device);
+    free(p->options);
+    free(p->options_raw);
+    free(p->options2);
+    free(p);
+}
+
+void fstab_dump(struct fstab *f)
+{
+    INFO("Dumping fstab:\n");
+    INFO("version: %d\n", f->version);
+    INFO("count: %d\n", f->count);
+
+    int i;
+    for(i = 0; i < f->count; ++i)
+    {
+        INFO("Partition %d:\n", i);
+        INFO("    path: %s\n", f->parts[i]->path);
+        INFO("    device: %s\n", f->parts[i]->device);
+        INFO("    type: %s\n", f->parts[i]->type);
+        INFO("    mountflags: 0x%lX\n", f->parts[i]->mountflags);
+        INFO("    options: %s\n", f->parts[i]->options);
+        INFO("    options2: %s\n", f->parts[i]->options2);
+    }
+}
+
+struct fstab_part *fstab_find_first_by_path(struct fstab *f, const char *path)
+{
+    int i;
+    for(i = 0; i < f->count; ++i)
+        if(strcmp(f->parts[i]->path, path) == 0)
+            return f->parts[i];
+
+    return NULL;
+}
+
+struct fstab_part *fstab_find_next_by_path(struct fstab *f, const char *path, struct fstab_part *prev)
+{
+    int i, found_prev = 0;
+    for(i = 0; i < f->count; ++i)
+    {
+        if(!found_prev)
+        {
+            if(f->parts[i] == prev)
+                found_prev = 1;
+        }
+        else if(strcmp(f->parts[i]->path, path) == 0)
+        {
+            return f->parts[i];
+        }
+    }
+    return NULL;
+}
+
+int fstab_disable_parts(struct fstab *f, const char *path)
+{
+    int i, cnt = 0;
+
+    for(i = 0; i < f->count; ++i)
+    {
+        if(strcmp(f->parts[i]->path, path) == 0)
+        {
+            f->parts[i]->disabled = 1;
+            ++cnt;
+        }
+    }
+
+    if(cnt == 0)
+    {
+        ERROR("Failed to disable partition %s, couldn't find it in fstab!\n", path);
+        return -1;
+    }
+    return cnt;
+}
+
+void fstab_parse_options(char *opt, struct fstab_part *part)
+{
+    int i;
+    char *p;
+    char *saveptr = NULL;
+
+    part->options = malloc(strlen(opt) + 2); // NULL and possible trailing comma
+    part->options[0] = 0;
+
+    p = strtok_r(opt, ",", &saveptr);
+    while(p)
+    {
+        for(i = 0; mount_flags[i].name; ++i)
+        {
+            if(strcmp(mount_flags[i].name, p) == 0)
+            {
+                part->mountflags |= mount_flags[i].flag;
+                break;
+            }
+        }
+
+        if(!mount_flags[i].name)
+        {
+            strcat(part->options, p);
+            strcat(part->options, ",");
+        }
+
+        p = strtok_r(NULL, ",", &saveptr);
+    }
+
+    int len = strlen(part->options);
+    if(len != 0)
+    {
+        part->options[len-1] = 0; // remove trailing comma
+        part->options = realloc(part->options, len);
+    }
+    else
+    {
+        free(part->options);
+        part->options = NULL;
+    }
+}
+
+struct fstab *fstab_auto_load(void)
+{
+    char path[64];
+    path[0] = 0;
+
+    if(access("/mrom.fstab", F_OK) >= 0)
+        strcpy(path, "/mrom.fstab");
+    else
+    {
+        DIR *d = opendir("/");
+        if(!d)
+        {
+            ERROR("Failed to open /\n");
+            return NULL;
+        }
+
+        struct dirent *dt;
+        while((dt = readdir(d)))
+        {
+            if(dt->d_type != DT_REG)
+                continue;
+
+            // For some reason, CM includes goldfish's fstab, ignore it
+            // (goldfish is the virtual device for emulator)
+            if(strcmp(dt->d_name, "fstab.goldfish") == 0)
+                continue;
+
+            if(strncmp(dt->d_name, "fstab.", sizeof("fstab.")-1) == 0)
+            {
+                strcpy(path, "/");
+                strcat(path, dt->d_name);
+
+                // try to find specifically fstab.device
+#ifdef TARGET_DEVICE
+                if(strcmp(dt->d_name, "fstab."TARGET_DEVICE) == 0)
+                    break;
+#endif
+            }
+        }
+        closedir(d);
+    }
+
+    if(path[0] == 0)
+    {
+        ERROR("Failed to find fstab!\n");
+        return NULL;
+    }
+
+    ERROR("Loading fstab \"%s\"...\n", path);
+    return fstab_load(path, 1);
+}
+
+void fstab_add_part(struct fstab *f, const char *dev, const char *path, const char *type, const char *options, const char *options2)
+{
+    struct fstab_part *p = mzalloc(sizeof(struct fstab_part));
+    p->path = strdup(path);
+    p->device = strdup(dev);
+    p->type = strdup(type);
+    p->options_raw = strdup(options);
+    fstab_parse_options(p->options_raw, p);
+    p->options2 = strdup(options2);
+
+    list_add(&f->parts, p);
+    ++f->count;
+}
+
+struct fstab_part *fstab_clone_part(struct fstab_part *p)
+{
+    struct fstab_part *new_p = mzalloc(sizeof(struct fstab_part));
+    memcpy(new_p, p, sizeof(struct fstab_part));
+
+    new_p->path = strdup(p->path);
+    new_p->device = strdup(p->device);
+    new_p->type = strdup(p->type);
+    new_p->options_raw = strdup(p->options_raw);
+    new_p->options = strdup(p->options);
+    new_p->options2 = strdup(p->options2);
+
+    return new_p;
+}
+
+void fstab_add_part_struct(struct fstab *f, struct fstab_part *p)
+{
+    list_add(&f->parts, p);
+    ++f->count;
+}
+
+void fstab_update_device(struct fstab *f, const char *oldDev, const char *newDev)
+{
+    int i;
+    char *tmp = strdup(oldDev);
+
+    for(i = 0; i < f->count; ++i)
+    {
+        if(strcmp(f->parts[i]->device, tmp) == 0)
+        {
+            f->parts[i]->device = realloc(f->parts[i]->device, strlen(newDev)+1);
+            strcpy(f->parts[i]->device, newDev);
+        }
+    }
+
+    free(tmp);
+}
diff --git a/lib/fstab.h b/lib/fstab.h
index 47831ce..4a5ca12 100755
--- a/lib/fstab.h
+++ b/lib/fstab.h
@@ -1,58 +1,58 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef FSTAB_H
-#define FSTAB_H
-
-struct fstab_part
-{
-    char *path;
-    char *device;
-    char *type;
-    char *options_raw;
-    unsigned long mountflags;
-    char *options;
-    char *options2;
-    int disabled;
-};
-
-struct fstab
-{
-    int version;
-    int count;
-    char *path;
-    struct fstab_part **parts;
-};
-
-struct fstab *fstab_create_empty(int version);
-struct fstab *fstab_load(const char *path, int resolve_symlinks);
-struct fstab *fstab_auto_load(void);
-void fstab_destroy(struct fstab *f);
-void fstab_destroy_part(struct fstab_part *p);
-void fstab_dump(struct fstab *f);
-struct fstab_part *fstab_find_first_by_path(struct fstab *f, const char *path);
-struct fstab_part *fstab_find_next_by_path(struct fstab *f, const char *path, struct fstab_part *prev);
-void fstab_parse_options(char *opt, struct fstab_part *p);
-int fstab_save(struct fstab *f, const char *path);
-int fstab_disable_parts(struct fstab *f, const char *path);
-void fstab_add_part(struct fstab *f, const char *dev, const char *path, const char *type, const char *options, const char *options2);
-void fstab_add_part_struct(struct fstab *f, struct fstab_part *p);
-struct fstab_part *fstab_clone_part(struct fstab_part *p);
-void fstab_update_device(struct fstab *f, const char *oldDev, const char *newDev);
-
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FSTAB_H
+#define FSTAB_H
+
+struct fstab_part
+{
+    char *path;
+    char *device;
+    char *type;
+    char *options_raw;
+    unsigned long mountflags;
+    char *options;
+    char *options2;
+    int disabled;
+};
+
+struct fstab
+{
+    int version;
+    int count;
+    char *path;
+    struct fstab_part **parts;
+};
+
+struct fstab *fstab_create_empty(int version);
+struct fstab *fstab_load(const char *path, int resolve_symlinks);
+struct fstab *fstab_auto_load(void);
+void fstab_destroy(struct fstab *f);
+void fstab_destroy_part(struct fstab_part *p);
+void fstab_dump(struct fstab *f);
+struct fstab_part *fstab_find_first_by_path(struct fstab *f, const char *path);
+struct fstab_part *fstab_find_next_by_path(struct fstab *f, const char *path, struct fstab_part *prev);
+void fstab_parse_options(char *opt, struct fstab_part *p);
+int fstab_save(struct fstab *f, const char *path);
+int fstab_disable_parts(struct fstab *f, const char *path);
+void fstab_add_part(struct fstab *f, const char *dev, const char *path, const char *type, const char *options, const char *options2);
+void fstab_add_part_struct(struct fstab *f, struct fstab_part *p);
+struct fstab_part *fstab_clone_part(struct fstab_part *p);
+void fstab_update_device(struct fstab *f, const char *oldDev, const char *newDev);
+
+
+#endif
diff --git a/lib/inject.c b/lib/inject.c
index 59b8aab..9d1116f 100755
--- a/lib/inject.c
+++ b/lib/inject.c
@@ -1,234 +1,234 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <string.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <stdio.h>
-
-#include "inject.h"
-#include "mrom_data.h"
-#include "log.h"
-#include "util.h"
-#include "../version.h"
-
-// clone libbootimg to /system/extras/ from
-// https://github.com/Tasssadar/libbootimg.git
-#include <libbootimg.h>
-
-#if LIBBOOTIMG_VERSION  < 0x000200
-#error "libbootimg version 0.2.0 or higher is required. Please update libbootimg."
-#endif
-
-#define TMP_RD_UNPACKED_DIR "/mrom_rd"
-
-static int get_img_trampoline_ver(struct bootimg *img)
-{
-    int ver = 0;
-    if(strncmp((char*)img->hdr.name, "tr_ver", 6) == 0)
-        ver = atoi((char*)img->hdr.name + 6);
-    return ver;
-}
-
-static int copy_rd_files(UNUSED const char *path, UNUSED const char *busybox_path)
-{
-    char buf[256];
-
-    if (access(TMP_RD_UNPACKED_DIR"/main_init", F_OK) < 0 &&
-        rename(TMP_RD_UNPACKED_DIR"/init", TMP_RD_UNPACKED_DIR"/main_init") < 0)
-    {
-        ERROR("Failed to move /init to /main_init!\n");
-        return -1;
-    }
-
-    snprintf(buf, sizeof(buf), "%s/trampoline", mrom_dir());
-    if(copy_file(buf, TMP_RD_UNPACKED_DIR"/init") < 0)
-    {
-        ERROR("Failed to copy trampoline to /init!\n");
-        return -1;
-    }
-    chmod(TMP_RD_UNPACKED_DIR"/init", 0750);
-
-    remove(TMP_RD_UNPACKED_DIR"/sbin/ueventd");
-    remove(TMP_RD_UNPACKED_DIR"/sbin/watchdogd");
-    symlink("../main_init", TMP_RD_UNPACKED_DIR"/sbin/ueventd");
-    symlink("../main_init", TMP_RD_UNPACKED_DIR"/sbin/watchdogd");
-
-#ifdef MR_USE_MROM_FSTAB
-    snprintf(buf, sizeof(buf), "%s/mrom.fstab", mrom_dir());
-    copy_file(buf, TMP_RD_UNPACKED_DIR"/mrom.fstab");
-#else
-    remove(TMP_RD_UNPACKED_DIR"/mrom.fstab");
-#endif
-
-#ifdef MR_ENCRYPTION
-    remove_dir(TMP_RD_UNPACKED_DIR"/mrom_enc");
-
-    if(mr_system("busybox cp -a \"%s/enc\" \"%s/mrom_enc\"", mrom_dir(), TMP_RD_UNPACKED_DIR) != 0)
-    {
-        ERROR("Failed to copy encryption files!\n");
-        return -1;
-    }
-#endif
-    return 0;
-}
-
-#define RD_GZIP 1
-#define RD_LZ4  2
-static int inject_rd(const char *path)
-{
-    int result = -1;
-    uint32_t magic = 0;
-
-    FILE *f = fopen(path, "re");
-    if(!f)
-    {
-        ERROR("Couldn't open %s!\n", path);
-        return -1;
-    }
-    fread(&magic, sizeof(magic), 1, f);
-    fclose(f);
-
-    remove_dir(TMP_RD_UNPACKED_DIR);
-    mkdir(TMP_RD_UNPACKED_DIR, 0755);
-
-    // Decompress initrd
-    int type;
-    char buff[256];
-    char busybox_path[256];
-    snprintf(busybox_path, sizeof(busybox_path), "%s/busybox", mrom_dir());
-
-    char *cmd[] = { busybox_path, "sh", "-c", buff, NULL };
-
-    if((magic & 0xFFFF) == 0x8B1F)
-    {
-        type = RD_GZIP;
-        snprintf(buff, sizeof(buff), "B=\"%s\"; cd \"%s\"; \"$B\" gzip -d -c \"%s\" | \"$B\" cpio -i", busybox_path, TMP_RD_UNPACKED_DIR, path);
-    }
-    else if(magic == 0x184C2102)
-    {
-        type = RD_LZ4;
-        snprintf(buff, sizeof(buff), "cd \"%s\"; \"%s/lz4\" -d \"%s\" stdout | \"%s\" cpio -i", TMP_RD_UNPACKED_DIR, mrom_dir(), path, busybox_path);
-    }
-    else
-    {
-        ERROR("Unknown ramdisk magic 0x%08X, can't update trampoline\n", magic);
-        goto success;
-    }
-
-    int r = run_cmd(cmd);
-    if(r != 0)
-    {
-        ERROR("Failed to unpack ramdisk! %s\n", buff);
-        goto fail;
-    }
-
-    // Update files
-    if(copy_rd_files(path, busybox_path) < 0)
-        goto fail;
-
-    // Pack initrd again
-    switch(type)
-    {
-        case RD_GZIP:
-            snprintf(buff, sizeof(buff), "B=\"%s\"; cd \"%s\"; \"$B\" find . | \"$B\" cpio -o -H newc | \"$B\" gzip > \"%s\"", busybox_path, TMP_RD_UNPACKED_DIR, path);
-            break;
-        case RD_LZ4:
-            snprintf(buff, sizeof(buff), "B=\"%s\"; cd \"%s\"; \"$B\" find . | \"$B\" cpio -o -H newc | \"%s/lz4\" stdin \"%s\"", busybox_path, TMP_RD_UNPACKED_DIR, mrom_dir(), path);
-            break;
-    }
-
-    r = run_cmd(cmd);
-    if(r != 0)
-    {
-        ERROR("Failed to pack ramdisk!\n");
-        goto fail;
-    }
-
-success:
-    result = 0;
-fail:
-    remove_dir(TMP_RD_UNPACKED_DIR);
-    return result;
-}
-
-int inject_bootimg(const char *img_path, int force)
-{
-    int res = -1;
-    struct bootimg img;
-    int img_ver;
-    char initrd_path[256];
-    static const char *initrd_tmp_name = "/inject-initrd.img";
-
-    if(libbootimg_init_load(&img, img_path, LIBBOOTIMG_LOAD_ALL) < 0)
-    {
-        ERROR("Could not open boot image (%s)!\n", img_path);
-        return -1;
-    }
-
-    img_ver = get_img_trampoline_ver(&img);
-    if(!force && img_ver == VERSION_TRAMPOLINE)
-    {
-        INFO("No need to update trampoline.\n");
-        res = 0;
-        goto exit;
-    }
-
-    INFO("Updating trampoline from ver %d to %d\n", img_ver, VERSION_TRAMPOLINE);
-
-    if(libbootimg_dump_ramdisk(&img, initrd_tmp_name) < 0)
-    {
-        ERROR("Failed to dump ramdisk to %s!\n", initrd_path);
-        goto exit;
-    }
-
-    if(inject_rd(initrd_tmp_name) >= 0)
-    {
-        // Update the boot.img
-        snprintf((char*)img.hdr.name, BOOT_NAME_SIZE, "tr_ver%d", VERSION_TRAMPOLINE);
-#ifdef MR_RD_ADDR
-        img.hdr.ramdisk_addr = MR_RD_ADDR;
-#endif
-
-        if(libbootimg_load_ramdisk(&img, initrd_tmp_name) < 0)
-        {
-            ERROR("Failed to load ramdisk from %s!\n", initrd_tmp_name);
-            goto exit;
-        }
-
-        char tmp[256];
-        strcpy(tmp, img_path);
-        strcat(tmp, ".new");
-        if(libbootimg_write_img(&img, tmp) >= 0)
-        {
-            INFO("Writing boot.img updated with trampoline v%d\n", VERSION_TRAMPOLINE);
-            if(copy_file(tmp, img_path) < 0)
-                ERROR("Failed to copy %s to %s!\n", tmp, img_path);
-            else
-                res = 0;
-            remove(tmp);
-        }
-        else
-            ERROR("Failed to libbootimg_write_img!\n");
-    }
-
-exit:
-    libbootimg_destroy(&img);
-    remove("/inject-initrd.img");
-    return res;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+
+#include "inject.h"
+#include "mrom_data.h"
+#include "log.h"
+#include "util.h"
+#include "../version.h"
+
+// clone libbootimg to /system/extras/ from
+// https://github.com/Tasssadar/libbootimg.git
+#include <libbootimg.h>
+
+#if LIBBOOTIMG_VERSION  < 0x000200
+#error "libbootimg version 0.2.0 or higher is required. Please update libbootimg."
+#endif
+
+#define TMP_RD_UNPACKED_DIR "/mrom_rd"
+
+static int get_img_trampoline_ver(struct bootimg *img)
+{
+    int ver = 0;
+    if(strncmp((char*)img->hdr.name, "tr_ver", 6) == 0)
+        ver = atoi((char*)img->hdr.name + 6);
+    return ver;
+}
+
+static int copy_rd_files(UNUSED const char *path, UNUSED const char *busybox_path)
+{
+    char buf[256];
+
+    if (access(TMP_RD_UNPACKED_DIR"/main_init", F_OK) < 0 &&
+        rename(TMP_RD_UNPACKED_DIR"/init", TMP_RD_UNPACKED_DIR"/main_init") < 0)
+    {
+        ERROR("Failed to move /init to /main_init!\n");
+        return -1;
+    }
+
+    snprintf(buf, sizeof(buf), "%s/trampoline", mrom_dir());
+    if(copy_file(buf, TMP_RD_UNPACKED_DIR"/init") < 0)
+    {
+        ERROR("Failed to copy trampoline to /init!\n");
+        return -1;
+    }
+    chmod(TMP_RD_UNPACKED_DIR"/init", 0750);
+
+    remove(TMP_RD_UNPACKED_DIR"/sbin/ueventd");
+    remove(TMP_RD_UNPACKED_DIR"/sbin/watchdogd");
+    symlink("../main_init", TMP_RD_UNPACKED_DIR"/sbin/ueventd");
+    symlink("../main_init", TMP_RD_UNPACKED_DIR"/sbin/watchdogd");
+
+#ifdef MR_USE_MROM_FSTAB
+    snprintf(buf, sizeof(buf), "%s/mrom.fstab", mrom_dir());
+    copy_file(buf, TMP_RD_UNPACKED_DIR"/mrom.fstab");
+#else
+    remove(TMP_RD_UNPACKED_DIR"/mrom.fstab");
+#endif
+
+#ifdef MR_ENCRYPTION
+    remove_dir(TMP_RD_UNPACKED_DIR"/mrom_enc");
+
+    if(mr_system("busybox cp -a \"%s/enc\" \"%s/mrom_enc\"", mrom_dir(), TMP_RD_UNPACKED_DIR) != 0)
+    {
+        ERROR("Failed to copy encryption files!\n");
+        return -1;
+    }
+#endif
+    return 0;
+}
+
+#define RD_GZIP 1
+#define RD_LZ4  2
+static int inject_rd(const char *path)
+{
+    int result = -1;
+    uint32_t magic = 0;
+
+    FILE *f = fopen(path, "re");
+    if(!f)
+    {
+        ERROR("Couldn't open %s!\n", path);
+        return -1;
+    }
+    fread(&magic, sizeof(magic), 1, f);
+    fclose(f);
+
+    remove_dir(TMP_RD_UNPACKED_DIR);
+    mkdir(TMP_RD_UNPACKED_DIR, 0755);
+
+    // Decompress initrd
+    int type;
+    char buff[256];
+    char busybox_path[256];
+    snprintf(busybox_path, sizeof(busybox_path), "%s/busybox", mrom_dir());
+
+    char *cmd[] = { busybox_path, "sh", "-c", buff, NULL };
+
+    if((magic & 0xFFFF) == 0x8B1F)
+    {
+        type = RD_GZIP;
+        snprintf(buff, sizeof(buff), "B=\"%s\"; cd \"%s\"; \"$B\" gzip -d -c \"%s\" | \"$B\" cpio -i", busybox_path, TMP_RD_UNPACKED_DIR, path);
+    }
+    else if(magic == 0x184C2102)
+    {
+        type = RD_LZ4;
+        snprintf(buff, sizeof(buff), "cd \"%s\"; \"%s/lz4\" -d \"%s\" stdout | \"%s\" cpio -i", TMP_RD_UNPACKED_DIR, mrom_dir(), path, busybox_path);
+    }
+    else
+    {
+        ERROR("Unknown ramdisk magic 0x%08X, can't update trampoline\n", magic);
+        goto success;
+    }
+
+    int r = run_cmd(cmd);
+    if(r != 0)
+    {
+        ERROR("Failed to unpack ramdisk! %s\n", buff);
+        goto fail;
+    }
+
+    // Update files
+    if(copy_rd_files(path, busybox_path) < 0)
+        goto fail;
+
+    // Pack initrd again
+    switch(type)
+    {
+        case RD_GZIP:
+            snprintf(buff, sizeof(buff), "B=\"%s\"; cd \"%s\"; \"$B\" find . | \"$B\" cpio -o -H newc | \"$B\" gzip > \"%s\"", busybox_path, TMP_RD_UNPACKED_DIR, path);
+            break;
+        case RD_LZ4:
+            snprintf(buff, sizeof(buff), "B=\"%s\"; cd \"%s\"; \"$B\" find . | \"$B\" cpio -o -H newc | \"%s/lz4\" stdin \"%s\"", busybox_path, TMP_RD_UNPACKED_DIR, mrom_dir(), path);
+            break;
+    }
+
+    r = run_cmd(cmd);
+    if(r != 0)
+    {
+        ERROR("Failed to pack ramdisk!\n");
+        goto fail;
+    }
+
+success:
+    result = 0;
+fail:
+    remove_dir(TMP_RD_UNPACKED_DIR);
+    return result;
+}
+
+int inject_bootimg(const char *img_path, int force)
+{
+    int res = -1;
+    struct bootimg img;
+    int img_ver;
+    char initrd_path[256];
+    static const char *initrd_tmp_name = "/inject-initrd.img";
+
+    if(libbootimg_init_load(&img, img_path, LIBBOOTIMG_LOAD_ALL) < 0)
+    {
+        ERROR("Could not open boot image (%s)!\n", img_path);
+        return -1;
+    }
+
+    img_ver = get_img_trampoline_ver(&img);
+    if(!force && img_ver == VERSION_TRAMPOLINE)
+    {
+        INFO("No need to update trampoline.\n");
+        res = 0;
+        goto exit;
+    }
+
+    INFO("Updating trampoline from ver %d to %d\n", img_ver, VERSION_TRAMPOLINE);
+
+    if(libbootimg_dump_ramdisk(&img, initrd_tmp_name) < 0)
+    {
+        ERROR("Failed to dump ramdisk to %s!\n", initrd_path);
+        goto exit;
+    }
+
+    if(inject_rd(initrd_tmp_name) >= 0)
+    {
+        // Update the boot.img
+        snprintf((char*)img.hdr.name, BOOT_NAME_SIZE, "tr_ver%d", VERSION_TRAMPOLINE);
+#ifdef MR_RD_ADDR
+        img.hdr.ramdisk_addr = MR_RD_ADDR;
+#endif
+
+        if(libbootimg_load_ramdisk(&img, initrd_tmp_name) < 0)
+        {
+            ERROR("Failed to load ramdisk from %s!\n", initrd_tmp_name);
+            goto exit;
+        }
+
+        char tmp[256];
+        strcpy(tmp, img_path);
+        strcat(tmp, ".new");
+        if(libbootimg_write_img(&img, tmp) >= 0)
+        {
+            INFO("Writing boot.img updated with trampoline v%d\n", VERSION_TRAMPOLINE);
+            if(copy_file(tmp, img_path) < 0)
+                ERROR("Failed to copy %s to %s!\n", tmp, img_path);
+            else
+                res = 0;
+            remove(tmp);
+        }
+        else
+            ERROR("Failed to libbootimg_write_img!\n");
+    }
+
+exit:
+    libbootimg_destroy(&img);
+    remove("/inject-initrd.img");
+    return res;
+}
diff --git a/lib/inject.h b/lib/inject.h
index 7bbe36d..6b2f6c4 100755
--- a/lib/inject.h
+++ b/lib/inject.h
@@ -1,23 +1,23 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef INJECT_H
-#define INJECT_H
-
-int inject_bootimg(const char *img_path, int force);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef INJECT_H
+#define INJECT_H
+
+int inject_bootimg(const char *img_path, int force);
+
+#endif
diff --git a/lib/input.c b/lib/input.c
index 415fe6c..0b59ff4 100755
--- a/lib/input.c
+++ b/lib/input.c
@@ -1,794 +1,794 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/poll.h>
-#include <sys/time.h>
-#include <linux/input.h>
-#include <linux/kd.h>
-#include <pthread.h>
-#include <dirent.h>
-#include <assert.h>
-
-#include <string.h>
-#include <malloc.h>
-
-#include "input.h"
-#include "input_priv.h"
-#include "framebuffer.h"
-#include "util.h"
-#include "log.h"
-#include "workers.h"
-#include "containers.h"
-#include "notification_card.h"
-
-// for touch calculation
-int mt_screen_res[2] = { 0 };
-touch_event mt_events[MAX_FINGERS];
-int mt_slot = 0;
-int mt_switch_xy = 0;
-int mt_range_x[2] = { 0 };
-int mt_range_y[2] = { 0 };
-
-static struct pollfd ev_fds[MAX_DEVICES];
-static unsigned ev_count = 0;
-static volatile int input_run = 0;
-
-static int key_queue[10];
-static int8_t key_itr = 10;
-static pthread_mutex_t key_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t touch_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_t input_thread;
-
-static pthread_mutex_t input_start_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t input_start_cond = PTHREAD_COND_INITIALIZER;
-
-static handler_list_it *mt_handlers = NULL;
-static handlers_ctx **inactive_ctx = NULL;
-
-#define DIV_ROUND_UP(n,d)  (((n) + (d) - 1) / (d))
-#define BIT(nr)            (1UL << (nr))
-#define BIT_MASK(nr)       (1UL << ((nr) % BITS_PER_LONG))
-#define BIT_WORD(nr)       ((nr) / BITS_PER_LONG)
-#define BITS_PER_BYTE      8
-#define BITS_PER_LONG      (sizeof(long) * BITS_PER_BYTE)
-#define BITS_TO_LONGS(nr)  DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
-
-static void get_abs_min_max(int fd)
-{
-    struct input_absinfo absinfo;
-
-    if(ioctl(fd, EVIOCGABS(ABS_MT_POSITION_X), &absinfo) >= 0)
-    {
-        mt_range_x[0] = absinfo.minimum;
-        mt_range_x[1] = absinfo.maximum;
-    }
-
-    if(ioctl(fd, EVIOCGABS(ABS_MT_POSITION_Y), &absinfo) >= 0)
-    {
-        mt_range_y[0] = absinfo.minimum;
-        mt_range_y[1] = absinfo.maximum;
-    }
-
-    mt_switch_xy = (mt_range_x[1] > mt_range_y[1]);
-    if(mt_switch_xy)
-    {
-        int tmp[2];
-        memcpy(tmp, mt_range_x, 2*sizeof(int));
-        memcpy(mt_range_x, mt_range_y, 2*sizeof(int));
-        memcpy(mt_range_y, tmp, 2*sizeof(int));
-    }
-}
-
-static int ev_init(void)
-{
-    DIR *dir;
-    struct dirent *de;
-    int fd;
-    long absbit[BITS_TO_LONGS(ABS_CNT)];
-
-    ev_count = 0;
-    mt_screen_res[0] = fb_get_vi_xres();
-    mt_screen_res[1] = fb_get_vi_yres();
-
-    init_touch_specifics();
-
-    dir = opendir("/dev/input");
-    if(!dir)
-        return -1;
-
-    while((de = readdir(dir)))
-    {
-        if(strncmp(de->d_name,"event",5))
-            continue;
-
-        fd = openat(dirfd(dir), de->d_name, O_RDONLY | O_CLOEXEC);
-        if(fd < 0)
-            continue;
-
-        ev_fds[ev_count].fd = fd;
-        ev_fds[ev_count].events = POLLIN;
-
-        if (ioctl(fd, EVIOCGBIT(EV_ABS, ABS_CNT), absbit) >= 0)
-        {
-             if ((absbit[BIT_WORD(ABS_MT_POSITION_X)] & BIT_MASK(ABS_MT_POSITION_X)) &&
-                (absbit[BIT_WORD(ABS_MT_POSITION_Y)] & BIT_MASK(ABS_MT_POSITION_Y)))
-             {
-                 get_abs_min_max(fd);
-             }
-        }
-
-        ev_count++;
-        if(ev_count == MAX_DEVICES) break;
-    }
-    closedir(dir);
-
-    return 0;
-}
-
-static void ev_exit(void)
-{
-    destroy_touch_specifics();
-
-    while (ev_count > 0) {
-        close(ev_fds[--ev_count].fd);
-    }
-}
-
-static int ev_get(struct input_event *ev, unsigned dont_wait)
-{
-    int r;
-    unsigned n;
-
-    do {
-        r = poll(ev_fds, ev_count, dont_wait ? 0 : -1);
-
-        if(r > 0) {
-            for(n = 0; n < ev_count; n++) {
-                if(ev_fds[n].revents & POLLIN) {
-                    r = read(ev_fds[n].fd, ev, sizeof(*ev));
-                    if(r == sizeof(*ev)) return 0;
-                }
-            }
-        }
-    } while(dont_wait == 0);
-
-    return -1;
-}
-
-#define IS_KEY_HANDLED(key) (key >= KEY_VOLUMEDOWN && key <= KEY_POWER)
-
-static int screenshot_trigger_handle_keyevent(int code, int pressed)
-{
-    static int power_pressed = 0;
-    switch(code)
-    {
-        case KEY_POWER:
-            power_pressed = pressed;
-            break;
-        case KEY_VOLUMEDOWN:
-            if(power_pressed && pressed)
-            {
-                fb_save_screenshot();
-                return 0;
-            }
-            break;
-    }
-    return -1;
-}
-
-static void handle_key_event(struct input_event *ev)
-{
-    if(!IS_KEY_HANDLED(ev->code))
-        return;
-
-    if(screenshot_trigger_handle_keyevent(ev->code, (ev->value != 0)) != -1)
-        return;
-
-    if(keyaction_handle_keyevent(ev->code, (ev->value != 0)) != -1)
-        return;
-
-    if(ev->value != 0)
-        return;
-
-    pthread_mutex_lock(&key_mutex);
-    if(key_itr > 0)
-        key_queue[--key_itr] = ev->code;
-    pthread_mutex_unlock(&key_mutex);
-}
-
-int calc_mt_pos(int val, int *range, int d_max)
-{
-    int res = ((val-range[0])*100);
-    res /= (range[1]-range[0]);
-    return (res*d_max)/100;
-}
-
-static void mt_recalc_pos_rotation(touch_event *ev)
-{
-    switch(fb_rotation)
-    {
-        case 0:
-            ev->x = ev->orig_x;
-            ev->y = ev->orig_y;
-            return;
-        case 90:
-            ev->x = ev->orig_y;
-            ev->y = ev->orig_x;
-
-            ev->y = fb_height - ev->y;
-            break;
-        case 180:
-            ev->x = fb_width - ev->orig_x;
-            ev->y = fb_height - ev->orig_y;
-            break;
-        case 270:
-            ev->x = ev->orig_y;
-            ev->y = ev->orig_x;
-
-            ev->x = fb_width - ev->x;
-            break;
-    }
-}
-
-void touch_commit_events(struct timeval ev_time)
-{
-    pthread_mutex_lock(&touch_mutex);
-    int has_handlers = (mt_handlers != NULL);
-    pthread_mutex_unlock(&touch_mutex);
-
-    if(!has_handlers)
-        return;
-
-    uint32_t i;
-    int res;
-    touch_handler *h;
-    handler_list_it *it;
-
-    for(i = 0; i < ARRAY_SIZE(mt_events); ++i)
-    {
-        mt_events[i].us_diff = timeval_us_diff(ev_time, mt_events[i].time);
-        mt_events[i].time = ev_time;
-
-        if(!mt_events[i].changed)
-            continue;
-
-        keyaction_clear_active();
-
-        if(mt_events[i].changed & TCHNG_POS)
-            mt_recalc_pos_rotation(&mt_events[i]);
-
-        pthread_mutex_lock(&touch_mutex);
-        it = mt_handlers;
-        while(it)
-        {
-            h = it->handler;
-
-            res = (*h->callback)(&mt_events[i], h->data);
-            if(res == 0)
-                mt_events[i].consumed = 1;
-            else if(res == 1)
-                break;
-
-            it = it->next;
-        }
-        pthread_mutex_unlock(&touch_mutex);
-
-        mt_events[i].consumed = 0;
-        mt_events[i].changed = 0;
-    }
-}
-
-static void *input_thread_work(UNUSED void *cookie)
-{
-    ev_init();
-    struct input_event ev;
-
-    memset(mt_events, 0, sizeof(mt_events));
-
-    key_itr = 10;
-    mt_slot = 0;
-
-    pthread_mutex_lock(&input_start_mutex);
-    pthread_cond_broadcast(&input_start_cond);
-    pthread_mutex_unlock(&input_start_mutex);
-
-    int res;
-    while(input_run)
-    {
-        while(ev_get(&ev, 1) == 0)
-        {
-            switch(ev.type)
-            {
-                case EV_KEY:
-                    handle_key_event(&ev);
-                    break;
-                case EV_ABS:
-                    handle_abs_event(&ev);
-                    break;
-                case EV_SYN:
-                    handle_syn_event(&ev);
-                    break;
-            }
-        }
-        usleep(10000);
-    }
-    ev_exit();
-    return NULL;
-}
-
-int get_last_key(void)
-{
-    int res = -1;
-    pthread_mutex_lock(&key_mutex);
-    if(key_itr != 10)
-        res = key_queue[key_itr++];
-    pthread_mutex_unlock(&key_mutex);
-    return res;
-}
-
-int wait_for_key(void)
-{
-    int res = -1;
-    while(res == -1)
-    {
-        res = get_last_key();
-        usleep(10000);
-    }
-    return res;
-}
-
-int is_any_key_pressed(void)
-{
-    size_t n, i;
-    unsigned long keys[BITS_TO_LONGS(KEY_CNT)];
-    for(n = 0; n < ev_count; ++n)
-    {
-        if(ioctl(ev_fds[n].fd, EVIOCGKEY(KEY_CNT), keys) >= 0)
-            for(i = 0; i < BITS_TO_LONGS(KEY_CNT); ++i)
-                if(keys[i] != 0)
-                    return 1;
-    }
-    return 0;
-}
-
-void start_input_thread(void)
-{
-    start_input_thread_wait(0);
-}
-
-void start_input_thread_wait(int wait_for_start)
-{
-    pthread_mutex_lock(&input_start_mutex);
-    if(input_run)
-    {
-        pthread_mutex_unlock(&input_start_mutex);
-        return;
-    }
-
-    input_run = 1;
-    pthread_create(&input_thread, NULL, input_thread_work, NULL);
-    if(wait_for_start)
-        pthread_cond_wait(&input_start_cond, &input_start_mutex);
-    pthread_mutex_unlock(&input_start_mutex);
-}
-
-void stop_input_thread(void)
-{
-    pthread_mutex_lock(&input_start_mutex);
-    if(!input_run)
-    {
-        pthread_mutex_unlock(&input_start_mutex);
-        return;
-    }
-
-    input_run = 0;
-    pthread_join(input_thread, NULL);
-    pthread_mutex_unlock(&input_start_mutex);
-}
-
-
-static void add_touch_handler_priv(touch_callback callback, void *data)
-{
-    touch_handler *handler = mzalloc(sizeof(touch_handler));
-    handler->data = data;
-    handler->callback = callback;
-
-    handler_list_it *new_it = mzalloc(sizeof(handler_list_it));
-    new_it->handler = handler;
-
-    pthread_mutex_lock(&touch_mutex);
-
-    handler_list_it *it = mt_handlers;
-    if(mt_handlers)
-        it->prev = new_it;
-    new_it->next = it;
-    mt_handlers = new_it;
-
-    pthread_mutex_unlock(&touch_mutex);
-}
-
-static void rm_touch_handler_priv(touch_callback callback, void *data)
-{
-    pthread_mutex_lock(&touch_mutex);
-
-    handler_list_it *it = mt_handlers;
-    while(it)
-    {
-        if(it->handler->callback != callback || it->handler->data != data)
-        {
-            it = it->next;
-            continue;
-        }
-
-        if(it->prev)
-            it->prev->next = it->next;
-        if(it->next)
-            it->next->prev = it->prev;
-
-        if(it == mt_handlers)
-            mt_handlers = it->next;
-
-        free(it->handler);
-        free(it);
-        break;
-    }
-
-    pthread_mutex_unlock(&touch_mutex);
-}
-
-typedef void (*handler_call)(touch_callback, void*);
-struct handler_thread_data
-{
-    handler_call handler;
-    touch_callback callback;
-    void *data;
-};
-
-static void *touch_handler_thread_work(void *data)
-{
-    struct handler_thread_data *d = data;
-    d->handler(d->callback, d->data);
-    free(d);
-    return NULL;
-}
-
-static void touch_handler_thread_dispatcher(int force_async, handler_call h_c, touch_callback callback, void *data)
-{
-    if(force_async || pthread_self() == input_thread)
-    {
-        struct handler_thread_data *d = mzalloc(sizeof(struct handler_thread_data));
-        d->handler = h_c;
-        d->callback = callback;
-        d->data = data;
-
-        pthread_t handler_thread;
-        pthread_create(&handler_thread, NULL, touch_handler_thread_work, d);
-    }
-    else
-        h_c(callback, data);
-}
-
-void add_touch_handler(touch_callback callback, void *data)
-{
-   touch_handler_thread_dispatcher(0, add_touch_handler_priv, callback, data);
-}
-
-void rm_touch_handler(touch_callback callback, void *data)
-{
-    touch_handler_thread_dispatcher(0, rm_touch_handler_priv, callback, data);
-}
-
-void add_touch_handler_async(touch_callback callback, void *data)
-{
-   touch_handler_thread_dispatcher(1, add_touch_handler_priv, callback, data);
-}
-
-void rm_touch_handler_async(touch_callback callback, void *data)
-{
-    touch_handler_thread_dispatcher(1, rm_touch_handler_priv, callback, data);
-}
-
-void input_push_context(void)
-{
-    handlers_ctx *ctx = mzalloc(sizeof(handlers_ctx));
-
-    pthread_mutex_lock(&touch_mutex);
-    ctx->handlers = mt_handlers;
-    mt_handlers = NULL;
-    pthread_mutex_unlock(&touch_mutex);
-
-    list_add(&inactive_ctx, ctx);
-}
-
-void input_pop_context(void)
-{
-    if(!inactive_ctx)
-        return;
-
-    int idx = list_item_count(inactive_ctx)-1;
-    handlers_ctx *ctx = inactive_ctx[idx];
-
-    pthread_mutex_lock(&touch_mutex);
-    mt_handlers = ctx->handlers;
-    pthread_mutex_unlock(&touch_mutex);
-
-    list_rm_noreorder(&inactive_ctx, ctx, &free);
-}
-
-struct keyaction
-{
-    fb_item_pos *parent;
-    void *data;
-    keyaction_call call;
-};
-
-struct keyaction_ctx
-{
-    int actions_len;
-    struct keyaction **actions;
-    struct keyaction *cur_act;
-    pthread_mutex_t lock;
-    uint32_t repeat_timer;
-    int repeat;
-    int enable;
-};
-
-static struct keyaction_ctx keyaction_ctx = {
-    .actions_len = 0,
-    .actions = NULL,
-    .cur_act = NULL,
-    .lock = PTHREAD_MUTEX_INITIALIZER,
-    .repeat = KEYACT_NONE,
-    .enable = 0,
-};
-
-#define REPEAT_TIME_FIRST 500
-#define REPEAT_TIME 150
-
-static int compare_keyactions(const void* k1, const void* k2)
-{
-    const struct keyaction *a1 = *((const struct keyaction **)k1);
-    const struct keyaction *a2 = *((const struct keyaction **)k2);
-
-    if(a1->parent->y < a2->parent->y)
-        return -1;
-    else if(a1->parent->y > a2->parent->y)
-        return 1;
-    else
-    {
-        if(a1->parent->x < a2->parent->x)
-            return -1;
-        else if(a1->parent->x > a2->parent->x)
-            return 1;
-    }
-    return 0;
-}
-
-void keyaction_add(void *parent, keyaction_call call, void *data)
-{
-    struct keyaction *k = mzalloc(sizeof(struct keyaction));
-    k->parent = parent;
-    k->data = data;
-    k->call = call;
-
-    pthread_mutex_lock(&keyaction_ctx.lock);
-
-    list_add(&keyaction_ctx.actions, k);
-    ++keyaction_ctx.actions_len;
-
-    qsort(keyaction_ctx.actions, keyaction_ctx.actions_len,
-          sizeof(struct keyaction *), &compare_keyactions);
-
-    pthread_mutex_unlock(&keyaction_ctx.lock);
-}
-
-void keyaction_remove(keyaction_call call, void *data)
-{
-    pthread_mutex_lock(&keyaction_ctx.lock);
-    if(keyaction_ctx.actions)
-    {
-        int i;
-        struct keyaction *a;
-        for(i = 0; keyaction_ctx.actions[i]; ++i)
-        {
-            a = keyaction_ctx.actions[i];
-            if(a->call == call && a->data == data)
-            {
-                if(a == keyaction_ctx.cur_act)
-                {
-                    a->call(a->data, KEYACT_CLEAR);
-                    keyaction_ctx.cur_act = NULL;
-                }
-
-                list_rm_at(&keyaction_ctx.actions, i, &free);
-                --keyaction_ctx.actions_len;
-                break;
-            }
-        }
-    }
-    pthread_mutex_unlock(&keyaction_ctx.lock);
-}
-
-void keyaction_clear(void)
-{
-    pthread_mutex_lock(&keyaction_ctx.lock);
-
-    list_clear(&keyaction_ctx.actions, &free);
-    keyaction_ctx.actions_len = 0;
-    keyaction_ctx.repeat = KEYACT_NONE;
-    keyaction_ctx.cur_act = NULL;
-
-    pthread_mutex_unlock(&keyaction_ctx.lock);
-}
-
-static int keyaction_is_visible(struct keyaction *a)
-{
-    return (a->parent->x >= 0 && a->parent->y >= 0 &&
-            a->parent->x + a->parent->w <= (int)fb_width &&
-            a->parent->y + a->parent->h <= (int)fb_height);
-}
-
-// expects locked mutex
-static void keyaction_call_cur_act(struct keyaction_ctx *c, int action)
-{
-    if(!c->cur_act)
-        return;
-
-    keyaction_call call = c->cur_act->call;
-    void *data = c->cur_act->data;
-    int res;
-
-    pthread_mutex_unlock(&c->lock);
-    res = (*call)(data, action);
-    pthread_mutex_lock(&c->lock);
-
-    if (res != 1 || (action != KEYACT_UP && action != KEYACT_DOWN))
-        return;
-
-    struct keyaction **a = c->actions;
-    for(; *a; ++a)
-    {
-        if(*a == c->cur_act)
-        {
-            do
-            {
-                if(action == KEYACT_UP)
-                    c->cur_act = (a != c->actions) ? *(--a) : NULL;
-                else
-                    c->cur_act = *(++a);
-
-                if(c->cur_act)
-                    ERROR("act %d %d %d %d\n", c->cur_act->parent->x, c->cur_act->parent->y, c->cur_act->parent->w, c->cur_act->parent->h);
-            }
-            while(c->cur_act && !keyaction_is_visible(c->cur_act));
-
-            if(c->cur_act)
-                c->cur_act->call(c->cur_act->data, action);
-            return;
-        }
-    }
-    // should never be reached
-    ERROR("keyaction_call_cur_act: current action not found in actions!\n");
-}
-
-static int keyaction_repeat_worker(uint32_t diff, void *data)
-{
-    struct keyaction_ctx *c = data;
-
-    pthread_mutex_lock(&c->lock);
-    if(c->repeat != KEYACT_NONE)
-    {
-        if(c->repeat_timer <= diff)
-        {
-            keyaction_call_cur_act(c, c->repeat);
-            c->repeat_timer = REPEAT_TIME;
-        }
-        else
-            c->repeat_timer -= diff;
-    }
-    pthread_mutex_unlock(&c->lock);
-
-    return 0;
-}
-
-void keyaction_clear_active(void)
-{
-    pthread_mutex_lock(&keyaction_ctx.lock);
-    if(keyaction_ctx.enable && keyaction_ctx.cur_act)
-    {
-        keyaction_call_cur_act(&keyaction_ctx, KEYACT_CLEAR);
-        keyaction_ctx.repeat = KEYACT_NONE;
-        keyaction_ctx.cur_act = NULL;
-    }
-    pthread_mutex_unlock(&keyaction_ctx.lock);
-}
-
-int keyaction_handle_keyevent(int key, int press)
-{
-    int res = -1;
-    int act = KEYACT_NONE;
-    switch(key)
-    {
-        case KEY_POWER:
-            act = KEYACT_CONFIRM;
-            break;
-        case KEY_VOLUMEDOWN:
-            act = KEYACT_DOWN;
-            break;
-        case KEY_VOLUMEUP:
-            act = KEYACT_UP;
-            break;
-    }
-
-    pthread_mutex_lock(&keyaction_ctx.lock);
-    if(keyaction_ctx.enable == 0 || !keyaction_ctx.actions)
-        goto exit;
-
-    res = 0;
-
-    if(press == 1 && ncard_try_cancel())
-        goto exit;
-
-    if(keyaction_ctx.repeat == act && press == 0)
-        keyaction_ctx.repeat = KEYACT_NONE;
-    else if(keyaction_ctx.repeat == KEYACT_NONE && press == 1)
-    {
-        if(keyaction_ctx.cur_act == NULL)
-        {
-            if(act == KEYACT_DOWN)
-                keyaction_ctx.cur_act = *keyaction_ctx.actions;
-            else if(act == KEYACT_UP)
-                keyaction_ctx.cur_act = *(keyaction_ctx.actions + keyaction_ctx.actions_len - 1);
-            else
-                goto exit;
-        }
-
-        keyaction_call_cur_act(&keyaction_ctx, act);
-
-        if(act != KEYACT_CONFIRM)
-        {
-            keyaction_ctx.repeat = act;
-            keyaction_ctx.repeat_timer = REPEAT_TIME_FIRST;
-        }
-    }
-
-exit:
-    pthread_mutex_unlock(&keyaction_ctx.lock);
-    return res;
-}
-
-void keyaction_enable(int enable)
-{
-    pthread_mutex_lock(&keyaction_ctx.lock);
-    if(enable != keyaction_ctx.enable)
-    {
-        keyaction_ctx.enable = enable;
-        pthread_mutex_unlock(&keyaction_ctx.lock);
-
-        if(enable)
-            workers_add(&keyaction_repeat_worker, &keyaction_ctx);
-        else
-            workers_remove(&keyaction_repeat_worker, &keyaction_ctx);
-    }
-    else
-        pthread_mutex_unlock(&keyaction_ctx.lock);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/poll.h>
+#include <sys/time.h>
+#include <linux/input.h>
+#include <linux/kd.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <assert.h>
+
+#include <string.h>
+#include <malloc.h>
+
+#include "input.h"
+#include "input_priv.h"
+#include "framebuffer.h"
+#include "util.h"
+#include "log.h"
+#include "workers.h"
+#include "containers.h"
+#include "notification_card.h"
+
+// for touch calculation
+int mt_screen_res[2] = { 0 };
+touch_event mt_events[MAX_FINGERS];
+int mt_slot = 0;
+int mt_switch_xy = 0;
+int mt_range_x[2] = { 0 };
+int mt_range_y[2] = { 0 };
+
+static struct pollfd ev_fds[MAX_DEVICES];
+static unsigned ev_count = 0;
+static volatile int input_run = 0;
+
+static int key_queue[10];
+static int8_t key_itr = 10;
+static pthread_mutex_t key_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t touch_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_t input_thread;
+
+static pthread_mutex_t input_start_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t input_start_cond = PTHREAD_COND_INITIALIZER;
+
+static handler_list_it *mt_handlers = NULL;
+static handlers_ctx **inactive_ctx = NULL;
+
+#define DIV_ROUND_UP(n,d)  (((n) + (d) - 1) / (d))
+#define BIT(nr)            (1UL << (nr))
+#define BIT_MASK(nr)       (1UL << ((nr) % BITS_PER_LONG))
+#define BIT_WORD(nr)       ((nr) / BITS_PER_LONG)
+#define BITS_PER_BYTE      8
+#define BITS_PER_LONG      (sizeof(long) * BITS_PER_BYTE)
+#define BITS_TO_LONGS(nr)  DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+
+static void get_abs_min_max(int fd)
+{
+    struct input_absinfo absinfo;
+
+    if(ioctl(fd, EVIOCGABS(ABS_MT_POSITION_X), &absinfo) >= 0)
+    {
+        mt_range_x[0] = absinfo.minimum;
+        mt_range_x[1] = absinfo.maximum;
+    }
+
+    if(ioctl(fd, EVIOCGABS(ABS_MT_POSITION_Y), &absinfo) >= 0)
+    {
+        mt_range_y[0] = absinfo.minimum;
+        mt_range_y[1] = absinfo.maximum;
+    }
+
+    mt_switch_xy = (mt_range_x[1] > mt_range_y[1]);
+    if(mt_switch_xy)
+    {
+        int tmp[2];
+        memcpy(tmp, mt_range_x, 2*sizeof(int));
+        memcpy(mt_range_x, mt_range_y, 2*sizeof(int));
+        memcpy(mt_range_y, tmp, 2*sizeof(int));
+    }
+}
+
+static int ev_init(void)
+{
+    DIR *dir;
+    struct dirent *de;
+    int fd;
+    long absbit[BITS_TO_LONGS(ABS_CNT)];
+
+    ev_count = 0;
+    mt_screen_res[0] = fb_get_vi_xres();
+    mt_screen_res[1] = fb_get_vi_yres();
+
+    init_touch_specifics();
+
+    dir = opendir("/dev/input");
+    if(!dir)
+        return -1;
+
+    while((de = readdir(dir)))
+    {
+        if(strncmp(de->d_name,"event",5))
+            continue;
+
+        fd = openat(dirfd(dir), de->d_name, O_RDONLY | O_CLOEXEC);
+        if(fd < 0)
+            continue;
+
+        ev_fds[ev_count].fd = fd;
+        ev_fds[ev_count].events = POLLIN;
+
+        if (ioctl(fd, EVIOCGBIT(EV_ABS, ABS_CNT), absbit) >= 0)
+        {
+             if ((absbit[BIT_WORD(ABS_MT_POSITION_X)] & BIT_MASK(ABS_MT_POSITION_X)) &&
+                (absbit[BIT_WORD(ABS_MT_POSITION_Y)] & BIT_MASK(ABS_MT_POSITION_Y)))
+             {
+                 get_abs_min_max(fd);
+             }
+        }
+
+        ev_count++;
+        if(ev_count == MAX_DEVICES) break;
+    }
+    closedir(dir);
+
+    return 0;
+}
+
+static void ev_exit(void)
+{
+    destroy_touch_specifics();
+
+    while (ev_count > 0) {
+        close(ev_fds[--ev_count].fd);
+    }
+}
+
+static int ev_get(struct input_event *ev, unsigned dont_wait)
+{
+    int r;
+    unsigned n;
+
+    do {
+        r = poll(ev_fds, ev_count, dont_wait ? 0 : -1);
+
+        if(r > 0) {
+            for(n = 0; n < ev_count; n++) {
+                if(ev_fds[n].revents & POLLIN) {
+                    r = read(ev_fds[n].fd, ev, sizeof(*ev));
+                    if(r == sizeof(*ev)) return 0;
+                }
+            }
+        }
+    } while(dont_wait == 0);
+
+    return -1;
+}
+
+#define IS_KEY_HANDLED(key) (key >= KEY_VOLUMEDOWN && key <= KEY_POWER)
+
+static int screenshot_trigger_handle_keyevent(int code, int pressed)
+{
+    static int power_pressed = 0;
+    switch(code)
+    {
+        case KEY_POWER:
+            power_pressed = pressed;
+            break;
+        case KEY_VOLUMEDOWN:
+            if(power_pressed && pressed)
+            {
+                fb_save_screenshot();
+                return 0;
+            }
+            break;
+    }
+    return -1;
+}
+
+static void handle_key_event(struct input_event *ev)
+{
+    if(!IS_KEY_HANDLED(ev->code))
+        return;
+
+    if(screenshot_trigger_handle_keyevent(ev->code, (ev->value != 0)) != -1)
+        return;
+
+    if(keyaction_handle_keyevent(ev->code, (ev->value != 0)) != -1)
+        return;
+
+    if(ev->value != 0)
+        return;
+
+    pthread_mutex_lock(&key_mutex);
+    if(key_itr > 0)
+        key_queue[--key_itr] = ev->code;
+    pthread_mutex_unlock(&key_mutex);
+}
+
+int calc_mt_pos(int val, int *range, int d_max)
+{
+    int res = ((val-range[0])*100);
+    res /= (range[1]-range[0]);
+    return (res*d_max)/100;
+}
+
+static void mt_recalc_pos_rotation(touch_event *ev)
+{
+    switch(fb_rotation)
+    {
+        case 0:
+            ev->x = ev->orig_x;
+            ev->y = ev->orig_y;
+            return;
+        case 90:
+            ev->x = ev->orig_y;
+            ev->y = ev->orig_x;
+
+            ev->y = fb_height - ev->y;
+            break;
+        case 180:
+            ev->x = fb_width - ev->orig_x;
+            ev->y = fb_height - ev->orig_y;
+            break;
+        case 270:
+            ev->x = ev->orig_y;
+            ev->y = ev->orig_x;
+
+            ev->x = fb_width - ev->x;
+            break;
+    }
+}
+
+void touch_commit_events(struct timeval ev_time)
+{
+    pthread_mutex_lock(&touch_mutex);
+    int has_handlers = (mt_handlers != NULL);
+    pthread_mutex_unlock(&touch_mutex);
+
+    if(!has_handlers)
+        return;
+
+    uint32_t i;
+    int res;
+    touch_handler *h;
+    handler_list_it *it;
+
+    for(i = 0; i < ARRAY_SIZE(mt_events); ++i)
+    {
+        mt_events[i].us_diff = timeval_us_diff(ev_time, mt_events[i].time);
+        mt_events[i].time = ev_time;
+
+        if(!mt_events[i].changed)
+            continue;
+
+        keyaction_clear_active();
+
+        if(mt_events[i].changed & TCHNG_POS)
+            mt_recalc_pos_rotation(&mt_events[i]);
+
+        pthread_mutex_lock(&touch_mutex);
+        it = mt_handlers;
+        while(it)
+        {
+            h = it->handler;
+
+            res = (*h->callback)(&mt_events[i], h->data);
+            if(res == 0)
+                mt_events[i].consumed = 1;
+            else if(res == 1)
+                break;
+
+            it = it->next;
+        }
+        pthread_mutex_unlock(&touch_mutex);
+
+        mt_events[i].consumed = 0;
+        mt_events[i].changed = 0;
+    }
+}
+
+static void *input_thread_work(UNUSED void *cookie)
+{
+    ev_init();
+    struct input_event ev;
+
+    memset(mt_events, 0, sizeof(mt_events));
+
+    key_itr = 10;
+    mt_slot = 0;
+
+    pthread_mutex_lock(&input_start_mutex);
+    pthread_cond_broadcast(&input_start_cond);
+    pthread_mutex_unlock(&input_start_mutex);
+
+    int res;
+    while(input_run)
+    {
+        while(ev_get(&ev, 1) == 0)
+        {
+            switch(ev.type)
+            {
+                case EV_KEY:
+                    handle_key_event(&ev);
+                    break;
+                case EV_ABS:
+                    handle_abs_event(&ev);
+                    break;
+                case EV_SYN:
+                    handle_syn_event(&ev);
+                    break;
+            }
+        }
+        usleep(10000);
+    }
+    ev_exit();
+    return NULL;
+}
+
+int get_last_key(void)
+{
+    int res = -1;
+    pthread_mutex_lock(&key_mutex);
+    if(key_itr != 10)
+        res = key_queue[key_itr++];
+    pthread_mutex_unlock(&key_mutex);
+    return res;
+}
+
+int wait_for_key(void)
+{
+    int res = -1;
+    while(res == -1)
+    {
+        res = get_last_key();
+        usleep(10000);
+    }
+    return res;
+}
+
+int is_any_key_pressed(void)
+{
+    size_t n, i;
+    unsigned long keys[BITS_TO_LONGS(KEY_CNT)];
+    for(n = 0; n < ev_count; ++n)
+    {
+        if(ioctl(ev_fds[n].fd, EVIOCGKEY(KEY_CNT), keys) >= 0)
+            for(i = 0; i < BITS_TO_LONGS(KEY_CNT); ++i)
+                if(keys[i] != 0)
+                    return 1;
+    }
+    return 0;
+}
+
+void start_input_thread(void)
+{
+    start_input_thread_wait(0);
+}
+
+void start_input_thread_wait(int wait_for_start)
+{
+    pthread_mutex_lock(&input_start_mutex);
+    if(input_run)
+    {
+        pthread_mutex_unlock(&input_start_mutex);
+        return;
+    }
+
+    input_run = 1;
+    pthread_create(&input_thread, NULL, input_thread_work, NULL);
+    if(wait_for_start)
+        pthread_cond_wait(&input_start_cond, &input_start_mutex);
+    pthread_mutex_unlock(&input_start_mutex);
+}
+
+void stop_input_thread(void)
+{
+    pthread_mutex_lock(&input_start_mutex);
+    if(!input_run)
+    {
+        pthread_mutex_unlock(&input_start_mutex);
+        return;
+    }
+
+    input_run = 0;
+    pthread_join(input_thread, NULL);
+    pthread_mutex_unlock(&input_start_mutex);
+}
+
+
+static void add_touch_handler_priv(touch_callback callback, void *data)
+{
+    touch_handler *handler = mzalloc(sizeof(touch_handler));
+    handler->data = data;
+    handler->callback = callback;
+
+    handler_list_it *new_it = mzalloc(sizeof(handler_list_it));
+    new_it->handler = handler;
+
+    pthread_mutex_lock(&touch_mutex);
+
+    handler_list_it *it = mt_handlers;
+    if(mt_handlers)
+        it->prev = new_it;
+    new_it->next = it;
+    mt_handlers = new_it;
+
+    pthread_mutex_unlock(&touch_mutex);
+}
+
+static void rm_touch_handler_priv(touch_callback callback, void *data)
+{
+    pthread_mutex_lock(&touch_mutex);
+
+    handler_list_it *it = mt_handlers;
+    while(it)
+    {
+        if(it->handler->callback != callback || it->handler->data != data)
+        {
+            it = it->next;
+            continue;
+        }
+
+        if(it->prev)
+            it->prev->next = it->next;
+        if(it->next)
+            it->next->prev = it->prev;
+
+        if(it == mt_handlers)
+            mt_handlers = it->next;
+
+        free(it->handler);
+        free(it);
+        break;
+    }
+
+    pthread_mutex_unlock(&touch_mutex);
+}
+
+typedef void (*handler_call)(touch_callback, void*);
+struct handler_thread_data
+{
+    handler_call handler;
+    touch_callback callback;
+    void *data;
+};
+
+static void *touch_handler_thread_work(void *data)
+{
+    struct handler_thread_data *d = data;
+    d->handler(d->callback, d->data);
+    free(d);
+    return NULL;
+}
+
+static void touch_handler_thread_dispatcher(int force_async, handler_call h_c, touch_callback callback, void *data)
+{
+    if(force_async || pthread_self() == input_thread)
+    {
+        struct handler_thread_data *d = mzalloc(sizeof(struct handler_thread_data));
+        d->handler = h_c;
+        d->callback = callback;
+        d->data = data;
+
+        pthread_t handler_thread;
+        pthread_create(&handler_thread, NULL, touch_handler_thread_work, d);
+    }
+    else
+        h_c(callback, data);
+}
+
+void add_touch_handler(touch_callback callback, void *data)
+{
+   touch_handler_thread_dispatcher(0, add_touch_handler_priv, callback, data);
+}
+
+void rm_touch_handler(touch_callback callback, void *data)
+{
+    touch_handler_thread_dispatcher(0, rm_touch_handler_priv, callback, data);
+}
+
+void add_touch_handler_async(touch_callback callback, void *data)
+{
+   touch_handler_thread_dispatcher(1, add_touch_handler_priv, callback, data);
+}
+
+void rm_touch_handler_async(touch_callback callback, void *data)
+{
+    touch_handler_thread_dispatcher(1, rm_touch_handler_priv, callback, data);
+}
+
+void input_push_context(void)
+{
+    handlers_ctx *ctx = mzalloc(sizeof(handlers_ctx));
+
+    pthread_mutex_lock(&touch_mutex);
+    ctx->handlers = mt_handlers;
+    mt_handlers = NULL;
+    pthread_mutex_unlock(&touch_mutex);
+
+    list_add(&inactive_ctx, ctx);
+}
+
+void input_pop_context(void)
+{
+    if(!inactive_ctx)
+        return;
+
+    int idx = list_item_count(inactive_ctx)-1;
+    handlers_ctx *ctx = inactive_ctx[idx];
+
+    pthread_mutex_lock(&touch_mutex);
+    mt_handlers = ctx->handlers;
+    pthread_mutex_unlock(&touch_mutex);
+
+    list_rm_noreorder(&inactive_ctx, ctx, &free);
+}
+
+struct keyaction
+{
+    fb_item_pos *parent;
+    void *data;
+    keyaction_call call;
+};
+
+struct keyaction_ctx
+{
+    int actions_len;
+    struct keyaction **actions;
+    struct keyaction *cur_act;
+    pthread_mutex_t lock;
+    uint32_t repeat_timer;
+    int repeat;
+    int enable;
+};
+
+static struct keyaction_ctx keyaction_ctx = {
+    .actions_len = 0,
+    .actions = NULL,
+    .cur_act = NULL,
+    .lock = PTHREAD_MUTEX_INITIALIZER,
+    .repeat = KEYACT_NONE,
+    .enable = 0,
+};
+
+#define REPEAT_TIME_FIRST 500
+#define REPEAT_TIME 150
+
+static int compare_keyactions(const void* k1, const void* k2)
+{
+    const struct keyaction *a1 = *((const struct keyaction **)k1);
+    const struct keyaction *a2 = *((const struct keyaction **)k2);
+
+    if(a1->parent->y < a2->parent->y)
+        return -1;
+    else if(a1->parent->y > a2->parent->y)
+        return 1;
+    else
+    {
+        if(a1->parent->x < a2->parent->x)
+            return -1;
+        else if(a1->parent->x > a2->parent->x)
+            return 1;
+    }
+    return 0;
+}
+
+void keyaction_add(void *parent, keyaction_call call, void *data)
+{
+    struct keyaction *k = mzalloc(sizeof(struct keyaction));
+    k->parent = parent;
+    k->data = data;
+    k->call = call;
+
+    pthread_mutex_lock(&keyaction_ctx.lock);
+
+    list_add(&keyaction_ctx.actions, k);
+    ++keyaction_ctx.actions_len;
+
+    qsort(keyaction_ctx.actions, keyaction_ctx.actions_len,
+          sizeof(struct keyaction *), &compare_keyactions);
+
+    pthread_mutex_unlock(&keyaction_ctx.lock);
+}
+
+void keyaction_remove(keyaction_call call, void *data)
+{
+    pthread_mutex_lock(&keyaction_ctx.lock);
+    if(keyaction_ctx.actions)
+    {
+        int i;
+        struct keyaction *a;
+        for(i = 0; keyaction_ctx.actions[i]; ++i)
+        {
+            a = keyaction_ctx.actions[i];
+            if(a->call == call && a->data == data)
+            {
+                if(a == keyaction_ctx.cur_act)
+                {
+                    a->call(a->data, KEYACT_CLEAR);
+                    keyaction_ctx.cur_act = NULL;
+                }
+
+                list_rm_at(&keyaction_ctx.actions, i, &free);
+                --keyaction_ctx.actions_len;
+                break;
+            }
+        }
+    }
+    pthread_mutex_unlock(&keyaction_ctx.lock);
+}
+
+void keyaction_clear(void)
+{
+    pthread_mutex_lock(&keyaction_ctx.lock);
+
+    list_clear(&keyaction_ctx.actions, &free);
+    keyaction_ctx.actions_len = 0;
+    keyaction_ctx.repeat = KEYACT_NONE;
+    keyaction_ctx.cur_act = NULL;
+
+    pthread_mutex_unlock(&keyaction_ctx.lock);
+}
+
+static int keyaction_is_visible(struct keyaction *a)
+{
+    return (a->parent->x >= 0 && a->parent->y >= 0 &&
+            a->parent->x + a->parent->w <= (int)fb_width &&
+            a->parent->y + a->parent->h <= (int)fb_height);
+}
+
+// expects locked mutex
+static void keyaction_call_cur_act(struct keyaction_ctx *c, int action)
+{
+    if(!c->cur_act)
+        return;
+
+    keyaction_call call = c->cur_act->call;
+    void *data = c->cur_act->data;
+    int res;
+
+    pthread_mutex_unlock(&c->lock);
+    res = (*call)(data, action);
+    pthread_mutex_lock(&c->lock);
+
+    if (res != 1 || (action != KEYACT_UP && action != KEYACT_DOWN))
+        return;
+
+    struct keyaction **a = c->actions;
+    for(; *a; ++a)
+    {
+        if(*a == c->cur_act)
+        {
+            do
+            {
+                if(action == KEYACT_UP)
+                    c->cur_act = (a != c->actions) ? *(--a) : NULL;
+                else
+                    c->cur_act = *(++a);
+
+                if(c->cur_act)
+                    ERROR("act %d %d %d %d\n", c->cur_act->parent->x, c->cur_act->parent->y, c->cur_act->parent->w, c->cur_act->parent->h);
+            }
+            while(c->cur_act && !keyaction_is_visible(c->cur_act));
+
+            if(c->cur_act)
+                c->cur_act->call(c->cur_act->data, action);
+            return;
+        }
+    }
+    // should never be reached
+    ERROR("keyaction_call_cur_act: current action not found in actions!\n");
+}
+
+static int keyaction_repeat_worker(uint32_t diff, void *data)
+{
+    struct keyaction_ctx *c = data;
+
+    pthread_mutex_lock(&c->lock);
+    if(c->repeat != KEYACT_NONE)
+    {
+        if(c->repeat_timer <= diff)
+        {
+            keyaction_call_cur_act(c, c->repeat);
+            c->repeat_timer = REPEAT_TIME;
+        }
+        else
+            c->repeat_timer -= diff;
+    }
+    pthread_mutex_unlock(&c->lock);
+
+    return 0;
+}
+
+void keyaction_clear_active(void)
+{
+    pthread_mutex_lock(&keyaction_ctx.lock);
+    if(keyaction_ctx.enable && keyaction_ctx.cur_act)
+    {
+        keyaction_call_cur_act(&keyaction_ctx, KEYACT_CLEAR);
+        keyaction_ctx.repeat = KEYACT_NONE;
+        keyaction_ctx.cur_act = NULL;
+    }
+    pthread_mutex_unlock(&keyaction_ctx.lock);
+}
+
+int keyaction_handle_keyevent(int key, int press)
+{
+    int res = -1;
+    int act = KEYACT_NONE;
+    switch(key)
+    {
+        case KEY_POWER:
+            act = KEYACT_CONFIRM;
+            break;
+        case KEY_VOLUMEDOWN:
+            act = KEYACT_DOWN;
+            break;
+        case KEY_VOLUMEUP:
+            act = KEYACT_UP;
+            break;
+    }
+
+    pthread_mutex_lock(&keyaction_ctx.lock);
+    if(keyaction_ctx.enable == 0 || !keyaction_ctx.actions)
+        goto exit;
+
+    res = 0;
+
+    if(press == 1 && ncard_try_cancel())
+        goto exit;
+
+    if(keyaction_ctx.repeat == act && press == 0)
+        keyaction_ctx.repeat = KEYACT_NONE;
+    else if(keyaction_ctx.repeat == KEYACT_NONE && press == 1)
+    {
+        if(keyaction_ctx.cur_act == NULL)
+        {
+            if(act == KEYACT_DOWN)
+                keyaction_ctx.cur_act = *keyaction_ctx.actions;
+            else if(act == KEYACT_UP)
+                keyaction_ctx.cur_act = *(keyaction_ctx.actions + keyaction_ctx.actions_len - 1);
+            else
+                goto exit;
+        }
+
+        keyaction_call_cur_act(&keyaction_ctx, act);
+
+        if(act != KEYACT_CONFIRM)
+        {
+            keyaction_ctx.repeat = act;
+            keyaction_ctx.repeat_timer = REPEAT_TIME_FIRST;
+        }
+    }
+
+exit:
+    pthread_mutex_unlock(&keyaction_ctx.lock);
+    return res;
+}
+
+void keyaction_enable(int enable)
+{
+    pthread_mutex_lock(&keyaction_ctx.lock);
+    if(enable != keyaction_ctx.enable)
+    {
+        keyaction_ctx.enable = enable;
+        pthread_mutex_unlock(&keyaction_ctx.lock);
+
+        if(enable)
+            workers_add(&keyaction_repeat_worker, &keyaction_ctx);
+        else
+            workers_remove(&keyaction_repeat_worker, &keyaction_ctx);
+    }
+    else
+        pthread_mutex_unlock(&keyaction_ctx.lock);
+}
diff --git a/lib/input.h b/lib/input.h
index 8cae9f4..3ec3389 100755
--- a/lib/input.h
+++ b/lib/input.h
@@ -1,86 +1,86 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef INPUT_H
-#define INPUT_H
-
-#include <sys/time.h>
-#include "framebuffer.h"
-
-#define KEY_VOLUMEUP 115
-#define KEY_VOLUMEDOWN 114
-#define KEY_POWER 116
-
-enum
-{
-    TCHNG_POS       = 0x01,
-    //TCHNG_PRESSURE  = 0x02, // unused
-    TCHNG_ADDED     = 0x04,
-    TCHNG_REMOVED   = 0x08
-};
-
-typedef struct
-{
-    int id;
-    int x, orig_x;
-    int y, orig_y;
-    int changed;
-    int consumed;
-
-    struct timeval time;
-    int64_t us_diff;
-} touch_event;
-
-typedef int (*touch_callback)(touch_event*, void*); // event, data
-
-void start_input_thread(void);
-void start_input_thread_wait(int wait_for_start);
-void stop_input_thread(void);
-
-int get_last_key(void);
-int wait_for_key(void);
-int is_any_key_pressed(void);
-
-void add_touch_handler(touch_callback callback, void *data);
-void rm_touch_handler(touch_callback callback, void *data);
-void add_touch_handler_async(touch_callback callback, void *data);
-void rm_touch_handler_async(touch_callback callback, void *data);
-
-void input_push_context(void);
-void input_pop_context(void);
-
-
-enum
-{
-    KEYACT_NONE = 0,
-    KEYACT_UP,
-    KEYACT_DOWN,
-    KEYACT_CONFIRM,
-    KEYACT_CLEAR,
-};
-
-#define KEYACT_FRAME_W (8*DPI_MUL)
-
-typedef int (*keyaction_call)(void *, int); // data, action
-void keyaction_add(void *parent, keyaction_call call, void *data);
-void keyaction_remove(keyaction_call call, void *data);
-void keyaction_clear(void);
-void keyaction_clear_active(void);
-int keyaction_handle_keyevent(int key, int press);
-void keyaction_enable(int enable);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef INPUT_H
+#define INPUT_H
+
+#include <sys/time.h>
+#include "framebuffer.h"
+
+#define KEY_VOLUMEUP 115
+#define KEY_VOLUMEDOWN 114
+#define KEY_POWER 116
+
+enum
+{
+    TCHNG_POS       = 0x01,
+    //TCHNG_PRESSURE  = 0x02, // unused
+    TCHNG_ADDED     = 0x04,
+    TCHNG_REMOVED   = 0x08
+};
+
+typedef struct
+{
+    int id;
+    int x, orig_x;
+    int y, orig_y;
+    int changed;
+    int consumed;
+
+    struct timeval time;
+    int64_t us_diff;
+} touch_event;
+
+typedef int (*touch_callback)(touch_event*, void*); // event, data
+
+void start_input_thread(void);
+void start_input_thread_wait(int wait_for_start);
+void stop_input_thread(void);
+
+int get_last_key(void);
+int wait_for_key(void);
+int is_any_key_pressed(void);
+
+void add_touch_handler(touch_callback callback, void *data);
+void rm_touch_handler(touch_callback callback, void *data);
+void add_touch_handler_async(touch_callback callback, void *data);
+void rm_touch_handler_async(touch_callback callback, void *data);
+
+void input_push_context(void);
+void input_pop_context(void);
+
+
+enum
+{
+    KEYACT_NONE = 0,
+    KEYACT_UP,
+    KEYACT_DOWN,
+    KEYACT_CONFIRM,
+    KEYACT_CLEAR,
+};
+
+#define KEYACT_FRAME_W (8*DPI_MUL)
+
+typedef int (*keyaction_call)(void *, int); // data, action
+void keyaction_add(void *parent, keyaction_call call, void *data);
+void keyaction_remove(keyaction_call call, void *data);
+void keyaction_clear(void);
+void keyaction_clear_active(void);
+int keyaction_handle_keyevent(int key, int press);
+void keyaction_enable(int enable);
+
+#endif
diff --git a/lib/input_priv.h b/lib/input_priv.h
index 9ebffc9..d40fb14 100755
--- a/lib/input_priv.h
+++ b/lib/input_priv.h
@@ -1,67 +1,67 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef INPUT_PRIV_H
-#define INPUT_PRIV_H
-
-#include <sys/time.h>
-#include "input.h"
-
-#define MAX_DEVICES 16
-#define MAX_FINGERS 10
-
-// for touch calculation
-extern int mt_screen_res[2];
-extern touch_event mt_events[MAX_FINGERS];
-extern int mt_slot;
-extern int mt_switch_xy;
-extern int mt_range_x[2];
-extern int mt_range_y[2];
-
-typedef struct
-{
-    void *data;
-    touch_callback callback;
-} touch_handler;
-
-struct handler_list_it
-{
-    touch_handler *handler;
-
-    struct handler_list_it *prev;
-    struct handler_list_it *next;
-};
-
-typedef struct handler_list_it handler_list_it;
-
-typedef struct
-{
-    int handlers_mode;
-    handler_list_it *handlers;
-} handlers_ctx;
-
-void touch_commit_events(struct timeval ev_time);
-inline int calc_mt_pos(int val, int *range, int d_max);
-
-// Implemented in input_touch*.c files
-void handle_abs_event(struct input_event *ev);
-void handle_syn_event(struct input_event *ev);
-void init_touch_specifics(void);
-void destroy_touch_specifics(void);
-
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef INPUT_PRIV_H
+#define INPUT_PRIV_H
+
+#include <sys/time.h>
+#include "input.h"
+
+#define MAX_DEVICES 16
+#define MAX_FINGERS 10
+
+// for touch calculation
+extern int mt_screen_res[2];
+extern touch_event mt_events[MAX_FINGERS];
+extern int mt_slot;
+extern int mt_switch_xy;
+extern int mt_range_x[2];
+extern int mt_range_y[2];
+
+typedef struct
+{
+    void *data;
+    touch_callback callback;
+} touch_handler;
+
+struct handler_list_it
+{
+    touch_handler *handler;
+
+    struct handler_list_it *prev;
+    struct handler_list_it *next;
+};
+
+typedef struct handler_list_it handler_list_it;
+
+typedef struct
+{
+    int handlers_mode;
+    handler_list_it *handlers;
+} handlers_ctx;
+
+void touch_commit_events(struct timeval ev_time);
+inline int calc_mt_pos(int val, int *range, int d_max);
+
+// Implemented in input_touch*.c files
+void handle_abs_event(struct input_event *ev);
+void handle_syn_event(struct input_event *ev);
+void init_touch_specifics(void);
+void destroy_touch_specifics(void);
+
+
+#endif
diff --git a/lib/input_type_a.c b/lib/input_type_a.c
index 7e3224e..38b8eb6 100755
--- a/lib/input_type_a.c
+++ b/lib/input_type_a.c
@@ -1,164 +1,164 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-// Implementation of "Protocol Example A" from kernel's
-// Documentation/input/multi-touch-protocol.txt
-
-// This protocol requires client to keep track of ids,
-// I don't really like this implementation, but I can't
-// come up with anything better :/
-
-#include <linux/input.h>
-#include <assert.h>
-#include <stdlib.h>
-
-#include "input.h"
-#include "input_priv.h"
-#include "util.h"
-
-static int *active_touches = NULL;
-static int *curr_touches = NULL;
-
-static void idlist_clear(int *list)
-{
-    int i;
-    for(i = 0; i < MAX_FINGERS && list[i] != -1; ++i)
-        list[i] = -1;
-}
-
-static int *idlist_init(void)
-{
-    int *res = malloc(MAX_FINGERS*sizeof(int));
-
-    int i;
-    for(i = 0; i < MAX_FINGERS; ++i)
-        res[i] = -1;
-
-    return res;
-}
-
-static void idlist_swap(int **list_a, int **list_b)
-{
-    int *tmp = *list_a;
-    *list_a = *list_b;
-    *list_b = tmp;
-}
-
-static int idlist_add(int *list, int id)
-{
-    int i;
-    for(i = 0; i < MAX_FINGERS; ++i)
-    {
-        if(list[i] == id)
-            return -1;
-
-        if(list[i] == -1)
-        {
-            list[i] = id;
-            return 0;
-        }
-    }
-    assert(0);
-    return -1;
-}
-
-static int idlist_rm(int *list, int id)
-{
-    int i;
-    for(i = 0; i < MAX_FINGERS; ++i)
-    {
-        if(list[i] == -1)
-            return -1;
-
-        if(list[i] == id)
-        {
-            for(++i; i < MAX_FINGERS && list[i] != -1; ++i)
-                list[i-1] = list[i];
-            list[i-1] = -1;
-            return 0;
-        }
-    }
-    return -1;
-}
-
-void init_touch_specifics(void)
-{
-    active_touches = idlist_init();
-    curr_touches = idlist_init();
-}
-
-void destroy_touch_specifics(void)
-{
-    free(active_touches);
-    free(curr_touches);
-    active_touches = NULL;
-    curr_touches = NULL;
-}
-
-void handle_abs_event(struct input_event *ev)
-{
-    switch(ev->code)
-    {
-        case ABS_MT_TRACKING_ID:
-        {
-            mt_events[mt_slot++].id = ev->value;
-            break;
-        }
-        case ABS_MT_POSITION_X:
-        case ABS_MT_POSITION_Y:
-        {
-            if((ev->code == ABS_MT_POSITION_X) ^ (mt_switch_xy != 0))
-            {
-                mt_events[mt_slot].orig_x = calc_mt_pos(ev->value, mt_range_x, mt_screen_res[0]);
-                if(mt_switch_xy)
-                    mt_events[mt_slot].orig_x = mt_screen_res[0] - mt_events[mt_slot].orig_x;
-            }
-            else
-                mt_events[mt_slot].orig_y = calc_mt_pos(ev->value, mt_range_y, mt_screen_res[1]);
-
-            mt_events[mt_slot].changed |= TCHNG_POS;
-            break;
-        }
-    }
-}
-
-void handle_syn_event(struct input_event *ev)
-{
-    if(ev->code != SYN_REPORT)
-        return;
-
-    idlist_swap(&curr_touches, &active_touches);
-
-    int i;
-    for(i = 0; i < mt_slot; ++i)
-    {
-        idlist_add(active_touches, mt_events[i].id);
-        if(idlist_rm(curr_touches, mt_events[i].id) == -1)
-            mt_events[i].changed |= TCHNG_ADDED;
-    }
-
-    for(i = 0; mt_slot < MAX_FINGERS && i < MAX_FINGERS && curr_touches[i] != -1; ++i)
-    {
-        mt_events[mt_slot].id = curr_touches[i];
-        mt_events[mt_slot].changed = TCHNG_REMOVED;
-        curr_touches[i] = -1;
-        ++mt_slot;
-    }
-
-    mt_slot = 0;
-    touch_commit_events(ev->time);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// Implementation of "Protocol Example A" from kernel's
+// Documentation/input/multi-touch-protocol.txt
+
+// This protocol requires client to keep track of ids,
+// I don't really like this implementation, but I can't
+// come up with anything better :/
+
+#include <linux/input.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#include "input.h"
+#include "input_priv.h"
+#include "util.h"
+
+static int *active_touches = NULL;
+static int *curr_touches = NULL;
+
+static void idlist_clear(int *list)
+{
+    int i;
+    for(i = 0; i < MAX_FINGERS && list[i] != -1; ++i)
+        list[i] = -1;
+}
+
+static int *idlist_init(void)
+{
+    int *res = malloc(MAX_FINGERS*sizeof(int));
+
+    int i;
+    for(i = 0; i < MAX_FINGERS; ++i)
+        res[i] = -1;
+
+    return res;
+}
+
+static void idlist_swap(int **list_a, int **list_b)
+{
+    int *tmp = *list_a;
+    *list_a = *list_b;
+    *list_b = tmp;
+}
+
+static int idlist_add(int *list, int id)
+{
+    int i;
+    for(i = 0; i < MAX_FINGERS; ++i)
+    {
+        if(list[i] == id)
+            return -1;
+
+        if(list[i] == -1)
+        {
+            list[i] = id;
+            return 0;
+        }
+    }
+    assert(0);
+    return -1;
+}
+
+static int idlist_rm(int *list, int id)
+{
+    int i;
+    for(i = 0; i < MAX_FINGERS; ++i)
+    {
+        if(list[i] == -1)
+            return -1;
+
+        if(list[i] == id)
+        {
+            for(++i; i < MAX_FINGERS && list[i] != -1; ++i)
+                list[i-1] = list[i];
+            list[i-1] = -1;
+            return 0;
+        }
+    }
+    return -1;
+}
+
+void init_touch_specifics(void)
+{
+    active_touches = idlist_init();
+    curr_touches = idlist_init();
+}
+
+void destroy_touch_specifics(void)
+{
+    free(active_touches);
+    free(curr_touches);
+    active_touches = NULL;
+    curr_touches = NULL;
+}
+
+void handle_abs_event(struct input_event *ev)
+{
+    switch(ev->code)
+    {
+        case ABS_MT_TRACKING_ID:
+        {
+            mt_events[mt_slot++].id = ev->value;
+            break;
+        }
+        case ABS_MT_POSITION_X:
+        case ABS_MT_POSITION_Y:
+        {
+            if((ev->code == ABS_MT_POSITION_X) ^ (mt_switch_xy != 0))
+            {
+                mt_events[mt_slot].orig_x = calc_mt_pos(ev->value, mt_range_x, mt_screen_res[0]);
+                if(mt_switch_xy)
+                    mt_events[mt_slot].orig_x = mt_screen_res[0] - mt_events[mt_slot].orig_x;
+            }
+            else
+                mt_events[mt_slot].orig_y = calc_mt_pos(ev->value, mt_range_y, mt_screen_res[1]);
+
+            mt_events[mt_slot].changed |= TCHNG_POS;
+            break;
+        }
+    }
+}
+
+void handle_syn_event(struct input_event *ev)
+{
+    if(ev->code != SYN_REPORT)
+        return;
+
+    idlist_swap(&curr_touches, &active_touches);
+
+    int i;
+    for(i = 0; i < mt_slot; ++i)
+    {
+        idlist_add(active_touches, mt_events[i].id);
+        if(idlist_rm(curr_touches, mt_events[i].id) == -1)
+            mt_events[i].changed |= TCHNG_ADDED;
+    }
+
+    for(i = 0; mt_slot < MAX_FINGERS && i < MAX_FINGERS && curr_touches[i] != -1; ++i)
+    {
+        mt_events[mt_slot].id = curr_touches[i];
+        mt_events[mt_slot].changed = TCHNG_REMOVED;
+        curr_touches[i] = -1;
+        ++mt_slot;
+    }
+
+    mt_slot = 0;
+    touch_commit_events(ev->time);
+}
diff --git a/lib/input_type_b.c b/lib/input_type_b.c
index d919d8f..a025ccd 100755
--- a/lib/input_type_b.c
+++ b/lib/input_type_b.c
@@ -1,77 +1,77 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-// Implementation of "Protocol Example B" from kernel's
-// Documentation/input/multi-touch-protocol.txt
-
-#include <linux/input.h>
-#include "input.h"
-#include "input_priv.h"
-#include "util.h"
-
-void init_touch_specifics(void)
-{
-
-}
-
-void destroy_touch_specifics(void)
-{
-
-}
-
-void handle_abs_event(struct input_event *ev)
-{
-    switch(ev->code)
-    {
-        case ABS_MT_SLOT:
-            if(ev->value < (int)ARRAY_SIZE(mt_events))
-                mt_slot = ev->value;
-            break;
-        case ABS_MT_TRACKING_ID:
-        {
-            if(ev->value != -1)
-            {
-                mt_events[mt_slot].id = ev->value;
-                mt_events[mt_slot].changed |= TCHNG_ADDED;
-            }
-            else
-                mt_events[mt_slot].changed |= TCHNG_REMOVED;
-            break;
-        }
-        case ABS_MT_POSITION_X:
-        case ABS_MT_POSITION_Y:
-        {
-            if((ev->code == ABS_MT_POSITION_X) ^ (mt_switch_xy != 0))
-            {
-                mt_events[mt_slot].orig_x = calc_mt_pos(ev->value, mt_range_x, mt_screen_res[0]);
-                if(mt_switch_xy)
-                    mt_events[mt_slot].orig_x = mt_screen_res[0] - mt_events[mt_slot].orig_x;
-            }
-            else
-                mt_events[mt_slot].orig_y = calc_mt_pos(ev->value, mt_range_y, mt_screen_res[1]);
-
-            mt_events[mt_slot].changed |= TCHNG_POS;
-            break;
-        }
-    }
-}
-
-void handle_syn_event(struct input_event *ev)
-{
-    if(ev->code == SYN_REPORT)
-        touch_commit_events(ev->time);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// Implementation of "Protocol Example B" from kernel's
+// Documentation/input/multi-touch-protocol.txt
+
+#include <linux/input.h>
+#include "input.h"
+#include "input_priv.h"
+#include "util.h"
+
+void init_touch_specifics(void)
+{
+
+}
+
+void destroy_touch_specifics(void)
+{
+
+}
+
+void handle_abs_event(struct input_event *ev)
+{
+    switch(ev->code)
+    {
+        case ABS_MT_SLOT:
+            if(ev->value < (int)ARRAY_SIZE(mt_events))
+                mt_slot = ev->value;
+            break;
+        case ABS_MT_TRACKING_ID:
+        {
+            if(ev->value != -1)
+            {
+                mt_events[mt_slot].id = ev->value;
+                mt_events[mt_slot].changed |= TCHNG_ADDED;
+            }
+            else
+                mt_events[mt_slot].changed |= TCHNG_REMOVED;
+            break;
+        }
+        case ABS_MT_POSITION_X:
+        case ABS_MT_POSITION_Y:
+        {
+            if((ev->code == ABS_MT_POSITION_X) ^ (mt_switch_xy != 0))
+            {
+                mt_events[mt_slot].orig_x = calc_mt_pos(ev->value, mt_range_x, mt_screen_res[0]);
+                if(mt_switch_xy)
+                    mt_events[mt_slot].orig_x = mt_screen_res[0] - mt_events[mt_slot].orig_x;
+            }
+            else
+                mt_events[mt_slot].orig_y = calc_mt_pos(ev->value, mt_range_y, mt_screen_res[1]);
+
+            mt_events[mt_slot].changed |= TCHNG_POS;
+            break;
+        }
+    }
+}
+
+void handle_syn_event(struct input_event *ev)
+{
+    if(ev->code == SYN_REPORT)
+        touch_commit_events(ev->time);
+}
diff --git a/lib/keyboard.c b/lib/keyboard.c
index b60faf8..28ff19a 100755
--- a/lib/keyboard.c
+++ b/lib/keyboard.c
@@ -1,231 +1,231 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-
-#include "containers.h"
-#include "keyboard.h"
-#include "util.h"
-#include "log.h"
-#include "workers.h"
-
-#define KS(x) ((x-1) << 16)
-#define GET_KS(x) ((x & 0xFF0000)>> 16)
-
-#define KF(x) ((x) << 8)
-#define GET_KF(x) ((x & 0xFF00) >> 8)
-#define KFLAG_HALF KF(0x01)
-#define KFLAG_PLUS_HALF KF(0x02)
-
-static const char *specialKeys[] = {
-    NULL,  // OSK_EMPTY
-    "OK",  // OSK_ENTER
-    "<",   // OSK_BACKSPACE
-    "X",   // OSK_CLEAR
-    "abc", // OSK_CHARSET1
-    "ABC", // OSK_CHARSET2
-    "?123",// OSK_CHARSET3
-    "=\\<",// OSK_CHARSET4
-};
-
-// One keycode
-// bits | 0         | 8       | 16      |
-// data | character | flags   | colspan |
-static const uint32_t pinKeycodeMap[] = {
-    OSK_EMPTY | KFLAG_HALF, '1', '2', '3', OSK_EMPTY,
-    OSK_EMPTY | KFLAG_HALF, '4', '5', '6', OSK_CLEAR,
-    OSK_EMPTY | KFLAG_HALF, '7', '8', '9', OSK_BACKSPACE,
-    OSK_EMPTY | KFLAG_HALF, '0' | KS(3),   OSK_ENTER,
-    0
-};
-
-// rows, cols
-static const uint32_t pinKeycodeMapDimensions[] = { 4, 5 };
-
-static const uint32_t normalKeycodeMapCharset1[] = {
-    'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
-    OSK_EMPTY| KFLAG_HALF, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l',
-    OSK_CHARSET2 | KFLAG_PLUS_HALF, 'z', 'x', 'c', 'v', 'b', 'n', 'm', OSK_BACKSPACE | KFLAG_PLUS_HALF, OSK_EMPTY,
-    OSK_CHARSET3 | KS(2), ' ' | KS(5), '.', OSK_ENTER | KS(2),
-    0
-};
-
-static const uint32_t normalKeycodeMapCharset2[] = {
-    'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
-    OSK_EMPTY| KFLAG_HALF, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L',
-    OSK_CHARSET1 | KFLAG_PLUS_HALF, 'Z', 'X', 'C', 'V', 'B', 'N', 'M', OSK_BACKSPACE | KFLAG_PLUS_HALF, OSK_EMPTY,
-    OSK_CHARSET3 | KS(2), ' ' | KS(5), '.', OSK_ENTER | KS(2),
-    0
-};
-
-static const uint32_t normalKeycodeMapCharset3[] = {
-    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
-    OSK_EMPTY | KFLAG_HALF, '@', '#', '$', '%', '&', '-', '+', '(', ')',
-    OSK_CHARSET4 | KFLAG_PLUS_HALF, '*', '"', '\'', ':', ';', '!', '?', OSK_BACKSPACE | KFLAG_PLUS_HALF, OSK_EMPTY,
-    OSK_CHARSET1 | KS(2), ',', '_', ' ' | KS(3), '/', OSK_ENTER | KS(2),
-    0
-};
-
-static const uint32_t normalKeycodeMapCharset4[] = {
-    '~', '`', '|', '<', '>', '-', '+', '!', '?', ';',
-    OSK_EMPTY | KFLAG_HALF, '^', '\\', '$', '%', '&', '-', '+', '{', '}',
-    OSK_CHARSET3 | KFLAG_PLUS_HALF, '*', '"', '\'', ':', ';', '[', ']', OSK_BACKSPACE | KFLAG_PLUS_HALF, OSK_EMPTY,
-    OSK_CHARSET1 | KS(2), ',', ' ' | KS(4), '/', OSK_ENTER | KS(2),
-    0
-};
-
-static const uint32_t *normalKeycodeMapCharsetMapping[] = {
-    normalKeycodeMapCharset4, // OSK_CHARSET4
-    normalKeycodeMapCharset3, // OSK_CHARSET3
-    normalKeycodeMapCharset2, // OSK_CHARSET2
-    normalKeycodeMapCharset1, // OSK_CHARSET1
-};
-
-// rows, cols
-static const uint32_t normalKeycodeMapDimensions[] = { 4, 10 };
-
-#define PADDING (8*DPI_MUL)
-
-struct keyboard_btn_data {
-    struct keyboard *k;
-    int btn_idx;
-};
-
-static int keyboard_init_map(struct keyboard *k, const uint32_t *map, const uint32_t *dimen);
-
-
-static int keyboard_charset_switch_worker(UNUSED uint32_t diff, void *data)
-{
-    void **keyboard_bnt_data_old = NULL;
-    struct keyboard_btn_data *d = data;
-    uint8_t keycode = (d->k->keycode_map[d->btn_idx] & 0xFF);
-
-    fb_batch_start();
-    list_clear(&d->k->btns, &button_destroy);
-    list_swap(&d->k->keyboard_bnt_data, &keyboard_bnt_data_old);
-    keyboard_init_map(d->k, normalKeycodeMapCharsetMapping[keycode - OSK_CHARSET4], normalKeycodeMapDimensions);
-    fb_batch_end();
-    fb_request_draw();
-
-    list_clear(&keyboard_bnt_data_old, free);
-    return 1;
-}
-
-static void keyboard_btn_clicked(void *data)
-{
-    struct keyboard_btn_data *d = data;
-    uint8_t keycode = (d->k->keycode_map[d->btn_idx] & 0xFF);
-
-    if(keycode >= OSK_CHARSET4 && keycode <= OSK_CHARSET1)
-        workers_add(keyboard_charset_switch_worker, data);
-    else if(d->k->key_pressed)
-        d->k->key_pressed(d->k->key_pressed_data, keycode);
-}
-
-int keyboard_init_map(struct keyboard *k, const uint32_t *map, const uint32_t *dimen)
-{
-    button *btn;
-    int i, idx = 0;
-    uint32_t col = 0;
-    char buf[2] = { 0 };
-    uint8_t code;
-
-    int x = k->x + PADDING;
-    int y = k->y + PADDING;
-    int w;
-    const int btn_w = (k->w - PADDING*(dimen[1]+1)) /dimen[1];
-    const int btn_h = (k->h - PADDING*(dimen[0]+1)) /dimen[0];
-
-    for(i = 0; map[i]; ++i)
-    {
-        code = (map[i] & 0xFF);
-        w = (GET_KS(map[i])+1)*btn_w + PADDING*GET_KS(map[i]);
-
-        if(map[i] & KFLAG_HALF)
-            w /= 2;
-        else if(map[i] & KFLAG_PLUS_HALF)
-            w = w*1.5 + PADDING*0.5;
-
-        if(code != OSK_EMPTY)
-        {
-            btn = mzalloc(sizeof(button));
-            btn->x = x;
-            btn->y = y;
-            btn->w = w;
-            btn->h = btn_h;
-
-            struct keyboard_btn_data *d = mzalloc(sizeof(struct keyboard_btn_data));
-            d->k = k;
-            d->btn_idx = i;
-            btn->clicked_data = d;
-            btn->clicked = keyboard_btn_clicked;
-
-            buf[0] = (map[i] & 0xFF);
-            button_init_ui(btn, ((int8_t)buf[0]) >= 0 ? buf : specialKeys[0xFF - (map[i] & 0xFF)], SIZE_NORMAL);
-            list_add(&k->btns, btn);
-            list_add(&k->keyboard_bnt_data, d);
-        }
-
-        col += GET_KS(map[i])+1;
-        if(col < dimen[1])
-            x += w + PADDING;
-        else
-        {
-            x = k->x + PADDING;
-            y += btn_h + PADDING;
-            col = 0;
-        }
-    }
-
-    k->keycode_map = map;
-    return 0;
-}
-
-struct keyboard *keyboard_create(int type, int x, int y, int w, int h)
-{
-    struct keyboard *k = mzalloc(sizeof(struct keyboard));
-    k->x = x;
-    k->y = y;
-    k->w = w;
-    k->h = h;
-
-    switch(type)
-    {
-        case KEYBOARD_PIN:
-            keyboard_init_map(k, pinKeycodeMap, pinKeycodeMapDimensions);
-            break;
-        case KEYBOARD_NORMAL:
-        default:
-            keyboard_init_map(k, normalKeycodeMapCharset1, normalKeycodeMapDimensions);
-            break;
-    }
-
-    return k;
-}
-
-void keyboard_destroy(struct keyboard *k)
-{
-    list_clear(&k->btns, &button_destroy);
-    list_clear(&k->keyboard_bnt_data, free);
-    free(k);
-}
-
-void keyboard_set_callback(struct keyboard *k, keyboard_on_pressed_callback callback, void *data)
-{
-    k->key_pressed = callback;
-    k->key_pressed_data = data;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+
+#include "containers.h"
+#include "keyboard.h"
+#include "util.h"
+#include "log.h"
+#include "workers.h"
+
+#define KS(x) ((x-1) << 16)
+#define GET_KS(x) ((x & 0xFF0000)>> 16)
+
+#define KF(x) ((x) << 8)
+#define GET_KF(x) ((x & 0xFF00) >> 8)
+#define KFLAG_HALF KF(0x01)
+#define KFLAG_PLUS_HALF KF(0x02)
+
+static const char *specialKeys[] = {
+    NULL,  // OSK_EMPTY
+    "OK",  // OSK_ENTER
+    "<",   // OSK_BACKSPACE
+    "X",   // OSK_CLEAR
+    "abc", // OSK_CHARSET1
+    "ABC", // OSK_CHARSET2
+    "?123",// OSK_CHARSET3
+    "=\\<",// OSK_CHARSET4
+};
+
+// One keycode
+// bits | 0         | 8       | 16      |
+// data | character | flags   | colspan |
+static const uint32_t pinKeycodeMap[] = {
+    OSK_EMPTY | KFLAG_HALF, '1', '2', '3', OSK_EMPTY,
+    OSK_EMPTY | KFLAG_HALF, '4', '5', '6', OSK_CLEAR,
+    OSK_EMPTY | KFLAG_HALF, '7', '8', '9', OSK_BACKSPACE,
+    OSK_EMPTY | KFLAG_HALF, '0' | KS(3),   OSK_ENTER,
+    0
+};
+
+// rows, cols
+static const uint32_t pinKeycodeMapDimensions[] = { 4, 5 };
+
+static const uint32_t normalKeycodeMapCharset1[] = {
+    'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
+    OSK_EMPTY| KFLAG_HALF, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l',
+    OSK_CHARSET2 | KFLAG_PLUS_HALF, 'z', 'x', 'c', 'v', 'b', 'n', 'm', OSK_BACKSPACE | KFLAG_PLUS_HALF, OSK_EMPTY,
+    OSK_CHARSET3 | KS(2), ' ' | KS(5), '.', OSK_ENTER | KS(2),
+    0
+};
+
+static const uint32_t normalKeycodeMapCharset2[] = {
+    'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
+    OSK_EMPTY| KFLAG_HALF, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L',
+    OSK_CHARSET1 | KFLAG_PLUS_HALF, 'Z', 'X', 'C', 'V', 'B', 'N', 'M', OSK_BACKSPACE | KFLAG_PLUS_HALF, OSK_EMPTY,
+    OSK_CHARSET3 | KS(2), ' ' | KS(5), '.', OSK_ENTER | KS(2),
+    0
+};
+
+static const uint32_t normalKeycodeMapCharset3[] = {
+    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
+    OSK_EMPTY | KFLAG_HALF, '@', '#', '$', '%', '&', '-', '+', '(', ')',
+    OSK_CHARSET4 | KFLAG_PLUS_HALF, '*', '"', '\'', ':', ';', '!', '?', OSK_BACKSPACE | KFLAG_PLUS_HALF, OSK_EMPTY,
+    OSK_CHARSET1 | KS(2), ',', '_', ' ' | KS(3), '/', OSK_ENTER | KS(2),
+    0
+};
+
+static const uint32_t normalKeycodeMapCharset4[] = {
+    '~', '`', '|', '<', '>', '-', '+', '!', '?', ';',
+    OSK_EMPTY | KFLAG_HALF, '^', '\\', '$', '%', '&', '-', '+', '{', '}',
+    OSK_CHARSET3 | KFLAG_PLUS_HALF, '*', '"', '\'', ':', ';', '[', ']', OSK_BACKSPACE | KFLAG_PLUS_HALF, OSK_EMPTY,
+    OSK_CHARSET1 | KS(2), ',', ' ' | KS(4), '/', OSK_ENTER | KS(2),
+    0
+};
+
+static const uint32_t *normalKeycodeMapCharsetMapping[] = {
+    normalKeycodeMapCharset4, // OSK_CHARSET4
+    normalKeycodeMapCharset3, // OSK_CHARSET3
+    normalKeycodeMapCharset2, // OSK_CHARSET2
+    normalKeycodeMapCharset1, // OSK_CHARSET1
+};
+
+// rows, cols
+static const uint32_t normalKeycodeMapDimensions[] = { 4, 10 };
+
+#define PADDING (8*DPI_MUL)
+
+struct keyboard_btn_data {
+    struct keyboard *k;
+    int btn_idx;
+};
+
+static int keyboard_init_map(struct keyboard *k, const uint32_t *map, const uint32_t *dimen);
+
+
+static int keyboard_charset_switch_worker(UNUSED uint32_t diff, void *data)
+{
+    void **keyboard_bnt_data_old = NULL;
+    struct keyboard_btn_data *d = data;
+    uint8_t keycode = (d->k->keycode_map[d->btn_idx] & 0xFF);
+
+    fb_batch_start();
+    list_clear(&d->k->btns, &button_destroy);
+    list_swap(&d->k->keyboard_bnt_data, &keyboard_bnt_data_old);
+    keyboard_init_map(d->k, normalKeycodeMapCharsetMapping[keycode - OSK_CHARSET4], normalKeycodeMapDimensions);
+    fb_batch_end();
+    fb_request_draw();
+
+    list_clear(&keyboard_bnt_data_old, free);
+    return 1;
+}
+
+static void keyboard_btn_clicked(void *data)
+{
+    struct keyboard_btn_data *d = data;
+    uint8_t keycode = (d->k->keycode_map[d->btn_idx] & 0xFF);
+
+    if(keycode >= OSK_CHARSET4 && keycode <= OSK_CHARSET1)
+        workers_add(keyboard_charset_switch_worker, data);
+    else if(d->k->key_pressed)
+        d->k->key_pressed(d->k->key_pressed_data, keycode);
+}
+
+int keyboard_init_map(struct keyboard *k, const uint32_t *map, const uint32_t *dimen)
+{
+    button *btn;
+    int i, idx = 0;
+    uint32_t col = 0;
+    char buf[2] = { 0 };
+    uint8_t code;
+
+    int x = k->x + PADDING;
+    int y = k->y + PADDING;
+    int w;
+    const int btn_w = (k->w - PADDING*(dimen[1]+1)) /dimen[1];
+    const int btn_h = (k->h - PADDING*(dimen[0]+1)) /dimen[0];
+
+    for(i = 0; map[i]; ++i)
+    {
+        code = (map[i] & 0xFF);
+        w = (GET_KS(map[i])+1)*btn_w + PADDING*GET_KS(map[i]);
+
+        if(map[i] & KFLAG_HALF)
+            w /= 2;
+        else if(map[i] & KFLAG_PLUS_HALF)
+            w = w*1.5 + PADDING*0.5;
+
+        if(code != OSK_EMPTY)
+        {
+            btn = mzalloc(sizeof(button));
+            btn->x = x;
+            btn->y = y;
+            btn->w = w;
+            btn->h = btn_h;
+
+            struct keyboard_btn_data *d = mzalloc(sizeof(struct keyboard_btn_data));
+            d->k = k;
+            d->btn_idx = i;
+            btn->clicked_data = d;
+            btn->clicked = keyboard_btn_clicked;
+
+            buf[0] = (map[i] & 0xFF);
+            button_init_ui(btn, ((int8_t)buf[0]) >= 0 ? buf : specialKeys[0xFF - (map[i] & 0xFF)], SIZE_NORMAL);
+            list_add(&k->btns, btn);
+            list_add(&k->keyboard_bnt_data, d);
+        }
+
+        col += GET_KS(map[i])+1;
+        if(col < dimen[1])
+            x += w + PADDING;
+        else
+        {
+            x = k->x + PADDING;
+            y += btn_h + PADDING;
+            col = 0;
+        }
+    }
+
+    k->keycode_map = map;
+    return 0;
+}
+
+struct keyboard *keyboard_create(int type, int x, int y, int w, int h)
+{
+    struct keyboard *k = mzalloc(sizeof(struct keyboard));
+    k->x = x;
+    k->y = y;
+    k->w = w;
+    k->h = h;
+
+    switch(type)
+    {
+        case KEYBOARD_PIN:
+            keyboard_init_map(k, pinKeycodeMap, pinKeycodeMapDimensions);
+            break;
+        case KEYBOARD_NORMAL:
+        default:
+            keyboard_init_map(k, normalKeycodeMapCharset1, normalKeycodeMapDimensions);
+            break;
+    }
+
+    return k;
+}
+
+void keyboard_destroy(struct keyboard *k)
+{
+    list_clear(&k->btns, &button_destroy);
+    list_clear(&k->keyboard_bnt_data, free);
+    free(k);
+}
+
+void keyboard_set_callback(struct keyboard *k, keyboard_on_pressed_callback callback, void *data)
+{
+    k->key_pressed = callback;
+    k->key_pressed_data = data;
+}
diff --git a/lib/keyboard.h b/lib/keyboard.h
index dbfa99c..3aec496 100755
--- a/lib/keyboard.h
+++ b/lib/keyboard.h
@@ -1,53 +1,53 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KEYBOARD_H
-#define KEYBOARD_H
-
-#include <stdint.h>
-
-#include "framebuffer.h"
-#include "button.h"
-
-#define OSK_EMPTY 0xFF
-#define OSK_ENTER 0xFE
-#define OSK_BACKSPACE 0xFD
-#define OSK_CLEAR 0xFC
-#define OSK_CHARSET1 0xFB
-#define OSK_CHARSET2 0xFA
-#define OSK_CHARSET3 0xF9
-#define OSK_CHARSET4 0xF8
-
-typedef void (*keyboard_on_pressed_callback)(void *data, uint8_t keycode);
-struct keyboard
-{
-    FB_ITEM_POS
-    button **btns;
-    void **keyboard_bnt_data;
-    const uint32_t *keycode_map;
-    keyboard_on_pressed_callback key_pressed;
-    void *key_pressed_data;
-};
-
-#define KEYBOARD_PIN 0
-#define KEYBOARD_NORMAL 1
-
-struct keyboard *keyboard_create(int type, int x, int y, int w, int h);
-void keyboard_set_callback(struct keyboard *k, keyboard_on_pressed_callback callback, void *data);
-void keyboard_destroy(struct keyboard *k);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KEYBOARD_H
+#define KEYBOARD_H
+
+#include <stdint.h>
+
+#include "framebuffer.h"
+#include "button.h"
+
+#define OSK_EMPTY 0xFF
+#define OSK_ENTER 0xFE
+#define OSK_BACKSPACE 0xFD
+#define OSK_CLEAR 0xFC
+#define OSK_CHARSET1 0xFB
+#define OSK_CHARSET2 0xFA
+#define OSK_CHARSET3 0xF9
+#define OSK_CHARSET4 0xF8
+
+typedef void (*keyboard_on_pressed_callback)(void *data, uint8_t keycode);
+struct keyboard
+{
+    FB_ITEM_POS
+    button **btns;
+    void **keyboard_bnt_data;
+    const uint32_t *keycode_map;
+    keyboard_on_pressed_callback key_pressed;
+    void *key_pressed_data;
+};
+
+#define KEYBOARD_PIN 0
+#define KEYBOARD_NORMAL 1
+
+struct keyboard *keyboard_create(int type, int x, int y, int w, int h);
+void keyboard_set_callback(struct keyboard *k, keyboard_on_pressed_callback callback, void *data);
+void keyboard_destroy(struct keyboard *k);
+
+#endif
diff --git a/lib/listview.c b/lib/listview.c
index 58fbb3b..213b6a2 100755
--- a/lib/listview.c
+++ b/lib/listview.c
@@ -1,764 +1,764 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <string.h>
-
-#include <malloc.h>
-
-#include "listview.h"
-#include "framebuffer.h"
-#include "util.h"
-#include "log.h"
-#include "colors.h"
-#include "workers.h"
-#include "input.h"
-#include "animation.h"
-#include "notification_card.h"
-#include "containers.h"
-
-#define MARK_W (10*DPI_MUL)
-#define MARK_H (50*DPI_MUL)
-#define PADDING (35*DPI_MUL)
-#define LINE_W (2*DPI_MUL)
-#define SCROLL_DIST (20*DPI_MUL)
-#define OVERSCROLL_H (130*DPI_MUL)
-#define OVERSCROLL_MARK_H (4*DPI_MUL)
-#define OVERSCROLL_RETURN_SPD (10*DPI_MUL)
-
-static int listview_bounceback(UNUSED uint32_t diff, void *data)
-{
-    listview *v = (listview*)data;
-    const int max = v->fullH - v->h;
-
-    int step;
-    if(v->pos < 0)
-    {
-        step = imin(-v->pos, OVERSCROLL_RETURN_SPD);
-        listview_update_overscroll_mark(v, 0, -(v->pos+step));
-    }
-    else if(v->pos > max)
-    {
-        step = -imin(v->pos-max, OVERSCROLL_RETURN_SPD);
-        listview_update_overscroll_mark(v, 1, (v->pos - max + step));
-    }
-    else
-    {
-        if(v->overscroll_marks[0]->w != 0)
-            v->overscroll_marks[0]->w = 0;
-        if(v->overscroll_marks[1]->w != 0)
-            v->overscroll_marks[1]->w = 0;
-        return 0;
-    }
-
-    if(v->touch.id == -1)
-        listview_scroll_by(v, step);
-
-    return 0;
-}
-
-void listview_init_ui(listview *view)
-{
-    view->id = fb_generate_item_id();
-    view->parent = &DEFAULT_FB_PARENT;
-    view->level = LEVEL_LISTVIEW;
-    view->type = FB_IT_LISTVIEW;
-
-    view->keyact_item_selected = -1;
-    view->touch.id = -1;
-    view->tracker = touch_tracker_create();
-
-    view->last_rendered_pos.x = view->x;
-    view->last_rendered_pos.y = view->y;
-    view->last_rendered_pos.w = view->w;
-    view->last_rendered_pos.h = view->h;
-
-    add_touch_handler(&listview_touch_handler, view);
-
-    fb_ctx_add_item(view);
-}
-
-void listview_destroy(listview *view)
-{
-    workers_remove(listview_bounceback, view);
-
-    rm_touch_handler(&listview_touch_handler, view);
-
-    touch_tracker_destroy(view->tracker);
-
-    listview_clear(view);
-    list_clear(&view->ui_items, &fb_remove_item);
-
-    fb_rm_rect(view->scroll_mark);
-    fb_rm_rect(view->overscroll_marks[0]);
-    fb_rm_rect(view->overscroll_marks[1]);
-    fb_rm_rect(view->scroll_line);
-
-    fb_ctx_rm_item(view);
-
-    free(view);
-}
-
-listview_item *listview_add_item(listview *view, int id, void *data)
-{
-    listview_item *it = mzalloc(sizeof(listview_item));
-    it->id = id;
-    it->data = data;
-    it->flags = 0;
-    it->parent_rect = (fb_item_pos*)view;
-
-    if(!view->items)
-        keyaction_add(view, listview_keyaction_call, view);
-
-    list_add(&view->items, it);
-    return it;
-}
-
-void listview_clear(listview *view)
-{
-    if(listview_select_item(view, NULL))
-        listview_update_ui(view);
-
-    list_clear(&view->items, view->item_destroy);
-
-    keyaction_remove(listview_keyaction_call, view);
-}
-
-void listview_update_ui_args(listview *view, int only_if_moved, int mutex_locked)
-{
-    int y = 0;
-    int i, it_h, visible;
-    listview_item *it;
-
-    if(only_if_moved)
-    {
-        if (view->x == view->last_rendered_pos.x &&
-            view->y == view->last_rendered_pos.y &&
-            view->w == view->last_rendered_pos.w &&
-            view->h == view->last_rendered_pos.h)
-        {
-            return;
-        }
-
-        if(view->scroll_mark)
-        {
-            view->scroll_mark->x += view->x - view->last_rendered_pos.x;
-            view->scroll_mark->y += view->y - view->last_rendered_pos.y;
-            view->scroll_line->x += view->x - view->last_rendered_pos.x;
-            view->scroll_line->y += view->y - view->last_rendered_pos.y;
-            view->overscroll_marks[0]->y += view->y - view->last_rendered_pos.y;
-            view->overscroll_marks[1]->y += view->y - view->last_rendered_pos.y;
-        }
-
-        view->last_rendered_pos.x = view->x;
-        view->last_rendered_pos.y = view->y;
-        view->last_rendered_pos.w = view->w;
-        view->last_rendered_pos.h = view->h;
-    }
-
-    if(!mutex_locked)
-        fb_batch_start();
-
-    for(i = 0; view->items && view->items[i]; ++i)
-    {
-        it = view->items[i];
-        it_h = (*view->item_height)(it);
-
-        visible = (int)(view->pos <= y+it_h && y-view->pos <= view->h);
-
-        if(visible || (it->flags & IT_VISIBLE))
-            (*view->item_draw)(view->x, view->y+y-view->pos, view->w - PADDING, it);
-
-        if(visible)
-            it->flags |= IT_VISIBLE;
-        else
-            it->flags &= ~(IT_VISIBLE);
-
-        y += it_h;
-    }
-
-    view->fullH = y;
-
-    listview_enable_scroll(view, (int)(y > view->h));
-    if(y > view->h)
-        listview_update_scroll_mark(view);
-
-    if(!mutex_locked)
-        fb_batch_end();
-    fb_request_draw();
-}
-
-void listview_update_ui(listview *view)
-{
-    listview_update_ui_args(view, 0, 0);
-}
-
-void listview_enable_scroll(listview *view, int enable)
-{
-    if((view->scroll_mark != NULL) == (enable))
-        return;
-
-    if(enable)
-    {
-        int x = view->x + view->w - PADDING/2 - MARK_W/2;
-        view->scroll_mark = fb_add_rect(x, view->y, MARK_W, MARK_H, GRAY);
-        view->scroll_mark->parent = (fb_item_pos*)view;
-
-        x = view->x + view->w - PADDING/2 - LINE_W/2;
-        view->scroll_line = fb_add_rect(x, view->y, LINE_W, view->h, GRAY);
-        view->scroll_line->parent = (fb_item_pos*)view;
-
-        view->overscroll_marks[0] = fb_add_rect(view->x, view->y, 0, OVERSCROLL_MARK_H, C_HIGHLIGHT_BG);
-        view->overscroll_marks[0]->parent = (fb_item_pos*)view;
-        view->overscroll_marks[1] = fb_add_rect(view->x, view->y+view->h-OVERSCROLL_MARK_H,
-                                                0, OVERSCROLL_MARK_H, C_HIGHLIGHT_BG);
-        view->overscroll_marks[1]->parent = (fb_item_pos*)view;
-        workers_add(listview_bounceback, view);
-    }
-    else
-    {
-        workers_remove(listview_bounceback, view);
-
-        fb_rm_rect(view->scroll_mark);
-        fb_rm_rect(view->scroll_line);
-        fb_rm_rect(view->overscroll_marks[0]);
-        fb_rm_rect(view->overscroll_marks[1]);
-
-        view->scroll_mark = NULL;
-        view->scroll_line = NULL;
-        view->overscroll_marks[0] = NULL;
-        view->overscroll_marks[1] = NULL;
-    }
-}
-
-void listview_update_scroll_mark(listview *view)
-{
-    if(!view->scroll_mark)
-        return;
-
-    int pos = view->pos;
-    if(pos < 0)
-        pos = 0;
-    else if(pos > view->fullH - view->h)
-        pos = view->fullH - view->h;
-
-    int pct = (pos*100)/(view->fullH-view->h);
-    int y = view->y + ((view->h - MARK_H)*pct)/100;
-    view->scroll_mark->y = y;
-}
-
-void listview_update_overscroll_mark(listview *v, int side, float overscroll)
-{
-    int w = v->w * (overscroll / OVERSCROLL_H);
-    v->overscroll_marks[side]->w = w;
-    v->overscroll_marks[side]->x = v->x + (v->w >> 1) - (w >> 1);
-}
-
-int listview_touch_handler(touch_event *ev, void *data)
-{
-    listview *view = (listview*)data;
-    if(view->touch.id == -1 && (ev->changed & TCHNG_ADDED))
-    {
-        if (ev->x < view->x || ev->y < view->y ||
-            ev->x > view->x+view->w || ev->y > view->y+view->h)
-        {
-            if(listview_select_item(view, NULL))
-                listview_update_ui(view);
-            return -1;
-        }
-
-        if(ev->consumed)
-            return -1;
-
-        touch_tracker_start(view->tracker, ev);
-        view->touch.id = ev->id;
-        view->touch.hover = listview_item_at(view, ev->y);
-        view->touch.fast_scroll = (ev->x > view->x + view->w - PADDING*2 && ev->x <= view->x + view->w);
-
-        if(view->touch.hover)
-        {
-            view->touch.hover->flags |= IT_HOVER;
-            view->touch.hover->touchX = ev->x;
-            view->touch.hover->touchY = ev->y;
-        }
-        else
-            listview_select_item(view, NULL);
-        listview_keyaction_call(view, KEYACT_CLEAR);
-        listview_update_ui(view);
-        return 0;
-    }
-
-    if(view->touch.id != ev->id)
-        return -1;
-
-    if(ev->changed & TCHNG_REMOVED)
-    {
-        if(ev->x == -1 && ev->y == -1)
-        {
-            if(listview_select_item(view, NULL))
-                listview_update_ui(view);
-        }
-        else if(view->touch.hover)
-        {
-            if(view->selected == view->touch.hover)
-            {
-                if(view->item_confirmed)
-                    view->item_confirmed(view->selected);
-            }
-            else
-                listview_select_item(view, view->touch.hover);
-            view->touch.hover->flags &= ~(IT_HOVER);
-            view->touch.hover = NULL;
-        }
-        touch_tracker_finish(view->tracker, ev);
-        view->touch.id = -1;
-        listview_update_ui(view);
-        return 0;
-    }
-
-    if((ev->changed & TCHNG_POS))
-    {
-        touch_tracker_add(view->tracker, ev);
-
-        if(view->touch.hover && view->tracker->distance_abs_y > SCROLL_DIST)
-        {
-            view->touch.hover->flags &= ~(IT_HOVER);
-            view->touch.hover = NULL;
-        }
-
-        if(!view->touch.hover)
-        {
-            if(view->touch.fast_scroll)
-                listview_scroll_to(view, ((ev->y-view->y)*100)/(view->h));
-            else
-                listview_scroll_by(view, view->tracker->prev_y - ev->y);
-        }
-    }
-
-    return 0;
-}
-
-int listview_select_item(listview *view, listview_item *it)
-{
-    if(view->selected == it)
-        return 0;
-
-    if(view->item_selected)
-        (*view->item_selected)(view->selected, it);
-
-    if(view->selected)
-        view->selected->flags &= ~(IT_SELECTED);
-
-    if(it)
-        it->flags |= IT_SELECTED;
-
-    view->selected = it;
-    return 1;
-}
-
-void listview_scroll_by(listview *view, int y)
-{
-    if(!y || !view->scroll_mark)
-        return;
-
-    view->pos += y;
-
-    if(view->pos < -OVERSCROLL_H)
-        view->pos = -OVERSCROLL_H;
-    else if(view->pos > (view->fullH - view->h) + OVERSCROLL_H)
-        view->pos = (view->fullH - view->h) + OVERSCROLL_H;
-
-    listview_select_item(view, NULL);
-    listview_update_ui(view);
-}
-
-void listview_scroll_to(listview *view, int pct)
-{
-    if(!view->scroll_mark)
-        return;
-
-    view->pos = ((view->fullH - view->h)*pct)/100;
-
-    if(view->pos < 0)
-        view->pos = 0;
-    else if(view->pos > (view->fullH - view->h))
-        view->pos = (view->fullH - view->h);
-
-    listview_select_item(view, NULL);
-    listview_update_ui(view);
-}
-
-int listview_ensure_visible(listview *view, listview_item *it)
-{
-    if(!view->scroll_mark)
-        return 0;
-
-    int i;
-    int y = 0;
-    for(i = 0; view->items[i]; ++i)
-    {
-        if(it == view->items[i])
-            break;
-        y += view->item_height(view->items[i]);
-    }
-
-    int last_h = view->items[i] ? view->item_height(view->items[i]) : 0;
-
-    if((y + last_h) - view->pos > view->h)
-        view->pos = (y + last_h) - view->h;
-    else if(y - view->pos < 0)
-        view->pos = y;
-    else
-        return 0;
-    return 1;
-}
-
-int listview_ensure_selected_visible(listview *view)
-{
-    if(view->selected)
-        return listview_ensure_visible(view, view->selected);
-    else
-        return 0;
-}
-
-listview_item *listview_item_at(listview *view, int y_pos)
-{
-    int y = -view->pos + view->y;
-    int i, it_h;
-    listview_item *it;
-
-    for(i = 0; view->items && view->items[i]; ++i)
-    {
-        it = view->items[i];
-        it_h = (*view->item_height)(it);
-
-        if(y < y_pos && y+it_h > y_pos)
-            return it;
-
-        y += it_h;
-    }
-    return NULL;
-}
-
-int listview_keyaction_call(void *data, int act)
-{
-    listview *v = data;
-    switch(act)
-    {
-        case KEYACT_DOWN:
-        {
-            ++v->keyact_item_selected;
-            if(v->keyact_item_selected >= list_item_count(v->items))
-                v->keyact_item_selected = -1;
-            listview_update_keyact_frame(v);
-            return (v->keyact_item_selected == -1) ? 1 :0;
-        }
-        case KEYACT_UP:
-        {
-            if(v->keyact_item_selected == -1)
-                v->keyact_item_selected = list_item_count(v->items)-1;
-            else
-                --v->keyact_item_selected;
-            listview_update_keyact_frame(v);
-            return (v->keyact_item_selected == -1) ? 1 :0;
-        }
-        case KEYACT_CLEAR:
-        {
-            if(v->keyact_item_selected != -1)
-            {
-                v->keyact_item_selected = -1;
-                listview_select_item(v, NULL);
-                listview_update_ui(v);
-                fb_request_draw();
-            }
-            return 0;
-        }
-        case KEYACT_CONFIRM:
-        {
-            if(v->item_confirmed)
-                v->item_confirmed(v->items[v->keyact_item_selected]);
-            return 0;
-        }
-        default:
-            return 0;
-    }
-}
-
-void listview_update_keyact_frame(listview *view)
-{
-    if(view->keyact_item_selected == -1)
-    {
-        if(view->selected)
-        {
-            listview_select_item(view, NULL);
-            listview_update_ui(view);
-        }
-        return;
-    }
-
-    listview_item *it = view->items[view->keyact_item_selected];
-    listview_ensure_visible(view, it);
-
-    int i;
-    int y = view->y;
-    for(i = 0; i < view->keyact_item_selected && view->items[i]; ++i)
-        y += view->item_height(view->items[i]);
-
-    int h = view->item_height(view->items[i]);
-    y -= view->pos;
-
-    listview_select_item(view, it);
-    listview_update_ui(view);
-}
-
-#define ROM_ITEM_H (110*DPI_MUL)
-#define ROM_ITEM_SHADOW (7*DPI_MUL)
-#define ROM_ITEM_SEL_W (8*DPI_MUL)
-#define ROM_ICON_H (70*DPI_MUL)
-#define ROM_TEXT_PADDING_L (120*DPI_MUL)
-#define ROM_TEXT_PADDING_R ((ROM_TEXT_PADDING_L - ROM_ICON_H)/2)
-#define ROM_ICON_PADDING (ROM_TEXT_PADDING_L/2 - ROM_ICON_H/2)
-
-typedef struct
-{
-    char *text;
-    char *partition;
-    char *icon_path;
-    fb_text *text_it;
-    fb_text *part_it;
-    fb_rect *sel_rect;
-    fb_rect *sel_rect_sh;
-    fb_img *icon;
-    int deselect_anim_started;
-    int rom_name_size;
-    int last_y;
-    int last_x;
-} rom_item_data;
-
-void *rom_item_create(const char *text, const char *partition, const char *icon)
-{
-    rom_item_data *data = mzalloc(sizeof(rom_item_data));
-
-    data->rom_name_size = SIZE_BIG;
-
-    data->text = strdup(text);
-    if(partition)
-        data->partition = strdup(partition);
-    if(icon)
-        data->icon_path = strdup(icon);
-    return data;
-}
-
-static void rom_item_deselect_finished(void *data)
-{
-    rom_item_data *d = data;
-
-    fb_rm_rect(d->sel_rect);
-    fb_rm_rect(d->sel_rect_sh);
-    d->sel_rect = NULL;
-    d->sel_rect_sh = NULL;
-}
-
-static void rom_item_sel_step(void *data, UNUSED float interpolated)
-{
-    rom_item_data *d = data;
-    if(!d->sel_rect || !d->sel_rect_sh)
-        return;
-
-    d->sel_rect_sh->x = d->sel_rect->x + ROM_ITEM_SHADOW;
-    d->sel_rect_sh->y = d->sel_rect->y + ROM_ITEM_SHADOW;
-    d->sel_rect_sh->w = d->sel_rect->w;
-    d->sel_rect_sh->h = d->sel_rect->h;
-}
-
-static void rom_item_select(int x, int y, int w, int item_h, listview_item *it, rom_item_data *d)
-{
-    int baseX = it->touchX;
-    int baseY = it->touchY;
-    if(!baseX && !baseY)
-    {
-        baseX = x + w/2;
-        baseY = y + item_h/2;
-    }
-
-    d->deselect_anim_started = 0;
-
-    d->sel_rect_sh = fb_add_rect(baseX+ROM_ITEM_SHADOW, baseY+ROM_ITEM_SHADOW, 1, 1, C_BTN_FAKE_SHADOW);
-    d->sel_rect_sh->parent = it->parent_rect;
-    d->sel_rect = fb_add_rect(baseX, baseY, 1, 1, C_ROM_HIGHLIGHT);
-    d->sel_rect->parent = it->parent_rect;
-
-    item_anim *anim = item_anim_create(d->sel_rect, 300, INTERPOLATOR_ACCEL_DECEL);
-    anim->start_offset = 0;
-    anim->targetX = x;
-    anim->targetY = y;
-    anim->targetW = w;
-    anim->targetH = item_h;
-    anim->on_step_data = d;
-    anim->on_step_call = rom_item_sel_step;
-    item_anim_add(anim);
-
-    ncard_builder *b = ncard_create_builder();
-    ncard_set_text(b, "Tap again to boot the system");
-    fb_item_pos p;
-    p.y = y;
-    p.h = item_h;
-    ncard_avoid_item(b, &p);
-    ncard_show(b, 1);
-}
-
-static void rom_item_deselect(int x, int y, int w, int item_h, listview_item *it, rom_item_data *d)
-{
-    d->deselect_anim_started = 1;
-
-    if(!((listview*)it->parent_rect)->selected)
-        ncard_hide();
-
-    item_anim *anim = item_anim_create(d->sel_rect, 150, INTERPOLATOR_ACCELERATE);
-    if(it->touchX || it->touchY)
-    {
-        anim->targetX = it->touchX;
-        anim->targetY = it->touchY;
-    }
-    else
-    {
-        anim->targetX = x + w/2;
-        anim->targetY = y + item_h/2;
-    }
-    anim->targetW = 0;
-    anim->targetH = 0;
-    anim->on_step_data = d;
-    anim->on_step_call = rom_item_sel_step;
-    anim->on_finished_data = d;
-    anim->on_finished_call = rom_item_deselect_finished;
-    item_anim_add_after(anim);
-}
-
-void rom_item_draw(int x, int y, int w, listview_item *it)
-{
-    rom_item_data *d = (rom_item_data*)it->data;
-    const int item_h = rom_item_height(it);
-    if(!d->text_it)
-    {
-        d->last_x = x;
-        d->last_y = y;
-
-        fb_text_proto *p = fb_text_create(x+ROM_TEXT_PADDING_L, 0, C_TEXT, d->rom_name_size, d->text);
-        p->style = STYLE_CONDENSED;
-        d->text_it = fb_text_finalize(p);
-        d->text_it->parent = it->parent_rect;
-
-        while((d->text_it->w + ROM_TEXT_PADDING_L) >= (w - ROM_TEXT_PADDING_R) && d->rom_name_size > 3)
-            fb_text_set_size(d->text_it, --d->rom_name_size);
-
-        if(d->icon_path)
-        {
-            d->icon = fb_add_png_img(x+ROM_ICON_PADDING, 0, ROM_ICON_H, ROM_ICON_H, d->icon_path);
-            d->icon->parent = it->parent_rect;
-        }
-
-        if(d->partition)
-        {
-            d->part_it = fb_add_text(x+ROM_TEXT_PADDING_L, 0, C_TEXT_SECONDARY, SIZE_SMALL, d->partition);
-            d->part_it->parent = it->parent_rect;
-        }
-    }
-
-    if(!d->part_it)
-        center_text(d->text_it, -1, y, -1, item_h);
-    else
-    {
-        d->text_it->y = y + (item_h/2 - (d->text_it->h + d->part_it->h + 4*DPI_MUL)/2);
-        d->part_it->y = d->text_it->y + d->text_it->h + 4*DPI_MUL;
-        d->part_it->x += x - d->last_x;
-    }
-
-    d->text_it->x += x - d->last_x;
-
-    if(d->icon)
-    {
-        d->icon->x += x - d->last_x;
-        d->icon->y = y + (item_h/2 - ROM_ICON_H/2);
-    }
-
-    if(it->flags & IT_SELECTED)
-    {
-        if(!d->sel_rect)
-        {
-            rom_item_select(x, y, w, item_h, it, d);
-        }
-        else
-        {
-            d->sel_rect_sh->x += x - d->last_x;
-            d->sel_rect->x += x - d->last_x;
-            d->sel_rect_sh->y += y - d->last_y;
-            d->sel_rect->y += y - d->last_y;
-        }
-    }
-    else if(d->sel_rect)
-    {
-        if(!d->deselect_anim_started)
-        {
-            rom_item_deselect(x, y, w, item_h, it, d);
-        }
-        else
-        {
-            d->sel_rect_sh->x += x - d->last_x;
-            d->sel_rect->x += x - d->last_x;
-            d->sel_rect_sh->y += y - d->last_y;
-            d->sel_rect->y += y - d->last_y;
-        }
-    }
-
-    d->last_x = x;
-    d->last_y = y;
-}
-
-void rom_item_hide(void *data)
-{
-    rom_item_data *d = (rom_item_data*)data;
-    if(!d->text_it)
-        return;
-
-    fb_rm_text(d->text_it);
-    fb_rm_text(d->part_it);
-    fb_rm_rect(d->sel_rect);
-    fb_rm_rect(d->sel_rect_sh);
-    fb_rm_img(d->icon);
-
-    d->text_it = NULL;
-    d->part_it = NULL;
-    d->sel_rect = NULL;
-    d->sel_rect_sh = NULL;
-    d->icon = NULL;
-}
-
-int rom_item_height(UNUSED listview_item *it)
-{
-    return ROM_ITEM_H;
-}
-
-void rom_item_destroy(listview_item *it)
-{
-    rom_item_hide(it->data);
-    rom_item_data *d = (rom_item_data*)it->data;
-    free(d->text);
-    free(d->partition);
-    free(d->icon_path);
-    free(it->data);
-    free(it);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <malloc.h>
+
+#include "listview.h"
+#include "framebuffer.h"
+#include "util.h"
+#include "log.h"
+#include "colors.h"
+#include "workers.h"
+#include "input.h"
+#include "animation.h"
+#include "notification_card.h"
+#include "containers.h"
+
+#define MARK_W (10*DPI_MUL)
+#define MARK_H (50*DPI_MUL)
+#define PADDING (35*DPI_MUL)
+#define LINE_W (2*DPI_MUL)
+#define SCROLL_DIST (20*DPI_MUL)
+#define OVERSCROLL_H (130*DPI_MUL)
+#define OVERSCROLL_MARK_H (4*DPI_MUL)
+#define OVERSCROLL_RETURN_SPD (10*DPI_MUL)
+
+static int listview_bounceback(UNUSED uint32_t diff, void *data)
+{
+    listview *v = (listview*)data;
+    const int max = v->fullH - v->h;
+
+    int step;
+    if(v->pos < 0)
+    {
+        step = imin(-v->pos, OVERSCROLL_RETURN_SPD);
+        listview_update_overscroll_mark(v, 0, -(v->pos+step));
+    }
+    else if(v->pos > max)
+    {
+        step = -imin(v->pos-max, OVERSCROLL_RETURN_SPD);
+        listview_update_overscroll_mark(v, 1, (v->pos - max + step));
+    }
+    else
+    {
+        if(v->overscroll_marks[0]->w != 0)
+            v->overscroll_marks[0]->w = 0;
+        if(v->overscroll_marks[1]->w != 0)
+            v->overscroll_marks[1]->w = 0;
+        return 0;
+    }
+
+    if(v->touch.id == -1)
+        listview_scroll_by(v, step);
+
+    return 0;
+}
+
+void listview_init_ui(listview *view)
+{
+    view->id = fb_generate_item_id();
+    view->parent = &DEFAULT_FB_PARENT;
+    view->level = LEVEL_LISTVIEW;
+    view->type = FB_IT_LISTVIEW;
+
+    view->keyact_item_selected = -1;
+    view->touch.id = -1;
+    view->tracker = touch_tracker_create();
+
+    view->last_rendered_pos.x = view->x;
+    view->last_rendered_pos.y = view->y;
+    view->last_rendered_pos.w = view->w;
+    view->last_rendered_pos.h = view->h;
+
+    add_touch_handler(&listview_touch_handler, view);
+
+    fb_ctx_add_item(view);
+}
+
+void listview_destroy(listview *view)
+{
+    workers_remove(listview_bounceback, view);
+
+    rm_touch_handler(&listview_touch_handler, view);
+
+    touch_tracker_destroy(view->tracker);
+
+    listview_clear(view);
+    list_clear(&view->ui_items, &fb_remove_item);
+
+    fb_rm_rect(view->scroll_mark);
+    fb_rm_rect(view->overscroll_marks[0]);
+    fb_rm_rect(view->overscroll_marks[1]);
+    fb_rm_rect(view->scroll_line);
+
+    fb_ctx_rm_item(view);
+
+    free(view);
+}
+
+listview_item *listview_add_item(listview *view, int id, void *data)
+{
+    listview_item *it = mzalloc(sizeof(listview_item));
+    it->id = id;
+    it->data = data;
+    it->flags = 0;
+    it->parent_rect = (fb_item_pos*)view;
+
+    if(!view->items)
+        keyaction_add(view, listview_keyaction_call, view);
+
+    list_add(&view->items, it);
+    return it;
+}
+
+void listview_clear(listview *view)
+{
+    if(listview_select_item(view, NULL))
+        listview_update_ui(view);
+
+    list_clear(&view->items, view->item_destroy);
+
+    keyaction_remove(listview_keyaction_call, view);
+}
+
+void listview_update_ui_args(listview *view, int only_if_moved, int mutex_locked)
+{
+    int y = 0;
+    int i, it_h, visible;
+    listview_item *it;
+
+    if(only_if_moved)
+    {
+        if (view->x == view->last_rendered_pos.x &&
+            view->y == view->last_rendered_pos.y &&
+            view->w == view->last_rendered_pos.w &&
+            view->h == view->last_rendered_pos.h)
+        {
+            return;
+        }
+
+        if(view->scroll_mark)
+        {
+            view->scroll_mark->x += view->x - view->last_rendered_pos.x;
+            view->scroll_mark->y += view->y - view->last_rendered_pos.y;
+            view->scroll_line->x += view->x - view->last_rendered_pos.x;
+            view->scroll_line->y += view->y - view->last_rendered_pos.y;
+            view->overscroll_marks[0]->y += view->y - view->last_rendered_pos.y;
+            view->overscroll_marks[1]->y += view->y - view->last_rendered_pos.y;
+        }
+
+        view->last_rendered_pos.x = view->x;
+        view->last_rendered_pos.y = view->y;
+        view->last_rendered_pos.w = view->w;
+        view->last_rendered_pos.h = view->h;
+    }
+
+    if(!mutex_locked)
+        fb_batch_start();
+
+    for(i = 0; view->items && view->items[i]; ++i)
+    {
+        it = view->items[i];
+        it_h = (*view->item_height)(it);
+
+        visible = (int)(view->pos <= y+it_h && y-view->pos <= view->h);
+
+        if(visible || (it->flags & IT_VISIBLE))
+            (*view->item_draw)(view->x, view->y+y-view->pos, view->w - PADDING, it);
+
+        if(visible)
+            it->flags |= IT_VISIBLE;
+        else
+            it->flags &= ~(IT_VISIBLE);
+
+        y += it_h;
+    }
+
+    view->fullH = y;
+
+    listview_enable_scroll(view, (int)(y > view->h));
+    if(y > view->h)
+        listview_update_scroll_mark(view);
+
+    if(!mutex_locked)
+        fb_batch_end();
+    fb_request_draw();
+}
+
+void listview_update_ui(listview *view)
+{
+    listview_update_ui_args(view, 0, 0);
+}
+
+void listview_enable_scroll(listview *view, int enable)
+{
+    if((view->scroll_mark != NULL) == (enable))
+        return;
+
+    if(enable)
+    {
+        int x = view->x + view->w - PADDING/2 - MARK_W/2;
+        view->scroll_mark = fb_add_rect(x, view->y, MARK_W, MARK_H, GRAY);
+        view->scroll_mark->parent = (fb_item_pos*)view;
+
+        x = view->x + view->w - PADDING/2 - LINE_W/2;
+        view->scroll_line = fb_add_rect(x, view->y, LINE_W, view->h, GRAY);
+        view->scroll_line->parent = (fb_item_pos*)view;
+
+        view->overscroll_marks[0] = fb_add_rect(view->x, view->y, 0, OVERSCROLL_MARK_H, C_HIGHLIGHT_BG);
+        view->overscroll_marks[0]->parent = (fb_item_pos*)view;
+        view->overscroll_marks[1] = fb_add_rect(view->x, view->y+view->h-OVERSCROLL_MARK_H,
+                                                0, OVERSCROLL_MARK_H, C_HIGHLIGHT_BG);
+        view->overscroll_marks[1]->parent = (fb_item_pos*)view;
+        workers_add(listview_bounceback, view);
+    }
+    else
+    {
+        workers_remove(listview_bounceback, view);
+
+        fb_rm_rect(view->scroll_mark);
+        fb_rm_rect(view->scroll_line);
+        fb_rm_rect(view->overscroll_marks[0]);
+        fb_rm_rect(view->overscroll_marks[1]);
+
+        view->scroll_mark = NULL;
+        view->scroll_line = NULL;
+        view->overscroll_marks[0] = NULL;
+        view->overscroll_marks[1] = NULL;
+    }
+}
+
+void listview_update_scroll_mark(listview *view)
+{
+    if(!view->scroll_mark)
+        return;
+
+    int pos = view->pos;
+    if(pos < 0)
+        pos = 0;
+    else if(pos > view->fullH - view->h)
+        pos = view->fullH - view->h;
+
+    int pct = (pos*100)/(view->fullH-view->h);
+    int y = view->y + ((view->h - MARK_H)*pct)/100;
+    view->scroll_mark->y = y;
+}
+
+void listview_update_overscroll_mark(listview *v, int side, float overscroll)
+{
+    int w = v->w * (overscroll / OVERSCROLL_H);
+    v->overscroll_marks[side]->w = w;
+    v->overscroll_marks[side]->x = v->x + (v->w >> 1) - (w >> 1);
+}
+
+int listview_touch_handler(touch_event *ev, void *data)
+{
+    listview *view = (listview*)data;
+    if(view->touch.id == -1 && (ev->changed & TCHNG_ADDED))
+    {
+        if (ev->x < view->x || ev->y < view->y ||
+            ev->x > view->x+view->w || ev->y > view->y+view->h)
+        {
+            if(listview_select_item(view, NULL))
+                listview_update_ui(view);
+            return -1;
+        }
+
+        if(ev->consumed)
+            return -1;
+
+        touch_tracker_start(view->tracker, ev);
+        view->touch.id = ev->id;
+        view->touch.hover = listview_item_at(view, ev->y);
+        view->touch.fast_scroll = (ev->x > view->x + view->w - PADDING*2 && ev->x <= view->x + view->w);
+
+        if(view->touch.hover)
+        {
+            view->touch.hover->flags |= IT_HOVER;
+            view->touch.hover->touchX = ev->x;
+            view->touch.hover->touchY = ev->y;
+        }
+        else
+            listview_select_item(view, NULL);
+        listview_keyaction_call(view, KEYACT_CLEAR);
+        listview_update_ui(view);
+        return 0;
+    }
+
+    if(view->touch.id != ev->id)
+        return -1;
+
+    if(ev->changed & TCHNG_REMOVED)
+    {
+        if(ev->x == -1 && ev->y == -1)
+        {
+            if(listview_select_item(view, NULL))
+                listview_update_ui(view);
+        }
+        else if(view->touch.hover)
+        {
+            if(view->selected == view->touch.hover)
+            {
+                if(view->item_confirmed)
+                    view->item_confirmed(view->selected);
+            }
+            else
+                listview_select_item(view, view->touch.hover);
+            view->touch.hover->flags &= ~(IT_HOVER);
+            view->touch.hover = NULL;
+        }
+        touch_tracker_finish(view->tracker, ev);
+        view->touch.id = -1;
+        listview_update_ui(view);
+        return 0;
+    }
+
+    if((ev->changed & TCHNG_POS))
+    {
+        touch_tracker_add(view->tracker, ev);
+
+        if(view->touch.hover && view->tracker->distance_abs_y > SCROLL_DIST)
+        {
+            view->touch.hover->flags &= ~(IT_HOVER);
+            view->touch.hover = NULL;
+        }
+
+        if(!view->touch.hover)
+        {
+            if(view->touch.fast_scroll)
+                listview_scroll_to(view, ((ev->y-view->y)*100)/(view->h));
+            else
+                listview_scroll_by(view, view->tracker->prev_y - ev->y);
+        }
+    }
+
+    return 0;
+}
+
+int listview_select_item(listview *view, listview_item *it)
+{
+    if(view->selected == it)
+        return 0;
+
+    if(view->item_selected)
+        (*view->item_selected)(view->selected, it);
+
+    if(view->selected)
+        view->selected->flags &= ~(IT_SELECTED);
+
+    if(it)
+        it->flags |= IT_SELECTED;
+
+    view->selected = it;
+    return 1;
+}
+
+void listview_scroll_by(listview *view, int y)
+{
+    if(!y || !view->scroll_mark)
+        return;
+
+    view->pos += y;
+
+    if(view->pos < -OVERSCROLL_H)
+        view->pos = -OVERSCROLL_H;
+    else if(view->pos > (view->fullH - view->h) + OVERSCROLL_H)
+        view->pos = (view->fullH - view->h) + OVERSCROLL_H;
+
+    listview_select_item(view, NULL);
+    listview_update_ui(view);
+}
+
+void listview_scroll_to(listview *view, int pct)
+{
+    if(!view->scroll_mark)
+        return;
+
+    view->pos = ((view->fullH - view->h)*pct)/100;
+
+    if(view->pos < 0)
+        view->pos = 0;
+    else if(view->pos > (view->fullH - view->h))
+        view->pos = (view->fullH - view->h);
+
+    listview_select_item(view, NULL);
+    listview_update_ui(view);
+}
+
+int listview_ensure_visible(listview *view, listview_item *it)
+{
+    if(!view->scroll_mark)
+        return 0;
+
+    int i;
+    int y = 0;
+    for(i = 0; view->items[i]; ++i)
+    {
+        if(it == view->items[i])
+            break;
+        y += view->item_height(view->items[i]);
+    }
+
+    int last_h = view->items[i] ? view->item_height(view->items[i]) : 0;
+
+    if((y + last_h) - view->pos > view->h)
+        view->pos = (y + last_h) - view->h;
+    else if(y - view->pos < 0)
+        view->pos = y;
+    else
+        return 0;
+    return 1;
+}
+
+int listview_ensure_selected_visible(listview *view)
+{
+    if(view->selected)
+        return listview_ensure_visible(view, view->selected);
+    else
+        return 0;
+}
+
+listview_item *listview_item_at(listview *view, int y_pos)
+{
+    int y = -view->pos + view->y;
+    int i, it_h;
+    listview_item *it;
+
+    for(i = 0; view->items && view->items[i]; ++i)
+    {
+        it = view->items[i];
+        it_h = (*view->item_height)(it);
+
+        if(y < y_pos && y+it_h > y_pos)
+            return it;
+
+        y += it_h;
+    }
+    return NULL;
+}
+
+int listview_keyaction_call(void *data, int act)
+{
+    listview *v = data;
+    switch(act)
+    {
+        case KEYACT_DOWN:
+        {
+            ++v->keyact_item_selected;
+            if(v->keyact_item_selected >= list_item_count(v->items))
+                v->keyact_item_selected = -1;
+            listview_update_keyact_frame(v);
+            return (v->keyact_item_selected == -1) ? 1 :0;
+        }
+        case KEYACT_UP:
+        {
+            if(v->keyact_item_selected == -1)
+                v->keyact_item_selected = list_item_count(v->items)-1;
+            else
+                --v->keyact_item_selected;
+            listview_update_keyact_frame(v);
+            return (v->keyact_item_selected == -1) ? 1 :0;
+        }
+        case KEYACT_CLEAR:
+        {
+            if(v->keyact_item_selected != -1)
+            {
+                v->keyact_item_selected = -1;
+                listview_select_item(v, NULL);
+                listview_update_ui(v);
+                fb_request_draw();
+            }
+            return 0;
+        }
+        case KEYACT_CONFIRM:
+        {
+            if(v->item_confirmed)
+                v->item_confirmed(v->items[v->keyact_item_selected]);
+            return 0;
+        }
+        default:
+            return 0;
+    }
+}
+
+void listview_update_keyact_frame(listview *view)
+{
+    if(view->keyact_item_selected == -1)
+    {
+        if(view->selected)
+        {
+            listview_select_item(view, NULL);
+            listview_update_ui(view);
+        }
+        return;
+    }
+
+    listview_item *it = view->items[view->keyact_item_selected];
+    listview_ensure_visible(view, it);
+
+    int i;
+    int y = view->y;
+    for(i = 0; i < view->keyact_item_selected && view->items[i]; ++i)
+        y += view->item_height(view->items[i]);
+
+    int h = view->item_height(view->items[i]);
+    y -= view->pos;
+
+    listview_select_item(view, it);
+    listview_update_ui(view);
+}
+
+#define ROM_ITEM_H (110*DPI_MUL)
+#define ROM_ITEM_SHADOW (7*DPI_MUL)
+#define ROM_ITEM_SEL_W (8*DPI_MUL)
+#define ROM_ICON_H (70*DPI_MUL)
+#define ROM_TEXT_PADDING_L (120*DPI_MUL)
+#define ROM_TEXT_PADDING_R ((ROM_TEXT_PADDING_L - ROM_ICON_H)/2)
+#define ROM_ICON_PADDING (ROM_TEXT_PADDING_L/2 - ROM_ICON_H/2)
+
+typedef struct
+{
+    char *text;
+    char *partition;
+    char *icon_path;
+    fb_text *text_it;
+    fb_text *part_it;
+    fb_rect *sel_rect;
+    fb_rect *sel_rect_sh;
+    fb_img *icon;
+    int deselect_anim_started;
+    int rom_name_size;
+    int last_y;
+    int last_x;
+} rom_item_data;
+
+void *rom_item_create(const char *text, const char *partition, const char *icon)
+{
+    rom_item_data *data = mzalloc(sizeof(rom_item_data));
+
+    data->rom_name_size = SIZE_BIG;
+
+    data->text = strdup(text);
+    if(partition)
+        data->partition = strdup(partition);
+    if(icon)
+        data->icon_path = strdup(icon);
+    return data;
+}
+
+static void rom_item_deselect_finished(void *data)
+{
+    rom_item_data *d = data;
+
+    fb_rm_rect(d->sel_rect);
+    fb_rm_rect(d->sel_rect_sh);
+    d->sel_rect = NULL;
+    d->sel_rect_sh = NULL;
+}
+
+static void rom_item_sel_step(void *data, UNUSED float interpolated)
+{
+    rom_item_data *d = data;
+    if(!d->sel_rect || !d->sel_rect_sh)
+        return;
+
+    d->sel_rect_sh->x = d->sel_rect->x + ROM_ITEM_SHADOW;
+    d->sel_rect_sh->y = d->sel_rect->y + ROM_ITEM_SHADOW;
+    d->sel_rect_sh->w = d->sel_rect->w;
+    d->sel_rect_sh->h = d->sel_rect->h;
+}
+
+static void rom_item_select(int x, int y, int w, int item_h, listview_item *it, rom_item_data *d)
+{
+    int baseX = it->touchX;
+    int baseY = it->touchY;
+    if(!baseX && !baseY)
+    {
+        baseX = x + w/2;
+        baseY = y + item_h/2;
+    }
+
+    d->deselect_anim_started = 0;
+
+    d->sel_rect_sh = fb_add_rect(baseX+ROM_ITEM_SHADOW, baseY+ROM_ITEM_SHADOW, 1, 1, C_BTN_FAKE_SHADOW);
+    d->sel_rect_sh->parent = it->parent_rect;
+    d->sel_rect = fb_add_rect(baseX, baseY, 1, 1, C_ROM_HIGHLIGHT);
+    d->sel_rect->parent = it->parent_rect;
+
+    item_anim *anim = item_anim_create(d->sel_rect, 300, INTERPOLATOR_ACCEL_DECEL);
+    anim->start_offset = 0;
+    anim->targetX = x;
+    anim->targetY = y;
+    anim->targetW = w;
+    anim->targetH = item_h;
+    anim->on_step_data = d;
+    anim->on_step_call = rom_item_sel_step;
+    item_anim_add(anim);
+
+    ncard_builder *b = ncard_create_builder();
+    ncard_set_text(b, "Tap again to boot the system");
+    fb_item_pos p;
+    p.y = y;
+    p.h = item_h;
+    ncard_avoid_item(b, &p);
+    ncard_show(b, 1);
+}
+
+static void rom_item_deselect(int x, int y, int w, int item_h, listview_item *it, rom_item_data *d)
+{
+    d->deselect_anim_started = 1;
+
+    if(!((listview*)it->parent_rect)->selected)
+        ncard_hide();
+
+    item_anim *anim = item_anim_create(d->sel_rect, 150, INTERPOLATOR_ACCELERATE);
+    if(it->touchX || it->touchY)
+    {
+        anim->targetX = it->touchX;
+        anim->targetY = it->touchY;
+    }
+    else
+    {
+        anim->targetX = x + w/2;
+        anim->targetY = y + item_h/2;
+    }
+    anim->targetW = 0;
+    anim->targetH = 0;
+    anim->on_step_data = d;
+    anim->on_step_call = rom_item_sel_step;
+    anim->on_finished_data = d;
+    anim->on_finished_call = rom_item_deselect_finished;
+    item_anim_add_after(anim);
+}
+
+void rom_item_draw(int x, int y, int w, listview_item *it)
+{
+    rom_item_data *d = (rom_item_data*)it->data;
+    const int item_h = rom_item_height(it);
+    if(!d->text_it)
+    {
+        d->last_x = x;
+        d->last_y = y;
+
+        fb_text_proto *p = fb_text_create(x+ROM_TEXT_PADDING_L, 0, C_TEXT, d->rom_name_size, d->text);
+        p->style = STYLE_CONDENSED;
+        d->text_it = fb_text_finalize(p);
+        d->text_it->parent = it->parent_rect;
+
+        while((d->text_it->w + ROM_TEXT_PADDING_L) >= (w - ROM_TEXT_PADDING_R) && d->rom_name_size > 3)
+            fb_text_set_size(d->text_it, --d->rom_name_size);
+
+        if(d->icon_path)
+        {
+            d->icon = fb_add_png_img(x+ROM_ICON_PADDING, 0, ROM_ICON_H, ROM_ICON_H, d->icon_path);
+            d->icon->parent = it->parent_rect;
+        }
+
+        if(d->partition)
+        {
+            d->part_it = fb_add_text(x+ROM_TEXT_PADDING_L, 0, C_TEXT_SECONDARY, SIZE_SMALL, d->partition);
+            d->part_it->parent = it->parent_rect;
+        }
+    }
+
+    if(!d->part_it)
+        center_text(d->text_it, -1, y, -1, item_h);
+    else
+    {
+        d->text_it->y = y + (item_h/2 - (d->text_it->h + d->part_it->h + 4*DPI_MUL)/2);
+        d->part_it->y = d->text_it->y + d->text_it->h + 4*DPI_MUL;
+        d->part_it->x += x - d->last_x;
+    }
+
+    d->text_it->x += x - d->last_x;
+
+    if(d->icon)
+    {
+        d->icon->x += x - d->last_x;
+        d->icon->y = y + (item_h/2 - ROM_ICON_H/2);
+    }
+
+    if(it->flags & IT_SELECTED)
+    {
+        if(!d->sel_rect)
+        {
+            rom_item_select(x, y, w, item_h, it, d);
+        }
+        else
+        {
+            d->sel_rect_sh->x += x - d->last_x;
+            d->sel_rect->x += x - d->last_x;
+            d->sel_rect_sh->y += y - d->last_y;
+            d->sel_rect->y += y - d->last_y;
+        }
+    }
+    else if(d->sel_rect)
+    {
+        if(!d->deselect_anim_started)
+        {
+            rom_item_deselect(x, y, w, item_h, it, d);
+        }
+        else
+        {
+            d->sel_rect_sh->x += x - d->last_x;
+            d->sel_rect->x += x - d->last_x;
+            d->sel_rect_sh->y += y - d->last_y;
+            d->sel_rect->y += y - d->last_y;
+        }
+    }
+
+    d->last_x = x;
+    d->last_y = y;
+}
+
+void rom_item_hide(void *data)
+{
+    rom_item_data *d = (rom_item_data*)data;
+    if(!d->text_it)
+        return;
+
+    fb_rm_text(d->text_it);
+    fb_rm_text(d->part_it);
+    fb_rm_rect(d->sel_rect);
+    fb_rm_rect(d->sel_rect_sh);
+    fb_rm_img(d->icon);
+
+    d->text_it = NULL;
+    d->part_it = NULL;
+    d->sel_rect = NULL;
+    d->sel_rect_sh = NULL;
+    d->icon = NULL;
+}
+
+int rom_item_height(UNUSED listview_item *it)
+{
+    return ROM_ITEM_H;
+}
+
+void rom_item_destroy(listview_item *it)
+{
+    rom_item_hide(it->data);
+    rom_item_data *d = (rom_item_data*)it->data;
+    free(d->text);
+    free(d->partition);
+    free(d->icon_path);
+    free(it->data);
+    free(it);
+}
diff --git a/lib/listview.h b/lib/listview.h
index ef57411..078e33e 100755
--- a/lib/listview.h
+++ b/lib/listview.h
@@ -1,104 +1,104 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef LISTVIEW_H
-#define LISTVIEW_H
-
-#include "input.h"
-#include "framebuffer.h"
-#include "touch_tracker.h"
-
-enum
-{
-    IT_VISIBLE  = 0x01,
-    IT_HOVER    = 0x02,
-    IT_SELECTED = 0x04,
-};
-
-typedef struct
-{
-    int id;
-    void *data;
-    int flags;
-    fb_item_pos *parent_rect;
-    int touchX, touchY;
-} listview_item;
-
-typedef struct 
-{
-    int id;
-    listview_item *hover;
-    int fast_scroll;
-} listview_touch_data;
-
-typedef struct
-{
-    FB_ITEM_HEAD
-
-    fb_item_pos last_rendered_pos;
-
-    int pos; // scroll pos
-    int fullH; // height of all items
-
-    listview_item **items;
-    listview_item *selected;
-
-    void (*item_draw)(int, int, int, listview_item *); // x, y, w, item
-    void (*item_hide)(void*); // data
-    int (*item_height)(listview_item *); // item
-
-    void (*item_destroy)(listview_item *);
-    void (*item_selected)(listview_item *, listview_item *); // prev, now
-    void (*item_confirmed)(listview_item *); // item - confirmed by keyaction
-
-    fb_item_header **ui_items;
-    fb_rect *scroll_mark;
-    fb_rect *overscroll_marks[2];
-    fb_rect *scroll_line;
-    int keyact_item_selected;
-
-    listview_touch_data touch;
-    touch_tracker *tracker;
-} listview;
-
-int listview_touch_handler(touch_event *ev, void *data);
-
-void listview_init_ui(listview *view);
-void listview_destroy(listview *view);
-listview_item *listview_add_item(listview *view, int id, void *data);
-void listview_clear(listview *view);
-inline void listview_update_ui(listview *view);
-void listview_update_ui_args(listview *view, int only_if_moved, int mutex_locked);
-void listview_enable_scroll(listview *view, int enable);
-void listview_update_scroll_mark(listview *view);
-void listview_update_overscroll_mark(listview *v, int side, float overscroll);
-void listview_scroll_by(listview *view, int y);
-void listview_scroll_to(listview *view, int pct);
-int listview_ensure_visible(listview *view, listview_item *it);
-int listview_ensure_selected_visible(listview *view);
-listview_item *listview_item_at(listview *view, int y_pos);
-inline int listview_select_item(listview *view, listview_item *it);
-void listview_update_keyact_frame(listview *view);
-int listview_keyaction_call(void *data, int act);
-
-void *rom_item_create(const char *text, const char *partition, const char *icon);
-void rom_item_draw(int x, int y, int w, listview_item *it);
-void rom_item_hide(void *data);
-int rom_item_height(listview_item *it);
-void rom_item_destroy(listview_item *it);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef LISTVIEW_H
+#define LISTVIEW_H
+
+#include "input.h"
+#include "framebuffer.h"
+#include "touch_tracker.h"
+
+enum
+{
+    IT_VISIBLE  = 0x01,
+    IT_HOVER    = 0x02,
+    IT_SELECTED = 0x04,
+};
+
+typedef struct
+{
+    int id;
+    void *data;
+    int flags;
+    fb_item_pos *parent_rect;
+    int touchX, touchY;
+} listview_item;
+
+typedef struct 
+{
+    int id;
+    listview_item *hover;
+    int fast_scroll;
+} listview_touch_data;
+
+typedef struct
+{
+    FB_ITEM_HEAD
+
+    fb_item_pos last_rendered_pos;
+
+    int pos; // scroll pos
+    int fullH; // height of all items
+
+    listview_item **items;
+    listview_item *selected;
+
+    void (*item_draw)(int, int, int, listview_item *); // x, y, w, item
+    void (*item_hide)(void*); // data
+    int (*item_height)(listview_item *); // item
+
+    void (*item_destroy)(listview_item *);
+    void (*item_selected)(listview_item *, listview_item *); // prev, now
+    void (*item_confirmed)(listview_item *); // item - confirmed by keyaction
+
+    fb_item_header **ui_items;
+    fb_rect *scroll_mark;
+    fb_rect *overscroll_marks[2];
+    fb_rect *scroll_line;
+    int keyact_item_selected;
+
+    listview_touch_data touch;
+    touch_tracker *tracker;
+} listview;
+
+int listview_touch_handler(touch_event *ev, void *data);
+
+void listview_init_ui(listview *view);
+void listview_destroy(listview *view);
+listview_item *listview_add_item(listview *view, int id, void *data);
+void listview_clear(listview *view);
+inline void listview_update_ui(listview *view);
+void listview_update_ui_args(listview *view, int only_if_moved, int mutex_locked);
+void listview_enable_scroll(listview *view, int enable);
+void listview_update_scroll_mark(listview *view);
+void listview_update_overscroll_mark(listview *v, int side, float overscroll);
+void listview_scroll_by(listview *view, int y);
+void listview_scroll_to(listview *view, int pct);
+int listview_ensure_visible(listview *view, listview_item *it);
+int listview_ensure_selected_visible(listview *view);
+listview_item *listview_item_at(listview *view, int y_pos);
+inline int listview_select_item(listview *view, listview_item *it);
+void listview_update_keyact_frame(listview *view);
+int listview_keyaction_call(void *data, int act);
+
+void *rom_item_create(const char *text, const char *partition, const char *icon);
+void rom_item_draw(int x, int y, int w, listview_item *it);
+void rom_item_hide(void *data);
+int rom_item_height(listview_item *it);
+void rom_item_destroy(listview_item *it);
+
+#endif
diff --git a/lib/log.h b/lib/log.h
index 32594a7..3686b37 100755
--- a/lib/log.h
+++ b/lib/log.h
@@ -1,33 +1,33 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _INIT_LOG_H_
-#define _INIT_LOG_H_
-
-#include "mrom_data.h"
-
-#ifdef LOG_TO_STDOUT
-  #include <stdio.h>
-  #define ERROR(fmt, ...) fprintf(stderr, "%s: " fmt "\n", mrom_log_tag(), ##__VA_ARGS__)
-  #define INFO(fmt, ...) printf("%s: " fmt "\n", mrom_log_tag(),  ##__VA_ARGS__)
-#else
-  #include <cutils/klog.h>
-
-  #define ERROR(fmt, ...) klog_write(3, "<3>%s: " fmt, mrom_log_tag(), ##__VA_ARGS__)
-  #define INFO(fmt, ...) klog_write(6, "<6>%s: " fmt, mrom_log_tag(), ##__VA_ARGS__)
-#endif
-
-#endif
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_LOG_H_
+#define _INIT_LOG_H_
+
+#include "mrom_data.h"
+
+#ifdef LOG_TO_STDOUT
+  #include <stdio.h>
+  #define ERROR(fmt, ...) fprintf(stderr, "%s: " fmt "\n", mrom_log_tag(), ##__VA_ARGS__)
+  #define INFO(fmt, ...) printf("%s: " fmt "\n", mrom_log_tag(),  ##__VA_ARGS__)
+#else
+  #include <cutils/klog.h>
+
+  #define ERROR(fmt, ...) klog_write(3, "<3>%s: " fmt, mrom_log_tag(), ##__VA_ARGS__)
+  #define INFO(fmt, ...) klog_write(6, "<6>%s: " fmt, mrom_log_tag(), ##__VA_ARGS__)
+#endif
+
+#endif
diff --git a/lib/log.h.bak b/lib/log.h.bak
index 32594a7..3686b37 100755
--- a/lib/log.h.bak
+++ b/lib/log.h.bak
@@ -1,33 +1,33 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _INIT_LOG_H_
-#define _INIT_LOG_H_
-
-#include "mrom_data.h"
-
-#ifdef LOG_TO_STDOUT
-  #include <stdio.h>
-  #define ERROR(fmt, ...) fprintf(stderr, "%s: " fmt "\n", mrom_log_tag(), ##__VA_ARGS__)
-  #define INFO(fmt, ...) printf("%s: " fmt "\n", mrom_log_tag(),  ##__VA_ARGS__)
-#else
-  #include <cutils/klog.h>
-
-  #define ERROR(fmt, ...) klog_write(3, "<3>%s: " fmt, mrom_log_tag(), ##__VA_ARGS__)
-  #define INFO(fmt, ...) klog_write(6, "<6>%s: " fmt, mrom_log_tag(), ##__VA_ARGS__)
-#endif
-
-#endif
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_LOG_H_
+#define _INIT_LOG_H_
+
+#include "mrom_data.h"
+
+#ifdef LOG_TO_STDOUT
+  #include <stdio.h>
+  #define ERROR(fmt, ...) fprintf(stderr, "%s: " fmt "\n", mrom_log_tag(), ##__VA_ARGS__)
+  #define INFO(fmt, ...) printf("%s: " fmt "\n", mrom_log_tag(),  ##__VA_ARGS__)
+#else
+  #include <cutils/klog.h>
+
+  #define ERROR(fmt, ...) klog_write(3, "<3>%s: " fmt, mrom_log_tag(), ##__VA_ARGS__)
+  #define INFO(fmt, ...) klog_write(6, "<6>%s: " fmt, mrom_log_tag(), ##__VA_ARGS__)
+#endif
+
+#endif
diff --git a/lib/mrom_data.c b/lib/mrom_data.c
index 4dc2109..f73977e 100755
--- a/lib/mrom_data.c
+++ b/lib/mrom_data.c
@@ -1,90 +1,90 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <string.h>
-#include <stdio.h>
-
-#include "mrom_data.h"
-
-static char multirom_dir[128] = { 0 };
-static char log_tag[64] = { 0 };
-
-void mrom_set_dir(const char *mrom_dir)
-{
-    snprintf(multirom_dir, sizeof(multirom_dir), "%s", mrom_dir);
-}
-
-void mrom_set_log_tag(const char *tag)
-{
-    snprintf(log_tag, sizeof(log_tag), "%s", tag);
-}
-
-const char *mrom_log_tag(void)
-{
-    return log_tag;
-}
-
-const char *mrom_dir(void)
-{
-    return multirom_dir;
-}
-
-int mrom_is_second_boot(void)
-{
-    int i;
-    int res = 0;
-    FILE *f = NULL;
-    char buff[2048];
-
-    static const char *kmsg_paths[] = {
-        "/proc/last_kmsg",
-        "/sys/fs/pstore/console-ramoops",
-        NULL,
-    };
-
-    f = fopen("/proc/cmdline", "re");
-    if(f)
-    {
-        if(fgets(buff, sizeof(buff), f) && strstr(buff, "mrom_kexecd=1"))
-        {
-            res = 1;
-            goto exit;
-        }
-
-        fclose(f);
-        f = NULL;
-    }
-
-    for(i = 0; !f && kmsg_paths[i]; ++i)
-        f = fopen(kmsg_paths[i], "re");
-
-    if(!f)
-        return 0;
-
-    while(fgets(buff, sizeof(buff), f))
-    {
-        if(strstr(buff, SECOND_BOOT_KMESG))
-        {
-            res = 1;
-            goto exit;
-        }
-    }
-
-exit:
-    fclose(f);
-    return res;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+#include <stdio.h>
+
+#include "mrom_data.h"
+
+static char multirom_dir[128] = { 0 };
+static char log_tag[64] = { 0 };
+
+void mrom_set_dir(const char *mrom_dir)
+{
+    snprintf(multirom_dir, sizeof(multirom_dir), "%s", mrom_dir);
+}
+
+void mrom_set_log_tag(const char *tag)
+{
+    snprintf(log_tag, sizeof(log_tag), "%s", tag);
+}
+
+const char *mrom_log_tag(void)
+{
+    return log_tag;
+}
+
+const char *mrom_dir(void)
+{
+    return multirom_dir;
+}
+
+int mrom_is_second_boot(void)
+{
+    int i;
+    int res = 0;
+    FILE *f = NULL;
+    char buff[2048];
+
+    static const char *kmsg_paths[] = {
+        "/proc/last_kmsg",
+        "/sys/fs/pstore/console-ramoops",
+        NULL,
+    };
+
+    f = fopen("/proc/cmdline", "re");
+    if(f)
+    {
+        if(fgets(buff, sizeof(buff), f) && strstr(buff, "mrom_kexecd=1"))
+        {
+            res = 1;
+            goto exit;
+        }
+
+        fclose(f);
+        f = NULL;
+    }
+
+    for(i = 0; !f && kmsg_paths[i]; ++i)
+        f = fopen(kmsg_paths[i], "re");
+
+    if(!f)
+        return 0;
+
+    while(fgets(buff, sizeof(buff), f))
+    {
+        if(strstr(buff, SECOND_BOOT_KMESG))
+        {
+            res = 1;
+            goto exit;
+        }
+    }
+
+exit:
+    fclose(f);
+    return res;
+}
diff --git a/lib/mrom_data.h b/lib/mrom_data.h
index 7e3dff9..fb09e77 100755
--- a/lib/mrom_data.h
+++ b/lib/mrom_data.h
@@ -1,30 +1,30 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MROM_DATA_H
-#define MROM_DATA_H
-
-#define SECOND_BOOT_KMESG "MultiromSaysNextBootShouldBeSecondMagic108\n"
-
-void mrom_set_dir(const char *mrom_dir);
-void mrom_set_log_tag(const char *tag);
-
-const char *mrom_log_tag(void);
-const char *mrom_dir(void);
-int mrom_is_second_boot(void);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MROM_DATA_H
+#define MROM_DATA_H
+
+#define SECOND_BOOT_KMESG "MultiromSaysNextBootShouldBeSecondMagic108\n"
+
+void mrom_set_dir(const char *mrom_dir);
+void mrom_set_log_tag(const char *tag);
+
+const char *mrom_log_tag(void);
+const char *mrom_dir(void);
+int mrom_is_second_boot(void);
+
+#endif
diff --git a/lib/notification_card.c b/lib/notification_card.c
index ff41a7a..0610a1c 100755
--- a/lib/notification_card.c
+++ b/lib/notification_card.c
@@ -1,571 +1,571 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <pthread.h>
-
-#include <string.h>
-#include <malloc.h>
-
-#include "util.h"
-#include "animation.h"
-#include "framebuffer.h"
-#include "notification_card.h"
-#include "containers.h"
-#include "log.h"
-#include "input.h"
-#include "colors.h"
-
-enum
-{
-    LEVEL_NCARD_SHADOW = 49,
-    LEVEL_NCARD_BG = 50,
-    LEVEL_NCARD_BTN_HOVER = 55,
-    LEVEL_NCARD_TEXT = 60,
-
-    LEVEL_NCARD_CENTER_OFFSET = 1000,
-};
-
-#define CARD_PADDING_H (40*DPI_MUL)
-#define CARD_PADDING_V (30*DPI_MUL)
-#define CARD_MARGIN  (40*DPI_MUL)
-#define CARD_WIDTH (fb_width - CARD_MARGIN*2)
-#define CARD_SHADOW_OFF (7*DPI_MUL)
-
-ncard_builder *ncard_create_builder(void)
-{
-    return mzalloc(sizeof(ncard_builder));
-}
-
-void ncard_set_title(ncard_builder *b, const char *title)
-{
-    b->title = realloc(b->title, strlen(title)+1);
-    strcpy(b->title, title);
-}
-
-void ncard_set_text(ncard_builder *b, const char *text)
-{
-    b->text = realloc(b->text, strlen(text)+1);
-    strcpy(b->text, text);
-}
-
-void ncard_set_pos(ncard_builder *b, int pos)
-{
-    b->pos = pos;
-}
-
-void ncard_set_cancelable(ncard_builder *b, int cancelable)
-{
-    b->cancelable = cancelable;
-}
-
-void ncard_avoid_item(ncard_builder *b, void *item)
-{
-    fb_item_pos *it = item;
-    b->avoid_item = mzalloc(sizeof(fb_item_pos));
-    b->avoid_item->x = it->x;
-    b->avoid_item->y = it->y;
-    b->avoid_item->w = it->w;
-    b->avoid_item->h = it->h;
-}
-
-void ncard_add_btn(ncard_builder *b, int btn_type, const char *text, ncard_callback callback, void *callback_data)
-{
-    if(b->buttons[btn_type])
-    {
-        free(b->buttons[btn_type]->text);
-        free(b->buttons[btn_type]);
-    }
-
-    ncard_builder_btn *btn = mzalloc(sizeof(ncard_builder_btn));
-    btn->text = strtoupper(text);
-    btn->callback_data = callback_data;
-    btn->callback = callback;
-    b->buttons[btn_type] = btn;
-}
-
-void ncard_set_on_hidden(ncard_builder *b, ncard_callback callback, void *data)
-{
-    b->on_hidden_call = callback;
-    b->on_hidden_data = data;
-}
-
-void ncard_set_from_black(ncard_builder *b, int from_black)
-{
-    b->reveal_from_black = from_black;
-}
-
-static int ncard_calc_pos(ncard_builder* b, int max_y)
-{
-    if(b->pos == NCARD_POS_AUTO)
-    {
-        if(!b->avoid_item)
-            return NCARD_POS_TOP;
-        if(b->avoid_item->y > max_y)
-            return NCARD_POS_TOP;
-        return NCARD_POS_BOTTOM;
-    }
-    else
-        return b->pos;
-}
-
-struct ncard_btn
-{
-    fb_item_pos pos;
-    void *callback_data;
-    ncard_callback callback;
-};
-
-struct ncard
-{
-    fb_rect *bg;
-    fb_rect *shadow;
-    fb_rect *alpha_bg;
-    fb_text **texts;
-    fb_rect *hover_rect;
-    struct ncard_btn btns[BTN_COUNT];
-    int active_btns;
-    int pos;
-    int targetH;
-    int top_offset;
-    int last_y;
-    int hiding;
-    int touch_handler_registered;
-    int touch_id;
-    int hover_btn;
-    int cancelable;
-    ncard_callback on_hidden_call;
-    void *on_hidden_data;
-    int reveal_from_black;
-    pthread_mutex_t mutex;
-} ncard = {
-    .bg = NULL,
-    .shadow = NULL,
-    .texts = NULL,
-    .active_btns = 0,
-    .top_offset = 0,
-    .hiding = 0,
-    .hover_rect = NULL,
-    .touch_handler_registered = 0,
-    .touch_id = -1,
-    .hover_btn = 0,
-    .cancelable = 0,
-    .on_hidden_call = NULL,
-    .on_hidden_data = NULL,
-    .reveal_from_black = 0,
-    .mutex = PTHREAD_MUTEX_INITIALIZER,
-};
-
-static int ncard_touch_handler(touch_event *ev, void *data)
-{
-    struct ncard *c = data;
-
-    pthread_mutex_lock(&c->mutex);
-
-    if(c->touch_id == -1 && (ev->changed & TCHNG_ADDED))
-    {
-        int i;
-        for(i = 0; i < BTN_COUNT; ++i)
-        {
-            if(!(c->active_btns & (1 << i)))
-                continue;
-
-            if(in_rect(ev->x, ev->y, c->btns[i].pos.x, c->btns[i].pos.y, c->btns[i].pos.w, c->btns[i].pos.h))
-            {
-                fb_rm_rect(c->hover_rect);
-                int level = LEVEL_NCARD_BTN_HOVER;
-                if(c->pos == NCARD_POS_CENTER)
-                    level += LEVEL_NCARD_CENTER_OFFSET;
-                c->hover_rect = fb_add_rect_lvl(level, c->btns[i].pos.x, c->btns[i].pos.y, c->btns[i].pos.w, c->btns[i].pos.h, C_NCARD_SHADOW);
-
-                c->touch_id = ev->id;
-                c->hover_btn = i;
-                break;
-            }
-        }
-    }
-
-    if(c->touch_id != ev->id)
-    {
-        if(c->cancelable)
-        {
-            pthread_mutex_unlock(&c->mutex);
-            ncard_hide();
-            return 0;
-        }
-        else
-        {
-            pthread_mutex_unlock(&c->mutex);
-            return c->pos == NCARD_POS_CENTER ? 0 : -1;
-        }
-    }
-
-    if(ev->changed & TCHNG_REMOVED)
-    {
-        struct ncard_btn *b = &c->btns[c->hover_btn];
-        if(b->callback && in_rect(ev->x, ev->y, b->pos.x, b->pos.y, b->pos.w, b->pos.h))
-        {
-            ncard_callback call = b->callback;
-            void *call_data = b->callback_data;
-            pthread_mutex_unlock(&c->mutex);
-            call(call_data);
-            pthread_mutex_lock(&c->mutex);
-        }
-        else
-        {
-            fb_rm_rect(c->hover_rect);
-            c->hover_rect = NULL;
-        }
-        c->touch_id = -1;
-    }
-
-    pthread_mutex_unlock(&c->mutex);
-    return 0;
-}
-
-static void ncard_move_step(void *data, float interpolated)
-{
-    int i;
-    struct ncard *c = data;
-
-    pthread_mutex_lock(&c->mutex);
-
-    const int diff = c->bg->y - c->last_y;
-
-    for(i = 0; c->texts && c->texts[i]; ++i)
-        c->texts[i]->y += diff;
-
-    for(i = 0; i < BTN_COUNT; ++i)
-    {
-        if(!(c->active_btns & (1 << i)))
-            continue;
-        c->btns[i].pos.y += diff;
-    }
-
-    c->shadow->y += diff;
-    c->shadow->h = c->bg->h;
-    if(c->hover_rect)
-        c->hover_rect->y += diff;
-    c->last_y = c->bg->y;
-
-    if(c->alpha_bg && (c->hiding || (c->alpha_bg->color & (0xFF << 24)) != 0xCC000000))
-    {
-        if(interpolated > 1.f)
-            interpolated = 1.f;
-        if(c->hiding)
-            interpolated = 1.f - interpolated;
-
-        if(!c->hiding && c->reveal_from_black)
-            c->alpha_bg->color = (c->alpha_bg->color & ~(0xFF << 24)) | ((0xFF - (int)(0x33*interpolated)) << 24);
-        else
-            c->alpha_bg->color = (c->alpha_bg->color & ~(0xFF << 24)) | (((int)(0xCC*interpolated)) << 24);
-    }
-
-    pthread_mutex_unlock(&c->mutex);
-
-    fb_request_draw();
-}
-
-static void ncard_reveal_finished(UNUSED void *data)
-{
-    pthread_mutex_lock(&ncard.mutex);
-    ncard.bg->h = ncard.targetH;
-    ncard.shadow->h = ncard.targetH;
-    pthread_mutex_unlock(&ncard.mutex);
-}
-
-static void ncard_hide_finished(void *data)
-{
-    struct ncard *c = data;
-    list_clear(&c->texts, fb_remove_item);
-    fb_rm_rect(c->shadow);
-    fb_rm_rect(c->alpha_bg);
-    fb_rm_rect(c->hover_rect);
-    free(c);
-}
-
-void ncard_set_top_offset(int top_offset)
-{
-    pthread_mutex_lock(&ncard.mutex);
-    ncard.top_offset = top_offset;
-    pthread_mutex_unlock(&ncard.mutex);
-}
-
-void ncard_show(ncard_builder *b, int destroy_builder)
-{
-    int i, items_h, btn_x, btn_h, has_btn = 0, it_y = 0, lvl_offset = 0;
-    fb_text *title = 0, *text = 0, *btns[BTN_COUNT];
-    int interpolator;
-
-    pthread_mutex_lock(&ncard.mutex);
-
-    if(ncard.bg)
-        anim_cancel_for(ncard.bg, 0);
-
-    if(b->pos == NCARD_POS_CENTER)
-        lvl_offset = LEVEL_NCARD_CENTER_OFFSET;
-
-    items_h = CARD_PADDING_V*2;
-    if(b->title)
-    {
-        fb_text_proto *p = fb_text_create(CARD_MARGIN + CARD_PADDING_H, fb_height, C_NCARD_TEXT, SIZE_EXTRA, b->title);
-        p->level = LEVEL_NCARD_TEXT + lvl_offset;
-        p->style = STYLE_MEDIUM;
-        p->wrap_w = CARD_WIDTH - CARD_PADDING_H*2;
-        title = fb_text_finalize(p);
-        items_h += title->h;
-    }
-
-    if(b->text)
-    {
-        fb_text_proto *p = fb_text_create(CARD_MARGIN + CARD_PADDING_H, fb_height, C_NCARD_TEXT_SECONDARY, SIZE_NORMAL, b->text);\
-        p->level = LEVEL_NCARD_TEXT + lvl_offset;
-        p->wrap_w = CARD_WIDTH - CARD_PADDING_H*2;
-        if(!title)
-        {
-            p->style = STYLE_ITALIC;
-            p->justify = JUSTIFY_CENTER;
-        }
-        text = fb_text_finalize(p);
-        items_h += text->h;
-    }
-
-    if(title && text)
-        items_h += title->h;
-
-    ncard.active_btns = 0;
-    btn_x = CARD_MARGIN + CARD_WIDTH - CARD_PADDING_H;
-    btn_h = 0;
-    for(i = 0; i < BTN_COUNT; ++i)
-    {
-        if(!b->buttons[i])
-            continue;
-
-        ncard.active_btns |= (1 << i);
-
-        fb_text_proto *p = fb_text_create(btn_x, fb_height, C_NCARD_TEXT, SIZE_NORMAL, b->buttons[i]->text);
-        p->level = LEVEL_NCARD_TEXT + lvl_offset;
-        p->style = STYLE_MEDIUM;
-        fb_text *t = fb_text_finalize(p);
-        t->x -= t->w;
-        btn_x -= t->w + t->h*2;
-        btn_h = imax(t->h*2, btn_h);
-        btns[i] = t;
-
-        ncard.btns[i].callback_data = b->buttons[i]->callback_data;
-        ncard.btns[i].callback = b->buttons[i]->callback;
-        ncard.btns[i].pos.w = t->w + t->h*2;
-        ncard.btns[i].pos.h = t->h*3;
-        ncard.btns[i].pos.x = btn_x + t->h;
-    }
-
-    items_h += btn_h*1.25;
-
-    int new_pos = ncard_calc_pos(b, ncard.top_offset + items_h + CARD_MARGIN);
-
-    if(new_pos != ncard.pos && ncard.bg)
-    {
-        pthread_mutex_unlock(&ncard.mutex);
-        ncard_hide();
-        pthread_mutex_lock(&ncard.mutex);
-    }
-
-    ncard.pos = new_pos;
-
-    list_clear(&ncard.texts, fb_remove_item);
-    fb_rm_rect(ncard.hover_rect);
-    ncard.hover_rect = NULL;
-
-    if(!ncard.bg)
-    {
-        ncard.bg = fb_add_rect_lvl(LEVEL_NCARD_BG + lvl_offset, CARD_MARGIN, 0, CARD_WIDTH, items_h, C_NCARD_BG);
-        ncard.bg->y = ncard.pos == NCARD_POS_BOTTOM ? (int)fb_height : -items_h;
-        ncard.shadow = fb_add_rect_lvl(LEVEL_NCARD_SHADOW + lvl_offset, CARD_MARGIN + CARD_SHADOW_OFF, 0, CARD_WIDTH, items_h, C_NCARD_SHADOW);
-        interpolator = INTERPOLATOR_OVERSHOOT;
-    }
-    else
-        interpolator = INTERPOLATOR_ACCEL_DECEL;
-
-    ncard.targetH = items_h;
-    if(ncard.pos != NCARD_POS_CENTER)
-        ncard.targetH *= 1.3;
-    else if(!ncard.alpha_bg)
-    {
-        ncard.alpha_bg = fb_add_rect_lvl(LEVEL_NCARD_SHADOW + lvl_offset - 1, 0, 0, fb_width, fb_height,
-                b->reveal_from_black ? BLACK : 0x00000000);
-    }
-
-    if(items_h >= ncard.bg->h)
-    {
-        ncard.bg->h = ncard.targetH;
-        ncard.shadow->h = ncard.bg->h;
-    }
-
-    it_y = ncard.bg->y + CARD_PADDING_V;
-    if(ncard.pos == NCARD_POS_TOP)
-        it_y += ncard.bg->h - items_h;
-
-    if(title)
-    {
-        title->y = it_y;
-        it_y += title->h*1.5;
-        list_add(&ncard.texts, title);
-    }
-
-    if(text)
-    {
-        text->y = it_y;
-        it_y += text->h + btn_h*0.75;
-        if(!title)
-            center_text(text, 0, -1, fb_width, -1);
-        list_add(&ncard.texts, text);
-    }
-
-    for(i = 0; i < BTN_COUNT; ++i)
-    {
-        if(!(ncard.active_btns & (1 << i)))
-            continue;
-        btns[i]->y = it_y;
-        ncard.btns[i].pos.y = it_y - ncard.btns[i].pos.h/3;
-        list_add(&ncard.texts, btns[i]);
-    }
-
-    if(ncard.active_btns && !ncard.touch_handler_registered)
-    {
-        add_touch_handler_async(ncard_touch_handler, &ncard);
-        ncard.touch_handler_registered = 1;
-    }
-    else if(!ncard.active_btns && ncard.touch_handler_registered)
-    {
-        rm_touch_handler_async(ncard_touch_handler, &ncard);
-        ncard.touch_handler_registered = 0;
-    }
-
-    ncard.shadow->y = ncard.pos == NCARD_POS_BOTTOM ? ncard.bg->y - CARD_SHADOW_OFF : ncard.bg->y + CARD_SHADOW_OFF;
-
-    ncard.last_y = ncard.bg->y;
-    ncard.cancelable = b->cancelable;
-    ncard.on_hidden_call = b->on_hidden_call;
-    ncard.on_hidden_data = b->on_hidden_data;
-    ncard.reveal_from_black = b->reveal_from_black;
-
-    item_anim *a = item_anim_create(ncard.bg, 400, interpolator);
-    switch(ncard.pos)
-    {
-        case NCARD_POS_TOP:
-            a->targetY = ncard.top_offset - (ncard.bg->h - items_h);
-            break;
-        case NCARD_POS_BOTTOM:
-            a->targetY = fb_height - items_h;
-            break;
-        case NCARD_POS_CENTER:
-            a->targetY = fb_height/2 - items_h/2;
-            break;
-    }
-    a->targetH = ncard.targetH;
-    a->on_step_call = ncard_move_step;
-    a->on_step_data = &ncard;
-    a->on_finished_call = ncard_reveal_finished;
-    item_anim_add(a);
-
-    pthread_mutex_unlock(&ncard.mutex);
-
-    if(destroy_builder)
-        ncard_destroy_builder(b);
-}
-
-void ncard_hide(void)
-{
-    if(!ncard.bg)
-        return;
-
-    anim_cancel_for(ncard.bg, 0);
-
-    struct ncard *c = mzalloc(sizeof(struct ncard));
-    pthread_mutex_lock(&ncard.mutex);
-    c->bg = ncard.bg;
-    c->shadow = ncard.shadow;
-    c->hover_rect = ncard.hover_rect;
-    c->texts = ncard.texts;
-    c->last_y = c->bg->y;
-    c->alpha_bg = ncard.alpha_bg;
-    c->hiding = 1;
-    ncard.shadow = NULL;
-    ncard.hover_rect = NULL;
-    ncard.bg = NULL;
-    ncard.texts = NULL;
-    ncard.alpha_bg = NULL;
-
-    if(ncard.touch_handler_registered)
-    {
-        rm_touch_handler(ncard_touch_handler, &ncard);
-        ncard.touch_handler_registered = 0;
-    }
-
-    pthread_mutex_unlock(&ncard.mutex);
-
-    item_anim *a = item_anim_create(c->bg, 400, INTERPOLATOR_ACCELERATE);
-    a->targetY = ncard.pos == NCARD_POS_TOP ? -c->bg->h : (int)fb_height + c->bg->h;
-    a->destroy_item_when_finished = 1;
-    a->on_step_call = ncard_move_step;
-    a->on_step_data = c;
-    a->on_finished_call = ncard_hide_finished;
-    a->on_finished_data = c;
-    item_anim_add(a);
-
-    if(ncard.on_hidden_call)
-        ncard.on_hidden_call(ncard.on_hidden_data);
-}
-
-void ncard_hide_callback(UNUSED void *data)
-{
-    ncard_hide();
-}
-
-void ncard_destroy_builder(ncard_builder *b)
-{
-    free(b->title);
-    free(b->text);
-    free(b->avoid_item);
-
-    int i;
-    for(i = 0; i < BTN_COUNT; ++i)
-    {
-        if(b->buttons[i])
-        {
-            free(b->buttons[i]->text);
-            free(b->buttons[i]);
-        }
-    }
-    free(b);
-}
-
-int ncard_try_cancel(void)
-{
-    if(ncard.bg && ncard.cancelable)
-    {
-        ncard_hide();
-        return 1;
-    }
-    return 0;
-}
-
-int ncard_is_visible(void)
-{
-    return ncard.bg != NULL;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include <string.h>
+#include <malloc.h>
+
+#include "util.h"
+#include "animation.h"
+#include "framebuffer.h"
+#include "notification_card.h"
+#include "containers.h"
+#include "log.h"
+#include "input.h"
+#include "colors.h"
+
+enum
+{
+    LEVEL_NCARD_SHADOW = 49,
+    LEVEL_NCARD_BG = 50,
+    LEVEL_NCARD_BTN_HOVER = 55,
+    LEVEL_NCARD_TEXT = 60,
+
+    LEVEL_NCARD_CENTER_OFFSET = 1000,
+};
+
+#define CARD_PADDING_H (40*DPI_MUL)
+#define CARD_PADDING_V (30*DPI_MUL)
+#define CARD_MARGIN  (40*DPI_MUL)
+#define CARD_WIDTH (fb_width - CARD_MARGIN*2)
+#define CARD_SHADOW_OFF (7*DPI_MUL)
+
+ncard_builder *ncard_create_builder(void)
+{
+    return mzalloc(sizeof(ncard_builder));
+}
+
+void ncard_set_title(ncard_builder *b, const char *title)
+{
+    b->title = realloc(b->title, strlen(title)+1);
+    strcpy(b->title, title);
+}
+
+void ncard_set_text(ncard_builder *b, const char *text)
+{
+    b->text = realloc(b->text, strlen(text)+1);
+    strcpy(b->text, text);
+}
+
+void ncard_set_pos(ncard_builder *b, int pos)
+{
+    b->pos = pos;
+}
+
+void ncard_set_cancelable(ncard_builder *b, int cancelable)
+{
+    b->cancelable = cancelable;
+}
+
+void ncard_avoid_item(ncard_builder *b, void *item)
+{
+    fb_item_pos *it = item;
+    b->avoid_item = mzalloc(sizeof(fb_item_pos));
+    b->avoid_item->x = it->x;
+    b->avoid_item->y = it->y;
+    b->avoid_item->w = it->w;
+    b->avoid_item->h = it->h;
+}
+
+void ncard_add_btn(ncard_builder *b, int btn_type, const char *text, ncard_callback callback, void *callback_data)
+{
+    if(b->buttons[btn_type])
+    {
+        free(b->buttons[btn_type]->text);
+        free(b->buttons[btn_type]);
+    }
+
+    ncard_builder_btn *btn = mzalloc(sizeof(ncard_builder_btn));
+    btn->text = strtoupper(text);
+    btn->callback_data = callback_data;
+    btn->callback = callback;
+    b->buttons[btn_type] = btn;
+}
+
+void ncard_set_on_hidden(ncard_builder *b, ncard_callback callback, void *data)
+{
+    b->on_hidden_call = callback;
+    b->on_hidden_data = data;
+}
+
+void ncard_set_from_black(ncard_builder *b, int from_black)
+{
+    b->reveal_from_black = from_black;
+}
+
+static int ncard_calc_pos(ncard_builder* b, int max_y)
+{
+    if(b->pos == NCARD_POS_AUTO)
+    {
+        if(!b->avoid_item)
+            return NCARD_POS_TOP;
+        if(b->avoid_item->y > max_y)
+            return NCARD_POS_TOP;
+        return NCARD_POS_BOTTOM;
+    }
+    else
+        return b->pos;
+}
+
+struct ncard_btn
+{
+    fb_item_pos pos;
+    void *callback_data;
+    ncard_callback callback;
+};
+
+struct ncard
+{
+    fb_rect *bg;
+    fb_rect *shadow;
+    fb_rect *alpha_bg;
+    fb_text **texts;
+    fb_rect *hover_rect;
+    struct ncard_btn btns[BTN_COUNT];
+    int active_btns;
+    int pos;
+    int targetH;
+    int top_offset;
+    int last_y;
+    int hiding;
+    int touch_handler_registered;
+    int touch_id;
+    int hover_btn;
+    int cancelable;
+    ncard_callback on_hidden_call;
+    void *on_hidden_data;
+    int reveal_from_black;
+    pthread_mutex_t mutex;
+} ncard = {
+    .bg = NULL,
+    .shadow = NULL,
+    .texts = NULL,
+    .active_btns = 0,
+    .top_offset = 0,
+    .hiding = 0,
+    .hover_rect = NULL,
+    .touch_handler_registered = 0,
+    .touch_id = -1,
+    .hover_btn = 0,
+    .cancelable = 0,
+    .on_hidden_call = NULL,
+    .on_hidden_data = NULL,
+    .reveal_from_black = 0,
+    .mutex = PTHREAD_MUTEX_INITIALIZER,
+};
+
+static int ncard_touch_handler(touch_event *ev, void *data)
+{
+    struct ncard *c = data;
+
+    pthread_mutex_lock(&c->mutex);
+
+    if(c->touch_id == -1 && (ev->changed & TCHNG_ADDED))
+    {
+        int i;
+        for(i = 0; i < BTN_COUNT; ++i)
+        {
+            if(!(c->active_btns & (1 << i)))
+                continue;
+
+            if(in_rect(ev->x, ev->y, c->btns[i].pos.x, c->btns[i].pos.y, c->btns[i].pos.w, c->btns[i].pos.h))
+            {
+                fb_rm_rect(c->hover_rect);
+                int level = LEVEL_NCARD_BTN_HOVER;
+                if(c->pos == NCARD_POS_CENTER)
+                    level += LEVEL_NCARD_CENTER_OFFSET;
+                c->hover_rect = fb_add_rect_lvl(level, c->btns[i].pos.x, c->btns[i].pos.y, c->btns[i].pos.w, c->btns[i].pos.h, C_NCARD_SHADOW);
+
+                c->touch_id = ev->id;
+                c->hover_btn = i;
+                break;
+            }
+        }
+    }
+
+    if(c->touch_id != ev->id)
+    {
+        if(c->cancelable)
+        {
+            pthread_mutex_unlock(&c->mutex);
+            ncard_hide();
+            return 0;
+        }
+        else
+        {
+            pthread_mutex_unlock(&c->mutex);
+            return c->pos == NCARD_POS_CENTER ? 0 : -1;
+        }
+    }
+
+    if(ev->changed & TCHNG_REMOVED)
+    {
+        struct ncard_btn *b = &c->btns[c->hover_btn];
+        if(b->callback && in_rect(ev->x, ev->y, b->pos.x, b->pos.y, b->pos.w, b->pos.h))
+        {
+            ncard_callback call = b->callback;
+            void *call_data = b->callback_data;
+            pthread_mutex_unlock(&c->mutex);
+            call(call_data);
+            pthread_mutex_lock(&c->mutex);
+        }
+        else
+        {
+            fb_rm_rect(c->hover_rect);
+            c->hover_rect = NULL;
+        }
+        c->touch_id = -1;
+    }
+
+    pthread_mutex_unlock(&c->mutex);
+    return 0;
+}
+
+static void ncard_move_step(void *data, float interpolated)
+{
+    int i;
+    struct ncard *c = data;
+
+    pthread_mutex_lock(&c->mutex);
+
+    const int diff = c->bg->y - c->last_y;
+
+    for(i = 0; c->texts && c->texts[i]; ++i)
+        c->texts[i]->y += diff;
+
+    for(i = 0; i < BTN_COUNT; ++i)
+    {
+        if(!(c->active_btns & (1 << i)))
+            continue;
+        c->btns[i].pos.y += diff;
+    }
+
+    c->shadow->y += diff;
+    c->shadow->h = c->bg->h;
+    if(c->hover_rect)
+        c->hover_rect->y += diff;
+    c->last_y = c->bg->y;
+
+    if(c->alpha_bg && (c->hiding || (c->alpha_bg->color & (0xFF << 24)) != 0xCC000000))
+    {
+        if(interpolated > 1.f)
+            interpolated = 1.f;
+        if(c->hiding)
+            interpolated = 1.f - interpolated;
+
+        if(!c->hiding && c->reveal_from_black)
+            c->alpha_bg->color = (c->alpha_bg->color & ~(0xFF << 24)) | ((0xFF - (int)(0x33*interpolated)) << 24);
+        else
+            c->alpha_bg->color = (c->alpha_bg->color & ~(0xFF << 24)) | (((int)(0xCC*interpolated)) << 24);
+    }
+
+    pthread_mutex_unlock(&c->mutex);
+
+    fb_request_draw();
+}
+
+static void ncard_reveal_finished(UNUSED void *data)
+{
+    pthread_mutex_lock(&ncard.mutex);
+    ncard.bg->h = ncard.targetH;
+    ncard.shadow->h = ncard.targetH;
+    pthread_mutex_unlock(&ncard.mutex);
+}
+
+static void ncard_hide_finished(void *data)
+{
+    struct ncard *c = data;
+    list_clear(&c->texts, fb_remove_item);
+    fb_rm_rect(c->shadow);
+    fb_rm_rect(c->alpha_bg);
+    fb_rm_rect(c->hover_rect);
+    free(c);
+}
+
+void ncard_set_top_offset(int top_offset)
+{
+    pthread_mutex_lock(&ncard.mutex);
+    ncard.top_offset = top_offset;
+    pthread_mutex_unlock(&ncard.mutex);
+}
+
+void ncard_show(ncard_builder *b, int destroy_builder)
+{
+    int i, items_h, btn_x, btn_h, has_btn = 0, it_y = 0, lvl_offset = 0;
+    fb_text *title = 0, *text = 0, *btns[BTN_COUNT];
+    int interpolator;
+
+    pthread_mutex_lock(&ncard.mutex);
+
+    if(ncard.bg)
+        anim_cancel_for(ncard.bg, 0);
+
+    if(b->pos == NCARD_POS_CENTER)
+        lvl_offset = LEVEL_NCARD_CENTER_OFFSET;
+
+    items_h = CARD_PADDING_V*2;
+    if(b->title)
+    {
+        fb_text_proto *p = fb_text_create(CARD_MARGIN + CARD_PADDING_H, fb_height, C_NCARD_TEXT, SIZE_EXTRA, b->title);
+        p->level = LEVEL_NCARD_TEXT + lvl_offset;
+        p->style = STYLE_MEDIUM;
+        p->wrap_w = CARD_WIDTH - CARD_PADDING_H*2;
+        title = fb_text_finalize(p);
+        items_h += title->h;
+    }
+
+    if(b->text)
+    {
+        fb_text_proto *p = fb_text_create(CARD_MARGIN + CARD_PADDING_H, fb_height, C_NCARD_TEXT_SECONDARY, SIZE_NORMAL, b->text);\
+        p->level = LEVEL_NCARD_TEXT + lvl_offset;
+        p->wrap_w = CARD_WIDTH - CARD_PADDING_H*2;
+        if(!title)
+        {
+            p->style = STYLE_ITALIC;
+            p->justify = JUSTIFY_CENTER;
+        }
+        text = fb_text_finalize(p);
+        items_h += text->h;
+    }
+
+    if(title && text)
+        items_h += title->h;
+
+    ncard.active_btns = 0;
+    btn_x = CARD_MARGIN + CARD_WIDTH - CARD_PADDING_H;
+    btn_h = 0;
+    for(i = 0; i < BTN_COUNT; ++i)
+    {
+        if(!b->buttons[i])
+            continue;
+
+        ncard.active_btns |= (1 << i);
+
+        fb_text_proto *p = fb_text_create(btn_x, fb_height, C_NCARD_TEXT, SIZE_NORMAL, b->buttons[i]->text);
+        p->level = LEVEL_NCARD_TEXT + lvl_offset;
+        p->style = STYLE_MEDIUM;
+        fb_text *t = fb_text_finalize(p);
+        t->x -= t->w;
+        btn_x -= t->w + t->h*2;
+        btn_h = imax(t->h*2, btn_h);
+        btns[i] = t;
+
+        ncard.btns[i].callback_data = b->buttons[i]->callback_data;
+        ncard.btns[i].callback = b->buttons[i]->callback;
+        ncard.btns[i].pos.w = t->w + t->h*2;
+        ncard.btns[i].pos.h = t->h*3;
+        ncard.btns[i].pos.x = btn_x + t->h;
+    }
+
+    items_h += btn_h*1.25;
+
+    int new_pos = ncard_calc_pos(b, ncard.top_offset + items_h + CARD_MARGIN);
+
+    if(new_pos != ncard.pos && ncard.bg)
+    {
+        pthread_mutex_unlock(&ncard.mutex);
+        ncard_hide();
+        pthread_mutex_lock(&ncard.mutex);
+    }
+
+    ncard.pos = new_pos;
+
+    list_clear(&ncard.texts, fb_remove_item);
+    fb_rm_rect(ncard.hover_rect);
+    ncard.hover_rect = NULL;
+
+    if(!ncard.bg)
+    {
+        ncard.bg = fb_add_rect_lvl(LEVEL_NCARD_BG + lvl_offset, CARD_MARGIN, 0, CARD_WIDTH, items_h, C_NCARD_BG);
+        ncard.bg->y = ncard.pos == NCARD_POS_BOTTOM ? (int)fb_height : -items_h;
+        ncard.shadow = fb_add_rect_lvl(LEVEL_NCARD_SHADOW + lvl_offset, CARD_MARGIN + CARD_SHADOW_OFF, 0, CARD_WIDTH, items_h, C_NCARD_SHADOW);
+        interpolator = INTERPOLATOR_OVERSHOOT;
+    }
+    else
+        interpolator = INTERPOLATOR_ACCEL_DECEL;
+
+    ncard.targetH = items_h;
+    if(ncard.pos != NCARD_POS_CENTER)
+        ncard.targetH *= 1.3;
+    else if(!ncard.alpha_bg)
+    {
+        ncard.alpha_bg = fb_add_rect_lvl(LEVEL_NCARD_SHADOW + lvl_offset - 1, 0, 0, fb_width, fb_height,
+                b->reveal_from_black ? BLACK : 0x00000000);
+    }
+
+    if(items_h >= ncard.bg->h)
+    {
+        ncard.bg->h = ncard.targetH;
+        ncard.shadow->h = ncard.bg->h;
+    }
+
+    it_y = ncard.bg->y + CARD_PADDING_V;
+    if(ncard.pos == NCARD_POS_TOP)
+        it_y += ncard.bg->h - items_h;
+
+    if(title)
+    {
+        title->y = it_y;
+        it_y += title->h*1.5;
+        list_add(&ncard.texts, title);
+    }
+
+    if(text)
+    {
+        text->y = it_y;
+        it_y += text->h + btn_h*0.75;
+        if(!title)
+            center_text(text, 0, -1, fb_width, -1);
+        list_add(&ncard.texts, text);
+    }
+
+    for(i = 0; i < BTN_COUNT; ++i)
+    {
+        if(!(ncard.active_btns & (1 << i)))
+            continue;
+        btns[i]->y = it_y;
+        ncard.btns[i].pos.y = it_y - ncard.btns[i].pos.h/3;
+        list_add(&ncard.texts, btns[i]);
+    }
+
+    if(ncard.active_btns && !ncard.touch_handler_registered)
+    {
+        add_touch_handler_async(ncard_touch_handler, &ncard);
+        ncard.touch_handler_registered = 1;
+    }
+    else if(!ncard.active_btns && ncard.touch_handler_registered)
+    {
+        rm_touch_handler_async(ncard_touch_handler, &ncard);
+        ncard.touch_handler_registered = 0;
+    }
+
+    ncard.shadow->y = ncard.pos == NCARD_POS_BOTTOM ? ncard.bg->y - CARD_SHADOW_OFF : ncard.bg->y + CARD_SHADOW_OFF;
+
+    ncard.last_y = ncard.bg->y;
+    ncard.cancelable = b->cancelable;
+    ncard.on_hidden_call = b->on_hidden_call;
+    ncard.on_hidden_data = b->on_hidden_data;
+    ncard.reveal_from_black = b->reveal_from_black;
+
+    item_anim *a = item_anim_create(ncard.bg, 400, interpolator);
+    switch(ncard.pos)
+    {
+        case NCARD_POS_TOP:
+            a->targetY = ncard.top_offset - (ncard.bg->h - items_h);
+            break;
+        case NCARD_POS_BOTTOM:
+            a->targetY = fb_height - items_h;
+            break;
+        case NCARD_POS_CENTER:
+            a->targetY = fb_height/2 - items_h/2;
+            break;
+    }
+    a->targetH = ncard.targetH;
+    a->on_step_call = ncard_move_step;
+    a->on_step_data = &ncard;
+    a->on_finished_call = ncard_reveal_finished;
+    item_anim_add(a);
+
+    pthread_mutex_unlock(&ncard.mutex);
+
+    if(destroy_builder)
+        ncard_destroy_builder(b);
+}
+
+void ncard_hide(void)
+{
+    if(!ncard.bg)
+        return;
+
+    anim_cancel_for(ncard.bg, 0);
+
+    struct ncard *c = mzalloc(sizeof(struct ncard));
+    pthread_mutex_lock(&ncard.mutex);
+    c->bg = ncard.bg;
+    c->shadow = ncard.shadow;
+    c->hover_rect = ncard.hover_rect;
+    c->texts = ncard.texts;
+    c->last_y = c->bg->y;
+    c->alpha_bg = ncard.alpha_bg;
+    c->hiding = 1;
+    ncard.shadow = NULL;
+    ncard.hover_rect = NULL;
+    ncard.bg = NULL;
+    ncard.texts = NULL;
+    ncard.alpha_bg = NULL;
+
+    if(ncard.touch_handler_registered)
+    {
+        rm_touch_handler(ncard_touch_handler, &ncard);
+        ncard.touch_handler_registered = 0;
+    }
+
+    pthread_mutex_unlock(&ncard.mutex);
+
+    item_anim *a = item_anim_create(c->bg, 400, INTERPOLATOR_ACCELERATE);
+    a->targetY = ncard.pos == NCARD_POS_TOP ? -c->bg->h : (int)fb_height + c->bg->h;
+    a->destroy_item_when_finished = 1;
+    a->on_step_call = ncard_move_step;
+    a->on_step_data = c;
+    a->on_finished_call = ncard_hide_finished;
+    a->on_finished_data = c;
+    item_anim_add(a);
+
+    if(ncard.on_hidden_call)
+        ncard.on_hidden_call(ncard.on_hidden_data);
+}
+
+void ncard_hide_callback(UNUSED void *data)
+{
+    ncard_hide();
+}
+
+void ncard_destroy_builder(ncard_builder *b)
+{
+    free(b->title);
+    free(b->text);
+    free(b->avoid_item);
+
+    int i;
+    for(i = 0; i < BTN_COUNT; ++i)
+    {
+        if(b->buttons[i])
+        {
+            free(b->buttons[i]->text);
+            free(b->buttons[i]);
+        }
+    }
+    free(b);
+}
+
+int ncard_try_cancel(void)
+{
+    if(ncard.bg && ncard.cancelable)
+    {
+        ncard_hide();
+        return 1;
+    }
+    return 0;
+}
+
+int ncard_is_visible(void)
+{
+    return ncard.bg != NULL;
+}
diff --git a/lib/notification_card.h b/lib/notification_card.h
index 8d57fa9..e53f415 100755
--- a/lib/notification_card.h
+++ b/lib/notification_card.h
@@ -1,79 +1,79 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef NOTIFICATION_CARD_H
-#define NOTIFICATION_CARD_H
-
-#include "framebuffer.h"
-
-enum // order from right to left
-{
-    BTN_POSITIVE,
-    BTN_NEGATIVE,
-
-    BTN_COUNT
-};
-
-enum
-{
-    NCARD_POS_AUTO,
-    NCARD_POS_TOP,
-    NCARD_POS_BOTTOM,
-    NCARD_POS_CENTER,
-};
-
-typedef void (*ncard_callback)(void*);
-
-typedef struct
-{
-    char *text;
-    void *callback_data;
-    ncard_callback callback;
-} ncard_builder_btn;
-
-typedef struct
-{
-    char *title;
-    char *text;
-    ncard_builder_btn *buttons[BTN_COUNT];
-    int pos;
-    fb_item_pos *avoid_item;
-    int cancelable;
-    ncard_callback on_hidden_call;
-    void *on_hidden_data;
-    int reveal_from_black;
-} ncard_builder;
-
-ncard_builder *ncard_create_builder(void);
-void ncard_set_title(ncard_builder *b, const char *title);
-void ncard_set_text(ncard_builder *b, const char *text);
-void ncard_set_pos(ncard_builder *b, int pos);
-void ncard_set_cancelable(ncard_builder *b, int cancelable);
-void ncard_avoid_item(ncard_builder *b, void *item);
-void ncard_add_btn(ncard_builder *b, int btn_type, const char *text, ncard_callback callback, void *callback_data);
-void ncard_set_on_hidden(ncard_builder *b, ncard_callback callback, void *data);
-void ncard_set_from_black(ncard_builder *b, int from_black);
-
-void ncard_set_top_offset(int offset);
-void ncard_show(ncard_builder *b, int destroy_builder);
-void ncard_hide(void);
-int ncard_is_visible(void);
-int ncard_try_cancel(void);
-void ncard_hide_callback(void *data);
-void ncard_destroy_builder(ncard_builder *b);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef NOTIFICATION_CARD_H
+#define NOTIFICATION_CARD_H
+
+#include "framebuffer.h"
+
+enum // order from right to left
+{
+    BTN_POSITIVE,
+    BTN_NEGATIVE,
+
+    BTN_COUNT
+};
+
+enum
+{
+    NCARD_POS_AUTO,
+    NCARD_POS_TOP,
+    NCARD_POS_BOTTOM,
+    NCARD_POS_CENTER,
+};
+
+typedef void (*ncard_callback)(void*);
+
+typedef struct
+{
+    char *text;
+    void *callback_data;
+    ncard_callback callback;
+} ncard_builder_btn;
+
+typedef struct
+{
+    char *title;
+    char *text;
+    ncard_builder_btn *buttons[BTN_COUNT];
+    int pos;
+    fb_item_pos *avoid_item;
+    int cancelable;
+    ncard_callback on_hidden_call;
+    void *on_hidden_data;
+    int reveal_from_black;
+} ncard_builder;
+
+ncard_builder *ncard_create_builder(void);
+void ncard_set_title(ncard_builder *b, const char *title);
+void ncard_set_text(ncard_builder *b, const char *text);
+void ncard_set_pos(ncard_builder *b, int pos);
+void ncard_set_cancelable(ncard_builder *b, int cancelable);
+void ncard_avoid_item(ncard_builder *b, void *item);
+void ncard_add_btn(ncard_builder *b, int btn_type, const char *text, ncard_callback callback, void *callback_data);
+void ncard_set_on_hidden(ncard_builder *b, ncard_callback callback, void *data);
+void ncard_set_from_black(ncard_builder *b, int from_black);
+
+void ncard_set_top_offset(int offset);
+void ncard_show(ncard_builder *b, int destroy_builder);
+void ncard_hide(void);
+int ncard_is_visible(void);
+int ncard_try_cancel(void);
+void ncard_hide_callback(void *data);
+void ncard_destroy_builder(ncard_builder *b);
+
+#endif
diff --git a/lib/progressdots.c b/lib/progressdots.c
index c5928f4..73ae3b6 100755
--- a/lib/progressdots.c
+++ b/lib/progressdots.c
@@ -1,63 +1,63 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <unistd.h>
-
-#include <malloc.h>
-
-#include "progressdots.h"
-#include "colors.h"
-#include "workers.h"
-#include "util.h"
-#include "animation.h"
-
-static void progdots_anim_finished(void *data)
-{
-    progdots *p = data;
-
-    item_anim *a = item_anim_create(p->rect, 1000, INTERPOLATOR_ACCEL_DECEL);
-    if(p->rect->x == p->x)
-        a->targetX = p->x + PROGDOTS_W - p->rect->w;
-    else
-        a->targetX = p->x;
-    a->start_offset = 300;
-    a->on_finished_call = progdots_anim_finished;
-    a->on_finished_data = p;
-    item_anim_add(a);
-}
-
-progdots *progdots_create(int x, int y)
-{
-    progdots *p = mzalloc(sizeof(progdots));
-    p->x = x;
-    p->y = y;
-
-    p->rect = fb_add_rect(x, y, PROGDOTS_H*4, PROGDOTS_H, C_HIGHLIGHT_BG);
-    item_anim *a = item_anim_create(p->rect, 1000, INTERPOLATOR_ACCEL_DECEL);
-    a->targetX = x + PROGDOTS_W - p->rect->w;
-    a->on_finished_call = progdots_anim_finished;
-    a->on_finished_data = p;
-    item_anim_add(a);
-    return p;
-}
-
-void progdots_destroy(progdots *p)
-{
-    anim_cancel_for(p->rect, 0);
-    fb_rm_rect(p->rect);
-    free(p);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <unistd.h>
+
+#include <malloc.h>
+
+#include "progressdots.h"
+#include "colors.h"
+#include "workers.h"
+#include "util.h"
+#include "animation.h"
+
+static void progdots_anim_finished(void *data)
+{
+    progdots *p = data;
+
+    item_anim *a = item_anim_create(p->rect, 1000, INTERPOLATOR_ACCEL_DECEL);
+    if(p->rect->x == p->x)
+        a->targetX = p->x + PROGDOTS_W - p->rect->w;
+    else
+        a->targetX = p->x;
+    a->start_offset = 300;
+    a->on_finished_call = progdots_anim_finished;
+    a->on_finished_data = p;
+    item_anim_add(a);
+}
+
+progdots *progdots_create(int x, int y)
+{
+    progdots *p = mzalloc(sizeof(progdots));
+    p->x = x;
+    p->y = y;
+
+    p->rect = fb_add_rect(x, y, PROGDOTS_H*4, PROGDOTS_H, C_HIGHLIGHT_BG);
+    item_anim *a = item_anim_create(p->rect, 1000, INTERPOLATOR_ACCEL_DECEL);
+    a->targetX = x + PROGDOTS_W - p->rect->w;
+    a->on_finished_call = progdots_anim_finished;
+    a->on_finished_data = p;
+    item_anim_add(a);
+    return p;
+}
+
+void progdots_destroy(progdots *p)
+{
+    anim_cancel_for(p->rect, 0);
+    fb_rm_rect(p->rect);
+    free(p);
+}
diff --git a/lib/progressdots.h b/lib/progressdots.h
index 3182c6b..f485115 100755
--- a/lib/progressdots.h
+++ b/lib/progressdots.h
@@ -1,37 +1,37 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef PROGRESSDOTS_H
-#define PROGRESSDOTS_H
-
-#include "framebuffer.h"
-
-#define PROGDOTS_W (400*DPI_MUL)
-#define PROGDOTS_H (10*DPI_MUL)
-#define PROGDOTS_CNT 8
-
-typedef struct
-{
-	FB_ITEM_POS
-
-    fb_rect *rect;
-} progdots;
-
-progdots *progdots_create(int x, int y);
-void progdots_destroy(progdots *p);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef PROGRESSDOTS_H
+#define PROGRESSDOTS_H
+
+#include "framebuffer.h"
+
+#define PROGDOTS_W (400*DPI_MUL)
+#define PROGDOTS_H (10*DPI_MUL)
+#define PROGDOTS_CNT 8
+
+typedef struct
+{
+	FB_ITEM_POS
+
+    fb_rect *rect;
+} progdots;
+
+progdots *progdots_create(int x, int y);
+void progdots_destroy(progdots *p);
+
+#endif
diff --git a/lib/tabview.c b/lib/tabview.c
index 40784c8..572324f 100755
--- a/lib/tabview.c
+++ b/lib/tabview.c
@@ -1,291 +1,291 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-
-#include <malloc.h>
-#include <string.h>
-
-#include "tabview.h"
-#include "containers.h"
-#include "util.h"
-#include "animation.h"
-#include "log.h"
-#include "input.h"
-
-struct tabview_page
-{
-    fb_item_pos **items;
-    int last_offset;
-};
-
-typedef struct tabview_page tabview_page;
-
-static void tabview_page_destroy(tabview_page *p)
-{
-    list_clear(&p->items, NULL);
-    free(p);
-}
-
-static void tabview_page_update_offset(tabview_page *p, int offset)
-{
-    if(!p->items || offset == p->last_offset)
-        return;
-
-    fb_item_pos **itr;
-    const int diff = offset - p->last_offset;
-
-    for(itr = p->items; *itr; ++itr)
-        (*itr)->x += diff;
-
-    p->last_offset = offset;
-}
-
-int tabview_touch_handler(touch_event *ev, void *data)
-{
-    tabview *t = data;
-    if(t->touch_id == -1 && (ev->changed & TCHNG_ADDED))
-    {
-        if (ev->x < t->x || ev->y < t->y ||
-            ev->x > t->x+t->w || ev->y > t->y+t->h)
-        {
-            return -1;
-        }
-
-        t->touch_id = ev->id;
-        t->touch_moving = 0;
-        touch_tracker_start(t->tracker, ev);
-
-        if(t->anim_id != ANIM_INVALID_ID)
-        {
-            anim_cancel(t->anim_id, 0);
-            t->anim_id = ANIM_INVALID_ID;
-        }
-        return -1;
-    }
-
-    if(t->touch_id != ev->id)
-        return -1;
-
-    if(ev->changed & TCHNG_REMOVED)
-    {
-        t->touch_id = -1;
-        touch_tracker_finish(t->tracker, ev);
-
-        if(!t->touch_moving)
-            return -1;
-
-        if(t->pos % t->w != 0)
-        {
-            int page_idx, duration = 100;   
-            float page = ((float)t->pos)/t->w;
-            if(page < 0)
-                page_idx = 0;
-            else if(page >= t->count - 1)
-                page_idx = t->count - 1;
-            else
-            {
-                float velocity = touch_tracker_get_velocity(t->tracker, TRACKER_X);
-                if(fabs(velocity) >= 1000.f)
-                {
-                    page_idx = (int)page;
-                    if(velocity < 0.f)
-                        ++page_idx;
-                    duration = iabs(t->pos - page_idx*t->w)/(fabs(velocity*DPI_MUL)/1000);
-                }
-                else
-                    page_idx = (int)(page + 0.5f);
-            }
-
-            if(page_idx != t->curr_page)
-            {
-                if(t->on_page_changed_by_swipe)
-                    t->on_page_changed_by_swipe(page_idx);
-                t->curr_page = page_idx;
-            }
-
-            tabview_set_active_page(t, page_idx, duration);
-        }
-        return -1;
-    }
-
-    if(ev->changed & TCHNG_POS)
-    {
-        touch_tracker_add(t->tracker, ev);
-
-        if(!t->touch_moving)
-        {
-            if (t->tracker->distance_abs_x >= 25*DPI_MUL && t->tracker->distance_abs_x > t->tracker->distance_abs_y*3)
-            {
-                t->touch_moving = 1;
-                ev->changed |= TCHNG_REMOVED;
-                ev->x = -1;
-                ev->y = -1;
-
-                t->pos += -t->tracker->distance_x;
-                tabview_update_positions(t);
-            }
-            return -1;
-        }
-
-        t->pos += t->tracker->prev_x - ev->x;
-        tabview_update_positions(t);
-        return 1;
-    }
-
-    return -1;
-}
-
-tabview *tabview_create(int x, int y, int w, int h)
-{
-    tabview *t = mzalloc(sizeof(tabview));
-    t->x = x;
-    t->y = y;
-    t->w = w;
-    t->h = h;
-    t->anim_id = ANIM_INVALID_ID;
-    t->touch_id = -1;
-    t->tracker = touch_tracker_create();
-    pthread_mutex_init(&t->mutex, NULL);
-    return t;
-}
-
-void tabview_destroy(tabview *t)
-{
-    rm_touch_handler(&tabview_touch_handler, t);
-    pthread_mutex_destroy(&t->mutex);
-    list_clear(&t->pages, tabview_page_destroy);
-    touch_tracker_destroy(t->tracker);
-    free(t);
-}
-
-void tabview_add_page(tabview *t, int idx)
-{
-    if(idx == -1)
-        idx = t->count;
-
-    tabview_page *p = mzalloc(sizeof(tabview_page));
-
-    pthread_mutex_lock(&t->mutex);
-    list_add_at(&t->pages, idx, p);
-    ++t->count;
-    t->fullW = t->count*t->w;
-    pthread_mutex_unlock(&t->mutex);
-}
-
-void tabview_rm_page(tabview *t, int idx)
-{
-    if(idx < 0 || idx >= t->count)
-        return;
-
-    pthread_mutex_lock(&t->mutex);
-    list_rm_at(&t->pages, idx, tabview_page_destroy);
-    --t->count;
-    t->fullW = t->count*t->w;
-    pthread_mutex_unlock(&t->mutex);
-}
-
-void tabview_add_item(tabview *t, int page_idx, void *fb_item)
-{
-    if(page_idx < 0 || page_idx >= t->count)
-        return;
-
-    pthread_mutex_lock(&t->mutex);
-    list_add(&t->pages[page_idx]->items, fb_item);
-    pthread_mutex_unlock(&t->mutex);
-}
-
-void tabview_add_items(tabview *t, int page_idx, void *fb_items)
-{
-    if(page_idx < 0 || page_idx >= t->count || !fb_items)
-        return;
-
-    pthread_mutex_lock(&t->mutex);
-    list_add_from_list(&t->pages[page_idx]->items, fb_items);
-    pthread_mutex_unlock(&t->mutex);
-}
-
-void tabview_rm_item(tabview *t, int page_idx, void *fb_item)
-{
-    if(page_idx < 0 || page_idx >= t->count)
-        return;
-
-    pthread_mutex_lock(&t->mutex);
-    list_rm(&t->pages[page_idx]->items, fb_item, NULL);
-    pthread_mutex_unlock(&t->mutex);
-}
-
-void tabview_update_positions(tabview *t)
-{
-    int i;
-    int x = 0;
-
-    if(t->last_reported_pos != t->pos)
-    {
-        if(t->on_pos_changed)
-            t->on_pos_changed(((float)t->pos)/t->w);
-        t->last_reported_pos = t->pos;
-    }
-
-    fb_batch_start();
-    pthread_mutex_lock(&t->mutex);
-    for(i = 0; i < t->count; ++i)
-    {   
-        tabview_page_update_offset(t->pages[i], x - t->pos);
-        x += t->w;
-    }
-    pthread_mutex_unlock(&t->mutex);
-    fb_batch_end();
-    fb_request_draw();
-}
-
-static void tabview_move_anim_step(void *data, float interpolated)
-{
-    tabview *t = data;
-    t->pos = t->anim_pos_start + (t->anim_pos_diff * interpolated);
-    tabview_update_positions(t);
-}
-
-void tabview_set_active_page(tabview *t, int page_idx, int anim_duration)
-{
-    if(page_idx < 0 || page_idx >= t->count)
-        return;
-
-    if(t->curr_page == page_idx && t->pos == page_idx*t->w)
-        return;
-
-    if(t->anim_id != ANIM_INVALID_ID)
-        anim_cancel(t->anim_id, 0);
-
-    t->curr_page = page_idx;
-
-    if(anim_duration == 0)
-    {
-        t->pos = page_idx*t->w;
-        tabview_update_positions(t);
-        return;
-    }
-
-    t->anim_pos_start = t->pos;
-    t->anim_pos_diff = page_idx*t->w - t->pos;
-
-    call_anim *a = call_anim_create(t, tabview_move_anim_step, anim_duration, INTERPOLATOR_DECELERATE);
-    t->anim_id = a->id;
-    call_anim_add(a);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+
+#include <malloc.h>
+#include <string.h>
+
+#include "tabview.h"
+#include "containers.h"
+#include "util.h"
+#include "animation.h"
+#include "log.h"
+#include "input.h"
+
+struct tabview_page
+{
+    fb_item_pos **items;
+    int last_offset;
+};
+
+typedef struct tabview_page tabview_page;
+
+static void tabview_page_destroy(tabview_page *p)
+{
+    list_clear(&p->items, NULL);
+    free(p);
+}
+
+static void tabview_page_update_offset(tabview_page *p, int offset)
+{
+    if(!p->items || offset == p->last_offset)
+        return;
+
+    fb_item_pos **itr;
+    const int diff = offset - p->last_offset;
+
+    for(itr = p->items; *itr; ++itr)
+        (*itr)->x += diff;
+
+    p->last_offset = offset;
+}
+
+int tabview_touch_handler(touch_event *ev, void *data)
+{
+    tabview *t = data;
+    if(t->touch_id == -1 && (ev->changed & TCHNG_ADDED))
+    {
+        if (ev->x < t->x || ev->y < t->y ||
+            ev->x > t->x+t->w || ev->y > t->y+t->h)
+        {
+            return -1;
+        }
+
+        t->touch_id = ev->id;
+        t->touch_moving = 0;
+        touch_tracker_start(t->tracker, ev);
+
+        if(t->anim_id != ANIM_INVALID_ID)
+        {
+            anim_cancel(t->anim_id, 0);
+            t->anim_id = ANIM_INVALID_ID;
+        }
+        return -1;
+    }
+
+    if(t->touch_id != ev->id)
+        return -1;
+
+    if(ev->changed & TCHNG_REMOVED)
+    {
+        t->touch_id = -1;
+        touch_tracker_finish(t->tracker, ev);
+
+        if(!t->touch_moving)
+            return -1;
+
+        if(t->pos % t->w != 0)
+        {
+            int page_idx, duration = 100;   
+            float page = ((float)t->pos)/t->w;
+            if(page < 0)
+                page_idx = 0;
+            else if(page >= t->count - 1)
+                page_idx = t->count - 1;
+            else
+            {
+                float velocity = touch_tracker_get_velocity(t->tracker, TRACKER_X);
+                if(fabs(velocity) >= 1000.f)
+                {
+                    page_idx = (int)page;
+                    if(velocity < 0.f)
+                        ++page_idx;
+                    duration = iabs(t->pos - page_idx*t->w)/(fabs(velocity*DPI_MUL)/1000);
+                }
+                else
+                    page_idx = (int)(page + 0.5f);
+            }
+
+            if(page_idx != t->curr_page)
+            {
+                if(t->on_page_changed_by_swipe)
+                    t->on_page_changed_by_swipe(page_idx);
+                t->curr_page = page_idx;
+            }
+
+            tabview_set_active_page(t, page_idx, duration);
+        }
+        return -1;
+    }
+
+    if(ev->changed & TCHNG_POS)
+    {
+        touch_tracker_add(t->tracker, ev);
+
+        if(!t->touch_moving)
+        {
+            if (t->tracker->distance_abs_x >= 25*DPI_MUL && t->tracker->distance_abs_x > t->tracker->distance_abs_y*3)
+            {
+                t->touch_moving = 1;
+                ev->changed |= TCHNG_REMOVED;
+                ev->x = -1;
+                ev->y = -1;
+
+                t->pos += -t->tracker->distance_x;
+                tabview_update_positions(t);
+            }
+            return -1;
+        }
+
+        t->pos += t->tracker->prev_x - ev->x;
+        tabview_update_positions(t);
+        return 1;
+    }
+
+    return -1;
+}
+
+tabview *tabview_create(int x, int y, int w, int h)
+{
+    tabview *t = mzalloc(sizeof(tabview));
+    t->x = x;
+    t->y = y;
+    t->w = w;
+    t->h = h;
+    t->anim_id = ANIM_INVALID_ID;
+    t->touch_id = -1;
+    t->tracker = touch_tracker_create();
+    pthread_mutex_init(&t->mutex, NULL);
+    return t;
+}
+
+void tabview_destroy(tabview *t)
+{
+    rm_touch_handler(&tabview_touch_handler, t);
+    pthread_mutex_destroy(&t->mutex);
+    list_clear(&t->pages, tabview_page_destroy);
+    touch_tracker_destroy(t->tracker);
+    free(t);
+}
+
+void tabview_add_page(tabview *t, int idx)
+{
+    if(idx == -1)
+        idx = t->count;
+
+    tabview_page *p = mzalloc(sizeof(tabview_page));
+
+    pthread_mutex_lock(&t->mutex);
+    list_add_at(&t->pages, idx, p);
+    ++t->count;
+    t->fullW = t->count*t->w;
+    pthread_mutex_unlock(&t->mutex);
+}
+
+void tabview_rm_page(tabview *t, int idx)
+{
+    if(idx < 0 || idx >= t->count)
+        return;
+
+    pthread_mutex_lock(&t->mutex);
+    list_rm_at(&t->pages, idx, tabview_page_destroy);
+    --t->count;
+    t->fullW = t->count*t->w;
+    pthread_mutex_unlock(&t->mutex);
+}
+
+void tabview_add_item(tabview *t, int page_idx, void *fb_item)
+{
+    if(page_idx < 0 || page_idx >= t->count)
+        return;
+
+    pthread_mutex_lock(&t->mutex);
+    list_add(&t->pages[page_idx]->items, fb_item);
+    pthread_mutex_unlock(&t->mutex);
+}
+
+void tabview_add_items(tabview *t, int page_idx, void *fb_items)
+{
+    if(page_idx < 0 || page_idx >= t->count || !fb_items)
+        return;
+
+    pthread_mutex_lock(&t->mutex);
+    list_add_from_list(&t->pages[page_idx]->items, fb_items);
+    pthread_mutex_unlock(&t->mutex);
+}
+
+void tabview_rm_item(tabview *t, int page_idx, void *fb_item)
+{
+    if(page_idx < 0 || page_idx >= t->count)
+        return;
+
+    pthread_mutex_lock(&t->mutex);
+    list_rm(&t->pages[page_idx]->items, fb_item, NULL);
+    pthread_mutex_unlock(&t->mutex);
+}
+
+void tabview_update_positions(tabview *t)
+{
+    int i;
+    int x = 0;
+
+    if(t->last_reported_pos != t->pos)
+    {
+        if(t->on_pos_changed)
+            t->on_pos_changed(((float)t->pos)/t->w);
+        t->last_reported_pos = t->pos;
+    }
+
+    fb_batch_start();
+    pthread_mutex_lock(&t->mutex);
+    for(i = 0; i < t->count; ++i)
+    {   
+        tabview_page_update_offset(t->pages[i], x - t->pos);
+        x += t->w;
+    }
+    pthread_mutex_unlock(&t->mutex);
+    fb_batch_end();
+    fb_request_draw();
+}
+
+static void tabview_move_anim_step(void *data, float interpolated)
+{
+    tabview *t = data;
+    t->pos = t->anim_pos_start + (t->anim_pos_diff * interpolated);
+    tabview_update_positions(t);
+}
+
+void tabview_set_active_page(tabview *t, int page_idx, int anim_duration)
+{
+    if(page_idx < 0 || page_idx >= t->count)
+        return;
+
+    if(t->curr_page == page_idx && t->pos == page_idx*t->w)
+        return;
+
+    if(t->anim_id != ANIM_INVALID_ID)
+        anim_cancel(t->anim_id, 0);
+
+    t->curr_page = page_idx;
+
+    if(anim_duration == 0)
+    {
+        t->pos = page_idx*t->w;
+        tabview_update_positions(t);
+        return;
+    }
+
+    t->anim_pos_start = t->pos;
+    t->anim_pos_diff = page_idx*t->w - t->pos;
+
+    call_anim *a = call_anim_create(t, tabview_move_anim_step, anim_duration, INTERPOLATOR_DECELERATE);
+    t->anim_id = a->id;
+    call_anim_add(a);
+}
diff --git a/lib/tabview.h b/lib/tabview.h
index 682bb06..e1b9822 100755
--- a/lib/tabview.h
+++ b/lib/tabview.h
@@ -1,64 +1,64 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef TABVIEW_H
-#define TABVIEW_H
-
-#include <pthread.h>
-#include "framebuffer.h"
-#include "input.h"
-#include "touch_tracker.h"
-
-struct tabview_page;
-
-typedef struct {
-	FB_ITEM_POS
-
-	int pos;
-    int anim_pos_start;
-    int anim_pos_diff;
-	int fullW;
-
-	struct tabview_page **pages;
-    int count;
-    int curr_page;
-
-    uint32_t anim_id;
-    pthread_mutex_t mutex;
-
-    void (*on_page_changed_by_swipe)(int); // new_page
-    void (*on_pos_changed)(float);
-
-    int last_reported_pos;
-
-    int touch_id;
-    int touch_moving;
-    touch_tracker *tracker;
-} tabview;
-
-tabview *tabview_create(int x, int y, int w, int h);
-int tabview_touch_handler(touch_event *ev, void *data);
-void tabview_destroy(tabview *t);
-void tabview_add_page(tabview *t, int idx);
-void tabview_rm_page(tabview *t, int idx);
-void tabview_add_item(tabview *t, int page_idx, void *fb_item);
-void tabview_add_items(tabview *t, int page_idx, void *fb_items);
-void tabview_rm_item(tabview *t, int page_idx, void *fb_item);
-void tabview_update_positions(tabview *t);
-void tabview_set_active_page(tabview *t, int page_idx, int anim_duration);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TABVIEW_H
+#define TABVIEW_H
+
+#include <pthread.h>
+#include "framebuffer.h"
+#include "input.h"
+#include "touch_tracker.h"
+
+struct tabview_page;
+
+typedef struct {
+	FB_ITEM_POS
+
+	int pos;
+    int anim_pos_start;
+    int anim_pos_diff;
+	int fullW;
+
+	struct tabview_page **pages;
+    int count;
+    int curr_page;
+
+    uint32_t anim_id;
+    pthread_mutex_t mutex;
+
+    void (*on_page_changed_by_swipe)(int); // new_page
+    void (*on_pos_changed)(float);
+
+    int last_reported_pos;
+
+    int touch_id;
+    int touch_moving;
+    touch_tracker *tracker;
+} tabview;
+
+tabview *tabview_create(int x, int y, int w, int h);
+int tabview_touch_handler(touch_event *ev, void *data);
+void tabview_destroy(tabview *t);
+void tabview_add_page(tabview *t, int idx);
+void tabview_rm_page(tabview *t, int idx);
+void tabview_add_item(tabview *t, int page_idx, void *fb_item);
+void tabview_add_items(tabview *t, int page_idx, void *fb_items);
+void tabview_rm_item(tabview *t, int page_idx, void *fb_item);
+void tabview_update_positions(tabview *t);
+void tabview_set_active_page(tabview *t, int page_idx, int anim_duration);
+
+#endif
diff --git a/lib/touch_tracker.c b/lib/touch_tracker.c
index 13880eb..a4e4382 100755
--- a/lib/touch_tracker.c
+++ b/lib/touch_tracker.c
@@ -1,81 +1,81 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-
-#include <string.h>
-#include <malloc.h>
-
-#include "touch_tracker.h"
-#include "util.h"
-
-touch_tracker *touch_tracker_create(void)
-{
-    touch_tracker *t = mzalloc(sizeof(touch_tracker));
-    return t;
-}
-
-void touch_tracker_destroy(touch_tracker *t)
-{
-    free(t);
-}
-
-void touch_tracker_start(touch_tracker *t, touch_event *ev)
-{
-    t->distance_abs_x = t->distance_abs_y = 0;
-    t->distance_x = t->distance_y = 0;
-    t->start_x = ev->x;
-    t->start_y = ev->y;
-    t->last_x = ev->x;
-    t->last_y = ev->y;
-    t->prev_x = ev->x;
-    t->prev_y = ev->y;
-    memcpy(&t->time_start, &ev->time, sizeof(struct timeval));
-}
-
-void touch_tracker_finish(touch_tracker *t, touch_event *ev)
-{
-    t->period = timeval_us_diff(ev->time, t->time_start);
-}
-
-void touch_tracker_add(touch_tracker *t, touch_event *ev)
-{
-    t->prev_x = t->last_x;
-    t->prev_y = t->last_y;
-    t->distance_x += ev->x - t->last_x;
-    t->distance_y += ev->y - t->last_y;
-    t->distance_abs_x += iabs(ev->x - t->last_x);
-    t->distance_abs_y += iabs(ev->y - t->last_y);
-    t->last_x = ev->x;
-    t->last_y = ev->y;
-}
-
-float touch_tracker_get_velocity(touch_tracker *t, int axis)
-{
-    if(axis == TRACKER_X)
-        return ((((float)t->distance_x) / t->period) * 1000000) / DPI_MUL;
-    else
-        return ((((float)t->distance_y) / t->period) * 1000000) / DPI_MUL;
-}
-
-float touch_tracker_get_velocity_abs(touch_tracker *t, int axis)
-{
-    if(axis == TRACKER_X)
-        return ((((float)t->distance_abs_x) / t->period) * 1000000) / DPI_MUL;
-    else
-        return ((((float)t->distance_abs_y) / t->period) * 1000000) / DPI_MUL;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+
+#include <string.h>
+#include <malloc.h>
+
+#include "touch_tracker.h"
+#include "util.h"
+
+touch_tracker *touch_tracker_create(void)
+{
+    touch_tracker *t = mzalloc(sizeof(touch_tracker));
+    return t;
+}
+
+void touch_tracker_destroy(touch_tracker *t)
+{
+    free(t);
+}
+
+void touch_tracker_start(touch_tracker *t, touch_event *ev)
+{
+    t->distance_abs_x = t->distance_abs_y = 0;
+    t->distance_x = t->distance_y = 0;
+    t->start_x = ev->x;
+    t->start_y = ev->y;
+    t->last_x = ev->x;
+    t->last_y = ev->y;
+    t->prev_x = ev->x;
+    t->prev_y = ev->y;
+    memcpy(&t->time_start, &ev->time, sizeof(struct timeval));
+}
+
+void touch_tracker_finish(touch_tracker *t, touch_event *ev)
+{
+    t->period = timeval_us_diff(ev->time, t->time_start);
+}
+
+void touch_tracker_add(touch_tracker *t, touch_event *ev)
+{
+    t->prev_x = t->last_x;
+    t->prev_y = t->last_y;
+    t->distance_x += ev->x - t->last_x;
+    t->distance_y += ev->y - t->last_y;
+    t->distance_abs_x += iabs(ev->x - t->last_x);
+    t->distance_abs_y += iabs(ev->y - t->last_y);
+    t->last_x = ev->x;
+    t->last_y = ev->y;
+}
+
+float touch_tracker_get_velocity(touch_tracker *t, int axis)
+{
+    if(axis == TRACKER_X)
+        return ((((float)t->distance_x) / t->period) * 1000000) / DPI_MUL;
+    else
+        return ((((float)t->distance_y) / t->period) * 1000000) / DPI_MUL;
+}
+
+float touch_tracker_get_velocity_abs(touch_tracker *t, int axis)
+{
+    if(axis == TRACKER_X)
+        return ((((float)t->distance_abs_x) / t->period) * 1000000) / DPI_MUL;
+    else
+        return ((((float)t->distance_abs_y) / t->period) * 1000000) / DPI_MUL;
+}
diff --git a/lib/touch_tracker.h b/lib/touch_tracker.h
index 008fb21..0254672 100755
--- a/lib/touch_tracker.h
+++ b/lib/touch_tracker.h
@@ -1,47 +1,47 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef TOUCH_TRACKER_H
-#define TOUCH_TRACKER_H
-
-#include <sys/time.h>
-#include <time.h>
-#include "input.h"
-
-#define TRACKER_X 0
-#define TRACKER_Y 1
-
-typedef struct
-{
-    struct timeval time_start;
-    int64_t period;
-    int distance_x, distance_y;
-    int distance_abs_x, distance_abs_y;
-    int last_x, last_y;
-    int prev_x, prev_y;
-    int start_x, start_y;
-} touch_tracker;
-
-touch_tracker *touch_tracker_create(void);
-void touch_tracker_destroy(touch_tracker *t);
-void touch_tracker_start(touch_tracker *t, touch_event *ev);
-void touch_tracker_finish(touch_tracker *t, touch_event *ev);
-void touch_tracker_add(touch_tracker *t, touch_event *ev);
-float touch_tracker_get_velocity(touch_tracker *t, int axis);
-float touch_tracker_get_velocity_abs(touch_tracker *t, int axis);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TOUCH_TRACKER_H
+#define TOUCH_TRACKER_H
+
+#include <sys/time.h>
+#include <time.h>
+#include "input.h"
+
+#define TRACKER_X 0
+#define TRACKER_Y 1
+
+typedef struct
+{
+    struct timeval time_start;
+    int64_t period;
+    int distance_x, distance_y;
+    int distance_abs_x, distance_abs_y;
+    int last_x, last_y;
+    int prev_x, prev_y;
+    int start_x, start_y;
+} touch_tracker;
+
+touch_tracker *touch_tracker_create(void);
+void touch_tracker_destroy(touch_tracker *t);
+void touch_tracker_start(touch_tracker *t, touch_event *ev);
+void touch_tracker_finish(touch_tracker *t, touch_event *ev);
+void touch_tracker_add(touch_tracker *t, touch_event *ev);
+float touch_tracker_get_velocity(touch_tracker *t, int axis);
+float touch_tracker_get_velocity_abs(touch_tracker *t, int axis);
+
+#endif
diff --git a/lib/util.c b/lib/util.c
index 4b11598..4eb55d7 100755
--- a/lib/util.c
+++ b/lib/util.c
@@ -1,806 +1,806 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdarg.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <fcntl.h>
-#include <ctype.h>
-#include <errno.h>
-#include <time.h>
-#include <dirent.h>
-#include <fcntl.h>
-#include <cutils/android_reboot.h>
-
-
-#include <malloc.h>
-#include <unistd.h>
-
-
-#ifdef HAVE_SELINUX
-#include <selinux/label.h>
-#endif
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <sys/wait.h>
-#include <sys/mount.h>
-#include <linux/loop.h>
-
-#include <private/android_filesystem_config.h>
-
-#include "log.h"
-#include "util.h"
-#include "mrom_data.h"
-
-/*
- * gettime() - returns the time in seconds of the system's monotonic clock or
- * zero on error.
- */
-time_t gettime(void)
-{
-    struct timespec ts;
-    int ret;
-
-    ret = clock_gettime(CLOCK_MONOTONIC, &ts);
-    if (ret < 0) {
-        ERROR("clock_gettime(CLOCK_MONOTONIC) failed: %s\n", strerror(errno));
-        return 0;
-    }
-
-    return ts.tv_sec;
-}
-
-/*
- * android_name_to_id - returns the integer uid/gid associated with the given
- * name, or -1U on error.
- */
-static unsigned int android_name_to_id(const char *name)
-{
-    struct android_id_info const *info = android_ids;
-    unsigned int n;
-
-    for (n = 0; n < android_id_count; n++) {
-        if (!strcmp(info[n].name, name))
-            return info[n].aid;
-    }
-
-    return -1U;
-}
-
-/*
- * decode_uid - decodes and returns the given string, which can be either the
- * numeric or name representation, into the integer uid or gid. Returns -1U on
- * error.
- */
-unsigned int decode_uid(const char *s)
-{
-    unsigned int v;
-
-    if (!s || *s == '\0')
-        return -1U;
-    if (isalpha(s[0]))
-        return android_name_to_id(s);
-
-    errno = 0;
-    v = (unsigned int) strtoul(s, 0, 0);
-    if (errno)
-        return -1U;
-    return v;
-}
-
-int mkdir_recursive(const char *pathname, mode_t mode)
-{
-    return mkdir_recursive_with_perms(pathname, mode, NULL, NULL);
-}
-
-int mkdir_recursive_with_perms(const char *pathname, mode_t mode, const char *owner, const char *group)
-{
-    char buf[128];
-    const char *slash;
-    const char *p = pathname;
-    int width;
-    int ret;
-    struct stat info;
-
-    while ((slash = strchr(p, '/')) != NULL) {
-        width = slash - pathname;
-        p = slash + 1;
-        if (width < 0)
-            break;
-        if (width == 0)
-            continue;
-        if ((unsigned int)width > sizeof(buf) - 1) {
-            ERROR("path too long for mkdir_recursive\n");
-            return -1;
-        }
-        memcpy(buf, pathname, width);
-        buf[width] = 0;
-        if (stat(buf, &info) != 0) {
-            ret = mkdir_with_perms(buf, mode, owner, group);
-            if (ret && errno != EEXIST)
-                return ret;
-        }
-    }
-    ret = mkdir(pathname, mode);
-    if (ret && errno != EEXIST)
-        return ret;
-    return 0;
-}
-
-int mkdir_with_perms(const char *path, mode_t mode, const char *owner, const char *group)
-{
-    int ret;
-
-    ret = mkdir(path, mode);
-    /* chmod in case the directory already exists */
-    if (ret == -1 && errno == EEXIST) {
-        ret = chmod(path, mode);
-    }
-    if (ret == -1) {
-        return -errno;
-    }
-
-    if(owner)
-    {
-        uid_t uid = decode_uid(owner);
-        gid_t gid = -1;
-
-        if(group)
-            gid = decode_uid(group);
-
-        if(chown(path, uid, gid) < 0)
-            return -errno;
-    }
-    return 0;
-}
-
-/*
-* replaces any unacceptable characters with '_', the
-* length of the resulting string is equal to the input string
-*/
-void sanitize(char *s)
-{
-    const char* accept =
-            "abcdefghijklmnopqrstuvwxyz"
-            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-            "0123456789"
-            "_-.";
-
-    if (!s)
-        return;
-
-    for (; *s; s++) {
-        s += strspn(s, accept);
-        if (*s) *s = '_';
-    }
-}
-
-int make_link(const char *oldpath, const char *newpath)
-{
-    int ret;
-    char buf[256];
-    char *slash;
-    int width;
-
-    slash = strrchr(newpath, '/');
-    if (!slash)
-        return -1;
-
-    width = slash - newpath;
-    if (width <= 0 || width > (int)sizeof(buf) - 1)
-        return -1;
-
-    memcpy(buf, newpath, width);
-    buf[width] = 0;
-    ret = mkdir_recursive(buf, 0755);
-    if (ret)
-    {
-        ERROR("Failed to create directory %s: %s (%d)\n", buf, strerror(errno), errno);
-        return -1;
-    }
-
-    ret = symlink(oldpath, newpath);
-    if (ret && errno != EEXIST)
-    {
-        ERROR("Failed to symlink %s to %s: %s (%d)\n", oldpath, newpath, strerror(errno), errno);
-        return -1;
-    }
-    return 0;
-}
-
-void remove_link(const char *oldpath, const char *newpath)
-{
-    char path[256];
-    ssize_t ret;
-    ret = readlink(newpath, path, sizeof(path) - 1);
-    if (ret <= 0)
-        return;
-    path[ret] = 0;
-    if (!strcmp(path, oldpath))
-        unlink(newpath);
-}
-
-int wait_for_file(const char *filename, int timeout)
-{
-    struct stat info;
-    time_t timeout_time = gettime() + timeout;
-    int ret = -1;
-
-    while (gettime() < timeout_time && ((ret = stat(filename, &info)) < 0))
-        usleep(10000);
-
-    return ret;
-}
-
-int copy_file(const char *from, const char *to)
-{
-    FILE *in = fopen(from, "re");
-    if(!in)
-        return -1;
-
-    FILE *out = fopen(to, "we");
-    if(!out)
-    {
-        fclose(in);
-        return -1;
-    }
-
-    fseek(in, 0, SEEK_END);
-    int size = ftell(in);
-    rewind(in);
-
-    char *buff = malloc(size);
-    fread(buff, 1, size, in);
-    fwrite(buff, 1, size, out);
-
-    fclose(in);
-    fclose(out);
-    free(buff);
-    return 0;
-}
-
-int write_file(const char *path, const char *value)
-{
-    int fd, ret, len;
-
-    fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC, 0622);
-
-    if (fd < 0)
-    {
-        ERROR("Failed to open file %s (%d: %s)\n", path, errno, strerror(errno));
-        return -errno;
-    }
-
-    len = strlen(value);
-
-    do {
-        ret = write(fd, value, len);
-    } while (ret < 0 && errno == EINTR);
-
-    close(fd);
-    if (ret < 0) {
-        return -errno;
-    } else {
-        return 0;
-    }
-}
-
-int remove_dir(const char *dir)
-{
-    struct DIR *d = opendir(dir);
-    if(!d)
-        return -1;
-
-    struct dirent *dt;
-    int res = 0;
-
-    int dir_len = strlen(dir) + 1;
-    char *n = malloc(dir_len + 1);
-    strcpy(n, dir);
-    strcat(n, "/");
-
-    while(res == 0 && (dt = readdir(d)))
-    {
-        if(dt->d_name[0] == '.' && (dt->d_name[1] == '.' || dt->d_name[1] == 0))
-            continue;
-
-        n = realloc(n, dir_len + strlen(dt->d_name) + 1);
-        n[dir_len] = 0;
-        strcat(n, dt->d_name);
-
-        if(dt->d_type == DT_DIR)
-        {
-            if(remove_dir(n) < 0)
-                res = -1;
-        }
-        else
-        {
-            if(remove(n) < 0)
-                res = -1;
-        }
-    }
-
-    free(n);
-    closedir(d);
-
-    if(res == 0 && remove(dir) < 0)
-        res = -1;
-    return res;
-}
-
-void stdio_to_null(void)
-{
-    int fd = open("/dev/null", O_RDWR|O_CLOEXEC);
-    if(fd >= 0)
-    {
-        dup2(fd, 0);
-        dup2(fd, 1);
-        dup2(fd, 2);
-        close(fd);
-    }
-}
-
-int run_cmd(char **cmd)
-{
-    return run_cmd_with_env(cmd, NULL);
-}
-
-int run_cmd_with_env(char **cmd, char *const *envp)
-{
-    pid_t pID = vfork();
-    if(pID == 0)
-    {
-        stdio_to_null();
-        execve(cmd[0], cmd, envp);
-        _exit(127);
-    }
-    else
-    {
-        int status = 0;
-        waitpid(pID, &status, 0);
-        return status;
-    }
-}
-
-
-char *run_get_stdout(char **cmd)
-{
-    int exit_code;
-    return run_get_stdout_with_exit(cmd, &exit_code);
-}
-
-char *run_get_stdout_with_exit(char **cmd, int *exit_code)
-{
-    return run_get_stdout_with_exit_with_env(cmd, exit_code, NULL);
-}
-
-char *run_get_stdout_with_exit_with_env(char **cmd, int *exit_code, char *const *envp)
-{
-   int fd[2];
-   if(pipe2(fd, O_CLOEXEC) < 0)
-        return NULL;
-
-    pid_t pid = vfork();
-    if (pid < 0)
-    {
-        close(fd[0]);
-        close(fd[1]);
-        return NULL;
-    }
-
-    if(pid == 0) // child
-    {
-        close(fd[0]);
-        dup2(fd[1], 1);  // send stdout to the pipe
-        dup2(fd[1], 2);  // send stderr to the pipe
-        close(fd[1]);
-
-        execve(cmd[0], cmd, envp);
-        _exit(127);
-    }
-    else
-    {
-        close(fd[1]);
-
-        char *res = malloc(512);
-        char buffer[512];
-        int size = 512, written = 0, len;
-        while ((len = read(fd[0], buffer, sizeof(buffer))) > 0)
-        {
-            if(written + len + 1 > size)
-            {
-                size = written + len + 256;
-                res = realloc(res, size);
-            }
-            memcpy(res+written, buffer, len);
-            written += len;
-            res[written] = 0;
-        }
-
-        close(fd[0]);
-
-        waitpid(pid, exit_code, 0);
-
-        if(written == 0)
-        {
-            free(res);
-            return NULL;
-        }
-        return res;
-    }
-    return NULL;
-}
-
-int mr_system(const char *shell_fmt, ...)
-{
-    int ret;
-    char busybox_path[256];
-    char path[256];
-    char shell[256];
-    char *real_shell = NULL;
-    char *const cmd_envp[] = { path, NULL };
-    //               0            1     2     3
-    char *cmd[] = { busybox_path, "sh", "-c", NULL, NULL };
-
-    snprintf(path, sizeof(path), "PATH=%s:/sbin:/system/bin", mrom_dir());
-    snprintf(busybox_path, sizeof(busybox_path), "%s/busybox", mrom_dir());
-
-    va_list ap;
-    va_start(ap, shell_fmt);
-    ret = vsnprintf(shell, sizeof(shell), shell_fmt, ap);
-    if(ret < (int)sizeof(shell))
-        real_shell = shell;
-    else
-    {
-        real_shell = malloc(ret+1);
-        vsnprintf(real_shell, ret+1, shell_fmt, ap);
-    }
-    va_end(ap);
-
-    cmd[3] = real_shell;
-    ret = run_cmd_with_env(cmd, cmd_envp);
-
-    if(real_shell != shell)
-        free(real_shell);
-    return ret;
-}
-
-uint32_t timespec_diff(struct timespec *f, struct timespec *s)
-{
-    uint32_t res = 0;
-    if(s->tv_nsec-f->tv_nsec < 0)
-    {
-        res = (s->tv_sec-f->tv_sec-1)*1000;
-        res += 1000 + ((s->tv_nsec-f->tv_nsec)/1000000);
-    }
-    else
-    {
-        res = (s->tv_sec-f->tv_sec)*1000;
-        res += (s->tv_nsec-f->tv_nsec)/1000000;
-    }
-    return res;
-}
-
-int64_t timeval_us_diff(struct timeval now, struct timeval prev)
-{
-    return ((int64_t)(now.tv_sec - prev.tv_sec))*1000000+
-        (now.tv_usec - prev.tv_usec);
-}
-
-// Tries to recursively resolve symlinks. If lstat fails at some point,
-// presumably because the target does not exist, returns the last resolved path.
-char *readlink_recursive(const char *link)
-{
-    struct stat info;
-    if(lstat(link, &info) < 0 || !S_ISLNK(info.st_mode))
-        return strdup(link);
-
-    char path[256];
-    char buff[256];
-    char *p = (char*)link;
-
-    do
-    {
-        if(info.st_size >= sizeof(path)-1)
-        {
-            ERROR("readlink_recursive(): Couldn't resolve, too long path.\n");
-            return NULL;
-        }
-
-        if(readlink(p, buff, info.st_size) != info.st_size)
-        {
-            ERROR("readlink_recursive: readlink() failed on %s!\n", p);
-            return NULL;
-        }
-
-        buff[info.st_size] = 0;
-        strcpy(path, buff);
-        p = path;
-    }
-    while(lstat(buff, &info) >= 0 && S_ISLNK(info.st_mode));
-
-    return strdup(buff);
-}
-
-/* Check to see if /proc/mounts contains any writeable filesystems
- * backed by a block device.
- * Return true if none found, else return false.
- */
-static int remount_ro_done(void)
-{
-    FILE *f;
-    char mount_dev[256];
-    char mount_dir[256];
-    char mount_type[256];
-    char mount_opts[256];
-    int mount_freq;
-    int mount_passno;
-    int match;
-    int found_rw_fs = 0;
-
-    f = fopen("/proc/mounts", "re");
-    if (! f) {
-        /* If we can't read /proc/mounts, just give up */
-        return 1;
-    }
-
-    do {
-        match = fscanf(f, "%255s %255s %255s %255s %d %d\n",
-                       mount_dev, mount_dir, mount_type,
-                       mount_opts, &mount_freq, &mount_passno);
-        mount_dev[255] = 0;
-        mount_dir[255] = 0;
-        mount_type[255] = 0;
-        mount_opts[255] = 0;
-        if ((match == 6) && !strncmp(mount_dev, "/dev/block", 10) && strstr(mount_opts, "rw")) {
-            found_rw_fs = 1;
-            break;
-        }
-    } while (match != EOF);
-
-    fclose(f);
-
-    return !found_rw_fs;
-}
-
-/* Remounting filesystems read-only is difficult when there are files
- * opened for writing or pending deletes on the filesystem.  There is
- * no way to force the remount with the mount(2) syscall.  The magic sysrq
- * 'u' command does an emergency remount read-only on all writable filesystems
- * that have a block device (i.e. not tmpfs filesystems) by calling
- * emergency_remount(), which knows how to force the remount to read-only.
- * Unfortunately, that is asynchronous, and just schedules the work and
- * returns.  The best way to determine if it is done is to read /proc/mounts
- * repeatedly until there are no more writable filesystems mounted on
- * block devices.
- */
-void emergency_remount_ro(void)
-{
-    int fd, cnt = 0;
-
-    sync();
-
-    /* Trigger the remount of the filesystems as read-only,
-     * which also marks them clean.
-     */
-    fd = open("/proc/sysrq-trigger", O_WRONLY|O_CLOEXEC);
-    if (fd < 0) {
-        return;
-    }
-    write(fd, "u", 1);
-    close(fd);
-
-
-    /* Now poll /proc/mounts till it's done */
-    while (!remount_ro_done() && (cnt < 3600)) {
-        usleep(100000);
-        cnt++;
-    }
-
-    return;
-}
-
-
-int imin(int a, int b)
-{
-    return (a < b) ? a : b;
-}
-
-int imax(int a, int b)
-{
-    return (a > b) ? a : b;
-}
-
-inline int iabs(int a)
-{
-    return a >= 0 ? a : -a;
-}
-
-int in_rect(int x, int y, int rx, int ry, int rw, int rh)
-{
-    if(x < rx || y < ry)
-        return 0;
-
-    if(x > rx+rw || y > ry+rh)
-        return 0;
-    return 1;
-}
-
-char *parse_string(char *src)
-{
-    char *start = strchr(src, '"');
-    char *end = strrchr(src, '"');
-
-    if(!start || start == end || start+1 == end)
-        return NULL;
-    ++start;
-    return strndup(start, end-start);
-}
-
-// alloc and fill with 0s
-void *mzalloc(size_t size)
-{
-    void *res = malloc(size);
-    memset(res, 0, size);
-    return res;
-}
-
-char *strtoupper(const char *str)
-{
-    int i;
-    const int len = strlen(str);
-    char *res = malloc(len + 1);
-    for(i = 0; i < len; ++i)
-    {
-        res[i] = str[i];
-        if(str[i] >= 'a' && str[i] <= 'z')
-            res[i] -= 'a'-'A';
-    }
-    res[i] = 0;
-    return res;
-}
-
-int strstartswith(const char *haystack, const char *needle)
-{
-    return strncmp(haystack, needle, strlen(needle)) == 0;
-}
-
-int strendswith(const char *haystack, const char *needle)
-{
-    size_t h_len = strlen(haystack);
-    size_t n_len = strlen(needle);
-    if(n_len == 0 || n_len > h_len)
-        return 0;
-    return strncmp(haystack + h_len - n_len, needle, n_len) == 0;
-}
-
-int create_loop_device(const char *dev_path, const char *img_path, int loop_num, int loop_chmod)
-{
-    int file_fd, device_fd, res = -1;
-
-    file_fd = open(img_path, O_RDWR | O_CLOEXEC);
-    if (file_fd < 0) {
-        ERROR("Failed to open image %s\n", img_path);
-        return -1;
-    }
-
-    INFO("create_loop_device: loop_num = %d", loop_num);
-
-    if(mknod(dev_path, S_IFBLK | loop_chmod, makedev(7, loop_num)) < 0)
-    {
-        if(errno != EEXIST)
-        {
-            ERROR("Failed to create loop file (%d: %s)\n", errno, strerror(errno));
-            goto close_file;
-        }
-        else
-            INFO("Loop file %s already exists, using it.\n", dev_path);
-    }
-
-    device_fd = open(dev_path, O_RDWR | O_CLOEXEC);
-    if (device_fd < 0)
-    {
-        ERROR("Failed to open loop file (%d: %s)\n", errno, strerror(errno));
-        goto close_file;
-    }
-
-    if (ioctl(device_fd, LOOP_SET_FD, file_fd) < 0)
-    {
-        ERROR("ioctl LOOP_SET_FD failed on %s (%d: %s)\n", dev_path, errno, strerror(errno));
-        goto close_dev;
-    }
-
-    res = 0;
-close_dev:
-    close(device_fd);
-close_file:
-    close(file_fd);
-    return res;
-}
-
-#define MAX_LOOP_NUM 1023
-int mount_image(const char *src, const char *dst, const char *fs, int flags, const void *data)
-{
-    char path[64];
-    int device_fd;
-    int loop_num = 0;
-    int res = -1;
-    struct stat info;
-    struct loop_info64 lo_info;
-
-    for(; loop_num < MAX_LOOP_NUM; ++loop_num)
-    {
-        sprintf(path, "/dev/block/loop%d", loop_num);
-        if(stat(path, &info) < 0)
-        {
-            if(errno == ENOENT)
-                break;
-        }
-        else if(S_ISBLK(info.st_mode) && (device_fd = open(path, O_RDWR | O_CLOEXEC)) >= 0)
-        {
-            int ioctl_res = ioctl(device_fd, LOOP_GET_STATUS64, &lo_info);
-            close(device_fd);
-
-            if (ioctl_res < 0 && errno == ENXIO)
-                break;
-        }
-    }
-
-    if(loop_num == MAX_LOOP_NUM)
-    {
-        ERROR("mount_image: failed to find suitable loop device number!");
-        return -1;
-    }
-
-    if(create_loop_device(path, src, loop_num, 0777) < 0)
-        return -1;
-
-    if(mount(path, dst, fs, flags, data) < 0)
-        ERROR("Failed to mount loop (%d: %s)\n", errno, strerror(errno));
-    else
-        res = 0;
-
-    return res;
-}
-
-void do_reboot(int type)
-{
-    sync();
-    emergency_remount_ro();
-
-    switch(type)
-    {
-        default:
-        case REBOOT_SYSTEM:
-            android_reboot(ANDROID_RB_RESTART, 0, 0);
-            break;
-        case REBOOT_RECOVERY:
-            android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
-            break;
-        case REBOOT_BOOTLOADER:
-            android_reboot(ANDROID_RB_RESTART2, 0, "bootloader");
-            break;
-        case REBOOT_SHUTDOWN:
-            android_reboot(ANDROID_RB_POWEROFF, 0, 0);
-            break;
-    }
-
-    while(1);
-}
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <errno.h>
+#include <time.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <cutils/android_reboot.h>
+
+
+#include <malloc.h>
+#include <unistd.h>
+
+
+#ifdef HAVE_SELINUX
+#include <selinux/label.h>
+#endif
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#include <sys/mount.h>
+#include <linux/loop.h>
+
+#include <private/android_filesystem_config.h>
+
+#include "log.h"
+#include "util.h"
+#include "mrom_data.h"
+
+/*
+ * gettime() - returns the time in seconds of the system's monotonic clock or
+ * zero on error.
+ */
+time_t gettime(void)
+{
+    struct timespec ts;
+    int ret;
+
+    ret = clock_gettime(CLOCK_MONOTONIC, &ts);
+    if (ret < 0) {
+        ERROR("clock_gettime(CLOCK_MONOTONIC) failed: %s\n", strerror(errno));
+        return 0;
+    }
+
+    return ts.tv_sec;
+}
+
+/*
+ * android_name_to_id - returns the integer uid/gid associated with the given
+ * name, or -1U on error.
+ */
+static unsigned int android_name_to_id(const char *name)
+{
+    struct android_id_info const *info = android_ids;
+    unsigned int n;
+
+    for (n = 0; n < android_id_count; n++) {
+        if (!strcmp(info[n].name, name))
+            return info[n].aid;
+    }
+
+    return -1U;
+}
+
+/*
+ * decode_uid - decodes and returns the given string, which can be either the
+ * numeric or name representation, into the integer uid or gid. Returns -1U on
+ * error.
+ */
+unsigned int decode_uid(const char *s)
+{
+    unsigned int v;
+
+    if (!s || *s == '\0')
+        return -1U;
+    if (isalpha(s[0]))
+        return android_name_to_id(s);
+
+    errno = 0;
+    v = (unsigned int) strtoul(s, 0, 0);
+    if (errno)
+        return -1U;
+    return v;
+}
+
+int mkdir_recursive(const char *pathname, mode_t mode)
+{
+    return mkdir_recursive_with_perms(pathname, mode, NULL, NULL);
+}
+
+int mkdir_recursive_with_perms(const char *pathname, mode_t mode, const char *owner, const char *group)
+{
+    char buf[128];
+    const char *slash;
+    const char *p = pathname;
+    int width;
+    int ret;
+    struct stat info;
+
+    while ((slash = strchr(p, '/')) != NULL) {
+        width = slash - pathname;
+        p = slash + 1;
+        if (width < 0)
+            break;
+        if (width == 0)
+            continue;
+        if ((unsigned int)width > sizeof(buf) - 1) {
+            ERROR("path too long for mkdir_recursive\n");
+            return -1;
+        }
+        memcpy(buf, pathname, width);
+        buf[width] = 0;
+        if (stat(buf, &info) != 0) {
+            ret = mkdir_with_perms(buf, mode, owner, group);
+            if (ret && errno != EEXIST)
+                return ret;
+        }
+    }
+    ret = mkdir(pathname, mode);
+    if (ret && errno != EEXIST)
+        return ret;
+    return 0;
+}
+
+int mkdir_with_perms(const char *path, mode_t mode, const char *owner, const char *group)
+{
+    int ret;
+
+    ret = mkdir(path, mode);
+    /* chmod in case the directory already exists */
+    if (ret == -1 && errno == EEXIST) {
+        ret = chmod(path, mode);
+    }
+    if (ret == -1) {
+        return -errno;
+    }
+
+    if(owner)
+    {
+        uid_t uid = decode_uid(owner);
+        gid_t gid = -1;
+
+        if(group)
+            gid = decode_uid(group);
+
+        if(chown(path, uid, gid) < 0)
+            return -errno;
+    }
+    return 0;
+}
+
+/*
+* replaces any unacceptable characters with '_', the
+* length of the resulting string is equal to the input string
+*/
+void sanitize(char *s)
+{
+    const char* accept =
+            "abcdefghijklmnopqrstuvwxyz"
+            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+            "0123456789"
+            "_-.";
+
+    if (!s)
+        return;
+
+    for (; *s; s++) {
+        s += strspn(s, accept);
+        if (*s) *s = '_';
+    }
+}
+
+int make_link(const char *oldpath, const char *newpath)
+{
+    int ret;
+    char buf[256];
+    char *slash;
+    int width;
+
+    slash = strrchr(newpath, '/');
+    if (!slash)
+        return -1;
+
+    width = slash - newpath;
+    if (width <= 0 || width > (int)sizeof(buf) - 1)
+        return -1;
+
+    memcpy(buf, newpath, width);
+    buf[width] = 0;
+    ret = mkdir_recursive(buf, 0755);
+    if (ret)
+    {
+        ERROR("Failed to create directory %s: %s (%d)\n", buf, strerror(errno), errno);
+        return -1;
+    }
+
+    ret = symlink(oldpath, newpath);
+    if (ret && errno != EEXIST)
+    {
+        ERROR("Failed to symlink %s to %s: %s (%d)\n", oldpath, newpath, strerror(errno), errno);
+        return -1;
+    }
+    return 0;
+}
+
+void remove_link(const char *oldpath, const char *newpath)
+{
+    char path[256];
+    ssize_t ret;
+    ret = readlink(newpath, path, sizeof(path) - 1);
+    if (ret <= 0)
+        return;
+    path[ret] = 0;
+    if (!strcmp(path, oldpath))
+        unlink(newpath);
+}
+
+int wait_for_file(const char *filename, int timeout)
+{
+    struct stat info;
+    time_t timeout_time = gettime() + timeout;
+    int ret = -1;
+
+    while (gettime() < timeout_time && ((ret = stat(filename, &info)) < 0))
+        usleep(10000);
+
+    return ret;
+}
+
+int copy_file(const char *from, const char *to)
+{
+    FILE *in = fopen(from, "re");
+    if(!in)
+        return -1;
+
+    FILE *out = fopen(to, "we");
+    if(!out)
+    {
+        fclose(in);
+        return -1;
+    }
+
+    fseek(in, 0, SEEK_END);
+    int size = ftell(in);
+    rewind(in);
+
+    char *buff = malloc(size);
+    fread(buff, 1, size, in);
+    fwrite(buff, 1, size, out);
+
+    fclose(in);
+    fclose(out);
+    free(buff);
+    return 0;
+}
+
+int write_file(const char *path, const char *value)
+{
+    int fd, ret, len;
+
+    fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC, 0622);
+
+    if (fd < 0)
+    {
+        ERROR("Failed to open file %s (%d: %s)\n", path, errno, strerror(errno));
+        return -errno;
+    }
+
+    len = strlen(value);
+
+    do {
+        ret = write(fd, value, len);
+    } while (ret < 0 && errno == EINTR);
+
+    close(fd);
+    if (ret < 0) {
+        return -errno;
+    } else {
+        return 0;
+    }
+}
+
+int remove_dir(const char *dir)
+{
+    struct DIR *d = opendir(dir);
+    if(!d)
+        return -1;
+
+    struct dirent *dt;
+    int res = 0;
+
+    int dir_len = strlen(dir) + 1;
+    char *n = malloc(dir_len + 1);
+    strcpy(n, dir);
+    strcat(n, "/");
+
+    while(res == 0 && (dt = readdir(d)))
+    {
+        if(dt->d_name[0] == '.' && (dt->d_name[1] == '.' || dt->d_name[1] == 0))
+            continue;
+
+        n = realloc(n, dir_len + strlen(dt->d_name) + 1);
+        n[dir_len] = 0;
+        strcat(n, dt->d_name);
+
+        if(dt->d_type == DT_DIR)
+        {
+            if(remove_dir(n) < 0)
+                res = -1;
+        }
+        else
+        {
+            if(remove(n) < 0)
+                res = -1;
+        }
+    }
+
+    free(n);
+    closedir(d);
+
+    if(res == 0 && remove(dir) < 0)
+        res = -1;
+    return res;
+}
+
+void stdio_to_null(void)
+{
+    int fd = open("/dev/null", O_RDWR|O_CLOEXEC);
+    if(fd >= 0)
+    {
+        dup2(fd, 0);
+        dup2(fd, 1);
+        dup2(fd, 2);
+        close(fd);
+    }
+}
+
+int run_cmd(char **cmd)
+{
+    return run_cmd_with_env(cmd, NULL);
+}
+
+int run_cmd_with_env(char **cmd, char *const *envp)
+{
+    pid_t pID = vfork();
+    if(pID == 0)
+    {
+        stdio_to_null();
+        execve(cmd[0], cmd, envp);
+        _exit(127);
+    }
+    else
+    {
+        int status = 0;
+        waitpid(pID, &status, 0);
+        return status;
+    }
+}
+
+
+char *run_get_stdout(char **cmd)
+{
+    int exit_code;
+    return run_get_stdout_with_exit(cmd, &exit_code);
+}
+
+char *run_get_stdout_with_exit(char **cmd, int *exit_code)
+{
+    return run_get_stdout_with_exit_with_env(cmd, exit_code, NULL);
+}
+
+char *run_get_stdout_with_exit_with_env(char **cmd, int *exit_code, char *const *envp)
+{
+   int fd[2];
+   if(pipe2(fd, O_CLOEXEC) < 0)
+        return NULL;
+
+    pid_t pid = vfork();
+    if (pid < 0)
+    {
+        close(fd[0]);
+        close(fd[1]);
+        return NULL;
+    }
+
+    if(pid == 0) // child
+    {
+        close(fd[0]);
+        dup2(fd[1], 1);  // send stdout to the pipe
+        dup2(fd[1], 2);  // send stderr to the pipe
+        close(fd[1]);
+
+        execve(cmd[0], cmd, envp);
+        _exit(127);
+    }
+    else
+    {
+        close(fd[1]);
+
+        char *res = malloc(512);
+        char buffer[512];
+        int size = 512, written = 0, len;
+        while ((len = read(fd[0], buffer, sizeof(buffer))) > 0)
+        {
+            if(written + len + 1 > size)
+            {
+                size = written + len + 256;
+                res = realloc(res, size);
+            }
+            memcpy(res+written, buffer, len);
+            written += len;
+            res[written] = 0;
+        }
+
+        close(fd[0]);
+
+        waitpid(pid, exit_code, 0);
+
+        if(written == 0)
+        {
+            free(res);
+            return NULL;
+        }
+        return res;
+    }
+    return NULL;
+}
+
+int mr_system(const char *shell_fmt, ...)
+{
+    int ret;
+    char busybox_path[256];
+    char path[256];
+    char shell[256];
+    char *real_shell = NULL;
+    char *const cmd_envp[] = { path, NULL };
+    //               0            1     2     3
+    char *cmd[] = { busybox_path, "sh", "-c", NULL, NULL };
+
+    snprintf(path, sizeof(path), "PATH=%s:/sbin:/system/bin", mrom_dir());
+    snprintf(busybox_path, sizeof(busybox_path), "%s/busybox", mrom_dir());
+
+    va_list ap;
+    va_start(ap, shell_fmt);
+    ret = vsnprintf(shell, sizeof(shell), shell_fmt, ap);
+    if(ret < (int)sizeof(shell))
+        real_shell = shell;
+    else
+    {
+        real_shell = malloc(ret+1);
+        vsnprintf(real_shell, ret+1, shell_fmt, ap);
+    }
+    va_end(ap);
+
+    cmd[3] = real_shell;
+    ret = run_cmd_with_env(cmd, cmd_envp);
+
+    if(real_shell != shell)
+        free(real_shell);
+    return ret;
+}
+
+uint32_t timespec_diff(struct timespec *f, struct timespec *s)
+{
+    uint32_t res = 0;
+    if(s->tv_nsec-f->tv_nsec < 0)
+    {
+        res = (s->tv_sec-f->tv_sec-1)*1000;
+        res += 1000 + ((s->tv_nsec-f->tv_nsec)/1000000);
+    }
+    else
+    {
+        res = (s->tv_sec-f->tv_sec)*1000;
+        res += (s->tv_nsec-f->tv_nsec)/1000000;
+    }
+    return res;
+}
+
+int64_t timeval_us_diff(struct timeval now, struct timeval prev)
+{
+    return ((int64_t)(now.tv_sec - prev.tv_sec))*1000000+
+        (now.tv_usec - prev.tv_usec);
+}
+
+// Tries to recursively resolve symlinks. If lstat fails at some point,
+// presumably because the target does not exist, returns the last resolved path.
+char *readlink_recursive(const char *link)
+{
+    struct stat info;
+    if(lstat(link, &info) < 0 || !S_ISLNK(info.st_mode))
+        return strdup(link);
+
+    char path[256];
+    char buff[256];
+    char *p = (char*)link;
+
+    do
+    {
+        if(info.st_size >= sizeof(path)-1)
+        {
+            ERROR("readlink_recursive(): Couldn't resolve, too long path.\n");
+            return NULL;
+        }
+
+        if(readlink(p, buff, info.st_size) != info.st_size)
+        {
+            ERROR("readlink_recursive: readlink() failed on %s!\n", p);
+            return NULL;
+        }
+
+        buff[info.st_size] = 0;
+        strcpy(path, buff);
+        p = path;
+    }
+    while(lstat(buff, &info) >= 0 && S_ISLNK(info.st_mode));
+
+    return strdup(buff);
+}
+
+/* Check to see if /proc/mounts contains any writeable filesystems
+ * backed by a block device.
+ * Return true if none found, else return false.
+ */
+static int remount_ro_done(void)
+{
+    FILE *f;
+    char mount_dev[256];
+    char mount_dir[256];
+    char mount_type[256];
+    char mount_opts[256];
+    int mount_freq;
+    int mount_passno;
+    int match;
+    int found_rw_fs = 0;
+
+    f = fopen("/proc/mounts", "re");
+    if (! f) {
+        /* If we can't read /proc/mounts, just give up */
+        return 1;
+    }
+
+    do {
+        match = fscanf(f, "%255s %255s %255s %255s %d %d\n",
+                       mount_dev, mount_dir, mount_type,
+                       mount_opts, &mount_freq, &mount_passno);
+        mount_dev[255] = 0;
+        mount_dir[255] = 0;
+        mount_type[255] = 0;
+        mount_opts[255] = 0;
+        if ((match == 6) && !strncmp(mount_dev, "/dev/block", 10) && strstr(mount_opts, "rw")) {
+            found_rw_fs = 1;
+            break;
+        }
+    } while (match != EOF);
+
+    fclose(f);
+
+    return !found_rw_fs;
+}
+
+/* Remounting filesystems read-only is difficult when there are files
+ * opened for writing or pending deletes on the filesystem.  There is
+ * no way to force the remount with the mount(2) syscall.  The magic sysrq
+ * 'u' command does an emergency remount read-only on all writable filesystems
+ * that have a block device (i.e. not tmpfs filesystems) by calling
+ * emergency_remount(), which knows how to force the remount to read-only.
+ * Unfortunately, that is asynchronous, and just schedules the work and
+ * returns.  The best way to determine if it is done is to read /proc/mounts
+ * repeatedly until there are no more writable filesystems mounted on
+ * block devices.
+ */
+void emergency_remount_ro(void)
+{
+    int fd, cnt = 0;
+
+    sync();
+
+    /* Trigger the remount of the filesystems as read-only,
+     * which also marks them clean.
+     */
+    fd = open("/proc/sysrq-trigger", O_WRONLY|O_CLOEXEC);
+    if (fd < 0) {
+        return;
+    }
+    write(fd, "u", 1);
+    close(fd);
+
+
+    /* Now poll /proc/mounts till it's done */
+    while (!remount_ro_done() && (cnt < 3600)) {
+        usleep(100000);
+        cnt++;
+    }
+
+    return;
+}
+
+
+int imin(int a, int b)
+{
+    return (a < b) ? a : b;
+}
+
+int imax(int a, int b)
+{
+    return (a > b) ? a : b;
+}
+
+inline int iabs(int a)
+{
+    return a >= 0 ? a : -a;
+}
+
+int in_rect(int x, int y, int rx, int ry, int rw, int rh)
+{
+    if(x < rx || y < ry)
+        return 0;
+
+    if(x > rx+rw || y > ry+rh)
+        return 0;
+    return 1;
+}
+
+char *parse_string(char *src)
+{
+    char *start = strchr(src, '"');
+    char *end = strrchr(src, '"');
+
+    if(!start || start == end || start+1 == end)
+        return NULL;
+    ++start;
+    return strndup(start, end-start);
+}
+
+// alloc and fill with 0s
+void *mzalloc(size_t size)
+{
+    void *res = malloc(size);
+    memset(res, 0, size);
+    return res;
+}
+
+char *strtoupper(const char *str)
+{
+    int i;
+    const int len = strlen(str);
+    char *res = malloc(len + 1);
+    for(i = 0; i < len; ++i)
+    {
+        res[i] = str[i];
+        if(str[i] >= 'a' && str[i] <= 'z')
+            res[i] -= 'a'-'A';
+    }
+    res[i] = 0;
+    return res;
+}
+
+int strstartswith(const char *haystack, const char *needle)
+{
+    return strncmp(haystack, needle, strlen(needle)) == 0;
+}
+
+int strendswith(const char *haystack, const char *needle)
+{
+    size_t h_len = strlen(haystack);
+    size_t n_len = strlen(needle);
+    if(n_len == 0 || n_len > h_len)
+        return 0;
+    return strncmp(haystack + h_len - n_len, needle, n_len) == 0;
+}
+
+int create_loop_device(const char *dev_path, const char *img_path, int loop_num, int loop_chmod)
+{
+    int file_fd, device_fd, res = -1;
+
+    file_fd = open(img_path, O_RDWR | O_CLOEXEC);
+    if (file_fd < 0) {
+        ERROR("Failed to open image %s\n", img_path);
+        return -1;
+    }
+
+    INFO("create_loop_device: loop_num = %d", loop_num);
+
+    if(mknod(dev_path, S_IFBLK | loop_chmod, makedev(7, loop_num)) < 0)
+    {
+        if(errno != EEXIST)
+        {
+            ERROR("Failed to create loop file (%d: %s)\n", errno, strerror(errno));
+            goto close_file;
+        }
+        else
+            INFO("Loop file %s already exists, using it.\n", dev_path);
+    }
+
+    device_fd = open(dev_path, O_RDWR | O_CLOEXEC);
+    if (device_fd < 0)
+    {
+        ERROR("Failed to open loop file (%d: %s)\n", errno, strerror(errno));
+        goto close_file;
+    }
+
+    if (ioctl(device_fd, LOOP_SET_FD, file_fd) < 0)
+    {
+        ERROR("ioctl LOOP_SET_FD failed on %s (%d: %s)\n", dev_path, errno, strerror(errno));
+        goto close_dev;
+    }
+
+    res = 0;
+close_dev:
+    close(device_fd);
+close_file:
+    close(file_fd);
+    return res;
+}
+
+#define MAX_LOOP_NUM 1023
+int mount_image(const char *src, const char *dst, const char *fs, int flags, const void *data)
+{
+    char path[64];
+    int device_fd;
+    int loop_num = 0;
+    int res = -1;
+    struct stat info;
+    struct loop_info64 lo_info;
+
+    for(; loop_num < MAX_LOOP_NUM; ++loop_num)
+    {
+        sprintf(path, "/dev/block/loop%d", loop_num);
+        if(stat(path, &info) < 0)
+        {
+            if(errno == ENOENT)
+                break;
+        }
+        else if(S_ISBLK(info.st_mode) && (device_fd = open(path, O_RDWR | O_CLOEXEC)) >= 0)
+        {
+            int ioctl_res = ioctl(device_fd, LOOP_GET_STATUS64, &lo_info);
+            close(device_fd);
+
+            if (ioctl_res < 0 && errno == ENXIO)
+                break;
+        }
+    }
+
+    if(loop_num == MAX_LOOP_NUM)
+    {
+        ERROR("mount_image: failed to find suitable loop device number!");
+        return -1;
+    }
+
+    if(create_loop_device(path, src, loop_num, 0777) < 0)
+        return -1;
+
+    if(mount(path, dst, fs, flags, data) < 0)
+        ERROR("Failed to mount loop (%d: %s)\n", errno, strerror(errno));
+    else
+        res = 0;
+
+    return res;
+}
+
+void do_reboot(int type)
+{
+    sync();
+    emergency_remount_ro();
+
+    switch(type)
+    {
+        default:
+        case REBOOT_SYSTEM:
+            android_reboot(ANDROID_RB_RESTART, 0, 0);
+            break;
+        case REBOOT_RECOVERY:
+            android_reboot(ANDROID_RB_RESTART2, 0, "recovery");
+            break;
+        case REBOOT_BOOTLOADER:
+            android_reboot(ANDROID_RB_RESTART2, 0, "bootloader");
+            break;
+        case REBOOT_SHUTDOWN:
+            android_reboot(ANDROID_RB_POWEROFF, 0, 0);
+            break;
+    }
+
+    while(1);
+}
diff --git a/lib/util.h b/lib/util.h
index f606f72..a5d0138 100755
--- a/lib/util.h
+++ b/lib/util.h
@@ -1,75 +1,75 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _INIT_UTIL_H_
-#define _INIT_UTIL_H_
-
-#include <unistd.h>
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/time.h>
-#include <time.h>
-
-#define UNUSED __attribute__((unused))
-
-#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
-
-#define REBOOT_SYSTEM 0
-#define REBOOT_RECOVERY 1
-#define REBOOT_BOOTLOADER 2
-#define REBOOT_SHUTDOWN 3
-
-time_t gettime(void);
-unsigned int decode_uid(const char *s);
-int mkdir_recursive(const char *pathname, mode_t mode);
-int mkdir_recursive_with_perms(const char *pathname, mode_t mode, const char *owner, const char *group);
-void sanitize(char *p);
-int make_link(const char *oldpath, const char *newpath);
-void remove_link(const char *oldpath, const char *newpath);
-int wait_for_file(const char *filename, int timeout);
-int copy_file(const char *from, const char *to);
-int copy_dir(const char *from, const char *to);
-int mkdir_with_perms(const char *path, mode_t mode, const char *owner, const char *group);
-int write_file(const char *path, const char *value);
-int remove_dir(const char *dir);
-int run_cmd(char **cmd);
-int run_cmd_with_env(char **cmd, char *const *envp);
-char *run_get_stdout(char **cmd);
-char *run_get_stdout_with_exit(char **cmd, int *exit_code);
-char *run_get_stdout_with_exit_with_env(char **cmd, int *exit_code, char *const *envp);
-char *readlink_recursive(const char *link);
-void stdio_to_null();
-char *parse_string(char *src);
-uint32_t timespec_diff(struct timespec *f, struct timespec *s);
-inline int64_t timeval_us_diff(struct timeval now, struct timeval prev);
-void emergency_remount_ro(void);
-int create_loop_device(const char *dev_path, const char *img_path, int loop_num, int loop_chmod);
-int mount_image(const char *src, const char *dst, const char *fs, int flags, const void *data);
-void do_reboot(int type);
-int mr_system(const char *shell_fmt, ...);
-
-inline int imin(int a, int b);
-inline int imax(int a, int b);
-inline int iabs(int a);
-inline int in_rect(int x, int y, int rx, int ry, int rw, int rh);
-
-inline void *mzalloc(size_t size); // alloc and fill with 0s
-char *strtoupper(const char *str);
-int strstartswith(const char *haystack, const char *needle);
-int strendswith(const char *haystack, const char *needle);
-
-#endif
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INIT_UTIL_H_
+#define _INIT_UTIL_H_
+
+#include <unistd.h>
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+
+#define UNUSED __attribute__((unused))
+
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
+
+#define REBOOT_SYSTEM 0
+#define REBOOT_RECOVERY 1
+#define REBOOT_BOOTLOADER 2
+#define REBOOT_SHUTDOWN 3
+
+time_t gettime(void);
+unsigned int decode_uid(const char *s);
+int mkdir_recursive(const char *pathname, mode_t mode);
+int mkdir_recursive_with_perms(const char *pathname, mode_t mode, const char *owner, const char *group);
+void sanitize(char *p);
+int make_link(const char *oldpath, const char *newpath);
+void remove_link(const char *oldpath, const char *newpath);
+int wait_for_file(const char *filename, int timeout);
+int copy_file(const char *from, const char *to);
+int copy_dir(const char *from, const char *to);
+int mkdir_with_perms(const char *path, mode_t mode, const char *owner, const char *group);
+int write_file(const char *path, const char *value);
+int remove_dir(const char *dir);
+int run_cmd(char **cmd);
+int run_cmd_with_env(char **cmd, char *const *envp);
+char *run_get_stdout(char **cmd);
+char *run_get_stdout_with_exit(char **cmd, int *exit_code);
+char *run_get_stdout_with_exit_with_env(char **cmd, int *exit_code, char *const *envp);
+char *readlink_recursive(const char *link);
+void stdio_to_null();
+char *parse_string(char *src);
+uint32_t timespec_diff(struct timespec *f, struct timespec *s);
+inline int64_t timeval_us_diff(struct timeval now, struct timeval prev);
+void emergency_remount_ro(void);
+int create_loop_device(const char *dev_path, const char *img_path, int loop_num, int loop_chmod);
+int mount_image(const char *src, const char *dst, const char *fs, int flags, const void *data);
+void do_reboot(int type);
+int mr_system(const char *shell_fmt, ...);
+
+inline int imin(int a, int b);
+inline int imax(int a, int b);
+inline int iabs(int a);
+inline int in_rect(int x, int y, int rx, int ry, int rw, int rh);
+
+inline void *mzalloc(size_t size); // alloc and fill with 0s
+char *strtoupper(const char *str);
+int strstartswith(const char *haystack, const char *needle);
+int strendswith(const char *haystack, const char *needle);
+
+#endif
diff --git a/lib/velocity_tracker.c b/lib/velocity_tracker.c
index ed47336..8ba711e 100755
--- a/lib/velocity_tracker.c
+++ b/lib/velocity_tracker.c
@@ -1,75 +1,75 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <stdlib.h>
-
-#include <string.h>
-#include <malloc.h>
-
-#include "touch_tracker.h"
-#include "util.h"
-
-touch_tracker *touch_tracker_create(void)
-{
-    touch_tracker *t = mzalloc(sizeof(touch_tracker));
-    return t;
-}
-
-void touch_tracker_destroy(touch_tracker *t)
-{
-    free(t);
-}
-
-void touch_tracker_start(touch_tracker *t, touch_event *ev)
-{
-    t->distance_abs_x = t->distance_abs_y = 0;
-    t->start_x = ev->x;
-    t->start_y = ev->y;
-    t->last_x = ev->x;
-    t->last_y = ev->y;
-    memcpy(&v->time_start, &ev->time, sizeof(struct timeval));
-}
-
-void touch_tracker_finish(touch_tracker *t, touch_event *ev)
-{
-    t->distance_x = ev->x - t->start_x;
-    t->distance_y = ev->y - t->start_y;
-    t->period = timeval_us_diff(ev->time, t->time_start);
-}
-
-void touch_tracker_add(touch_tracker *t, touch_event *ev)
-{
-    t->distance_abs_x += iabs(ev->x - t->last_x);
-    t->distance_abs_y += iabs(ev->y - t->last_y);
-    t->last_x = ev->x;
-    t->last_y = ev->y;
-}
-
-float touch_tracker_get_velocity(touch_tracker *t, int axis)
-{
-    if(axis == TRACKER_X)
-        return ((((float)t->distance_x) / t->period) * 1000000) / DPI_MUL;
-    else
-        return ((((float)t->distance_y) / t->period) * 1000000) / DPI_MUL;
-}
-
-float touch_tracker_get_velocity_abs(touch_tracker *t, int axis)
-{
-    if(axis == TRACKER_X)
-        return ((((float)t->distance_abs_x) / t->period) * 1000000) / DPI_MUL;
-    else
-        return ((((float)t->distance_abs_y) / t->period) * 1000000) / DPI_MUL;
-}
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+
+#include <string.h>
+#include <malloc.h>
+
+#include "touch_tracker.h"
+#include "util.h"
+
+touch_tracker *touch_tracker_create(void)
+{
+    touch_tracker *t = mzalloc(sizeof(touch_tracker));
+    return t;
+}
+
+void touch_tracker_destroy(touch_tracker *t)
+{
+    free(t);
+}
+
+void touch_tracker_start(touch_tracker *t, touch_event *ev)
+{
+    t->distance_abs_x = t->distance_abs_y = 0;
+    t->start_x = ev->x;
+    t->start_y = ev->y;
+    t->last_x = ev->x;
+    t->last_y = ev->y;
+    memcpy(&v->time_start, &ev->time, sizeof(struct timeval));
+}
+
+void touch_tracker_finish(touch_tracker *t, touch_event *ev)
+{
+    t->distance_x = ev->x - t->start_x;
+    t->distance_y = ev->y - t->start_y;
+    t->period = timeval_us_diff(ev->time, t->time_start);
+}
+
+void touch_tracker_add(touch_tracker *t, touch_event *ev)
+{
+    t->distance_abs_x += iabs(ev->x - t->last_x);
+    t->distance_abs_y += iabs(ev->y - t->last_y);
+    t->last_x = ev->x;
+    t->last_y = ev->y;
+}
+
+float touch_tracker_get_velocity(touch_tracker *t, int axis)
+{
+    if(axis == TRACKER_X)
+        return ((((float)t->distance_x) / t->period) * 1000000) / DPI_MUL;
+    else
+        return ((((float)t->distance_y) / t->period) * 1000000) / DPI_MUL;
+}
+
+float touch_tracker_get_velocity_abs(touch_tracker *t, int axis)
+{
+    if(axis == TRACKER_X)
+        return ((((float)t->distance_abs_x) / t->period) * 1000000) / DPI_MUL;
+    else
+        return ((((float)t->distance_abs_y) / t->period) * 1000000) / DPI_MUL;
+}
diff --git a/lib/workers.c b/lib/workers.c
index a6a01ce..cd65e49 100755
--- a/lib/workers.c
+++ b/lib/workers.c
@@ -1,155 +1,155 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <pthread.h>
-#include <stdlib.h>
-#include <unistd.h>
-
-#include <string.h>
-#include <malloc.h>
-
-#include "util.h"
-#include "workers.h"
-#include "log.h"
-#include "containers.h"
-
-struct worker
-{
-    void *data;
-    worker_call call;
-};
-
-struct worker_thread
-{
-    pthread_t thread;
-    pthread_mutex_t mutex;
-    struct worker **workers;
-    volatile int run;
-};
-
-static struct worker_thread worker_thread = {
-    .mutex = PTHREAD_MUTEX_INITIALIZER,
-    .workers = NULL,
-    .run = 0,
-};
-
-#define SLEEP_CONST 10
-static void *worker_thread_work(void *data)
-{
-    struct worker_thread *t = (struct worker_thread*)data;
-    struct worker **w;
-
-    struct timespec last, curr;
-    uint32_t diff = 0, prev_sleep = 0;
-    clock_gettime(CLOCK_MONOTONIC, &last);
-
-    while(t->run)
-    {
-        pthread_mutex_lock(&t->mutex);
-
-        clock_gettime(CLOCK_MONOTONIC, &curr);
-        diff = timespec_diff(&last, &curr);
-
-        for(w = t->workers; w && *w;)
-        {
-            if((*w)->call(diff, (*w)->data))
-                w = list_rm_at(&worker_thread.workers, w - t->workers, &free);
-            else
-                ++w;
-        }
-
-        pthread_mutex_unlock(&t->mutex);
-
-        last = curr;
-        if(diff <= SLEEP_CONST+prev_sleep)
-        {
-            prev_sleep = SLEEP_CONST+prev_sleep-diff;
-            usleep(prev_sleep*1000);
-        }
-        else
-            prev_sleep = 0;
-    }
-    return NULL;
-}
-
-void workers_start(void)
-{
-    if(worker_thread.run != 0)
-        return;
-
-    worker_thread.run = 1;
-    pthread_create(&worker_thread.thread, NULL, worker_thread_work, &worker_thread);
-}
-
-void workers_stop(void)
-{
-    if(worker_thread.run != 1)
-        return;
-
-    worker_thread.run = 0;
-    pthread_join(worker_thread.thread, NULL);
-
-    list_clear(&worker_thread.workers, &free);
-}
-
-void workers_add(worker_call call, void *data)
-{
-    if(worker_thread.run != 1)
-    {
-        ERROR("workers: adding worker when the thread isn't running'\n");
-        return;
-    }
-
-    struct worker *w = mzalloc(sizeof(struct worker));
-    w->call = call;
-    w->data = data;
-
-    pthread_mutex_lock(&worker_thread.mutex);
-    list_add(&worker_thread.workers, w);
-    pthread_mutex_unlock(&worker_thread.mutex);
-}
-
-void workers_remove(worker_call call, void *data)
-{
-    if(worker_thread.run != 1)
-    {
-        ERROR("workers: removing worker when the thread isn't running'\n");
-        return;
-    }
-
-    pthread_mutex_lock(&worker_thread.mutex);
-    if(worker_thread.workers)
-    {
-        int i;
-        struct worker *w;
-        for(i = 0; worker_thread.workers[i]; ++i)
-        {
-            w = worker_thread.workers[i];
-            if(w->call == call && w->data == data)
-            {
-                list_rm_at(&worker_thread.workers, i, &free);
-                break;
-            }
-        }
-    }
-    pthread_mutex_unlock(&worker_thread.mutex);
-}
-
-pthread_t workers_get_thread_id(void)
-{
-    return worker_thread.thread;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <pthread.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <string.h>
+#include <malloc.h>
+
+#include "util.h"
+#include "workers.h"
+#include "log.h"
+#include "containers.h"
+
+struct worker
+{
+    void *data;
+    worker_call call;
+};
+
+struct worker_thread
+{
+    pthread_t thread;
+    pthread_mutex_t mutex;
+    struct worker **workers;
+    volatile int run;
+};
+
+static struct worker_thread worker_thread = {
+    .mutex = PTHREAD_MUTEX_INITIALIZER,
+    .workers = NULL,
+    .run = 0,
+};
+
+#define SLEEP_CONST 10
+static void *worker_thread_work(void *data)
+{
+    struct worker_thread *t = (struct worker_thread*)data;
+    struct worker **w;
+
+    struct timespec last, curr;
+    uint32_t diff = 0, prev_sleep = 0;
+    clock_gettime(CLOCK_MONOTONIC, &last);
+
+    while(t->run)
+    {
+        pthread_mutex_lock(&t->mutex);
+
+        clock_gettime(CLOCK_MONOTONIC, &curr);
+        diff = timespec_diff(&last, &curr);
+
+        for(w = t->workers; w && *w;)
+        {
+            if((*w)->call(diff, (*w)->data))
+                w = list_rm_at(&worker_thread.workers, w - t->workers, &free);
+            else
+                ++w;
+        }
+
+        pthread_mutex_unlock(&t->mutex);
+
+        last = curr;
+        if(diff <= SLEEP_CONST+prev_sleep)
+        {
+            prev_sleep = SLEEP_CONST+prev_sleep-diff;
+            usleep(prev_sleep*1000);
+        }
+        else
+            prev_sleep = 0;
+    }
+    return NULL;
+}
+
+void workers_start(void)
+{
+    if(worker_thread.run != 0)
+        return;
+
+    worker_thread.run = 1;
+    pthread_create(&worker_thread.thread, NULL, worker_thread_work, &worker_thread);
+}
+
+void workers_stop(void)
+{
+    if(worker_thread.run != 1)
+        return;
+
+    worker_thread.run = 0;
+    pthread_join(worker_thread.thread, NULL);
+
+    list_clear(&worker_thread.workers, &free);
+}
+
+void workers_add(worker_call call, void *data)
+{
+    if(worker_thread.run != 1)
+    {
+        ERROR("workers: adding worker when the thread isn't running'\n");
+        return;
+    }
+
+    struct worker *w = mzalloc(sizeof(struct worker));
+    w->call = call;
+    w->data = data;
+
+    pthread_mutex_lock(&worker_thread.mutex);
+    list_add(&worker_thread.workers, w);
+    pthread_mutex_unlock(&worker_thread.mutex);
+}
+
+void workers_remove(worker_call call, void *data)
+{
+    if(worker_thread.run != 1)
+    {
+        ERROR("workers: removing worker when the thread isn't running'\n");
+        return;
+    }
+
+    pthread_mutex_lock(&worker_thread.mutex);
+    if(worker_thread.workers)
+    {
+        int i;
+        struct worker *w;
+        for(i = 0; worker_thread.workers[i]; ++i)
+        {
+            w = worker_thread.workers[i];
+            if(w->call == call && w->data == data)
+            {
+                list_rm_at(&worker_thread.workers, i, &free);
+                break;
+            }
+        }
+    }
+    pthread_mutex_unlock(&worker_thread.mutex);
+}
+
+pthread_t workers_get_thread_id(void)
+{
+    return worker_thread.thread;
+}
diff --git a/lib/workers.h b/lib/workers.h
index 777b880..8b7e045 100755
--- a/lib/workers.h
+++ b/lib/workers.h
@@ -1,32 +1,32 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef WORKERS_H
-#define WORKERS_H
-
-#include <stdint.h>
-#include <pthread.h>
-
-typedef int (*worker_call)(uint32_t, void *); // ms_diff, data. Returns 1 if it should be removed
-
-void workers_start(void);
-void workers_stop(void);
-void workers_add(worker_call call, void *data);
-void workers_remove(worker_call call, void *data);
-pthread_t workers_get_thread_id(void);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef WORKERS_H
+#define WORKERS_H
+
+#include <stdint.h>
+#include <pthread.h>
+
+typedef int (*worker_call)(uint32_t, void *); // ms_diff, data. Returns 1 if it should be removed
+
+void workers_start(void);
+void workers_stop(void);
+void workers_add(worker_call call, void *data);
+void workers_remove(worker_call call, void *data);
+pthread_t workers_get_thread_id(void);
+
+#endif
diff --git a/main.c b/main.c
index 0668a91..7339cc2 100755
--- a/main.c
+++ b/main.c
@@ -1,114 +1,114 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <cutils/android_reboot.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <sys/mount.h>
-#include <string.h>
-#include <errno.h>
-#include <time.h>
-
-#include "multirom.h"
-#include "lib/framebuffer.h"
-#include "lib/log.h"
-#include "version.h"
-#include "lib/util.h"
-#include "lib/mrom_data.h"
-
-#define EXEC_MASK (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)
-#define KEEP_REALDATA "/dev/.keep_realdata"
-#define REALDATA "/realdata"
-
-
-static void do_kexec(void)
-{
-    emergency_remount_ro();
-
-    execl("/kexec", "/kexec", "-e", NULL);
-
-    ERROR("kexec -e failed! (%d: %s)", errno, strerror(errno));
-    while(1);
-}
-
-int main(int argc, const char *argv[])
-{
-    int i;
-    const char *rom_to_boot = NULL;
-
-    for(i = 1; i < argc; ++i)
-    {
-        if(strcmp(argv[i], "-v") == 0)
-        {
-            printf("%d%s\n", VERSION_MULTIROM, VERSION_DEV_FIX);
-            fflush(stdout);
-            return 0;
-        }
-        else if(strncmp(argv[i], "--boot-rom=", sizeof("--boot-rom")) == 0)
-        {
-            rom_to_boot = argv[i] + sizeof("--boot-rom");
-        }
-    }
-
-    srand(time(0));
-    klog_init();
-
-    // output all messages to dmesg,
-    // but it is possible to filter out INFO messages
-    klog_set_level(6);
-
-    mrom_set_log_tag("multirom");
-
-    ERROR("Running MultiROM v%d%s\n", VERSION_MULTIROM, VERSION_DEV_FIX);
-
-    // root is mounted read only in android and MultiROM uses
-    // it to store some temp files, so remount it.
-    // Yes, there is better solution to this.
-    if(rom_to_boot)
-        mount(NULL, "/", NULL, MS_REMOUNT, NULL);
-
-    int exit = multirom(rom_to_boot);
-
-    if(rom_to_boot)
-        mount(NULL, "/", NULL, MS_RDONLY | MS_REMOUNT, NULL);
-
-    if(exit >= 0)
-    {
-        if(exit & EXIT_REBOOT_RECOVERY)
-            do_reboot(REBOOT_RECOVERY);
-        else if(exit & EXIT_REBOOT_BOOTLOADER)
-            do_reboot(REBOOT_BOOTLOADER);
-        else if(exit & EXIT_SHUTDOWN)
-            do_reboot(REBOOT_SHUTDOWN);
-        else if(exit & EXIT_REBOOT)
-            do_reboot(REBOOT_SYSTEM);
-
-        if(exit & EXIT_KEXEC)
-        {
-            do_kexec();
-            return 0;
-        }
-
-        // indicates trampoline to keep /realdata mounted
-        if(!(exit & EXIT_UMOUNT))
-            close(open(KEEP_REALDATA, O_WRONLY | O_CREAT, 0000));
-    }
-
-    return 0;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <cutils/android_reboot.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <sys/mount.h>
+#include <string.h>
+#include <errno.h>
+#include <time.h>
+
+#include "multirom.h"
+#include "lib/framebuffer.h"
+#include "lib/log.h"
+#include "version.h"
+#include "lib/util.h"
+#include "lib/mrom_data.h"
+
+#define EXEC_MASK (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)
+#define KEEP_REALDATA "/dev/.keep_realdata"
+#define REALDATA "/realdata"
+
+
+static void do_kexec(void)
+{
+    emergency_remount_ro();
+
+    execl("/kexec", "/kexec", "-e", NULL);
+
+    ERROR("kexec -e failed! (%d: %s)", errno, strerror(errno));
+    while(1);
+}
+
+int main(int argc, const char *argv[])
+{
+    int i;
+    const char *rom_to_boot = NULL;
+
+    for(i = 1; i < argc; ++i)
+    {
+        if(strcmp(argv[i], "-v") == 0)
+        {
+            printf("%d%s\n", VERSION_MULTIROM, VERSION_DEV_FIX);
+            fflush(stdout);
+            return 0;
+        }
+        else if(strncmp(argv[i], "--boot-rom=", sizeof("--boot-rom")) == 0)
+        {
+            rom_to_boot = argv[i] + sizeof("--boot-rom");
+        }
+    }
+
+    srand(time(0));
+    klog_init();
+
+    // output all messages to dmesg,
+    // but it is possible to filter out INFO messages
+    klog_set_level(6);
+
+    mrom_set_log_tag("multirom");
+
+    ERROR("Running MultiROM v%d%s\n", VERSION_MULTIROM, VERSION_DEV_FIX);
+
+    // root is mounted read only in android and MultiROM uses
+    // it to store some temp files, so remount it.
+    // Yes, there is better solution to this.
+    if(rom_to_boot)
+        mount(NULL, "/", NULL, MS_REMOUNT, NULL);
+
+    int exit = multirom(rom_to_boot);
+
+    if(rom_to_boot)
+        mount(NULL, "/", NULL, MS_RDONLY | MS_REMOUNT, NULL);
+
+    if(exit >= 0)
+    {
+        if(exit & EXIT_REBOOT_RECOVERY)
+            do_reboot(REBOOT_RECOVERY);
+        else if(exit & EXIT_REBOOT_BOOTLOADER)
+            do_reboot(REBOOT_BOOTLOADER);
+        else if(exit & EXIT_SHUTDOWN)
+            do_reboot(REBOOT_SHUTDOWN);
+        else if(exit & EXIT_REBOOT)
+            do_reboot(REBOOT_SYSTEM);
+
+        if(exit & EXIT_KEXEC)
+        {
+            do_kexec();
+            return 0;
+        }
+
+        // indicates trampoline to keep /realdata mounted
+        if(!(exit & EXIT_UMOUNT))
+            close(open(KEEP_REALDATA, O_WRONLY | O_CREAT, 0000));
+    }
+
+    return 0;
+}
diff --git a/multirom.c b/multirom.c
index e5ab00c..f9bba42 100755
--- a/multirom.c
+++ b/multirom.c
@@ -1,2558 +1,2558 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <string.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <sys/mount.h>
-#include <sys/klog.h>
-#include <linux/loop.h>
-#include <ctype.h>
-#include <unistd.h>
-
-
-#include <malloc.h>
-
-// clone libbootimg to /system/extras/ from
-// https://github.com/Tasssadar/libbootimg.git
-#include <libbootimg.h>
-
-#if LIBBOOTIMG_VERSION  < 0x000200
-#error "libbootimg version 0.2.0 or higher is required. Please update libbootimg."
-#endif
-
-#include "lib/containers.h"
-#include "lib/framebuffer.h"
-#include "lib/inject.h"
-#include "lib/input.h"
-#include "lib/log.h"
-#include "lib/util.h"
-#include "lib/mrom_data.h"
-#include "multirom.h"
-#include "multirom_ui.h"
-#include "version.h"
-#include "hooks.h"
-#include "rom_quirks.h"
-#include "kexec.h"
-
-#define REALDATA "/realdata"
-#define BUSYBOX_BIN "busybox"
-#define KEXEC_BIN "kexec"
-#define NTFS_BIN "ntfs-3g"
-#define EXFAT_BIN "exfat-fuse"
-#define INTERNAL_ROM_NAME "Internal"
-#define MAX_ROM_NAME_LEN 26
-#define LAYOUT_VERSION "/data/.layout_version"
-
-#define BATTERY_CAP "/sys/class/power_supply/battery/capacity"
-
-static char busybox_path[64] = { 0 };
-static char kexec_path[64] = { 0 };
-static char ntfs_path[64] = { 0 };
-static char exfat_path[64] = { 0 };
-static char partition_dir[64] = { 0 };
-
-static volatile int run_usb_refresh = 0;
-static pthread_t usb_refresh_thread;
-static pthread_mutex_t parts_mutex = PTHREAD_MUTEX_INITIALIZER;
-static void (*usb_refresh_handler)(void) = NULL;
-
-int multirom_find_base_dir(void)
-{
-    int i;
-    struct stat info;
-
-    static const char *paths[] = {
-        REALDATA"/media/0/multirom", // 4.2
-        REALDATA"/media/multirom",
-        "/data/media/0/multirom",
-        "/data/media/multirom",
-        NULL,
-    };
-
-    for(i = 0; paths[i]; ++i)
-    {
-        if(stat(paths[i], &info) < 0)
-            continue;
-
-        mrom_set_dir(paths[i]);
-
-        strncpy(partition_dir, paths[i], strchr(paths[i]+1, '/') - paths[i]);
-
-        sprintf(busybox_path, "%s/%s", paths[i], BUSYBOX_BIN);
-        sprintf(kexec_path, "%s/%s", paths[i], KEXEC_BIN);
-        sprintf(ntfs_path, "%s/%s", paths[i], NTFS_BIN);
-        sprintf(exfat_path, "%s/%s", paths[i], EXFAT_BIN);
-
-        chmod(kexec_path, 0755);
-        chmod(ntfs_path, 0755);
-        chmod(exfat_path, 0755);
-        return 0;
-    }
-    return -1;
-}
-
-int multirom(const char *rom_to_boot)
-{
-    if(multirom_find_base_dir() == -1)
-    {
-        ERROR("Could not find multirom dir\n");
-        return -1;
-    }
-
-    struct multirom_status s;
-    memset(&s, 0, sizeof(struct multirom_status));
-
-    multirom_load_status(&s);
-    multirom_dump_status(&s);
-
-    struct multirom_rom *to_boot = NULL;
-    int exit = (EXIT_REBOOT | EXIT_UMOUNT);
-
-    if(rom_to_boot != NULL)
-    {
-        struct multirom_rom *rom = multirom_get_rom(&s, rom_to_boot, NULL);
-        if(rom)
-        {
-            // Two possible scenarios: this ROM has kexec-hardboot and target
-            // ROM has boot image, so kexec it immediatelly or
-            // reboot and then proceed as usuall
-            if(((M(rom->type) & MASK_KEXEC) || rom->has_bootimg) && rom->type != ROM_DEFAULT && multirom_has_kexec())
-            {
-                to_boot = rom;
-                s.is_second_boot = 0;
-                INFO("Booting ROM %s...\n", rom_to_boot);
-            }
-            else
-            {
-                s.current_rom = rom;
-                s.auto_boot_type |= AUTOBOOT_FORCE_CURRENT;
-                INFO("Setting ROM %s to force autoboot\n", rom_to_boot);
-            }
-        }
-        else
-        {
-            ERROR("ROM %s was not found, force autoboot was not set!\n", rom_to_boot);
-            exit = EXIT_UMOUNT;
-        }
-    }
-    else if(s.is_second_boot != 0 || (s.auto_boot_type & AUTOBOOT_FORCE_CURRENT))
-    {
-        ERROR("Skipping ROM selection, is_second_boot=%d, auto_boot_type=0x%x\n", s.is_second_boot, s.auto_boot_type);
-        to_boot = s.current_rom;
-    }
-    else
-    {
-        // just to cache the result so that it does not take
-        // any time when the UI is up
-        multirom_has_kexec();
-
-        switch(multirom_ui(&s, &to_boot))
-        {
-            case UI_EXIT_BOOT_ROM: break;
-            case UI_EXIT_REBOOT:
-                exit = (EXIT_REBOOT | EXIT_UMOUNT);
-                break;
-            case UI_EXIT_REBOOT_RECOVERY:
-                exit = (EXIT_REBOOT_RECOVERY | EXIT_UMOUNT);
-                break;
-            case UI_EXIT_REBOOT_BOOTLOADER:
-                exit = (EXIT_REBOOT_BOOTLOADER | EXIT_UMOUNT);
-                break;
-            case UI_EXIT_SHUTDOWN:
-                exit = (EXIT_SHUTDOWN | EXIT_UMOUNT);
-                break;
-        }
-    }
-
-    if(to_boot)
-    {
-        s.auto_boot_type &= ~(AUTOBOOT_FORCE_CURRENT);
-
-        if(rom_to_boot == NULL)
-            multirom_run_scripts("run-on-boot", to_boot);
-
-        exit = multirom_prepare_for_boot(&s, to_boot);
-
-        // Something went wrong, exit/reboot
-        if(exit == -1)
-        {
-            if(rom_to_boot == NULL)
-            {
-                multirom_emergency_reboot();
-                exit = EXIT_REBOOT;
-            }
-            else
-                exit = EXIT_UMOUNT;
-            goto finish;
-        }
-
-        s.current_rom = to_boot;
-
-        free(s.curr_rom_part);
-        s.curr_rom_part = NULL;
-
-        if(to_boot->partition)
-            s.curr_rom_part = strdup(to_boot->partition->uuid);
-
-        if(s.is_second_boot == 0 && (M(to_boot->type) & MASK_ANDROID) && (exit & EXIT_KEXEC))
-        {
-            s.is_second_boot = 1;
-
-            // mrom_kexecd=1 param might be lost if kernel does not have kexec patches
-            ERROR(SECOND_BOOT_KMESG);
-        }
-        else
-            s.is_second_boot = 0;
-    }
-
-finish:
-    multirom_save_status(&s);
-    multirom_free_status(&s);
-
-    sync();
-
-    return exit;
-}
-
-int multirom_init_fb(int rotation)
-{
-    if(fb_open(rotation) < 0)
-    {
-        ERROR("Failed to open framebuffer!\n");
-        return -1;
-    }
-
-    fb_fill(BLACK);
-    return 0;
-}
-
-void multirom_emergency_reboot(void)
-{
-    char *klog;
-    fb_text_proto *p;
-    fb_img *t;
-    char *tail;
-    char *last_end;
-    int cur_y;
-    unsigned int media_rw_id;
-
-    if(multirom_init_fb(0) < 0)
-    {
-        ERROR("Failed to init framebuffer in emergency reboot\n");
-        return;
-    }
-    fb_set_background(BLACK);
-
-    klog = multirom_get_klog();
-
-    t = fb_add_text(0, 120, WHITE, SIZE_NORMAL,
-                "An error occured.\nShutting down MultiROM to avoid data corruption.\n"
-                "Report this error to the developer!\nDebug info: /sdcard/multirom_log.txt\n\n"
-                "Press POWER button to reboot.");
-
-    t = fb_add_text(0, t->y + t->h + 100*DPI_MUL, GRAYISH, SIZE_SMALL, "Last lines from klog:");
-    fb_add_rect(0, t->y + t->h + 5*DPI_MUL, fb_width, 1, GRAYISH);
-
-    tail = klog+strlen(klog);
-    last_end = tail;
-    cur_y = fb_height;
-    const int start_y = (t->y + t->h + 2);
-    while(tail > klog)
-    {
-        --tail;
-        if(*tail == '\n')
-        {
-            p = fb_text_create(0, cur_y, GRAYISH, 4*4, NULL);
-            p->text = malloc(last_end - tail);
-            memcpy(p->text, tail + 1, last_end - (tail + 1));
-            p->text[last_end - (tail + 1)] = 0;
-            p->style = STYLE_MONOSPACE;
-            t = fb_text_finalize(p);
-
-            cur_y -= t->h;
-            t->y = cur_y;
-            last_end = tail;
-
-            if(cur_y < start_y)
-            {
-                fb_rm_text(t);
-                break;
-            }
-        }
-    }
-
-    fb_force_draw();
-
-    multirom_copy_log(klog, "../multirom_log.txt");
-    free(klog);
-
-    media_rw_id = decode_uid("media_rw");
-    if(media_rw_id != -1U)
-        chown("../multirom_log.txt", (uid_t)media_rw_id, (gid_t)media_rw_id);
-    chmod("../multirom_log.txt", 0666);
-
-    // Wait for power key
-    start_input_thread();
-    while(wait_for_key() != KEY_POWER);
-    stop_input_thread();
-
-    fb_clear();
-    fb_close();
-}
-
-static int find_idx(int c)
-{
-    static const char *capital = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-    static const char *normal  = "abcdefghijklmnopqrstuvwxyz";
-
-    char *p;
-    if((p = strchr(capital, c)))
-        return p - capital;
-    else if((p = strchr(normal, c)))
-        return p - normal;
-
-    return -128 + c;
-}
-
-static int compare_rom_names(const void *a, const void *b)
-{
-    struct multirom_rom *rom_a = *((struct multirom_rom **)a);
-    struct multirom_rom *rom_b = *((struct multirom_rom **)b);
-
-    if(rom_a->type == ROM_DEFAULT)
-        return -1;
-    else if(rom_b->type == ROM_DEFAULT)
-        return 1;
-
-    char *itr_a = rom_a->name;
-    char *itr_b = rom_b->name;
-
-    while(1)
-    {
-        if(*itr_a == 0)
-            return -1;
-        else if(*itr_b == 0)
-            return 1;
-
-        if(*itr_a == *itr_b)
-        {
-            ++itr_a;
-            ++itr_b;
-            continue;
-        }
-
-        int idx_a = find_idx(*itr_a);
-        int idx_b = find_idx(*itr_b);
-
-        if(idx_a == idx_b)
-        {
-            ++itr_a;
-            ++itr_b;
-            continue;
-        }
-
-        return idx_a < idx_b ? -1 : 1;
-    }
-    return 0;
-}
-
-int multirom_default_status(struct multirom_status *s)
-{
-    s->is_second_boot = 0;
-    s->current_rom = NULL;
-    s->roms = NULL;
-    s->colors = 0;
-    s->brightness = MULTIROM_DEFAULT_BRIGHTNESS;
-    s->enable_adb = 0;
-    s->rotation = MULTIROM_DEFAULT_ROTATION;
-    s->anim_duration_coef = 1.f;
-
-    s->fstab = fstab_auto_load();
-    if(!s->fstab)
-        return -1;
-
-    char roms_path[256];
-    sprintf(roms_path, "%s/roms/"INTERNAL_ROM_NAME, mrom_dir());
-    DIR *d = opendir(roms_path);
-    if(!d)
-    {
-        ERROR("Failed to open Internal ROM's folder, creating one with ROM from internal memory...\n");
-        multirom_import_internal();
-    }
-    else
-        closedir(d);
-
-    sprintf(roms_path, "%s/roms", mrom_dir());
-    d = opendir(roms_path);
-    if(!d)
-    {
-        ERROR("Failed to open roms dir!\n");
-        return -1;
-    }
-
-    struct dirent *dr;
-    char path[256];
-    struct multirom_rom **add_roms = NULL;
-    while((dr = readdir(d)))
-    {
-        if(dr->d_name[0] == '.')
-            continue;
-
-        if(dr->d_type != DT_DIR)
-            continue;
-
-        if(strlen(dr->d_name) > MAX_ROM_NAME_LEN)
-        {
-            ERROR("Skipping ROM %s, name is too long (max %d chars allowed)\n", dr->d_name, MAX_ROM_NAME_LEN);
-            continue;
-        }
-
-        INFO("Adding ROM %s\n", dr->d_name);
-
-        struct multirom_rom *rom = malloc(sizeof(struct multirom_rom));
-        memset(rom, 0, sizeof(struct multirom_rom));
-
-        rom->id = multirom_generate_rom_id();
-        rom->name = strdup(dr->d_name);
-
-        snprintf(path, sizeof(path), "%s/%s", roms_path, rom->name);
-        rom->base_path = strdup(path);
-
-        rom->type = multirom_get_rom_type(rom);
-
-        snprintf(path, sizeof(path), "%s/boot.img", rom->base_path);
-        rom->has_bootimg = access(path, R_OK) == 0 ? 1 : 0;
-
-        multirom_find_rom_icon(rom);
-
-        list_add(&add_roms, rom);
-    }
-
-    closedir(d);
-
-    if(add_roms)
-    {
-        // sort roms
-        qsort(add_roms, list_item_count(add_roms), sizeof(struct multirom_rom*), compare_rom_names);
-
-        // add them to main list
-        list_swap(&add_roms, &s->roms);
-    }
-
-    s->current_rom = multirom_get_internal(s);
-    if(!s->current_rom)
-    {
-        ERROR("No internal rom found!\n");
-        return -1;
-    }
-
-    s->auto_boot_rom = s->current_rom;
-    s->auto_boot_seconds = 5;
-    s->auto_boot_type = AUTOBOOT_NAME;
-
-    return 0;
-}
-
-int multirom_load_status(struct multirom_status *s)
-{
-    INFO("Loading MultiROM status...\n");
-
-    multirom_default_status(s);
-
-    if(mrom_is_second_boot())
-        s->is_second_boot = 1;
-
-    // is_second_boot might be reset later, but we need to know if this
-    // is second boot when filling in kexec info
-    s->is_running_in_primary_rom = !s->is_second_boot;
-
-    char arg[256];
-    sprintf(arg, "%s/multirom.ini", mrom_dir());
-
-    FILE *f = fopen(arg, "re");
-    if(!f)
-    {
-        ERROR("Failed to open config file, using defaults!\n");
-        return -1;
-    }
-
-    char line[1024];
-    char current_rom[256] = { 0 };
-    char auto_boot_rom[256] = { 0 };
-
-    char name[64];
-    char *pch;
-
-    while((fgets(line, sizeof(line), f)))
-    {
-        pch = strtok (line, "=\n");
-        if(!pch) continue;
-        strcpy(name, pch);
-        pch = strtok (NULL, "=\n");
-        if(!pch) continue;
-        strcpy(arg, pch);
-
-        if(strstr(name, "current_rom"))
-            strcpy(current_rom, arg);
-        else if(strstr(name, "auto_boot_seconds"))
-            s->auto_boot_seconds = atoi(arg);
-        else if(strstr(name, "auto_boot_rom"))
-            strcpy(auto_boot_rom, arg);
-        else if(strstr(name, "auto_boot_type"))
-            s->auto_boot_type = atoi(arg);
-        else if(strstr(name, "curr_rom_part"))
-            s->curr_rom_part = strdup(arg);
-        else if(strstr(name, "colors_v2"))
-            s->colors = atoi(arg);
-        else if(strstr(name, "brightness"))
-            s->brightness = atoi(arg);
-        else if(strstr(name, "enable_adb"))
-            s->enable_adb = atoi(arg);
-        else if(strstr(name, "hide_internal"))
-            s->hide_internal = atoi(arg);
-        else if(strstr(name, "int_display_name"))
-            s->int_display_name = strdup(arg);
-        else if(strstr(name, "rotation"))
-            s->rotation = atoi(arg);
-        else if(strstr(name, "force_generic_fb"))
-            s->force_generic_fb = atoi(arg);
-        else if(strstr(name, "anim_duration_coef_pct"))
-            s->anim_duration_coef = ((float)atoi(arg)) / 100;
-    }
-
-    fclose(f);
-
-    // find USB drive if we're booting from it
-    if(s->curr_rom_part && s->is_second_boot)
-    {
-        struct usb_partition *p = NULL;
-        int tries = 0;
-        while(!p && tries < 10)
-        {
-            multirom_update_partitions(s);
-            p = multirom_get_partition(s, s->curr_rom_part);
-
-            if(p)
-            {
-                multirom_scan_partition_for_roms(s, p);
-                break;
-            }
-
-            ++tries;
-            ERROR("part %s not found, waiting 1s (%d)\n", s->curr_rom_part, tries);
-            sleep(1);
-        }
-    }
-
-    s->current_rom = multirom_get_rom(s, current_rom, s->curr_rom_part);
-    if(!s->current_rom)
-    {
-        ERROR("Failed to select current rom (%s, part %s), using Internal!\n", current_rom, s->curr_rom_part);
-        s->current_rom = multirom_get_internal(s);
-        if(!s->current_rom)
-        {
-            ERROR("No internal rom found!\n");
-            return -1;
-        }
-    }
-
-    if((s->auto_boot_type & AUTOBOOT_LAST) && !s->curr_rom_part)
-    {
-        s->auto_boot_rom = s->current_rom;
-    }
-    else
-    {
-        s->auto_boot_rom = multirom_get_rom(s, auto_boot_rom, NULL);
-        if(!s->auto_boot_rom)
-            ERROR("Could not find rom %s to auto-boot\n", auto_boot_rom);
-    }
-
-    if(s->int_display_name)
-    {
-        struct multirom_rom *r = multirom_get_internal(s);
-        r->name = realloc(r->name, strlen(s->int_display_name)+1);
-        strcpy(r->name, s->int_display_name);
-    }
-
-    fb_force_generic_impl(s->force_generic_fb);
-
-    if(s->anim_duration_coef == 0)
-        s->anim_duration_coef = 1.f;
-
-    return 0;
-}
-
-int multirom_save_status(struct multirom_status *s)
-{
-    INFO("Saving multirom status\n");
-
-    char path[256];
-    char auto_boot_name[MAX_ROM_NAME_LEN+1];
-    char current_name[MAX_ROM_NAME_LEN+1];
-
-    snprintf(path, sizeof(path), "%s/multirom.ini", mrom_dir());
-
-    FILE *f = fopen(path, "we");
-    if(!f)
-    {
-        ERROR("Failed to open/create status file!\n");
-        return -1;
-    }
-
-    multirom_fixup_rom_name(s->auto_boot_rom, auto_boot_name, "");
-    multirom_fixup_rom_name(s->current_rom, current_name, INTERNAL_ROM_NAME);
-
-    fprintf(f, "current_rom=%s\n", current_name);
-    fprintf(f, "auto_boot_seconds=%d\n", s->auto_boot_seconds);
-    fprintf(f, "auto_boot_rom=%s\n", auto_boot_name);
-    fprintf(f, "auto_boot_type=%d\n", s->auto_boot_type);
-    fprintf(f, "curr_rom_part=%s\n", s->curr_rom_part ? s->curr_rom_part : "");
-    fprintf(f, "colors_v2=%d\n", s->colors);
-    fprintf(f, "brightness=%d\n", s->brightness);
-    fprintf(f, "enable_adb=%d\n", s->enable_adb);
-    fprintf(f, "hide_internal=%d\n", s->hide_internal);
-    fprintf(f, "int_display_name=%s\n", s->int_display_name ? s->int_display_name : "");
-    fprintf(f, "rotation=%d\n", s->rotation);
-    fprintf(f, "force_generic_fb=%d\n", s->force_generic_fb);
-    fprintf(f, "anim_duration_coef_pct=%d\n", (int)(s->anim_duration_coef*100));
-
-    fclose(f);
-    return 0;
-}
-
-void multirom_fixup_rom_name(struct multirom_rom *rom, char *name, const char *def)
-{
-    if(rom)
-    {
-        if(rom->type == ROM_DEFAULT)
-            strcpy(name, INTERNAL_ROM_NAME);
-        else
-            strcpy(name, rom->name);
-    }
-    else
-    {
-        strcpy(name, def);
-    }
-}
-
-void multirom_dump_status(struct multirom_status *s)
-{
-    INFO("Dumping multirom status:\n");
-    INFO("  is_second_boot=%d\n", s->is_second_boot);
-    INFO("  is_running_in_primary_rom=%d\n", s->is_running_in_primary_rom);
-    INFO("  current_rom=%s\n", s->current_rom ? s->current_rom->name : "NULL");
-    INFO("  colors_v2=%d\n", s->colors);
-    INFO("  brightness=%d\n", s->brightness);
-    INFO("  enable_adb=%d\n", s->enable_adb);
-    INFO("  rotation=%d\n", s->rotation);
-    INFO("  force_generic_fb=%d\n", s->force_generic_fb);
-    INFO("  anim_duration_coef=%f\n", s->anim_duration_coef);
-    INFO("  hide_internal=%d\n", s->hide_internal);
-    INFO("  int_display_name=%s\n", s->int_display_name ? s->int_display_name : "NULL");
-    INFO("  auto_boot_seconds=%d\n", s->auto_boot_seconds);
-    INFO("  auto_boot_rom=%s\n", s->auto_boot_rom ? s->auto_boot_rom->name : "NULL");
-    INFO("  auto_boot_type=%d\n", s->auto_boot_type);
-    INFO("  curr_rom_part=%s\n", s->curr_rom_part ? s->curr_rom_part : "NULL");
-    INFO("\n");
-
-    int i;
-    for(i = 0; s->roms && s->roms[i]; ++i)
-    {
-        INFO("  ROM: %s\n", s->roms[i]->name);
-        INFO("    base_path: %s\n", s->roms[i]->base_path);
-        INFO("    icon_path: %s\n", s->roms[i]->icon_path);
-        INFO("    type: %d\n", s->roms[i]->type);
-        INFO("    has_bootimg: %d\n", s->roms[i]->has_bootimg);
-        if(s->roms[i]->partition)
-            INFO("    partition: %s (%s)\n", s->roms[i]->partition->name, s->roms[i]->partition->fs);
-    }
-}
-
-void multirom_free_status(struct multirom_status *s)
-{
-    list_clear(&s->partitions, &multirom_destroy_partition);
-    list_clear(&s->roms, &multirom_free_rom);
-    free(s->curr_rom_part);
-    free(s->int_display_name);
-    fstab_destroy(s->fstab);
-}
-
-void multirom_free_rom(void *rom)
-{
-    free(((struct multirom_rom*)rom)->name);
-    free(((struct multirom_rom*)rom)->base_path);
-    free(((struct multirom_rom*)rom)->icon_path);
-    free(rom);
-}
-
-void multirom_find_usb_roms(struct multirom_status *s)
-{
-    // remove USB roms
-    int i;
-    for(i = 0; s->roms && s->roms[i];)
-    {
-        if(s->roms[i]->partition)
-        {
-            list_rm_at(&s->roms, i, &multirom_free_rom);
-            i = 0;
-        }
-        else ++i;
-    }
-
-    char path[256];
-    struct usb_partition *p;
-
-    pthread_mutex_lock(&parts_mutex);
-    for(i = 0; s->partitions && s->partitions[i]; ++i)
-        multirom_scan_partition_for_roms(s, s->partitions[i]);
-    pthread_mutex_unlock(&parts_mutex);
-
-    multirom_dump_status(s);
-}
-
-int multirom_scan_partition_for_roms(struct multirom_status *s, struct usb_partition *p)
-{
-    char path[256];
-    int i;
-    struct dirent *dr;
-    struct multirom_rom **add_roms = NULL;
-
-#ifdef MR_MOVE_USB_DIR
-    // groupers will have old "multirom" folder on USB drive instead of "multirom-grouper".
-    // We have to move it.
-    sprintf(path, "%s/multirom", p->mount_path);
-    if(access(path, F_OK) >= 0)
-    {
-        char dest[256];
-        sprintf(dest, "%s/multirom-"TARGET_DEVICE, p->mount_path);
-
-        INFO("Moving usb dir %s to %s!\n", path, dest);
-
-        mkdir(dest, 0777);
-
-        char *cmd[] = { busybox_path, "sh", "-c", malloc(1024), NULL };
-        sprintf(cmd[3], "%s mv \"%s\"/* \"%s\"/", busybox_path, path, dest);
-
-        run_cmd(cmd);
-
-        rmdir(path);
-        free(cmd[3]);
-
-        sync();
-    }
-#endif
-
-    sprintf(path, "%s/multirom-"TARGET_DEVICE, p->mount_path);
-    if(access(path, F_OK) < 0)
-        return -1;
-
-    DIR *d = opendir(path);
-    if(!d)
-        return -1;
-
-    while((dr = readdir(d)) != NULL)
-    {
-        if(dr->d_name[0] == '.')
-            continue;
-
-        struct multirom_rom *rom = malloc(sizeof(struct multirom_rom));
-        memset(rom, 0, sizeof(struct multirom_rom));
-
-        rom->id = multirom_generate_rom_id();
-        rom->name = strdup(dr->d_name);
-
-        sprintf(path, "%s/multirom-"TARGET_DEVICE"/%s", p->mount_path, rom->name);
-        rom->base_path = strdup(path);
-
-        rom->partition = p;
-        rom->type = multirom_get_rom_type(rom);
-
-        sprintf(path, "%s/boot.img", rom->base_path);
-        rom->has_bootimg = access(path, R_OK) == 0 ? 1 : 0;
-
-        multirom_find_rom_icon(rom);
-
-        list_add(&add_roms, rom);
-    }
-    closedir(d);
-
-    if(add_roms)
-    {
-        // sort roms
-        qsort(add_roms, list_item_count(add_roms), sizeof(struct multirom_rom*), compare_rom_names);
-
-        list_add_from_list(&s->roms, add_roms);
-        list_clear(&add_roms, NULL);
-    }
-    return 0;
-}
-
-int multirom_path_exists(char *base, char *filename)
-{
-    char path[256];
-    sprintf(path, "%s/%s", base, filename);
-    if(access(path, R_OK) < 0)
-        return -1;
-    return 0;
-}
-
-int multirom_get_rom_type(struct multirom_rom *rom)
-{
-    if(!rom->partition && strcmp(rom->name, INTERNAL_ROM_NAME) == 0)
-        return ROM_DEFAULT;
-
-    char *b = rom->base_path;
-
-    // Handle android ROMs
-    if(!multirom_path_exists(b, "boot"))
-    {
-        if (!multirom_path_exists(b, "system") && !multirom_path_exists(b, "data") &&
-            !multirom_path_exists(b, "cache"))
-        {
-            if(!rom->partition) return ROM_ANDROID_INTERNAL;
-            else                return ROM_ANDROID_USB_DIR;
-        }
-        else if(!multirom_path_exists(b, "system.img") && !multirom_path_exists(b, "data.img") &&
-                !multirom_path_exists(b, "cache.img"))
-        {
-            return ROM_ANDROID_USB_IMG;
-        }
-    }
-
-    // handle linux ROMs
-    if(!multirom_path_exists(b, "rom_info.txt"))
-    {
-        if(!rom->partition)
-            return ROM_LINUX_INTERNAL;
-        else
-            return ROM_LINUX_USB;
-    }
-
-    // Handle Ubuntu 13.04 - deprecated
-    if ((!multirom_path_exists(b, "root") && multirom_path_exists(b, "boot.img")) ||
-       (!multirom_path_exists(b, "root.img") && rom->partition))
-    {
-        // try to copy rom_info.txt in there, ubuntu is deprecated
-        ERROR("Found deprecated Ubuntu 13.04, trying to copy rom_info.txt...\n");
-        char *cmd[] = { busybox_path, "cp", malloc(256), malloc(256), NULL };
-        sprintf(cmd[2], "%s/infos/ubuntu.txt", mrom_dir());
-        sprintf(cmd[3], "%s/rom_info.txt", b);
-
-        int res = run_cmd(cmd);
-
-        free(cmd[2]);
-        free(cmd[3]);
-
-        if(res != 0)
-        {
-            ERROR("Failed to copy rom_info for Ubuntu!\n");
-            if(!rom->partition) return ROM_UNSUPPORTED_INT;
-            else                return ROM_UNSUPPORTED_USB;
-        }
-        else
-        {
-            if(!rom->partition) return ROM_LINUX_INTERNAL;
-            else                return ROM_LINUX_USB;
-        }
-    }
-
-    // Handle ubuntu 12.10
-    if(!multirom_path_exists(b, "root") && !multirom_path_exists(b, "boot.img"))
-    {
-        if(!rom->partition) return ROM_UNSUPPORTED_INT;
-        else                return ROM_UNSUPPORTED_USB;
-    }
-
-    return ROM_UNKNOWN;
-}
-
-void multirom_import_internal(void)
-{
-    char path[256];
-
-    // multirom
-    mkdir(mrom_dir(), 0777);
-
-    // roms
-    snprintf(path, sizeof(path), "%s/roms", mrom_dir());
-    mkdir(path, 0777);
-
-    // internal rom
-    snprintf(path, sizeof(path), "%s/roms/%s", mrom_dir(), INTERNAL_ROM_NAME);
-    mkdir(path, 0777);
-
-    // set default icon if it doesn't exist yet
-    snprintf(path, sizeof(path), "%s/roms/%s/.icon_data", mrom_dir(), INTERNAL_ROM_NAME);
-    if(access(path, F_OK) < 0)
-    {
-        FILE *f = fopen(path, "we");
-        if(f)
-        {
-            fputs("predef_set\ncom.tassadar.multirommgr:drawable/romic_android\n", f);
-            fclose(f);
-        }
-    }
-}
-
-struct multirom_rom *multirom_get_internal(struct multirom_status *s)
-{
-    int i;
-    for(i = 0; s->roms && s->roms[i]; ++i)
-    {
-        if(s->roms[i]->type == ROM_DEFAULT)
-            return s->roms[i];
-    }
-    ERROR(" Something is wrong, multirom_get_internal returns NULL!\n");
-    return NULL;
-}
-
-struct multirom_rom *multirom_get_rom(struct multirom_status *s, const char *name, const char *part_uuid)
-{
-    if(part_uuid == NULL && strcmp(name, INTERNAL_ROM_NAME) == 0)
-        return multirom_get_internal(s);
-
-    int i = 0;
-    struct multirom_rom *r;
-    for(; s->roms && s->roms[i]; ++i)
-    {
-        r = s->roms[i];
-        if (r->type != ROM_DEFAULT && strcmp(r->name, name) == 0 &&
-           (!part_uuid || (r->partition && strcmp(r->partition->uuid, part_uuid) == 0)))
-        {
-            return r;
-        }
-    }
-
-    return NULL;
-}
-
-int multirom_generate_rom_id(void)
-{
-    static int id = 0;
-    return id++;
-}
-
-struct multirom_rom *multirom_get_rom_by_id(struct multirom_status *s, int id)
-{
-    int i = 0;
-    for(; s->roms && s->roms[i]; ++i)
-        if(s->roms[i]->id == id)
-            return s->roms[i];
-    return NULL;
-}
-
-int multirom_prepare_for_boot(struct multirom_status *s, struct multirom_rom *to_boot)
-{
-    int exit = EXIT_UMOUNT;
-    int type = to_boot->type;
-
-    if(((M(type) & MASK_KEXEC) || to_boot->has_bootimg) && type != ROM_DEFAULT && s->is_second_boot == 0)
-    {
-        if(multirom_load_kexec(s, to_boot) != 0)
-            return -1;
-        exit |= EXIT_KEXEC;
-    }
-
-    switch(type)
-    {
-        case ROM_DEFAULT:
-        {
-            rom_quirks_on_initrd_finalized();
-            break;
-        }
-        case ROM_LINUX_INTERNAL:
-        case ROM_LINUX_USB:
-            break;
-        case ROM_ANDROID_USB_IMG:
-        case ROM_ANDROID_USB_DIR:
-        case ROM_ANDROID_INTERNAL:
-        {
-            if(!(exit & (EXIT_REBOOT | EXIT_KEXEC)))
-            {
-                exit &= ~(EXIT_UMOUNT);
-
-                if(multirom_prep_android_mounts(s, to_boot) == -1)
-                    return -1;
-
-                if(multirom_create_media_link(s) == -1)
-                    return -1;
-
-                rom_quirks_on_initrd_finalized();
-
-                rcadditions_write_to_files(&s->rc);
-                rcadditions_free(&s->rc);
-            }
-
-            if(to_boot->partition)
-                to_boot->partition->keep_mounted = 1;
-            break;
-        }
-        default:
-            ERROR("Unknown ROM type\n");
-            return -1;
-    }
-
-    return exit;
-}
-
-#define EXEC_MASK (S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP)
-
-char *multirom_find_fstab_in_rc(const char *rcfile)
-{
-    FILE *f = fopen(rcfile, "re");
-    if(!f)
-    {
-        ERROR("Failed to open rcfile %s\n", rcfile);
-        return NULL;
-    }
-
-    char *p,*e;
-    char line[1024];
-    while(fgets(line, sizeof(line), f))
-    {
-        for(p = line; isspace(*p); ++p) { }
-
-        for(e = p+strlen(p)-1; isspace(*e); --e)
-            *e = 0;
-
-        if(*p == '#' || *p == 0)
-            continue;
-
-        if(strstr(p, "mount_all") == p)
-        {
-            fclose(f);
-
-            p += sizeof("mount_all")-1;
-            for(; isspace(*p); ++p) { }
-
-            return strdup(p);
-        }
-    }
-    fclose(f);
-    return NULL;
-}
-
-// On L dev preview and presumably later android releases, the firmware image
-// has mount option "context=...", which sets SELinux context for that whole
-// mount. It needs initialized SELinux in order to successfully mount, which
-// means it can't be done while in multirom (SELinux is initalized in real
-// init, after multirom exits). Workaround as follows:
-//  * inject 'start mrom_fw_mounter' before mount_all command in .rc file
-//  * append service mrom_fw_mounter block into said .rc file. This service
-//    starts binary 'fw_mounter', which is part of MultiROM and it just
-//    mounts the FW image file.
-//  * Copy fw_mounter to /sbin/ and setup its fstab
-//  * Real init starts mrom_fw_mounter service which mounts the image
-//
-// SELinux compains about the fw_mounter not having context set, but it still
-// works. There is a chance Google will disable all services which don't have
-// context set in sepolicy. That will be a problem.
-
-// UPDATE: fw_mounter gets shut down by SELinux on 6.0, inject .rc files and file_contexts instead.
-
-static int multirom_inject_fw_mounter(struct multirom_status *s, struct fstab_part *fw_part)
-{
-    char buf[512];
-
-    rcadditions_append_contexts(&s->rc, fw_part->device);
-    rcadditions_append_contexts(&s->rc, " u:object_r:asec_image_file:s0\n");
-
-    snprintf(buf, sizeof(buf), "    restorecon %s\n", fw_part->device);
-    rcadditions_append_trigger(&s->rc, "fs", buf);
-
-    snprintf(buf, sizeof(buf), "    mount %s loop@%s %s ", fw_part->type, fw_part->device, fw_part->path);
-    rcadditions_append_trigger(&s->rc, "fs", buf);
-
-    if(fw_part->options_raw)
-    {
-        char *c, *opts = strdup(fw_part->options_raw);
-        for(c = opts; *c; ++c)
-            if(*c == ',')
-                *c = ' ';
-        rcadditions_append_trigger(&s->rc, "fs", opts);
-        free(opts);
-    }
-
-    rcadditions_append_trigger(&s->rc, "fs", "\n");
-    return 0;
-}
-
-int multirom_prep_android_mounts(struct multirom_status *s, struct multirom_rom *rom)
-{
-    char in[128];
-    char out[128];
-    char path[256];
-    char *fstab_name = NULL;
-    int has_fw = 0;
-    struct fstab_part *fw_part = NULL;
-    int res = -1;
-
-    sprintf(path, "%s/firmware.img", rom->base_path);
-    has_fw = (access(path, R_OK) >= 0);
-
-    sprintf(path, "%s/boot", rom->base_path);
-
-    DIR *d = opendir(path);
-    if(!d)
-    {
-        ERROR("Failed to open rom path %s\n", path);
-        return -1;
-    }
-
-    struct dirent *dp = NULL;
-
-    while((dp = readdir(d)))
-    {
-        if(dp->d_name[0] == '.' && (dp->d_name[1] == '.' || dp->d_name[1] == 0))
-            continue;
-
-        sprintf(in, "%s/%s", path, dp->d_name);
-        sprintf(out, "/%s", dp->d_name);
-
-        copy_file(in, out);
-
-        if(strstr(dp->d_name, ".rc"))
-        {
-            // set permissions for .rc files
-            chmod(out, EXEC_MASK);
-
-            if(!fstab_name && strcmp(dp->d_name, "init."TARGET_DEVICE".rc") == 0)
-                fstab_name = multirom_find_fstab_in_rc(out);
-        }
-    }
-    closedir(d);
-
-    if(multirom_process_android_fstab(fstab_name, has_fw, &fw_part) != 0)
-        goto exit;
-
-    mkdir_with_perms("/system", 0755, NULL, NULL);
-    mkdir_with_perms("/data", 0771, "system", "system");
-    mkdir_with_perms("/cache", 0770, "system", "cache");
-    if(has_fw)
-        mkdir_with_perms("/firmware", 0771, "system", "system");
-
-    static const char *folders[2][3] =
-    {
-        { "system", "data", "cache" },
-        { "system.img", "data.img", "cache.img" },
-    };
-
-    unsigned long flags[2][3] = {
-        { MS_BIND | MS_RDONLY, MS_BIND, MS_BIND },
-        { MS_RDONLY | MS_NOATIME, MS_NOATIME, MS_NOATIME },
-    };
-
-    uint32_t i;
-    char from[256];
-    char to[256];
-    int img = (int)(rom->type == ROM_ANDROID_USB_IMG);
-    for(i = 0; i < ARRAY_SIZE(folders[0]); ++i)
-    {
-        snprintf(from, sizeof(from), "%s/%s", rom->base_path, folders[img][i]);
-        snprintf(to, sizeof(to), "/%s", folders[0][i]);
-
-        if(img == 0)
-        {
-            if(mount(from, to, "ext4", flags[img][i], "discard,nomblk_io_submit") < 0)
-            {
-                ERROR("Failed to mount %s to %s (%d: %s)\n", from, to, errno, strerror(errno));
-                goto exit;
-            }
-        }
-        else
-        {
-            if(mount_image(from, to, "ext4", flags[img][i], NULL) < 0)
-                goto exit;
-        }
-    }
-
-    if(has_fw && fw_part)
-    {
-        INFO("Mounting ROM's FW image instead of FW partition\n");
-        snprintf(from, sizeof(from), "%s/firmware.img", rom->base_path);
-        fw_part->device = realloc(fw_part->device, strlen(from)+1);
-        strcpy(fw_part->device, from);
-        multirom_inject_fw_mounter(s, fw_part);
-    }
-
-#if MR_DEVICE_HOOKS >= 1
-    int hooks_res = mrom_hook_after_android_mounts(busybox_path, rom->base_path, rom->type);
-    if(hooks_res < 0)
-    {
-        ERROR("mrom_hook_after_android_mounts returned %d!\n", hooks_res);
-        goto exit;
-    }
-#endif
-
-    res = 0;
-exit:
-    if(fw_part)
-        fstab_destroy_part(fw_part);
-    return res;
-}
-
-int multirom_process_android_fstab(char *fstab_name, int has_fw, struct fstab_part **fw_part)
-{
-    int res = -1;
-
-    if(fstab_name != NULL)
-        INFO("Using fstab %s from rc files\n", fstab_name);
-    else
-    {
-        DIR *d = opendir("/");
-        if(!d)
-        {
-            ERROR("Failed to open root folder!\n");
-            return -1;
-        }
-
-        struct dirent *dp = NULL;
-        while((dp = readdir(d)))
-        {
-            if(strstr(dp->d_name, "fstab.") == dp->d_name && strcmp(dp->d_name, "fstab.goldfish") != 0)
-            {
-                fstab_name = realloc(fstab_name, strlen(dp->d_name)+1);
-                strcpy(fstab_name, dp->d_name);
-                // try to find specifically fstab.device
-                if(strcmp(fstab_name, "fstab."TARGET_DEVICE) == 0)
-                    break;
-            }
-        }
-        closedir(d);
-
-        if(!fstab_name)
-        {
-            ERROR("Failed to find fstab file in root!\n");
-            return -1;
-        }
-    }
-
-    ERROR("Modifying fstab: %s\n", fstab_name);
-    struct fstab *tab = fstab_load(fstab_name, 0);
-    if(!tab)
-        goto exit;
-
-    int disable_sys = fstab_disable_parts(tab, "/system");
-    int disable_data = fstab_disable_parts(tab, "/data");
-    int disable_cache = fstab_disable_parts(tab, "/cache");
-
-    if(disable_sys < 0 || disable_data < 0 || disable_cache < 0)
-    {
-#if MR_DEVICE_HOOKS >= 4
-        if(!mrom_hook_allow_incomplete_fstab())
-#endif
-        {
-            goto exit;
-        }
-    }
-
-    if(has_fw)
-    {
-        struct fstab_part *p = fstab_find_first_by_path(tab, "/firmware");
-        if(p)
-        {
-            *fw_part = fstab_clone_part(p);
-            p->disabled = 1;
-        }
-    }
-
-    // Android considers empty fstab invalid
-    if(tab->count <= 3 + has_fw)
-    {
-        INFO("fstab would be empty, adding dummy line\n");
-        fstab_add_part(tab, "tmpfs", "/dummy_tmpfs", "tmpfs", "ro,nosuid,nodev", "defaults");
-        mkdir("/dummy_tmpfs", 0644);
-    }
-
-    if(fstab_save(tab, fstab_name) == 0)
-        res = 0;
-
-exit:
-    if(tab)
-        fstab_destroy(tab);
-    free(fstab_name);
-    return res;
-}
-
-int multirom_create_media_link(struct multirom_status *s)
-{
-    int media_new = 0;
-    int api_level = multirom_get_api_level("/system/build.prop");
-    if(api_level <= 0)
-        return -1;
-
-    struct stat info;
-    if(stat(REALDATA"/media/0", &info) >= 0)
-        media_new = 1;
-
-    static const char *paths[] = {
-        REALDATA"/media",      // 0
-        REALDATA"/media/0",    // 1
-
-        "/data/media",         // 2
-        "/data/media/0",       // 3
-    };
-
-    int from, to;
-
-    if(api_level <= 16)
-    {
-        to = 2;
-        if(!media_new) from = 0;
-        else           from = 1;
-    }
-    else if(api_level >= 17)
-    {
-        from = 0;
-        if(!media_new) to = 3;
-        else           to = 2;
-    }
-
-    ERROR("Making media dir: api %d, media_new %d, %s to %s\n", api_level, media_new, paths[from], paths[to]);
-    if(mkdir_recursive(paths[to], 0775) == -1)
-    {
-        ERROR("Failed to make media dir\n");
-        return -1;
-    }
-
-    if(mount(paths[from], paths[to], "ext4", MS_BIND, "") < 0)
-    {
-        ERROR("Failed to bind media folder %d (%s)\n", errno, strerror(errno));
-        return -1;
-    }
-
-    if(api_level >= 17)
-    {
-        char buf[16];
-        buf[0] = 0;
-
-        FILE *f = fopen(LAYOUT_VERSION, "re");
-        const int rewrite = (!f || !fgets(buf, sizeof(buf), f) || atoi(buf) < 2);
-
-        if(f)
-            fclose(f);
-
-        if(rewrite)
-        {
-            f = fopen(LAYOUT_VERSION, "we");
-            if(!f)
-            {
-                ERROR("Failed to create .layout_version!\n");
-                return -1;
-            }
-
-            fputc(api_level > 19 ? '3' : '2', f);
-            fclose(f);
-            chmod(LAYOUT_VERSION, 0600);
-        }
-
-        // We need to set SELinux context for this file in case it was created by multirom,
-        // but can't do it here because selinux was not initialized
-        rcadditions_append_trigger(&s->rc, "post-fs-data", "    restorecon " LAYOUT_VERSION "\n");
-    }
-
-    return 0;
-}
-
-int multirom_get_api_level(const char *path)
-{
-    FILE *f = fopen(path, "re");
-    if(!f)
-    {
-        ERROR("Could not open %s to read api level!\n", path);
-        return -1;
-    }
-
-    int res = -1;
-    char line[256];
-    while(res == -1 && (fgets(line, sizeof(line), f)))
-    {
-        if(strstr(line, "ro.build.version.sdk=") == line)
-            res = atoi(strchr(line, '=')+1);
-    }
-    fclose(f);
-
-    if(res == 0)
-        ERROR("Invalid ro.build.version.sdk line in build.prop\n");
-
-    return res;
-}
-
-int multirom_get_trampoline_ver(void)
-{
-    static int ver = -2;
-    if(ver == -2)
-    {
-        ver = -1;
-
-        char buff[128];
-        char *cmd[] = { buff, "-v", NULL };
-
-        // If we are booting into another ROM from already running system,
-        // /main_init was moved to /init and we have to use trampoline from
-        // /data/media
-        if(access("/main_init", F_OK) >= 0)
-            snprintf(buff, sizeof(buff), "/init");
-        else
-            snprintf(buff, sizeof(buff), "%s/trampoline", mrom_dir());
-
-        char *res = run_get_stdout(cmd);
-        if(res)
-        {
-            ver = atoi(res);
-            free(res);
-        }
-        else
-        {
-            ERROR("Failed to get trampoline version, run_get_stdout returned NULL!\n");
-        }
-    }
-    return ver;
-}
-
-int multirom_has_kexec(void)
-{
-    static int has_kexec = -1;
-    if(has_kexec != -1)
-        return has_kexec;
-
-#if MR_DEVICE_HOOKS >= 5
-    has_kexec = mrom_hook_has_kexec();
-#endif
-
-    if(has_kexec == -1)
-    {
-        if(access("/proc/config.gz", F_OK) >= 0)
-        {
-            char *cmd_cp[] = { busybox_path, "cp", "/proc/config.gz", "/ikconfig.gz", NULL };
-            run_cmd(cmd_cp);
-
-            char *cmd_gzip[] = { busybox_path, "gzip", "-d", "/ikconfig.gz", NULL };
-            run_cmd(cmd_gzip);
-
-            has_kexec = 1;
-
-            uint32_t i;
-            static const char *checks[] = {
-                "CONFIG_KEXEC_HARDBOOT=y",
-#ifndef MR_KEXEC_DTB
-                "CONFIG_ATAGS_PROC=y",
-#else
-                "CONFIG_PROC_DEVICETREE=y",
-#endif
-            };
-            //                   0             1       2     3
-            char *cmd_grep[] = { busybox_path, "grep", NULL, "/ikconfig", NULL };
-            for(i = 0; i < ARRAY_SIZE(checks); ++i)
-            {
-                cmd_grep[2] = (char*)checks[i];
-                if(run_cmd(cmd_grep) != 0)
-                {
-                    has_kexec = 0;
-                    ERROR("%s not found in /proc/config.gz!\n", checks[i]);
-                }
-            }
-
-            remove("/ikconfig");
-        }
-        else
-        {
-            // Kernel without /proc/config.gz enabled - check for /proc/atags file,
-            // if it is present, there is good change kexec-hardboot is enabled too.
-            ERROR("/proc/config.gz is not available!\n");
-#ifndef MR_KEXEC_DTB
-            const char *checkfile = "/proc/atags";
-#else
-            const char *checkfile = "/proc/device-tree";
-#endif
-            if(access(checkfile, R_OK) < 0)
-            {
-                ERROR("%s was not found!\n", checkfile);
-                has_kexec = 0;
-            }
-            else
-                has_kexec = 1;
-        }
-    }
-
-    if(has_kexec && mr_system("%s -u", kexec_path) != 0)
-    {
-        ERROR("kexec -u test has failed, kernel doesn't have kexec-hardboot patch enabled in config!\n");
-        has_kexec = 0;
-    }
-
-    return has_kexec;
-}
-
-int multirom_get_bootloader_cmdline(struct multirom_status *s, char *str, size_t size)
-{
-    FILE *f;
-    char *c, *e, *l;
-    int res = -1;
-    int bootimg_loaded = 0;
-    struct boot_img_hdr hdr;
-    struct fstab_part *boot;
-
-    f = fopen("/proc/cmdline", "re");
-    if(!f)
-        return -1;
-
-    str[0] = 0;
-
-    if(fgets(str, size, f) == NULL)
-        goto exit;
-
-    for(c = str; *c; ++c)
-        if(*c == '\n')
-            *c = ' ';
-
-    // Remove the part from boot.img
-    if(s->is_running_in_primary_rom || !s->current_rom || !s->current_rom->has_bootimg)
-    {
-        boot = fstab_find_first_by_path(s->fstab, "/boot");
-        if(boot && libbootimg_load_header(&hdr, boot->device) >= 0)
-            bootimg_loaded = 1;
-    }
-    else
-    {
-        char buf[256];
-        snprintf(buf, sizeof(buf), "%s/boot.img", s->current_rom->base_path);
-        if(libbootimg_load_header(&hdr, buf) >= 0)
-            bootimg_loaded = 1;
-    }
-
-    if(bootimg_loaded)
-    {
-        l = (char*)hdr.cmdline;
-        hdr.cmdline[BOOT_ARGS_SIZE-1] = 0;
-
-#if MR_DEVICE_HOOKS >= 5
-        mrom_hook_fixup_bootimg_cmdline(l, BOOT_ARGS_SIZE);
-#endif
-
-        if(*l != 0 && (c = strstr(str, l)))
-        {
-            e = c + strlen(l);
-            if(*e == ' ')
-                ++e;
-            memmove(c, e, strlen(e)+1); // plus NULL
-        }
-    }
-
-    res = 0;
-exit:
-    fclose(f);
-    return res;
-}
-
-int multirom_find_file(char *res, const char *name_part, const char *path)
-{
-    DIR *d = opendir(path);
-    if(!d)
-        return -1;
-
-    int wild = 0;
-    int len = strlen(name_part);
-    char *name = (char*)name_part;
-    char *i;
-    if((i = strchr(name_part, '*')))
-    {
-        wild = 1;
-        name = strndup(name_part, i-name);
-    }
-
-    int ret= -1;
-    struct dirent *dr;
-    while(ret == -1 && (dr = readdir(d)))
-    {
-        if(dr->d_name[0] == '.')
-            continue;
-
-        if ((!wild && strcmp(dr->d_name, name)) ||
-           ((wild && !strstr(dr->d_name, name))))
-            continue;
-
-        sprintf(res, "%s/%s", path, dr->d_name);
-        ret = 0;
-    }
-    closedir(d);
-    if(wild)
-        free(name);
-    return ret;
-}
-
-int multirom_load_kexec(struct multirom_status *s, struct multirom_rom *rom)
-{
-    int res = -1;
-    struct kexec kexec;
-    int loop_mounted = 0;
-
-    // to find /data partition
-    if(!rom->partition && multirom_update_partitions(s) < 0)
-    {
-        ERROR("Failed to update partitions\n");
-        return -1;
-    }
-
-    kexec_init(&kexec, kexec_path);
-    kexec_add_arg(&kexec, "--mem-min="MR_KEXEC_MEM_MIN);
-#ifdef MR_KEXEC_DTB
-    kexec_add_arg_prefix(&kexec, "--boardname=", TARGET_DEVICE);
-#endif
-
-    switch(rom->type)
-    {
-        case ROM_ANDROID_INTERNAL:
-        case ROM_ANDROID_USB_DIR:
-        case ROM_ANDROID_USB_IMG:
-            if(multirom_fill_kexec_android(s, rom, &kexec) != 0)
-                goto exit;
-            break;
-        case ROM_LINUX_INTERNAL:
-        case ROM_LINUX_USB:
-            loop_mounted = multirom_fill_kexec_linux(s, rom, &kexec);
-            if(loop_mounted < 0)
-                goto exit;
-            break;
-        default:
-            ERROR("Unsupported rom type to kexec (%d)!\n", rom->type);
-            goto exit;
-    }
-
-    res = kexec_load_exec(&kexec);
-
-    char *cmd_cp[] = { busybox_path, "cp", kexec_path, "/kexec", NULL };
-    run_cmd(cmd_cp);
-    chmod("/kexec", 0755);
-
-    if(loop_mounted)
-        umount("/mnt/image");
-
-    multirom_copy_log(NULL, "last_kexec_log.txt");
-
-exit:
-    kexec_destroy(&kexec);
-    return res;
-}
-
-int multirom_fill_kexec_android(struct multirom_status *s, struct multirom_rom *rom, struct kexec *kexec)
-{
-    int res = -1;
-    char img_path[256];
-    snprintf(img_path, sizeof(img_path), "%s/boot.img", rom->base_path);
-
-    // Trampolines in ROM boot images may get out of sync, so we need to check it and
-    // update if needed. I can't do that during ZIP installation because of USB drives.
-    if(inject_bootimg(img_path, 0) < 0)
-    {
-        ERROR("Failed to inject bootimg!\n");
-        return -1;
-    }
-
-    struct bootimg img;
-    if(libbootimg_init_load(&img, img_path, LIBBOOTIMG_LOAD_ALL) < 0)
-    {
-        ERROR("fill_kexec could not open boot image (%s)!\n", img_path);
-        return -1;
-    }
-
-    if(libbootimg_dump_kernel(&img, "/zImage") < 0)
-        goto exit;
-
-    if(libbootimg_dump_ramdisk(&img, "/initrd.img") < 0)
-        goto exit;
-
-    kexec_add_kernel(kexec, "/zImage", 1);
-    kexec_add_arg(kexec, "--initrd=/initrd.img");
-
-#ifdef MR_KEXEC_DTB
-    if(libbootimg_dump_dtb(&img, "/dtb.img") >= 0)
-        kexec_add_arg(kexec, "--dtb=/dtb.img");
-    else
-        kexec_add_arg(kexec, "--dtb");
-#endif
-
-    char cmdline[1536];
-    strcpy(cmdline, "--command-line=");
-
-    if(img.hdr.cmdline[0] != 0)
-    {
-        img.hdr.cmdline[BOOT_ARGS_SIZE-1] = 0;
-
-        // see multirom_get_bootloader_cmdline
-#if MR_DEVICE_HOOKS >= 5
-        mrom_hook_fixup_bootimg_cmdline((char*)img.hdr.cmdline, BOOT_ARGS_SIZE);
-#endif
-
-        strcat(cmdline, (char*)img.hdr.cmdline);
-        strcat(cmdline, " ");
-    }
-
-    if(multirom_get_bootloader_cmdline(s, cmdline+strlen(cmdline), sizeof(cmdline)-strlen(cmdline)-1) == -1)
-    {
-        ERROR("Failed to get cmdline\n");
-        goto exit;
-    }
-
-    if(!strstr(cmdline, " mrom_kexecd=1") && sizeof(cmdline)-strlen(cmdline)-1 >= sizeof("mrom_kexecd=1"))
-        strcat(cmdline, "mrom_kexecd=1");
-
-    kexec_add_arg(kexec, cmdline);
-
-    res = 0;
-exit:
-    libbootimg_destroy(&img);
-    return res;
-}
-
-static char *find_boot_file(char *path, char *root_path, char *base_path)
-{
-    if(!path)
-        return NULL;
-
-    struct stat info;
-    char cmd[256];
-    char *root = strstr(path, "%r");
-    if(root)
-        snprintf(cmd, sizeof(cmd), "%s/%s", root_path, root+2);
-    else
-        snprintf(cmd, sizeof(cmd), "%s/%s", base_path, path);
-
-    char *last = strrchr(cmd, '/');
-    if(!last)
-    {
-        ERROR("Failed to find boot file: %s\n", cmd);
-        return NULL;
-    }
-
-    *last = 0;
-
-    char *name = strdup(last+1);
-    char res[256];
-    if(multirom_find_file(res, name, cmd) < 0)
-    {
-        ERROR("Failed to find boot file: %s\n", cmd);
-        free(name);
-        return NULL;
-    }
-    return strdup(res);
-}
-
-int multirom_fill_kexec_linux(struct multirom_status *s, struct multirom_rom *rom, struct kexec *kexec)
-{
-    struct rom_info *info = multirom_parse_rom_info(s, rom);
-    if(!info)
-        return -1;
-
-    int res = -1;
-    int root_type = -1; // 0 = dir, 1 = img
-    int loop_mounted = 0;
-    char root_path[256];
-    const char *base_path;
-
-    if(!rom->partition)
-        base_path = partition_dir;
-    else
-        base_path = rom->partition->mount_path;
-
-    struct stat st;
-    char path[256];
-    char *tmp;
-
-    if((tmp = map_get_val(info->str_vals, "root_img")))
-    {
-        sprintf(path, "%s/%s", base_path, tmp);
-        if(stat(path, &st) >= 0)
-        {
-            root_type = 1;
-
-            char *img_fs = map_get_val(info->str_vals, "root_img_fs");
-
-            // mount the image file
-            mkdir("/mnt", 0777);
-            mkdir("/mnt/image", 0777);
-            if(mount_image(path, "/mnt/image", img_fs ? img_fs : "ext4", MS_NOATIME, NULL) < 0)
-                goto exit;
-
-            loop_mounted = 1;
-            strcpy(root_path, "/mnt/image");
-        }
-        else
-            ERROR("Path %s not found!\n", path);
-    }
-
-    if(root_type == -1 && (tmp = map_get_val(info->str_vals, "root_dir")))
-    {
-        sprintf(path, "%s/%s", base_path, tmp);
-        if(stat(path, &st) >= 0)
-        {
-            root_type = 0;
-            strcpy(root_path, path);
-        }
-        else
-            ERROR("Path %s not found!\n", path);
-    }
-
-    if(root_type == -1)
-    {
-        ERROR("Failed to find root of the ROM!\n");
-        goto exit;
-    }
-
-    char *str = find_boot_file(map_get_val(info->str_vals, "kernel_path"), root_path, rom->base_path);
-    if(str)
-    {
-        kexec_add_kernel(kexec, str, 1);
-        free(str);
-    }
-    else
-    {
-        // kernel is required
-        goto exit;
-    }
-
-#ifdef MR_KEXEC_DTB
-    str = NULL;
-
-    if (map_find(info->str_vals, "dtb_path") != -1)
-    {
-        str = find_boot_file(map_get_val(info->str_vals, "dtb_path"), root_path, rom->base_path);
-        if(!str)
-        {
-            ERROR("failed to find dtb_path!\n");
-            goto exit;
-        }
-    }
-    else
-    {
-        str = find_boot_file("%r/dtb.img", root_path, rom->base_path);
-    }
-
-    if(!str)
-        kexec_add_arg(kexec, "--dtb");
-    else
-    {
-        kexec_add_arg_prefix(kexec, "--dtb=", str);
-        free(str);
-    }
-#endif
-
-    str = find_boot_file(map_get_val(info->str_vals, "initrd_path"), root_path, rom->base_path);
-    if(str)
-    {
-        kexec_add_arg_prefix(kexec, "--initrd=", str);
-        free(str);
-    }
-
-    char cmdline[1536];
-    snprintf(cmdline, sizeof(cmdline), "--command-line=%s ", (char*)map_get_val(info->str_vals, "base_cmdline"));
-
-    str = NULL;
-    if(root_type == 0)
-        str = map_get_val(info->str_vals, "dir_cmdline");
-    else if(root_type == 1)
-        str = map_get_val(info->str_vals, "img_cmdline");
-
-    if(str)
-    {
-        if(strlen(str)+strlen(cmdline)+1 <= sizeof(cmdline))
-            strcat(cmdline, str);
-        else
-        {
-            ERROR("failed to fill kexec info, cmdline is too long!\n");
-            goto exit;
-        }
-    }
-
-    kexec_add_arg(kexec, cmdline);
-
-    res = loop_mounted;
-exit:
-    multirom_destroy_rom_info(info);
-    return res;
-}
-
-#define INFO_LINE_BUFF 4096
-struct rom_info *multirom_parse_rom_info(struct multirom_status *s, struct multirom_rom *rom)
-{
-    char path[256];
-
-    snprintf(path, sizeof(path), "%s/rom_info.txt", rom->base_path);
-    ERROR("Parsing %s...\n", path);
-
-    FILE *f = fopen(path, "re");
-    if(!f)
-    {
-        ERROR("Failed to open %s!\n", path);
-        return NULL;
-    }
-
-    struct rom_info *i = malloc(sizeof(struct rom_info));
-    memset(i, 0, sizeof(struct rom_info));
-    i->str_vals = map_create();
-
-    char *line = malloc(INFO_LINE_BUFF);
-    char key[32];
-    int line_cnt = 1;
-    for(; fgets(line, INFO_LINE_BUFF, f); ++line_cnt)
-    {
-        if(line[0] == '#')
-            continue;
-
-        char *val = strchr(line, '=');
-        if(!val || val-line >= (int)(sizeof(key)-1))
-            continue;
-
-        strncpy(key, line, val-line);
-        key[val-line] = 0;
-        ++val; // skip '=' char
-
-        // if string value
-        {
-            char *str = parse_string(val);
-            if(str)
-                map_add(i->str_vals, key, str, &free);
-            else
-                ERROR("Line %d: failed to parse string\n", line_cnt);
-        }
-    }
-    free(line);
-    fclose(f);
-
-    static const char *roots[] = { "root_dir", "root_img", NULL };
-    int found_root = 0;
-    int y;
-    for(y = 0; roots[y] && !found_root; ++y)
-    {
-        if(map_find(i->str_vals, (char*)roots[y]) >= 0)
-            found_root = 1;
-    }
-
-    if(!found_root)
-        ERROR("Failed to find any root key in %s\n", path);
-
-    static const char *req_keys[] = { "type", "kernel_path", "base_cmdline", NULL};
-    int failed = !found_root;
-    for(y = 0; req_keys[y]; ++y)
-    {
-        if(map_find(i->str_vals, (char*)req_keys[y]) < 0)
-        {
-            ERROR("Key \"%s\" key not found in %s\n", req_keys[y], path);
-            failed = 1;
-        }
-    }
-
-    // Only supported type is kexec, check just to make sure older releases
-    // can't try to run newer ROMs
-    if(failed == 0)
-    {
-        char *val = map_get_val(i->str_vals, "type");
-        if(strcmp(val, "kexec") != 0)
-        {
-            ERROR("Only supported rom_info type is \"kexec\", this rom_info has type \"%s\"!\n", val);
-            failed = 1;
-        }
-    }
-
-    if(failed == 1)
-    {
-        multirom_destroy_rom_info(i);
-        return NULL;
-    }
-
-    char **ref;
-    ERROR("Replacing aliases in root paths...\n");
-    for(y = 0; roots[y]; ++y)
-        if((ref = map_get_ref(i->str_vals, (char*)roots[y])))
-            multirom_replace_aliases_root_path(ref, rom);
-
-    ERROR("Replacing aliases in the cmdline...\n");
-    static const char *cmdlines[] = { "base_cmdline", "img_cmdline", "dir_cmdline", NULL };
-    for(y = 0; cmdlines[y]; ++y)
-        if((ref = map_get_ref(i->str_vals, (char*)cmdlines[y])))
-            multirom_replace_aliases_cmdline(ref, i, s, rom);
-
-    return i;
-}
-
-void multirom_destroy_rom_info(struct rom_info *info)
-{
-    if(!info)
-        return;
-
-    map_destroy(info->str_vals, &free);
-    free(info);
-}
-
-/*
-# Set up the cmdline
-# img_cmdline and dir_cmdline are appended to base_cmdline.
-# Several aliases are used:
-#  - %b - base command line from bootloader. You want this as first thing in cmdline.
-#  - %d - root device. is either "UUID=..." (USB drive) or "/dev/mmcblk0p9" or "/dev/mmcblk0p10"
-#  - %r - root fs type
-#  - %s - root directory, from root of the root device
-#  - %i - root image, from root of the root device
-#  - %f - fs of the root image
-*/
-int multirom_replace_aliases_cmdline(char **s, struct rom_info *i, struct multirom_status *status, struct multirom_rom *rom)
-{
-    size_t c = strcspn (*s, "%");
-
-    if(strlen(*s) == c)
-        return 0;
-
-    struct fstab_part *data_part = NULL;
-    if(!rom->partition)
-    {
-        // FIXME: might have wrong fs type, because of those "multi-fs" bullshit fstabs
-        // with multiple entries for /data
-        data_part = fstab_find_first_by_path(status->fstab, "/data");
-    }
-
-    char *buff = mzalloc(4096);
-
-    char *itr_o = buff;
-    char *itr_i = *s;
-    int res = -1;
-
-    while(1)
-    {
-        memcpy(itr_o, itr_i, c);
-        itr_o += c;
-        itr_i += c;
-
-        *itr_o = 0;
-
-        if(*itr_i != '%')
-            break;
-
-        ++itr_i;
-        switch(*itr_i)
-        {
-            // base command line from bootloader. You want this as first thing in cmdline.
-            case 'b':
-            {
-                if(multirom_get_bootloader_cmdline(status, itr_o, 1024) == -1)
-                {
-                    ERROR("Failed to get cmdline\n");
-                    goto fail;
-                }
-                break;
-            }
-            // root device. is either "UUID=..." (USB drive) or "/dev/mmcblk0p9" or "/dev/mmcblk0p10"
-            case 'd':
-            {
-                if(data_part)
-                {
-                    // Only android's ueventd creates /dev/block, so try to remove it
-                    // for _real_ linux OS. We can't use UUID, because it's the same for
-                    // /system, /data and /cache partitions
-                    char *blk = strstr(data_part->device, "/dev/block/");
-                    if(blk)
-                    {
-                        strcpy(itr_o, "/dev/");
-                        strcat(itr_o, blk+sizeof("/dev/block/")-1);
-                    }
-                    else
-                        strcpy(itr_o, data_part->device);
-                }
-                else if(rom->partition)
-                    sprintf(itr_o, "UUID=%s", rom->partition->uuid);
-                else
-                    ERROR("Failed to set root device\n");
-                break;
-            }
-            // root fs type
-            case 'r':
-            {
-                if(data_part)
-                    strcpy(itr_o, data_part->type);
-                else if(rom->partition)
-                {
-                    if(!strcmp(rom->partition->fs, "ntfs"))
-                        strcpy(itr_o, "ntfs-3g");
-                    else
-                        strcpy(itr_o, rom->partition->fs);
-                }
-                else
-                    ERROR("Failed to set root fs type\n");
-                break;
-            }
-            // root directory, from root of the root device
-            case 's':
-            {
-                char *d = map_get_val(i->str_vals, "root_dir");
-                if(!d)
-                {
-                    ERROR("%%s alias found in cmdline, but root_dir key was not found!\n");
-                    break;
-                }
-                sprintf(itr_o, "%s", d);
-                break;
-            }
-            // root image, from root of the root device
-            case 'i':
-            {
-                char *d = map_get_val(i->str_vals, "root_img");
-                if(!d)
-                {
-                    ERROR("%%s alias found in cmdline, but root_img key was not found!\n");
-                    break;
-                }
-                sprintf(itr_o, "%s", d);
-                break;
-            }
-            // fs of the root image
-            case 'f':
-            {
-                char *d = map_get_val(i->str_vals, "root_img_fs");
-                if(!d)
-                {
-                    ERROR("%%s alias found in cmdline, but root_img_fs key was not found!\n");
-                    break;
-                }
-                strcpy(itr_o, d);
-                break;
-            }
-        }
-        itr_o += strlen(itr_o);
-        c = strcspn (++itr_i, "%");
-    }
-
-    free(*s);
-    *s = realloc(buff, strlen(buff)+1);
-
-    ERROR("Alias-replaced cmdline: %s\n", *s);
-    return 0;
-
-fail:
-    free(buff);
-    return -1;
-}
-
-// - %m - ROMs folder (eg. /sdcard/multirom/roms/*rom_name*)
-int multirom_replace_aliases_root_path(char **s, struct multirom_rom *rom)
-{
-    char *alias = strstr(*s, "%m");
-    if(!alias)
-        return 0;
-
-    char buff[256] = { 0 };
-    memcpy(buff, *s, alias-*s);
-
-    if(rom->partition)
-        strcat(buff, rom->base_path + strlen(rom->partition->mount_path));
-    else
-        strcat(buff, rom->base_path + strlen(partition_dir));
-
-    strcat(buff, alias+2);
-
-    ERROR("Alias-replaced path: %s\n", buff);
-
-    free(*s);
-    *s = strdup(buff);
-    return 0;
-}
-
-int multirom_extract_bytes(const char *dst, FILE *src, size_t size)
-{
-    FILE *f = fopen(dst, "we");
-    if(!f)
-    {
-        ERROR("Failed to open dest file %s\n", dst);
-        return -1;
-    }
-
-    char *buff = malloc(size);
-
-    fread(buff, 1, size, src);
-    fwrite(buff, 1, size, f);
-
-    fclose(f);
-    free(buff);
-    return 0;
-}
-
-void multirom_destroy_partition(void *part)
-{
-    struct usb_partition *p = (struct usb_partition *)part;
-    if(p->mount_path && p->keep_mounted == 0)
-        umount(p->mount_path);
-
-    free(p->name);
-    free(p->uuid);
-    free(p->mount_path);
-    free(p->fs);
-    free(p);
-}
-
-int multirom_update_partitions(struct multirom_status *s)
-{
-    pthread_mutex_lock(&parts_mutex);
-
-    list_clear(&s->partitions, &multirom_destroy_partition);
-
-    int exit_code = 0;
-    char *cmd[] = { busybox_path, "blkid", NULL };
-    char *res = run_get_stdout_with_exit(cmd, &exit_code);
-    if(exit_code != 0 || res == NULL)
-    {
-        free(res);
-        pthread_mutex_unlock(&parts_mutex);
-        return exit_code == 0 ? 0 : -1;
-    }
-
-    char *tok;
-    char *name;
-    struct usb_partition *part;
-
-    char *line = strtok(res, "\n");
-    while(line != NULL)
-    {
-        if(strstr(line, "/dev/") != line)
-        {
-            ERROR("blkid line does not start with /dev/!\n");
-            break;
-        }
-
-        tok = strrchr(line, '/')+1;
-        name = strndup(tok, strchr(tok, ':') - tok);
-        if(strncmp(name, "mmcblk0", 7) == 0 || strncmp(name, "dm-", 3) == 0) // ignore internal nand
-        {
-            free(name);
-            goto next_itr;
-        }
-
-        part = mzalloc(sizeof(struct usb_partition));
-        part->name = name;
-
-        tok = strstr(line, "UUID=\"");
-        if(tok)
-        {
-            tok += sizeof("UUID=\"")-1;
-            part->uuid = strndup(tok, strchr(tok, '"') - tok);
-        }
-        else
-        {
-            ERROR("Part %s does not have UUID, line: \"%s\"\n", part->name, line);
-            multirom_destroy_partition(part);
-            goto next_itr;
-        }
-
-        tok = strstr(line, "TYPE=\"");
-        if(tok)
-        {
-            tok += sizeof("TYPE=\"")-1;
-            part->fs = strndup(tok, strchr(tok, '"') - tok);
-        }
-
-        if(part->fs && multirom_mount_usb(part) == 0)
-        {
-            list_add(&s->partitions, part);
-            ERROR("Found part %s: %s, %s\n", part->name, part->uuid, part->fs);
-        }
-        else
-        {
-            ERROR("Failed to mount part %s %s, %s\n", part->name, part->uuid, part->fs);
-            multirom_destroy_partition(part);
-        }
-
-next_itr:
-        line = strtok(NULL, "\n");
-    }
-    pthread_mutex_unlock(&parts_mutex);
-    free(res);
-
-    return 0;
-}
-
-int multirom_mount_usb(struct usb_partition *part)
-{
-    mkdir("/mnt", 0777);
-    mkdir("/mnt/mrom", 0777);
-
-    char path[256];
-    snprintf(path, sizeof(path), "/mnt/mrom/%s", part->name);
-    if(mkdir(path, 0777) != 0 && errno != EEXIST)
-    {
-        ERROR("Failed to create dir for mount %s\n", path);
-        return -1;
-    }
-
-    char src[256];
-    snprintf(src, sizeof(src), "/dev/block/%s", part->name);
-
-    if(strncmp(part->fs, "ntfs", 4) == 0)
-    {
-        char *cmd[] = { ntfs_path, src, path, NULL };
-        if(run_cmd(cmd) != 0)
-        {
-            ERROR("Failed to mount %s with ntfs-3g\n", src);
-            return -1;
-        }
-    }
-    else if(strcmp(part->fs, "exfat") == 0)
-    {
-        char *cmd[] = { exfat_path, "-o", "big_writes,max_read=131072,max_write=131072,nonempty", src, path, NULL };
-        if(run_cmd(cmd) != 0)
-        {
-            ERROR("Failed to mount %s with exfat\n", src);
-            return -1;
-        }
-    }
-    else if(mount(src, path, part->fs, MS_NOATIME, "") < 0)
-    {
-        ERROR("Failed to mount %s (%d: %s)\n", src, errno, strerror(errno));
-        return -1;
-    }
-
-    part->mount_path = strdup(path);
-    return 0;
-}
-
-void *multirom_usb_refresh_thread_work(void *status)
-{
-    uint32_t timer = 0;
-    struct stat info;
-
-    // stat.st_ctime is defined as unsigned long instead
-    // of time_t in android
-    unsigned long last_ctime = 0;
-    unsigned long last_ctime_nsec = 0;
-
-    while(run_usb_refresh)
-    {
-        if(timer <= 50)
-        {
-            if (stat("/dev/block", &info) >= 0 &&
-                (info.st_ctime != last_ctime || info.st_ctimensec != last_ctime_nsec))
-            {
-                multirom_update_partitions((struct multirom_status*)status);
-
-                if(usb_refresh_handler)
-                    (*usb_refresh_handler)();
-
-                last_ctime = info.st_ctime;
-                last_ctime_nsec = info.st_ctimensec;
-            }
-            timer = 500;
-        }
-        else
-            timer -= 50;
-        usleep(50000);
-    }
-    return NULL;
-}
-
-void multirom_set_usb_refresh_thread(struct multirom_status *s, int run)
-{
-    if(run_usb_refresh == run)
-        return;
-
-    run_usb_refresh = run;
-    if(run)
-        pthread_create(&usb_refresh_thread, NULL, multirom_usb_refresh_thread_work, s);
-    else
-        pthread_join(usb_refresh_thread, NULL);
-}
-
-void multirom_set_usb_refresh_handler(void (*handler)(void))
-{
-    usb_refresh_handler = handler;
-}
-
-char *multirom_get_klog(void)
-{
-    int len = klogctl(10, NULL, 0);
-    if      (len < 16*1024)      len = 16*1024;
-    else if (len > 16*1024*1024) len = 16*1024*1024;
-
-    char *buff = malloc(len + 1);
-    len = klogctl(3, buff, len);
-    if(len <= 0)
-    {
-        ERROR("Could not get klog!\n");
-        free(buff);
-        return NULL;
-    }
-    buff[len] = 0;
-    return buff;
-}
-
-int multirom_copy_log(char *klog, const char *dest_path_relative)
-{
-    int res = 0;
-    int freeLog = (klog == NULL);
-
-    if(!klog)
-        klog = multirom_get_klog();
-
-    if(klog)
-    {
-        char path[256];
-        snprintf(path, sizeof(path), "%s/%s", mrom_dir(), dest_path_relative);
-        FILE *f = fopen(path, "we");
-
-        if(f)
-        {
-            fwrite(klog, 1, strlen(klog), f);
-            fclose(f);
-            chmod(path, 0777);
-        }
-        else
-        {
-            ERROR("Failed to open %s!\n", path);
-            res = -1;
-        }
-    }
-    else
-    {
-        ERROR("Could not get klog!\n");
-        res = -1;
-    }
-
-    if(freeLog)
-        free(klog);
-    return res;
-}
-
-struct usb_partition *multirom_get_partition(struct multirom_status *s, char *uuid)
-{
-    int i;
-    for(i = 0; s->partitions && s->partitions[i]; ++i)
-        if(strcmp(s->partitions[i]->uuid, uuid) == 0)
-            return s->partitions[i];
-    return NULL;
-}
-
-int multirom_get_battery(void)
-{
-    char buff[4];
-
-    FILE *f = fopen(BATTERY_CAP, "re");
-    if(!f)
-        return -1;
-
-    fgets(buff, sizeof(buff), f);
-    fclose(f);
-
-    return atoi(buff);
-}
-
-int multirom_run_scripts(const char *type, struct multirom_rom *rom)
-{
-    char buff[512];
-    snprintf(buff, sizeof(buff), "%s/%s", rom->base_path, type);
-    if(access(buff, (R_OK | X_OK)) < 0)
-    {
-        ERROR("No %s scripts for ROM %s\n", type, rom->name);
-        return 0;
-    }
-
-    ERROR("Running %s scripts for ROM %s...\n", type, rom->name);
-
-    int res = mr_system("B=\"%s\"; P=\"%s\"; for x in $(\"$B\" ls \"$P/%s/\"*.sh); do echo Running script $x; \"$B\" sh $x \"$B\" \"$P\" || exit 1; done", busybox_path, rom->base_path, type);
-    if(res != 0)
-    {
-        ERROR("Error running scripts (%d)!\n", res);
-        return res;
-    }
-    return 0;
-}
-
-#define IC_TYPE_PREDEF 0
-#define IC_TYPE_USER   1
-#define USER_IC_PATH "../Android/data/com.tassadar.multirommgr/files"
-#define USER_IC_PATH_LEN 46
-#define DEFAULT_ICON "/icons/romic_default.png"
-#define DEFAULT_ICON_LEN 24
-
-void multirom_find_rom_icon(struct multirom_rom *rom)
-{
-    FILE *f;
-    int type = 0, len;
-    char buff[256];
-
-    snprintf(buff, sizeof(buff), "%s/.icon_data", rom->base_path);
-
-    f = fopen(buff, "re");
-    if(!f)
-        goto fail;
-
-    if(!fgets(buff, sizeof(buff), f))
-        goto fail;
-
-    if(strcmp(buff, "predef_set\n") == 0)
-        type = IC_TYPE_PREDEF;
-    else if(strcmp(buff, "user_defined\n") == 0)
-        type = IC_TYPE_USER;
-    else
-        goto fail;
-
-    if(!fgets(buff, sizeof(buff), f))
-        goto fail;
-    fclose(f);
-    f = NULL;
-
-    len = strlen(buff);
-    if(len < 2)
-        goto fail;
-
-    buff[--len] = 0; // remove \n
-
-    switch(type)
-    {
-        case IC_TYPE_PREDEF:
-        {
-            char *ic_name = strrchr(buff, '/');
-            if(!ic_name)
-                goto fail;
-
-            len = strlen(mrom_dir()) + 6 + strlen(ic_name)+4+1; // + /icons + .png + \0
-            rom->icon_path = malloc(len);
-            snprintf(rom->icon_path, len, "%s/icons%s.png", mrom_dir(), ic_name);
-            break;
-        }
-        case IC_TYPE_USER:
-        {
-            len = strlen(mrom_dir()) + 1 + USER_IC_PATH_LEN + 1 + len + 4 + 1; // + / + / + .png + \0
-            rom->icon_path = malloc(len);
-            snprintf(rom->icon_path, len, "%s/%s/%s.png", mrom_dir(), USER_IC_PATH, buff);
-            break;
-        }
-    }
-
-    if(access(rom->icon_path, F_OK) < 0)
-        goto fail;
-
-    return;
-fail:
-    if(f)
-        fclose(f);
-
-    len = strlen(mrom_dir()) + DEFAULT_ICON_LEN + 1;
-    rom->icon_path = realloc(rom->icon_path, len);
-    snprintf(rom->icon_path, len, "%s%s", mrom_dir(), DEFAULT_ICON);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/mount.h>
+#include <sys/klog.h>
+#include <linux/loop.h>
+#include <ctype.h>
+#include <unistd.h>
+
+
+#include <malloc.h>
+
+// clone libbootimg to /system/extras/ from
+// https://github.com/Tasssadar/libbootimg.git
+#include <libbootimg.h>
+
+#if LIBBOOTIMG_VERSION  < 0x000200
+#error "libbootimg version 0.2.0 or higher is required. Please update libbootimg."
+#endif
+
+#include "lib/containers.h"
+#include "lib/framebuffer.h"
+#include "lib/inject.h"
+#include "lib/input.h"
+#include "lib/log.h"
+#include "lib/util.h"
+#include "lib/mrom_data.h"
+#include "multirom.h"
+#include "multirom_ui.h"
+#include "version.h"
+#include "hooks.h"
+#include "rom_quirks.h"
+#include "kexec.h"
+
+#define REALDATA "/realdata"
+#define BUSYBOX_BIN "busybox"
+#define KEXEC_BIN "kexec"
+#define NTFS_BIN "ntfs-3g"
+#define EXFAT_BIN "exfat-fuse"
+#define INTERNAL_ROM_NAME "Internal"
+#define MAX_ROM_NAME_LEN 26
+#define LAYOUT_VERSION "/data/.layout_version"
+
+#define BATTERY_CAP "/sys/class/power_supply/battery/capacity"
+
+static char busybox_path[64] = { 0 };
+static char kexec_path[64] = { 0 };
+static char ntfs_path[64] = { 0 };
+static char exfat_path[64] = { 0 };
+static char partition_dir[64] = { 0 };
+
+static volatile int run_usb_refresh = 0;
+static pthread_t usb_refresh_thread;
+static pthread_mutex_t parts_mutex = PTHREAD_MUTEX_INITIALIZER;
+static void (*usb_refresh_handler)(void) = NULL;
+
+int multirom_find_base_dir(void)
+{
+    int i;
+    struct stat info;
+
+    static const char *paths[] = {
+        REALDATA"/media/0/multirom", // 4.2
+        REALDATA"/media/multirom",
+        "/data/media/0/multirom",
+        "/data/media/multirom",
+        NULL,
+    };
+
+    for(i = 0; paths[i]; ++i)
+    {
+        if(stat(paths[i], &info) < 0)
+            continue;
+
+        mrom_set_dir(paths[i]);
+
+        strncpy(partition_dir, paths[i], strchr(paths[i]+1, '/') - paths[i]);
+
+        sprintf(busybox_path, "%s/%s", paths[i], BUSYBOX_BIN);
+        sprintf(kexec_path, "%s/%s", paths[i], KEXEC_BIN);
+        sprintf(ntfs_path, "%s/%s", paths[i], NTFS_BIN);
+        sprintf(exfat_path, "%s/%s", paths[i], EXFAT_BIN);
+
+        chmod(kexec_path, 0755);
+        chmod(ntfs_path, 0755);
+        chmod(exfat_path, 0755);
+        return 0;
+    }
+    return -1;
+}
+
+int multirom(const char *rom_to_boot)
+{
+    if(multirom_find_base_dir() == -1)
+    {
+        ERROR("Could not find multirom dir\n");
+        return -1;
+    }
+
+    struct multirom_status s;
+    memset(&s, 0, sizeof(struct multirom_status));
+
+    multirom_load_status(&s);
+    multirom_dump_status(&s);
+
+    struct multirom_rom *to_boot = NULL;
+    int exit = (EXIT_REBOOT | EXIT_UMOUNT);
+
+    if(rom_to_boot != NULL)
+    {
+        struct multirom_rom *rom = multirom_get_rom(&s, rom_to_boot, NULL);
+        if(rom)
+        {
+            // Two possible scenarios: this ROM has kexec-hardboot and target
+            // ROM has boot image, so kexec it immediatelly or
+            // reboot and then proceed as usuall
+            if(((M(rom->type) & MASK_KEXEC) || rom->has_bootimg) && rom->type != ROM_DEFAULT && multirom_has_kexec())
+            {
+                to_boot = rom;
+                s.is_second_boot = 0;
+                INFO("Booting ROM %s...\n", rom_to_boot);
+            }
+            else
+            {
+                s.current_rom = rom;
+                s.auto_boot_type |= AUTOBOOT_FORCE_CURRENT;
+                INFO("Setting ROM %s to force autoboot\n", rom_to_boot);
+            }
+        }
+        else
+        {
+            ERROR("ROM %s was not found, force autoboot was not set!\n", rom_to_boot);
+            exit = EXIT_UMOUNT;
+        }
+    }
+    else if(s.is_second_boot != 0 || (s.auto_boot_type & AUTOBOOT_FORCE_CURRENT))
+    {
+        ERROR("Skipping ROM selection, is_second_boot=%d, auto_boot_type=0x%x\n", s.is_second_boot, s.auto_boot_type);
+        to_boot = s.current_rom;
+    }
+    else
+    {
+        // just to cache the result so that it does not take
+        // any time when the UI is up
+        multirom_has_kexec();
+
+        switch(multirom_ui(&s, &to_boot))
+        {
+            case UI_EXIT_BOOT_ROM: break;
+            case UI_EXIT_REBOOT:
+                exit = (EXIT_REBOOT | EXIT_UMOUNT);
+                break;
+            case UI_EXIT_REBOOT_RECOVERY:
+                exit = (EXIT_REBOOT_RECOVERY | EXIT_UMOUNT);
+                break;
+            case UI_EXIT_REBOOT_BOOTLOADER:
+                exit = (EXIT_REBOOT_BOOTLOADER | EXIT_UMOUNT);
+                break;
+            case UI_EXIT_SHUTDOWN:
+                exit = (EXIT_SHUTDOWN | EXIT_UMOUNT);
+                break;
+        }
+    }
+
+    if(to_boot)
+    {
+        s.auto_boot_type &= ~(AUTOBOOT_FORCE_CURRENT);
+
+        if(rom_to_boot == NULL)
+            multirom_run_scripts("run-on-boot", to_boot);
+
+        exit = multirom_prepare_for_boot(&s, to_boot);
+
+        // Something went wrong, exit/reboot
+        if(exit == -1)
+        {
+            if(rom_to_boot == NULL)
+            {
+                multirom_emergency_reboot();
+                exit = EXIT_REBOOT;
+            }
+            else
+                exit = EXIT_UMOUNT;
+            goto finish;
+        }
+
+        s.current_rom = to_boot;
+
+        free(s.curr_rom_part);
+        s.curr_rom_part = NULL;
+
+        if(to_boot->partition)
+            s.curr_rom_part = strdup(to_boot->partition->uuid);
+
+        if(s.is_second_boot == 0 && (M(to_boot->type) & MASK_ANDROID) && (exit & EXIT_KEXEC))
+        {
+            s.is_second_boot = 1;
+
+            // mrom_kexecd=1 param might be lost if kernel does not have kexec patches
+            ERROR(SECOND_BOOT_KMESG);
+        }
+        else
+            s.is_second_boot = 0;
+    }
+
+finish:
+    multirom_save_status(&s);
+    multirom_free_status(&s);
+
+    sync();
+
+    return exit;
+}
+
+int multirom_init_fb(int rotation)
+{
+    if(fb_open(rotation) < 0)
+    {
+        ERROR("Failed to open framebuffer!\n");
+        return -1;
+    }
+
+    fb_fill(BLACK);
+    return 0;
+}
+
+void multirom_emergency_reboot(void)
+{
+    char *klog;
+    fb_text_proto *p;
+    fb_img *t;
+    char *tail;
+    char *last_end;
+    int cur_y;
+    unsigned int media_rw_id;
+
+    if(multirom_init_fb(0) < 0)
+    {
+        ERROR("Failed to init framebuffer in emergency reboot\n");
+        return;
+    }
+    fb_set_background(BLACK);
+
+    klog = multirom_get_klog();
+
+    t = fb_add_text(0, 120, WHITE, SIZE_NORMAL,
+                "An error occured.\nShutting down MultiROM to avoid data corruption.\n"
+                "Report this error to the developer!\nDebug info: /sdcard/multirom_log.txt\n\n"
+                "Press POWER button to reboot.");
+
+    t = fb_add_text(0, t->y + t->h + 100*DPI_MUL, GRAYISH, SIZE_SMALL, "Last lines from klog:");
+    fb_add_rect(0, t->y + t->h + 5*DPI_MUL, fb_width, 1, GRAYISH);
+
+    tail = klog+strlen(klog);
+    last_end = tail;
+    cur_y = fb_height;
+    const int start_y = (t->y + t->h + 2);
+    while(tail > klog)
+    {
+        --tail;
+        if(*tail == '\n')
+        {
+            p = fb_text_create(0, cur_y, GRAYISH, 4*4, NULL);
+            p->text = malloc(last_end - tail);
+            memcpy(p->text, tail + 1, last_end - (tail + 1));
+            p->text[last_end - (tail + 1)] = 0;
+            p->style = STYLE_MONOSPACE;
+            t = fb_text_finalize(p);
+
+            cur_y -= t->h;
+            t->y = cur_y;
+            last_end = tail;
+
+            if(cur_y < start_y)
+            {
+                fb_rm_text(t);
+                break;
+            }
+        }
+    }
+
+    fb_force_draw();
+
+    multirom_copy_log(klog, "../multirom_log.txt");
+    free(klog);
+
+    media_rw_id = decode_uid("media_rw");
+    if(media_rw_id != -1U)
+        chown("../multirom_log.txt", (uid_t)media_rw_id, (gid_t)media_rw_id);
+    chmod("../multirom_log.txt", 0666);
+
+    // Wait for power key
+    start_input_thread();
+    while(wait_for_key() != KEY_POWER);
+    stop_input_thread();
+
+    fb_clear();
+    fb_close();
+}
+
+static int find_idx(int c)
+{
+    static const char *capital = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+    static const char *normal  = "abcdefghijklmnopqrstuvwxyz";
+
+    char *p;
+    if((p = strchr(capital, c)))
+        return p - capital;
+    else if((p = strchr(normal, c)))
+        return p - normal;
+
+    return -128 + c;
+}
+
+static int compare_rom_names(const void *a, const void *b)
+{
+    struct multirom_rom *rom_a = *((struct multirom_rom **)a);
+    struct multirom_rom *rom_b = *((struct multirom_rom **)b);
+
+    if(rom_a->type == ROM_DEFAULT)
+        return -1;
+    else if(rom_b->type == ROM_DEFAULT)
+        return 1;
+
+    char *itr_a = rom_a->name;
+    char *itr_b = rom_b->name;
+
+    while(1)
+    {
+        if(*itr_a == 0)
+            return -1;
+        else if(*itr_b == 0)
+            return 1;
+
+        if(*itr_a == *itr_b)
+        {
+            ++itr_a;
+            ++itr_b;
+            continue;
+        }
+
+        int idx_a = find_idx(*itr_a);
+        int idx_b = find_idx(*itr_b);
+
+        if(idx_a == idx_b)
+        {
+            ++itr_a;
+            ++itr_b;
+            continue;
+        }
+
+        return idx_a < idx_b ? -1 : 1;
+    }
+    return 0;
+}
+
+int multirom_default_status(struct multirom_status *s)
+{
+    s->is_second_boot = 0;
+    s->current_rom = NULL;
+    s->roms = NULL;
+    s->colors = 0;
+    s->brightness = MULTIROM_DEFAULT_BRIGHTNESS;
+    s->enable_adb = 0;
+    s->rotation = MULTIROM_DEFAULT_ROTATION;
+    s->anim_duration_coef = 1.f;
+
+    s->fstab = fstab_auto_load();
+    if(!s->fstab)
+        return -1;
+
+    char roms_path[256];
+    sprintf(roms_path, "%s/roms/"INTERNAL_ROM_NAME, mrom_dir());
+    DIR *d = opendir(roms_path);
+    if(!d)
+    {
+        ERROR("Failed to open Internal ROM's folder, creating one with ROM from internal memory...\n");
+        multirom_import_internal();
+    }
+    else
+        closedir(d);
+
+    sprintf(roms_path, "%s/roms", mrom_dir());
+    d = opendir(roms_path);
+    if(!d)
+    {
+        ERROR("Failed to open roms dir!\n");
+        return -1;
+    }
+
+    struct dirent *dr;
+    char path[256];
+    struct multirom_rom **add_roms = NULL;
+    while((dr = readdir(d)))
+    {
+        if(dr->d_name[0] == '.')
+            continue;
+
+        if(dr->d_type != DT_DIR)
+            continue;
+
+        if(strlen(dr->d_name) > MAX_ROM_NAME_LEN)
+        {
+            ERROR("Skipping ROM %s, name is too long (max %d chars allowed)\n", dr->d_name, MAX_ROM_NAME_LEN);
+            continue;
+        }
+
+        INFO("Adding ROM %s\n", dr->d_name);
+
+        struct multirom_rom *rom = malloc(sizeof(struct multirom_rom));
+        memset(rom, 0, sizeof(struct multirom_rom));
+
+        rom->id = multirom_generate_rom_id();
+        rom->name = strdup(dr->d_name);
+
+        snprintf(path, sizeof(path), "%s/%s", roms_path, rom->name);
+        rom->base_path = strdup(path);
+
+        rom->type = multirom_get_rom_type(rom);
+
+        snprintf(path, sizeof(path), "%s/boot.img", rom->base_path);
+        rom->has_bootimg = access(path, R_OK) == 0 ? 1 : 0;
+
+        multirom_find_rom_icon(rom);
+
+        list_add(&add_roms, rom);
+    }
+
+    closedir(d);
+
+    if(add_roms)
+    {
+        // sort roms
+        qsort(add_roms, list_item_count(add_roms), sizeof(struct multirom_rom*), compare_rom_names);
+
+        // add them to main list
+        list_swap(&add_roms, &s->roms);
+    }
+
+    s->current_rom = multirom_get_internal(s);
+    if(!s->current_rom)
+    {
+        ERROR("No internal rom found!\n");
+        return -1;
+    }
+
+    s->auto_boot_rom = s->current_rom;
+    s->auto_boot_seconds = 5;
+    s->auto_boot_type = AUTOBOOT_NAME;
+
+    return 0;
+}
+
+int multirom_load_status(struct multirom_status *s)
+{
+    INFO("Loading MultiROM status...\n");
+
+    multirom_default_status(s);
+
+    if(mrom_is_second_boot())
+        s->is_second_boot = 1;
+
+    // is_second_boot might be reset later, but we need to know if this
+    // is second boot when filling in kexec info
+    s->is_running_in_primary_rom = !s->is_second_boot;
+
+    char arg[256];
+    sprintf(arg, "%s/multirom.ini", mrom_dir());
+
+    FILE *f = fopen(arg, "re");
+    if(!f)
+    {
+        ERROR("Failed to open config file, using defaults!\n");
+        return -1;
+    }
+
+    char line[1024];
+    char current_rom[256] = { 0 };
+    char auto_boot_rom[256] = { 0 };
+
+    char name[64];
+    char *pch;
+
+    while((fgets(line, sizeof(line), f)))
+    {
+        pch = strtok (line, "=\n");
+        if(!pch) continue;
+        strcpy(name, pch);
+        pch = strtok (NULL, "=\n");
+        if(!pch) continue;
+        strcpy(arg, pch);
+
+        if(strstr(name, "current_rom"))
+            strcpy(current_rom, arg);
+        else if(strstr(name, "auto_boot_seconds"))
+            s->auto_boot_seconds = atoi(arg);
+        else if(strstr(name, "auto_boot_rom"))
+            strcpy(auto_boot_rom, arg);
+        else if(strstr(name, "auto_boot_type"))
+            s->auto_boot_type = atoi(arg);
+        else if(strstr(name, "curr_rom_part"))
+            s->curr_rom_part = strdup(arg);
+        else if(strstr(name, "colors_v2"))
+            s->colors = atoi(arg);
+        else if(strstr(name, "brightness"))
+            s->brightness = atoi(arg);
+        else if(strstr(name, "enable_adb"))
+            s->enable_adb = atoi(arg);
+        else if(strstr(name, "hide_internal"))
+            s->hide_internal = atoi(arg);
+        else if(strstr(name, "int_display_name"))
+            s->int_display_name = strdup(arg);
+        else if(strstr(name, "rotation"))
+            s->rotation = atoi(arg);
+        else if(strstr(name, "force_generic_fb"))
+            s->force_generic_fb = atoi(arg);
+        else if(strstr(name, "anim_duration_coef_pct"))
+            s->anim_duration_coef = ((float)atoi(arg)) / 100;
+    }
+
+    fclose(f);
+
+    // find USB drive if we're booting from it
+    if(s->curr_rom_part && s->is_second_boot)
+    {
+        struct usb_partition *p = NULL;
+        int tries = 0;
+        while(!p && tries < 10)
+        {
+            multirom_update_partitions(s);
+            p = multirom_get_partition(s, s->curr_rom_part);
+
+            if(p)
+            {
+                multirom_scan_partition_for_roms(s, p);
+                break;
+            }
+
+            ++tries;
+            ERROR("part %s not found, waiting 1s (%d)\n", s->curr_rom_part, tries);
+            sleep(1);
+        }
+    }
+
+    s->current_rom = multirom_get_rom(s, current_rom, s->curr_rom_part);
+    if(!s->current_rom)
+    {
+        ERROR("Failed to select current rom (%s, part %s), using Internal!\n", current_rom, s->curr_rom_part);
+        s->current_rom = multirom_get_internal(s);
+        if(!s->current_rom)
+        {
+            ERROR("No internal rom found!\n");
+            return -1;
+        }
+    }
+
+    if((s->auto_boot_type & AUTOBOOT_LAST) && !s->curr_rom_part)
+    {
+        s->auto_boot_rom = s->current_rom;
+    }
+    else
+    {
+        s->auto_boot_rom = multirom_get_rom(s, auto_boot_rom, NULL);
+        if(!s->auto_boot_rom)
+            ERROR("Could not find rom %s to auto-boot\n", auto_boot_rom);
+    }
+
+    if(s->int_display_name)
+    {
+        struct multirom_rom *r = multirom_get_internal(s);
+        r->name = realloc(r->name, strlen(s->int_display_name)+1);
+        strcpy(r->name, s->int_display_name);
+    }
+
+    fb_force_generic_impl(s->force_generic_fb);
+
+    if(s->anim_duration_coef == 0)
+        s->anim_duration_coef = 1.f;
+
+    return 0;
+}
+
+int multirom_save_status(struct multirom_status *s)
+{
+    INFO("Saving multirom status\n");
+
+    char path[256];
+    char auto_boot_name[MAX_ROM_NAME_LEN+1];
+    char current_name[MAX_ROM_NAME_LEN+1];
+
+    snprintf(path, sizeof(path), "%s/multirom.ini", mrom_dir());
+
+    FILE *f = fopen(path, "we");
+    if(!f)
+    {
+        ERROR("Failed to open/create status file!\n");
+        return -1;
+    }
+
+    multirom_fixup_rom_name(s->auto_boot_rom, auto_boot_name, "");
+    multirom_fixup_rom_name(s->current_rom, current_name, INTERNAL_ROM_NAME);
+
+    fprintf(f, "current_rom=%s\n", current_name);
+    fprintf(f, "auto_boot_seconds=%d\n", s->auto_boot_seconds);
+    fprintf(f, "auto_boot_rom=%s\n", auto_boot_name);
+    fprintf(f, "auto_boot_type=%d\n", s->auto_boot_type);
+    fprintf(f, "curr_rom_part=%s\n", s->curr_rom_part ? s->curr_rom_part : "");
+    fprintf(f, "colors_v2=%d\n", s->colors);
+    fprintf(f, "brightness=%d\n", s->brightness);
+    fprintf(f, "enable_adb=%d\n", s->enable_adb);
+    fprintf(f, "hide_internal=%d\n", s->hide_internal);
+    fprintf(f, "int_display_name=%s\n", s->int_display_name ? s->int_display_name : "");
+    fprintf(f, "rotation=%d\n", s->rotation);
+    fprintf(f, "force_generic_fb=%d\n", s->force_generic_fb);
+    fprintf(f, "anim_duration_coef_pct=%d\n", (int)(s->anim_duration_coef*100));
+
+    fclose(f);
+    return 0;
+}
+
+void multirom_fixup_rom_name(struct multirom_rom *rom, char *name, const char *def)
+{
+    if(rom)
+    {
+        if(rom->type == ROM_DEFAULT)
+            strcpy(name, INTERNAL_ROM_NAME);
+        else
+            strcpy(name, rom->name);
+    }
+    else
+    {
+        strcpy(name, def);
+    }
+}
+
+void multirom_dump_status(struct multirom_status *s)
+{
+    INFO("Dumping multirom status:\n");
+    INFO("  is_second_boot=%d\n", s->is_second_boot);
+    INFO("  is_running_in_primary_rom=%d\n", s->is_running_in_primary_rom);
+    INFO("  current_rom=%s\n", s->current_rom ? s->current_rom->name : "NULL");
+    INFO("  colors_v2=%d\n", s->colors);
+    INFO("  brightness=%d\n", s->brightness);
+    INFO("  enable_adb=%d\n", s->enable_adb);
+    INFO("  rotation=%d\n", s->rotation);
+    INFO("  force_generic_fb=%d\n", s->force_generic_fb);
+    INFO("  anim_duration_coef=%f\n", s->anim_duration_coef);
+    INFO("  hide_internal=%d\n", s->hide_internal);
+    INFO("  int_display_name=%s\n", s->int_display_name ? s->int_display_name : "NULL");
+    INFO("  auto_boot_seconds=%d\n", s->auto_boot_seconds);
+    INFO("  auto_boot_rom=%s\n", s->auto_boot_rom ? s->auto_boot_rom->name : "NULL");
+    INFO("  auto_boot_type=%d\n", s->auto_boot_type);
+    INFO("  curr_rom_part=%s\n", s->curr_rom_part ? s->curr_rom_part : "NULL");
+    INFO("\n");
+
+    int i;
+    for(i = 0; s->roms && s->roms[i]; ++i)
+    {
+        INFO("  ROM: %s\n", s->roms[i]->name);
+        INFO("    base_path: %s\n", s->roms[i]->base_path);
+        INFO("    icon_path: %s\n", s->roms[i]->icon_path);
+        INFO("    type: %d\n", s->roms[i]->type);
+        INFO("    has_bootimg: %d\n", s->roms[i]->has_bootimg);
+        if(s->roms[i]->partition)
+            INFO("    partition: %s (%s)\n", s->roms[i]->partition->name, s->roms[i]->partition->fs);
+    }
+}
+
+void multirom_free_status(struct multirom_status *s)
+{
+    list_clear(&s->partitions, &multirom_destroy_partition);
+    list_clear(&s->roms, &multirom_free_rom);
+    free(s->curr_rom_part);
+    free(s->int_display_name);
+    fstab_destroy(s->fstab);
+}
+
+void multirom_free_rom(void *rom)
+{
+    free(((struct multirom_rom*)rom)->name);
+    free(((struct multirom_rom*)rom)->base_path);
+    free(((struct multirom_rom*)rom)->icon_path);
+    free(rom);
+}
+
+void multirom_find_usb_roms(struct multirom_status *s)
+{
+    // remove USB roms
+    int i;
+    for(i = 0; s->roms && s->roms[i];)
+    {
+        if(s->roms[i]->partition)
+        {
+            list_rm_at(&s->roms, i, &multirom_free_rom);
+            i = 0;
+        }
+        else ++i;
+    }
+
+    char path[256];
+    struct usb_partition *p;
+
+    pthread_mutex_lock(&parts_mutex);
+    for(i = 0; s->partitions && s->partitions[i]; ++i)
+        multirom_scan_partition_for_roms(s, s->partitions[i]);
+    pthread_mutex_unlock(&parts_mutex);
+
+    multirom_dump_status(s);
+}
+
+int multirom_scan_partition_for_roms(struct multirom_status *s, struct usb_partition *p)
+{
+    char path[256];
+    int i;
+    struct dirent *dr;
+    struct multirom_rom **add_roms = NULL;
+
+#ifdef MR_MOVE_USB_DIR
+    // groupers will have old "multirom" folder on USB drive instead of "multirom-grouper".
+    // We have to move it.
+    sprintf(path, "%s/multirom", p->mount_path);
+    if(access(path, F_OK) >= 0)
+    {
+        char dest[256];
+        sprintf(dest, "%s/multirom-"TARGET_DEVICE, p->mount_path);
+
+        INFO("Moving usb dir %s to %s!\n", path, dest);
+
+        mkdir(dest, 0777);
+
+        char *cmd[] = { busybox_path, "sh", "-c", malloc(1024), NULL };
+        sprintf(cmd[3], "%s mv \"%s\"/* \"%s\"/", busybox_path, path, dest);
+
+        run_cmd(cmd);
+
+        rmdir(path);
+        free(cmd[3]);
+
+        sync();
+    }
+#endif
+
+    sprintf(path, "%s/multirom-"TARGET_DEVICE, p->mount_path);
+    if(access(path, F_OK) < 0)
+        return -1;
+
+    DIR *d = opendir(path);
+    if(!d)
+        return -1;
+
+    while((dr = readdir(d)) != NULL)
+    {
+        if(dr->d_name[0] == '.')
+            continue;
+
+        struct multirom_rom *rom = malloc(sizeof(struct multirom_rom));
+        memset(rom, 0, sizeof(struct multirom_rom));
+
+        rom->id = multirom_generate_rom_id();
+        rom->name = strdup(dr->d_name);
+
+        sprintf(path, "%s/multirom-"TARGET_DEVICE"/%s", p->mount_path, rom->name);
+        rom->base_path = strdup(path);
+
+        rom->partition = p;
+        rom->type = multirom_get_rom_type(rom);
+
+        sprintf(path, "%s/boot.img", rom->base_path);
+        rom->has_bootimg = access(path, R_OK) == 0 ? 1 : 0;
+
+        multirom_find_rom_icon(rom);
+
+        list_add(&add_roms, rom);
+    }
+    closedir(d);
+
+    if(add_roms)
+    {
+        // sort roms
+        qsort(add_roms, list_item_count(add_roms), sizeof(struct multirom_rom*), compare_rom_names);
+
+        list_add_from_list(&s->roms, add_roms);
+        list_clear(&add_roms, NULL);
+    }
+    return 0;
+}
+
+int multirom_path_exists(char *base, char *filename)
+{
+    char path[256];
+    sprintf(path, "%s/%s", base, filename);
+    if(access(path, R_OK) < 0)
+        return -1;
+    return 0;
+}
+
+int multirom_get_rom_type(struct multirom_rom *rom)
+{
+    if(!rom->partition && strcmp(rom->name, INTERNAL_ROM_NAME) == 0)
+        return ROM_DEFAULT;
+
+    char *b = rom->base_path;
+
+    // Handle android ROMs
+    if(!multirom_path_exists(b, "boot"))
+    {
+        if (!multirom_path_exists(b, "system") && !multirom_path_exists(b, "data") &&
+            !multirom_path_exists(b, "cache"))
+        {
+            if(!rom->partition) return ROM_ANDROID_INTERNAL;
+            else                return ROM_ANDROID_USB_DIR;
+        }
+        else if(!multirom_path_exists(b, "system.img") && !multirom_path_exists(b, "data.img") &&
+                !multirom_path_exists(b, "cache.img"))
+        {
+            return ROM_ANDROID_USB_IMG;
+        }
+    }
+
+    // handle linux ROMs
+    if(!multirom_path_exists(b, "rom_info.txt"))
+    {
+        if(!rom->partition)
+            return ROM_LINUX_INTERNAL;
+        else
+            return ROM_LINUX_USB;
+    }
+
+    // Handle Ubuntu 13.04 - deprecated
+    if ((!multirom_path_exists(b, "root") && multirom_path_exists(b, "boot.img")) ||
+       (!multirom_path_exists(b, "root.img") && rom->partition))
+    {
+        // try to copy rom_info.txt in there, ubuntu is deprecated
+        ERROR("Found deprecated Ubuntu 13.04, trying to copy rom_info.txt...\n");
+        char *cmd[] = { busybox_path, "cp", malloc(256), malloc(256), NULL };
+        sprintf(cmd[2], "%s/infos/ubuntu.txt", mrom_dir());
+        sprintf(cmd[3], "%s/rom_info.txt", b);
+
+        int res = run_cmd(cmd);
+
+        free(cmd[2]);
+        free(cmd[3]);
+
+        if(res != 0)
+        {
+            ERROR("Failed to copy rom_info for Ubuntu!\n");
+            if(!rom->partition) return ROM_UNSUPPORTED_INT;
+            else                return ROM_UNSUPPORTED_USB;
+        }
+        else
+        {
+            if(!rom->partition) return ROM_LINUX_INTERNAL;
+            else                return ROM_LINUX_USB;
+        }
+    }
+
+    // Handle ubuntu 12.10
+    if(!multirom_path_exists(b, "root") && !multirom_path_exists(b, "boot.img"))
+    {
+        if(!rom->partition) return ROM_UNSUPPORTED_INT;
+        else                return ROM_UNSUPPORTED_USB;
+    }
+
+    return ROM_UNKNOWN;
+}
+
+void multirom_import_internal(void)
+{
+    char path[256];
+
+    // multirom
+    mkdir(mrom_dir(), 0777);
+
+    // roms
+    snprintf(path, sizeof(path), "%s/roms", mrom_dir());
+    mkdir(path, 0777);
+
+    // internal rom
+    snprintf(path, sizeof(path), "%s/roms/%s", mrom_dir(), INTERNAL_ROM_NAME);
+    mkdir(path, 0777);
+
+    // set default icon if it doesn't exist yet
+    snprintf(path, sizeof(path), "%s/roms/%s/.icon_data", mrom_dir(), INTERNAL_ROM_NAME);
+    if(access(path, F_OK) < 0)
+    {
+        FILE *f = fopen(path, "we");
+        if(f)
+        {
+            fputs("predef_set\ncom.tassadar.multirommgr:drawable/romic_android\n", f);
+            fclose(f);
+        }
+    }
+}
+
+struct multirom_rom *multirom_get_internal(struct multirom_status *s)
+{
+    int i;
+    for(i = 0; s->roms && s->roms[i]; ++i)
+    {
+        if(s->roms[i]->type == ROM_DEFAULT)
+            return s->roms[i];
+    }
+    ERROR(" Something is wrong, multirom_get_internal returns NULL!\n");
+    return NULL;
+}
+
+struct multirom_rom *multirom_get_rom(struct multirom_status *s, const char *name, const char *part_uuid)
+{
+    if(part_uuid == NULL && strcmp(name, INTERNAL_ROM_NAME) == 0)
+        return multirom_get_internal(s);
+
+    int i = 0;
+    struct multirom_rom *r;
+    for(; s->roms && s->roms[i]; ++i)
+    {
+        r = s->roms[i];
+        if (r->type != ROM_DEFAULT && strcmp(r->name, name) == 0 &&
+           (!part_uuid || (r->partition && strcmp(r->partition->uuid, part_uuid) == 0)))
+        {
+            return r;
+        }
+    }
+
+    return NULL;
+}
+
+int multirom_generate_rom_id(void)
+{
+    static int id = 0;
+    return id++;
+}
+
+struct multirom_rom *multirom_get_rom_by_id(struct multirom_status *s, int id)
+{
+    int i = 0;
+    for(; s->roms && s->roms[i]; ++i)
+        if(s->roms[i]->id == id)
+            return s->roms[i];
+    return NULL;
+}
+
+int multirom_prepare_for_boot(struct multirom_status *s, struct multirom_rom *to_boot)
+{
+    int exit = EXIT_UMOUNT;
+    int type = to_boot->type;
+
+    if(((M(type) & MASK_KEXEC) || to_boot->has_bootimg) && type != ROM_DEFAULT && s->is_second_boot == 0)
+    {
+        if(multirom_load_kexec(s, to_boot) != 0)
+            return -1;
+        exit |= EXIT_KEXEC;
+    }
+
+    switch(type)
+    {
+        case ROM_DEFAULT:
+        {
+            rom_quirks_on_initrd_finalized();
+            break;
+        }
+        case ROM_LINUX_INTERNAL:
+        case ROM_LINUX_USB:
+            break;
+        case ROM_ANDROID_USB_IMG:
+        case ROM_ANDROID_USB_DIR:
+        case ROM_ANDROID_INTERNAL:
+        {
+            if(!(exit & (EXIT_REBOOT | EXIT_KEXEC)))
+            {
+                exit &= ~(EXIT_UMOUNT);
+
+                if(multirom_prep_android_mounts(s, to_boot) == -1)
+                    return -1;
+
+                if(multirom_create_media_link(s) == -1)
+                    return -1;
+
+                rom_quirks_on_initrd_finalized();
+
+                rcadditions_write_to_files(&s->rc);
+                rcadditions_free(&s->rc);
+            }
+
+            if(to_boot->partition)
+                to_boot->partition->keep_mounted = 1;
+            break;
+        }
+        default:
+            ERROR("Unknown ROM type\n");
+            return -1;
+    }
+
+    return exit;
+}
+
+#define EXEC_MASK (S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IXGRP)
+
+char *multirom_find_fstab_in_rc(const char *rcfile)
+{
+    FILE *f = fopen(rcfile, "re");
+    if(!f)
+    {
+        ERROR("Failed to open rcfile %s\n", rcfile);
+        return NULL;
+    }
+
+    char *p,*e;
+    char line[1024];
+    while(fgets(line, sizeof(line), f))
+    {
+        for(p = line; isspace(*p); ++p) { }
+
+        for(e = p+strlen(p)-1; isspace(*e); --e)
+            *e = 0;
+
+        if(*p == '#' || *p == 0)
+            continue;
+
+        if(strstr(p, "mount_all") == p)
+        {
+            fclose(f);
+
+            p += sizeof("mount_all")-1;
+            for(; isspace(*p); ++p) { }
+
+            return strdup(p);
+        }
+    }
+    fclose(f);
+    return NULL;
+}
+
+// On L dev preview and presumably later android releases, the firmware image
+// has mount option "context=...", which sets SELinux context for that whole
+// mount. It needs initialized SELinux in order to successfully mount, which
+// means it can't be done while in multirom (SELinux is initalized in real
+// init, after multirom exits). Workaround as follows:
+//  * inject 'start mrom_fw_mounter' before mount_all command in .rc file
+//  * append service mrom_fw_mounter block into said .rc file. This service
+//    starts binary 'fw_mounter', which is part of MultiROM and it just
+//    mounts the FW image file.
+//  * Copy fw_mounter to /sbin/ and setup its fstab
+//  * Real init starts mrom_fw_mounter service which mounts the image
+//
+// SELinux compains about the fw_mounter not having context set, but it still
+// works. There is a chance Google will disable all services which don't have
+// context set in sepolicy. That will be a problem.
+
+// UPDATE: fw_mounter gets shut down by SELinux on 6.0, inject .rc files and file_contexts instead.
+
+static int multirom_inject_fw_mounter(struct multirom_status *s, struct fstab_part *fw_part)
+{
+    char buf[512];
+
+    rcadditions_append_contexts(&s->rc, fw_part->device);
+    rcadditions_append_contexts(&s->rc, " u:object_r:asec_image_file:s0\n");
+
+    snprintf(buf, sizeof(buf), "    restorecon %s\n", fw_part->device);
+    rcadditions_append_trigger(&s->rc, "fs", buf);
+
+    snprintf(buf, sizeof(buf), "    mount %s loop@%s %s ", fw_part->type, fw_part->device, fw_part->path);
+    rcadditions_append_trigger(&s->rc, "fs", buf);
+
+    if(fw_part->options_raw)
+    {
+        char *c, *opts = strdup(fw_part->options_raw);
+        for(c = opts; *c; ++c)
+            if(*c == ',')
+                *c = ' ';
+        rcadditions_append_trigger(&s->rc, "fs", opts);
+        free(opts);
+    }
+
+    rcadditions_append_trigger(&s->rc, "fs", "\n");
+    return 0;
+}
+
+int multirom_prep_android_mounts(struct multirom_status *s, struct multirom_rom *rom)
+{
+    char in[128];
+    char out[128];
+    char path[256];
+    char *fstab_name = NULL;
+    int has_fw = 0;
+    struct fstab_part *fw_part = NULL;
+    int res = -1;
+
+    sprintf(path, "%s/firmware.img", rom->base_path);
+    has_fw = (access(path, R_OK) >= 0);
+
+    sprintf(path, "%s/boot", rom->base_path);
+
+    DIR *d = opendir(path);
+    if(!d)
+    {
+        ERROR("Failed to open rom path %s\n", path);
+        return -1;
+    }
+
+    struct dirent *dp = NULL;
+
+    while((dp = readdir(d)))
+    {
+        if(dp->d_name[0] == '.' && (dp->d_name[1] == '.' || dp->d_name[1] == 0))
+            continue;
+
+        sprintf(in, "%s/%s", path, dp->d_name);
+        sprintf(out, "/%s", dp->d_name);
+
+        copy_file(in, out);
+
+        if(strstr(dp->d_name, ".rc"))
+        {
+            // set permissions for .rc files
+            chmod(out, EXEC_MASK);
+
+            if(!fstab_name && strcmp(dp->d_name, "init."TARGET_DEVICE".rc") == 0)
+                fstab_name = multirom_find_fstab_in_rc(out);
+        }
+    }
+    closedir(d);
+
+    if(multirom_process_android_fstab(fstab_name, has_fw, &fw_part) != 0)
+        goto exit;
+
+    mkdir_with_perms("/system", 0755, NULL, NULL);
+    mkdir_with_perms("/data", 0771, "system", "system");
+    mkdir_with_perms("/cache", 0770, "system", "cache");
+    if(has_fw)
+        mkdir_with_perms("/firmware", 0771, "system", "system");
+
+    static const char *folders[2][3] =
+    {
+        { "system", "data", "cache" },
+        { "system.img", "data.img", "cache.img" },
+    };
+
+    unsigned long flags[2][3] = {
+        { MS_BIND | MS_RDONLY, MS_BIND, MS_BIND },
+        { MS_RDONLY | MS_NOATIME, MS_NOATIME, MS_NOATIME },
+    };
+
+    uint32_t i;
+    char from[256];
+    char to[256];
+    int img = (int)(rom->type == ROM_ANDROID_USB_IMG);
+    for(i = 0; i < ARRAY_SIZE(folders[0]); ++i)
+    {
+        snprintf(from, sizeof(from), "%s/%s", rom->base_path, folders[img][i]);
+        snprintf(to, sizeof(to), "/%s", folders[0][i]);
+
+        if(img == 0)
+        {
+            if(mount(from, to, "ext4", flags[img][i], "discard,nomblk_io_submit") < 0)
+            {
+                ERROR("Failed to mount %s to %s (%d: %s)\n", from, to, errno, strerror(errno));
+                goto exit;
+            }
+        }
+        else
+        {
+            if(mount_image(from, to, "ext4", flags[img][i], NULL) < 0)
+                goto exit;
+        }
+    }
+
+    if(has_fw && fw_part)
+    {
+        INFO("Mounting ROM's FW image instead of FW partition\n");
+        snprintf(from, sizeof(from), "%s/firmware.img", rom->base_path);
+        fw_part->device = realloc(fw_part->device, strlen(from)+1);
+        strcpy(fw_part->device, from);
+        multirom_inject_fw_mounter(s, fw_part);
+    }
+
+#if MR_DEVICE_HOOKS >= 1
+    int hooks_res = mrom_hook_after_android_mounts(busybox_path, rom->base_path, rom->type);
+    if(hooks_res < 0)
+    {
+        ERROR("mrom_hook_after_android_mounts returned %d!\n", hooks_res);
+        goto exit;
+    }
+#endif
+
+    res = 0;
+exit:
+    if(fw_part)
+        fstab_destroy_part(fw_part);
+    return res;
+}
+
+int multirom_process_android_fstab(char *fstab_name, int has_fw, struct fstab_part **fw_part)
+{
+    int res = -1;
+
+    if(fstab_name != NULL)
+        INFO("Using fstab %s from rc files\n", fstab_name);
+    else
+    {
+        DIR *d = opendir("/");
+        if(!d)
+        {
+            ERROR("Failed to open root folder!\n");
+            return -1;
+        }
+
+        struct dirent *dp = NULL;
+        while((dp = readdir(d)))
+        {
+            if(strstr(dp->d_name, "fstab.") == dp->d_name && strcmp(dp->d_name, "fstab.goldfish") != 0)
+            {
+                fstab_name = realloc(fstab_name, strlen(dp->d_name)+1);
+                strcpy(fstab_name, dp->d_name);
+                // try to find specifically fstab.device
+                if(strcmp(fstab_name, "fstab."TARGET_DEVICE) == 0)
+                    break;
+            }
+        }
+        closedir(d);
+
+        if(!fstab_name)
+        {
+            ERROR("Failed to find fstab file in root!\n");
+            return -1;
+        }
+    }
+
+    ERROR("Modifying fstab: %s\n", fstab_name);
+    struct fstab *tab = fstab_load(fstab_name, 0);
+    if(!tab)
+        goto exit;
+
+    int disable_sys = fstab_disable_parts(tab, "/system");
+    int disable_data = fstab_disable_parts(tab, "/data");
+    int disable_cache = fstab_disable_parts(tab, "/cache");
+
+    if(disable_sys < 0 || disable_data < 0 || disable_cache < 0)
+    {
+#if MR_DEVICE_HOOKS >= 4
+        if(!mrom_hook_allow_incomplete_fstab())
+#endif
+        {
+            goto exit;
+        }
+    }
+
+    if(has_fw)
+    {
+        struct fstab_part *p = fstab_find_first_by_path(tab, "/firmware");
+        if(p)
+        {
+            *fw_part = fstab_clone_part(p);
+            p->disabled = 1;
+        }
+    }
+
+    // Android considers empty fstab invalid
+    if(tab->count <= 3 + has_fw)
+    {
+        INFO("fstab would be empty, adding dummy line\n");
+        fstab_add_part(tab, "tmpfs", "/dummy_tmpfs", "tmpfs", "ro,nosuid,nodev", "defaults");
+        mkdir("/dummy_tmpfs", 0644);
+    }
+
+    if(fstab_save(tab, fstab_name) == 0)
+        res = 0;
+
+exit:
+    if(tab)
+        fstab_destroy(tab);
+    free(fstab_name);
+    return res;
+}
+
+int multirom_create_media_link(struct multirom_status *s)
+{
+    int media_new = 0;
+    int api_level = multirom_get_api_level("/system/build.prop");
+    if(api_level <= 0)
+        return -1;
+
+    struct stat info;
+    if(stat(REALDATA"/media/0", &info) >= 0)
+        media_new = 1;
+
+    static const char *paths[] = {
+        REALDATA"/media",      // 0
+        REALDATA"/media/0",    // 1
+
+        "/data/media",         // 2
+        "/data/media/0",       // 3
+    };
+
+    int from, to;
+
+    if(api_level <= 16)
+    {
+        to = 2;
+        if(!media_new) from = 0;
+        else           from = 1;
+    }
+    else if(api_level >= 17)
+    {
+        from = 0;
+        if(!media_new) to = 3;
+        else           to = 2;
+    }
+
+    ERROR("Making media dir: api %d, media_new %d, %s to %s\n", api_level, media_new, paths[from], paths[to]);
+    if(mkdir_recursive(paths[to], 0775) == -1)
+    {
+        ERROR("Failed to make media dir\n");
+        return -1;
+    }
+
+    if(mount(paths[from], paths[to], "ext4", MS_BIND, "") < 0)
+    {
+        ERROR("Failed to bind media folder %d (%s)\n", errno, strerror(errno));
+        return -1;
+    }
+
+    if(api_level >= 17)
+    {
+        char buf[16];
+        buf[0] = 0;
+
+        FILE *f = fopen(LAYOUT_VERSION, "re");
+        const int rewrite = (!f || !fgets(buf, sizeof(buf), f) || atoi(buf) < 2);
+
+        if(f)
+            fclose(f);
+
+        if(rewrite)
+        {
+            f = fopen(LAYOUT_VERSION, "we");
+            if(!f)
+            {
+                ERROR("Failed to create .layout_version!\n");
+                return -1;
+            }
+
+            fputc(api_level > 19 ? '3' : '2', f);
+            fclose(f);
+            chmod(LAYOUT_VERSION, 0600);
+        }
+
+        // We need to set SELinux context for this file in case it was created by multirom,
+        // but can't do it here because selinux was not initialized
+        rcadditions_append_trigger(&s->rc, "post-fs-data", "    restorecon " LAYOUT_VERSION "\n");
+    }
+
+    return 0;
+}
+
+int multirom_get_api_level(const char *path)
+{
+    FILE *f = fopen(path, "re");
+    if(!f)
+    {
+        ERROR("Could not open %s to read api level!\n", path);
+        return -1;
+    }
+
+    int res = -1;
+    char line[256];
+    while(res == -1 && (fgets(line, sizeof(line), f)))
+    {
+        if(strstr(line, "ro.build.version.sdk=") == line)
+            res = atoi(strchr(line, '=')+1);
+    }
+    fclose(f);
+
+    if(res == 0)
+        ERROR("Invalid ro.build.version.sdk line in build.prop\n");
+
+    return res;
+}
+
+int multirom_get_trampoline_ver(void)
+{
+    static int ver = -2;
+    if(ver == -2)
+    {
+        ver = -1;
+
+        char buff[128];
+        char *cmd[] = { buff, "-v", NULL };
+
+        // If we are booting into another ROM from already running system,
+        // /main_init was moved to /init and we have to use trampoline from
+        // /data/media
+        if(access("/main_init", F_OK) >= 0)
+            snprintf(buff, sizeof(buff), "/init");
+        else
+            snprintf(buff, sizeof(buff), "%s/trampoline", mrom_dir());
+
+        char *res = run_get_stdout(cmd);
+        if(res)
+        {
+            ver = atoi(res);
+            free(res);
+        }
+        else
+        {
+            ERROR("Failed to get trampoline version, run_get_stdout returned NULL!\n");
+        }
+    }
+    return ver;
+}
+
+int multirom_has_kexec(void)
+{
+    static int has_kexec = -1;
+    if(has_kexec != -1)
+        return has_kexec;
+
+#if MR_DEVICE_HOOKS >= 5
+    has_kexec = mrom_hook_has_kexec();
+#endif
+
+    if(has_kexec == -1)
+    {
+        if(access("/proc/config.gz", F_OK) >= 0)
+        {
+            char *cmd_cp[] = { busybox_path, "cp", "/proc/config.gz", "/ikconfig.gz", NULL };
+            run_cmd(cmd_cp);
+
+            char *cmd_gzip[] = { busybox_path, "gzip", "-d", "/ikconfig.gz", NULL };
+            run_cmd(cmd_gzip);
+
+            has_kexec = 1;
+
+            uint32_t i;
+            static const char *checks[] = {
+                "CONFIG_KEXEC_HARDBOOT=y",
+#ifndef MR_KEXEC_DTB
+                "CONFIG_ATAGS_PROC=y",
+#else
+                "CONFIG_PROC_DEVICETREE=y",
+#endif
+            };
+            //                   0             1       2     3
+            char *cmd_grep[] = { busybox_path, "grep", NULL, "/ikconfig", NULL };
+            for(i = 0; i < ARRAY_SIZE(checks); ++i)
+            {
+                cmd_grep[2] = (char*)checks[i];
+                if(run_cmd(cmd_grep) != 0)
+                {
+                    has_kexec = 0;
+                    ERROR("%s not found in /proc/config.gz!\n", checks[i]);
+                }
+            }
+
+            remove("/ikconfig");
+        }
+        else
+        {
+            // Kernel without /proc/config.gz enabled - check for /proc/atags file,
+            // if it is present, there is good change kexec-hardboot is enabled too.
+            ERROR("/proc/config.gz is not available!\n");
+#ifndef MR_KEXEC_DTB
+            const char *checkfile = "/proc/atags";
+#else
+            const char *checkfile = "/proc/device-tree";
+#endif
+            if(access(checkfile, R_OK) < 0)
+            {
+                ERROR("%s was not found!\n", checkfile);
+                has_kexec = 0;
+            }
+            else
+                has_kexec = 1;
+        }
+    }
+
+    if(has_kexec && mr_system("%s -u", kexec_path) != 0)
+    {
+        ERROR("kexec -u test has failed, kernel doesn't have kexec-hardboot patch enabled in config!\n");
+        has_kexec = 0;
+    }
+
+    return has_kexec;
+}
+
+int multirom_get_bootloader_cmdline(struct multirom_status *s, char *str, size_t size)
+{
+    FILE *f;
+    char *c, *e, *l;
+    int res = -1;
+    int bootimg_loaded = 0;
+    struct boot_img_hdr hdr;
+    struct fstab_part *boot;
+
+    f = fopen("/proc/cmdline", "re");
+    if(!f)
+        return -1;
+
+    str[0] = 0;
+
+    if(fgets(str, size, f) == NULL)
+        goto exit;
+
+    for(c = str; *c; ++c)
+        if(*c == '\n')
+            *c = ' ';
+
+    // Remove the part from boot.img
+    if(s->is_running_in_primary_rom || !s->current_rom || !s->current_rom->has_bootimg)
+    {
+        boot = fstab_find_first_by_path(s->fstab, "/boot");
+        if(boot && libbootimg_load_header(&hdr, boot->device) >= 0)
+            bootimg_loaded = 1;
+    }
+    else
+    {
+        char buf[256];
+        snprintf(buf, sizeof(buf), "%s/boot.img", s->current_rom->base_path);
+        if(libbootimg_load_header(&hdr, buf) >= 0)
+            bootimg_loaded = 1;
+    }
+
+    if(bootimg_loaded)
+    {
+        l = (char*)hdr.cmdline;
+        hdr.cmdline[BOOT_ARGS_SIZE-1] = 0;
+
+#if MR_DEVICE_HOOKS >= 5
+        mrom_hook_fixup_bootimg_cmdline(l, BOOT_ARGS_SIZE);
+#endif
+
+        if(*l != 0 && (c = strstr(str, l)))
+        {
+            e = c + strlen(l);
+            if(*e == ' ')
+                ++e;
+            memmove(c, e, strlen(e)+1); // plus NULL
+        }
+    }
+
+    res = 0;
+exit:
+    fclose(f);
+    return res;
+}
+
+int multirom_find_file(char *res, const char *name_part, const char *path)
+{
+    DIR *d = opendir(path);
+    if(!d)
+        return -1;
+
+    int wild = 0;
+    int len = strlen(name_part);
+    char *name = (char*)name_part;
+    char *i;
+    if((i = strchr(name_part, '*')))
+    {
+        wild = 1;
+        name = strndup(name_part, i-name);
+    }
+
+    int ret= -1;
+    struct dirent *dr;
+    while(ret == -1 && (dr = readdir(d)))
+    {
+        if(dr->d_name[0] == '.')
+            continue;
+
+        if ((!wild && strcmp(dr->d_name, name)) ||
+           ((wild && !strstr(dr->d_name, name))))
+            continue;
+
+        sprintf(res, "%s/%s", path, dr->d_name);
+        ret = 0;
+    }
+    closedir(d);
+    if(wild)
+        free(name);
+    return ret;
+}
+
+int multirom_load_kexec(struct multirom_status *s, struct multirom_rom *rom)
+{
+    int res = -1;
+    struct kexec kexec;
+    int loop_mounted = 0;
+
+    // to find /data partition
+    if(!rom->partition && multirom_update_partitions(s) < 0)
+    {
+        ERROR("Failed to update partitions\n");
+        return -1;
+    }
+
+    kexec_init(&kexec, kexec_path);
+    kexec_add_arg(&kexec, "--mem-min="MR_KEXEC_MEM_MIN);
+#ifdef MR_KEXEC_DTB
+    kexec_add_arg_prefix(&kexec, "--boardname=", TARGET_DEVICE);
+#endif
+
+    switch(rom->type)
+    {
+        case ROM_ANDROID_INTERNAL:
+        case ROM_ANDROID_USB_DIR:
+        case ROM_ANDROID_USB_IMG:
+            if(multirom_fill_kexec_android(s, rom, &kexec) != 0)
+                goto exit;
+            break;
+        case ROM_LINUX_INTERNAL:
+        case ROM_LINUX_USB:
+            loop_mounted = multirom_fill_kexec_linux(s, rom, &kexec);
+            if(loop_mounted < 0)
+                goto exit;
+            break;
+        default:
+            ERROR("Unsupported rom type to kexec (%d)!\n", rom->type);
+            goto exit;
+    }
+
+    res = kexec_load_exec(&kexec);
+
+    char *cmd_cp[] = { busybox_path, "cp", kexec_path, "/kexec", NULL };
+    run_cmd(cmd_cp);
+    chmod("/kexec", 0755);
+
+    if(loop_mounted)
+        umount("/mnt/image");
+
+    multirom_copy_log(NULL, "last_kexec_log.txt");
+
+exit:
+    kexec_destroy(&kexec);
+    return res;
+}
+
+int multirom_fill_kexec_android(struct multirom_status *s, struct multirom_rom *rom, struct kexec *kexec)
+{
+    int res = -1;
+    char img_path[256];
+    snprintf(img_path, sizeof(img_path), "%s/boot.img", rom->base_path);
+
+    // Trampolines in ROM boot images may get out of sync, so we need to check it and
+    // update if needed. I can't do that during ZIP installation because of USB drives.
+    if(inject_bootimg(img_path, 0) < 0)
+    {
+        ERROR("Failed to inject bootimg!\n");
+        return -1;
+    }
+
+    struct bootimg img;
+    if(libbootimg_init_load(&img, img_path, LIBBOOTIMG_LOAD_ALL) < 0)
+    {
+        ERROR("fill_kexec could not open boot image (%s)!\n", img_path);
+        return -1;
+    }
+
+    if(libbootimg_dump_kernel(&img, "/zImage") < 0)
+        goto exit;
+
+    if(libbootimg_dump_ramdisk(&img, "/initrd.img") < 0)
+        goto exit;
+
+    kexec_add_kernel(kexec, "/zImage", 1);
+    kexec_add_arg(kexec, "--initrd=/initrd.img");
+
+#ifdef MR_KEXEC_DTB
+    if(libbootimg_dump_dtb(&img, "/dtb.img") >= 0)
+        kexec_add_arg(kexec, "--dtb=/dtb.img");
+    else
+        kexec_add_arg(kexec, "--dtb");
+#endif
+
+    char cmdline[1536];
+    strcpy(cmdline, "--command-line=");
+
+    if(img.hdr.cmdline[0] != 0)
+    {
+        img.hdr.cmdline[BOOT_ARGS_SIZE-1] = 0;
+
+        // see multirom_get_bootloader_cmdline
+#if MR_DEVICE_HOOKS >= 5
+        mrom_hook_fixup_bootimg_cmdline((char*)img.hdr.cmdline, BOOT_ARGS_SIZE);
+#endif
+
+        strcat(cmdline, (char*)img.hdr.cmdline);
+        strcat(cmdline, " ");
+    }
+
+    if(multirom_get_bootloader_cmdline(s, cmdline+strlen(cmdline), sizeof(cmdline)-strlen(cmdline)-1) == -1)
+    {
+        ERROR("Failed to get cmdline\n");
+        goto exit;
+    }
+
+    if(!strstr(cmdline, " mrom_kexecd=1") && sizeof(cmdline)-strlen(cmdline)-1 >= sizeof("mrom_kexecd=1"))
+        strcat(cmdline, "mrom_kexecd=1");
+
+    kexec_add_arg(kexec, cmdline);
+
+    res = 0;
+exit:
+    libbootimg_destroy(&img);
+    return res;
+}
+
+static char *find_boot_file(char *path, char *root_path, char *base_path)
+{
+    if(!path)
+        return NULL;
+
+    struct stat info;
+    char cmd[256];
+    char *root = strstr(path, "%r");
+    if(root)
+        snprintf(cmd, sizeof(cmd), "%s/%s", root_path, root+2);
+    else
+        snprintf(cmd, sizeof(cmd), "%s/%s", base_path, path);
+
+    char *last = strrchr(cmd, '/');
+    if(!last)
+    {
+        ERROR("Failed to find boot file: %s\n", cmd);
+        return NULL;
+    }
+
+    *last = 0;
+
+    char *name = strdup(last+1);
+    char res[256];
+    if(multirom_find_file(res, name, cmd) < 0)
+    {
+        ERROR("Failed to find boot file: %s\n", cmd);
+        free(name);
+        return NULL;
+    }
+    return strdup(res);
+}
+
+int multirom_fill_kexec_linux(struct multirom_status *s, struct multirom_rom *rom, struct kexec *kexec)
+{
+    struct rom_info *info = multirom_parse_rom_info(s, rom);
+    if(!info)
+        return -1;
+
+    int res = -1;
+    int root_type = -1; // 0 = dir, 1 = img
+    int loop_mounted = 0;
+    char root_path[256];
+    const char *base_path;
+
+    if(!rom->partition)
+        base_path = partition_dir;
+    else
+        base_path = rom->partition->mount_path;
+
+    struct stat st;
+    char path[256];
+    char *tmp;
+
+    if((tmp = map_get_val(info->str_vals, "root_img")))
+    {
+        sprintf(path, "%s/%s", base_path, tmp);
+        if(stat(path, &st) >= 0)
+        {
+            root_type = 1;
+
+            char *img_fs = map_get_val(info->str_vals, "root_img_fs");
+
+            // mount the image file
+            mkdir("/mnt", 0777);
+            mkdir("/mnt/image", 0777);
+            if(mount_image(path, "/mnt/image", img_fs ? img_fs : "ext4", MS_NOATIME, NULL) < 0)
+                goto exit;
+
+            loop_mounted = 1;
+            strcpy(root_path, "/mnt/image");
+        }
+        else
+            ERROR("Path %s not found!\n", path);
+    }
+
+    if(root_type == -1 && (tmp = map_get_val(info->str_vals, "root_dir")))
+    {
+        sprintf(path, "%s/%s", base_path, tmp);
+        if(stat(path, &st) >= 0)
+        {
+            root_type = 0;
+            strcpy(root_path, path);
+        }
+        else
+            ERROR("Path %s not found!\n", path);
+    }
+
+    if(root_type == -1)
+    {
+        ERROR("Failed to find root of the ROM!\n");
+        goto exit;
+    }
+
+    char *str = find_boot_file(map_get_val(info->str_vals, "kernel_path"), root_path, rom->base_path);
+    if(str)
+    {
+        kexec_add_kernel(kexec, str, 1);
+        free(str);
+    }
+    else
+    {
+        // kernel is required
+        goto exit;
+    }
+
+#ifdef MR_KEXEC_DTB
+    str = NULL;
+
+    if (map_find(info->str_vals, "dtb_path") != -1)
+    {
+        str = find_boot_file(map_get_val(info->str_vals, "dtb_path"), root_path, rom->base_path);
+        if(!str)
+        {
+            ERROR("failed to find dtb_path!\n");
+            goto exit;
+        }
+    }
+    else
+    {
+        str = find_boot_file("%r/dtb.img", root_path, rom->base_path);
+    }
+
+    if(!str)
+        kexec_add_arg(kexec, "--dtb");
+    else
+    {
+        kexec_add_arg_prefix(kexec, "--dtb=", str);
+        free(str);
+    }
+#endif
+
+    str = find_boot_file(map_get_val(info->str_vals, "initrd_path"), root_path, rom->base_path);
+    if(str)
+    {
+        kexec_add_arg_prefix(kexec, "--initrd=", str);
+        free(str);
+    }
+
+    char cmdline[1536];
+    snprintf(cmdline, sizeof(cmdline), "--command-line=%s ", (char*)map_get_val(info->str_vals, "base_cmdline"));
+
+    str = NULL;
+    if(root_type == 0)
+        str = map_get_val(info->str_vals, "dir_cmdline");
+    else if(root_type == 1)
+        str = map_get_val(info->str_vals, "img_cmdline");
+
+    if(str)
+    {
+        if(strlen(str)+strlen(cmdline)+1 <= sizeof(cmdline))
+            strcat(cmdline, str);
+        else
+        {
+            ERROR("failed to fill kexec info, cmdline is too long!\n");
+            goto exit;
+        }
+    }
+
+    kexec_add_arg(kexec, cmdline);
+
+    res = loop_mounted;
+exit:
+    multirom_destroy_rom_info(info);
+    return res;
+}
+
+#define INFO_LINE_BUFF 4096
+struct rom_info *multirom_parse_rom_info(struct multirom_status *s, struct multirom_rom *rom)
+{
+    char path[256];
+
+    snprintf(path, sizeof(path), "%s/rom_info.txt", rom->base_path);
+    ERROR("Parsing %s...\n", path);
+
+    FILE *f = fopen(path, "re");
+    if(!f)
+    {
+        ERROR("Failed to open %s!\n", path);
+        return NULL;
+    }
+
+    struct rom_info *i = malloc(sizeof(struct rom_info));
+    memset(i, 0, sizeof(struct rom_info));
+    i->str_vals = map_create();
+
+    char *line = malloc(INFO_LINE_BUFF);
+    char key[32];
+    int line_cnt = 1;
+    for(; fgets(line, INFO_LINE_BUFF, f); ++line_cnt)
+    {
+        if(line[0] == '#')
+            continue;
+
+        char *val = strchr(line, '=');
+        if(!val || val-line >= (int)(sizeof(key)-1))
+            continue;
+
+        strncpy(key, line, val-line);
+        key[val-line] = 0;
+        ++val; // skip '=' char
+
+        // if string value
+        {
+            char *str = parse_string(val);
+            if(str)
+                map_add(i->str_vals, key, str, &free);
+            else
+                ERROR("Line %d: failed to parse string\n", line_cnt);
+        }
+    }
+    free(line);
+    fclose(f);
+
+    static const char *roots[] = { "root_dir", "root_img", NULL };
+    int found_root = 0;
+    int y;
+    for(y = 0; roots[y] && !found_root; ++y)
+    {
+        if(map_find(i->str_vals, (char*)roots[y]) >= 0)
+            found_root = 1;
+    }
+
+    if(!found_root)
+        ERROR("Failed to find any root key in %s\n", path);
+
+    static const char *req_keys[] = { "type", "kernel_path", "base_cmdline", NULL};
+    int failed = !found_root;
+    for(y = 0; req_keys[y]; ++y)
+    {
+        if(map_find(i->str_vals, (char*)req_keys[y]) < 0)
+        {
+            ERROR("Key \"%s\" key not found in %s\n", req_keys[y], path);
+            failed = 1;
+        }
+    }
+
+    // Only supported type is kexec, check just to make sure older releases
+    // can't try to run newer ROMs
+    if(failed == 0)
+    {
+        char *val = map_get_val(i->str_vals, "type");
+        if(strcmp(val, "kexec") != 0)
+        {
+            ERROR("Only supported rom_info type is \"kexec\", this rom_info has type \"%s\"!\n", val);
+            failed = 1;
+        }
+    }
+
+    if(failed == 1)
+    {
+        multirom_destroy_rom_info(i);
+        return NULL;
+    }
+
+    char **ref;
+    ERROR("Replacing aliases in root paths...\n");
+    for(y = 0; roots[y]; ++y)
+        if((ref = map_get_ref(i->str_vals, (char*)roots[y])))
+            multirom_replace_aliases_root_path(ref, rom);
+
+    ERROR("Replacing aliases in the cmdline...\n");
+    static const char *cmdlines[] = { "base_cmdline", "img_cmdline", "dir_cmdline", NULL };
+    for(y = 0; cmdlines[y]; ++y)
+        if((ref = map_get_ref(i->str_vals, (char*)cmdlines[y])))
+            multirom_replace_aliases_cmdline(ref, i, s, rom);
+
+    return i;
+}
+
+void multirom_destroy_rom_info(struct rom_info *info)
+{
+    if(!info)
+        return;
+
+    map_destroy(info->str_vals, &free);
+    free(info);
+}
+
+/*
+# Set up the cmdline
+# img_cmdline and dir_cmdline are appended to base_cmdline.
+# Several aliases are used:
+#  - %b - base command line from bootloader. You want this as first thing in cmdline.
+#  - %d - root device. is either "UUID=..." (USB drive) or "/dev/mmcblk0p9" or "/dev/mmcblk0p10"
+#  - %r - root fs type
+#  - %s - root directory, from root of the root device
+#  - %i - root image, from root of the root device
+#  - %f - fs of the root image
+*/
+int multirom_replace_aliases_cmdline(char **s, struct rom_info *i, struct multirom_status *status, struct multirom_rom *rom)
+{
+    size_t c = strcspn (*s, "%");
+
+    if(strlen(*s) == c)
+        return 0;
+
+    struct fstab_part *data_part = NULL;
+    if(!rom->partition)
+    {
+        // FIXME: might have wrong fs type, because of those "multi-fs" bullshit fstabs
+        // with multiple entries for /data
+        data_part = fstab_find_first_by_path(status->fstab, "/data");
+    }
+
+    char *buff = mzalloc(4096);
+
+    char *itr_o = buff;
+    char *itr_i = *s;
+    int res = -1;
+
+    while(1)
+    {
+        memcpy(itr_o, itr_i, c);
+        itr_o += c;
+        itr_i += c;
+
+        *itr_o = 0;
+
+        if(*itr_i != '%')
+            break;
+
+        ++itr_i;
+        switch(*itr_i)
+        {
+            // base command line from bootloader. You want this as first thing in cmdline.
+            case 'b':
+            {
+                if(multirom_get_bootloader_cmdline(status, itr_o, 1024) == -1)
+                {
+                    ERROR("Failed to get cmdline\n");
+                    goto fail;
+                }
+                break;
+            }
+            // root device. is either "UUID=..." (USB drive) or "/dev/mmcblk0p9" or "/dev/mmcblk0p10"
+            case 'd':
+            {
+                if(data_part)
+                {
+                    // Only android's ueventd creates /dev/block, so try to remove it
+                    // for _real_ linux OS. We can't use UUID, because it's the same for
+                    // /system, /data and /cache partitions
+                    char *blk = strstr(data_part->device, "/dev/block/");
+                    if(blk)
+                    {
+                        strcpy(itr_o, "/dev/");
+                        strcat(itr_o, blk+sizeof("/dev/block/")-1);
+                    }
+                    else
+                        strcpy(itr_o, data_part->device);
+                }
+                else if(rom->partition)
+                    sprintf(itr_o, "UUID=%s", rom->partition->uuid);
+                else
+                    ERROR("Failed to set root device\n");
+                break;
+            }
+            // root fs type
+            case 'r':
+            {
+                if(data_part)
+                    strcpy(itr_o, data_part->type);
+                else if(rom->partition)
+                {
+                    if(!strcmp(rom->partition->fs, "ntfs"))
+                        strcpy(itr_o, "ntfs-3g");
+                    else
+                        strcpy(itr_o, rom->partition->fs);
+                }
+                else
+                    ERROR("Failed to set root fs type\n");
+                break;
+            }
+            // root directory, from root of the root device
+            case 's':
+            {
+                char *d = map_get_val(i->str_vals, "root_dir");
+                if(!d)
+                {
+                    ERROR("%%s alias found in cmdline, but root_dir key was not found!\n");
+                    break;
+                }
+                sprintf(itr_o, "%s", d);
+                break;
+            }
+            // root image, from root of the root device
+            case 'i':
+            {
+                char *d = map_get_val(i->str_vals, "root_img");
+                if(!d)
+                {
+                    ERROR("%%s alias found in cmdline, but root_img key was not found!\n");
+                    break;
+                }
+                sprintf(itr_o, "%s", d);
+                break;
+            }
+            // fs of the root image
+            case 'f':
+            {
+                char *d = map_get_val(i->str_vals, "root_img_fs");
+                if(!d)
+                {
+                    ERROR("%%s alias found in cmdline, but root_img_fs key was not found!\n");
+                    break;
+                }
+                strcpy(itr_o, d);
+                break;
+            }
+        }
+        itr_o += strlen(itr_o);
+        c = strcspn (++itr_i, "%");
+    }
+
+    free(*s);
+    *s = realloc(buff, strlen(buff)+1);
+
+    ERROR("Alias-replaced cmdline: %s\n", *s);
+    return 0;
+
+fail:
+    free(buff);
+    return -1;
+}
+
+// - %m - ROMs folder (eg. /sdcard/multirom/roms/*rom_name*)
+int multirom_replace_aliases_root_path(char **s, struct multirom_rom *rom)
+{
+    char *alias = strstr(*s, "%m");
+    if(!alias)
+        return 0;
+
+    char buff[256] = { 0 };
+    memcpy(buff, *s, alias-*s);
+
+    if(rom->partition)
+        strcat(buff, rom->base_path + strlen(rom->partition->mount_path));
+    else
+        strcat(buff, rom->base_path + strlen(partition_dir));
+
+    strcat(buff, alias+2);
+
+    ERROR("Alias-replaced path: %s\n", buff);
+
+    free(*s);
+    *s = strdup(buff);
+    return 0;
+}
+
+int multirom_extract_bytes(const char *dst, FILE *src, size_t size)
+{
+    FILE *f = fopen(dst, "we");
+    if(!f)
+    {
+        ERROR("Failed to open dest file %s\n", dst);
+        return -1;
+    }
+
+    char *buff = malloc(size);
+
+    fread(buff, 1, size, src);
+    fwrite(buff, 1, size, f);
+
+    fclose(f);
+    free(buff);
+    return 0;
+}
+
+void multirom_destroy_partition(void *part)
+{
+    struct usb_partition *p = (struct usb_partition *)part;
+    if(p->mount_path && p->keep_mounted == 0)
+        umount(p->mount_path);
+
+    free(p->name);
+    free(p->uuid);
+    free(p->mount_path);
+    free(p->fs);
+    free(p);
+}
+
+int multirom_update_partitions(struct multirom_status *s)
+{
+    pthread_mutex_lock(&parts_mutex);
+
+    list_clear(&s->partitions, &multirom_destroy_partition);
+
+    int exit_code = 0;
+    char *cmd[] = { busybox_path, "blkid", NULL };
+    char *res = run_get_stdout_with_exit(cmd, &exit_code);
+    if(exit_code != 0 || res == NULL)
+    {
+        free(res);
+        pthread_mutex_unlock(&parts_mutex);
+        return exit_code == 0 ? 0 : -1;
+    }
+
+    char *tok;
+    char *name;
+    struct usb_partition *part;
+
+    char *line = strtok(res, "\n");
+    while(line != NULL)
+    {
+        if(strstr(line, "/dev/") != line)
+        {
+            ERROR("blkid line does not start with /dev/!\n");
+            break;
+        }
+
+        tok = strrchr(line, '/')+1;
+        name = strndup(tok, strchr(tok, ':') - tok);
+        if(strncmp(name, "mmcblk0", 7) == 0 || strncmp(name, "dm-", 3) == 0) // ignore internal nand
+        {
+            free(name);
+            goto next_itr;
+        }
+
+        part = mzalloc(sizeof(struct usb_partition));
+        part->name = name;
+
+        tok = strstr(line, "UUID=\"");
+        if(tok)
+        {
+            tok += sizeof("UUID=\"")-1;
+            part->uuid = strndup(tok, strchr(tok, '"') - tok);
+        }
+        else
+        {
+            ERROR("Part %s does not have UUID, line: \"%s\"\n", part->name, line);
+            multirom_destroy_partition(part);
+            goto next_itr;
+        }
+
+        tok = strstr(line, "TYPE=\"");
+        if(tok)
+        {
+            tok += sizeof("TYPE=\"")-1;
+            part->fs = strndup(tok, strchr(tok, '"') - tok);
+        }
+
+        if(part->fs && multirom_mount_usb(part) == 0)
+        {
+            list_add(&s->partitions, part);
+            ERROR("Found part %s: %s, %s\n", part->name, part->uuid, part->fs);
+        }
+        else
+        {
+            ERROR("Failed to mount part %s %s, %s\n", part->name, part->uuid, part->fs);
+            multirom_destroy_partition(part);
+        }
+
+next_itr:
+        line = strtok(NULL, "\n");
+    }
+    pthread_mutex_unlock(&parts_mutex);
+    free(res);
+
+    return 0;
+}
+
+int multirom_mount_usb(struct usb_partition *part)
+{
+    mkdir("/mnt", 0777);
+    mkdir("/mnt/mrom", 0777);
+
+    char path[256];
+    snprintf(path, sizeof(path), "/mnt/mrom/%s", part->name);
+    if(mkdir(path, 0777) != 0 && errno != EEXIST)
+    {
+        ERROR("Failed to create dir for mount %s\n", path);
+        return -1;
+    }
+
+    char src[256];
+    snprintf(src, sizeof(src), "/dev/block/%s", part->name);
+
+    if(strncmp(part->fs, "ntfs", 4) == 0)
+    {
+        char *cmd[] = { ntfs_path, src, path, NULL };
+        if(run_cmd(cmd) != 0)
+        {
+            ERROR("Failed to mount %s with ntfs-3g\n", src);
+            return -1;
+        }
+    }
+    else if(strcmp(part->fs, "exfat") == 0)
+    {
+        char *cmd[] = { exfat_path, "-o", "big_writes,max_read=131072,max_write=131072,nonempty", src, path, NULL };
+        if(run_cmd(cmd) != 0)
+        {
+            ERROR("Failed to mount %s with exfat\n", src);
+            return -1;
+        }
+    }
+    else if(mount(src, path, part->fs, MS_NOATIME, "") < 0)
+    {
+        ERROR("Failed to mount %s (%d: %s)\n", src, errno, strerror(errno));
+        return -1;
+    }
+
+    part->mount_path = strdup(path);
+    return 0;
+}
+
+void *multirom_usb_refresh_thread_work(void *status)
+{
+    uint32_t timer = 0;
+    struct stat info;
+
+    // stat.st_ctime is defined as unsigned long instead
+    // of time_t in android
+    unsigned long last_ctime = 0;
+    unsigned long last_ctime_nsec = 0;
+
+    while(run_usb_refresh)
+    {
+        if(timer <= 50)
+        {
+            if (stat("/dev/block", &info) >= 0 &&
+                (info.st_ctime != last_ctime || info.st_ctimensec != last_ctime_nsec))
+            {
+                multirom_update_partitions((struct multirom_status*)status);
+
+                if(usb_refresh_handler)
+                    (*usb_refresh_handler)();
+
+                last_ctime = info.st_ctime;
+                last_ctime_nsec = info.st_ctimensec;
+            }
+            timer = 500;
+        }
+        else
+            timer -= 50;
+        usleep(50000);
+    }
+    return NULL;
+}
+
+void multirom_set_usb_refresh_thread(struct multirom_status *s, int run)
+{
+    if(run_usb_refresh == run)
+        return;
+
+    run_usb_refresh = run;
+    if(run)
+        pthread_create(&usb_refresh_thread, NULL, multirom_usb_refresh_thread_work, s);
+    else
+        pthread_join(usb_refresh_thread, NULL);
+}
+
+void multirom_set_usb_refresh_handler(void (*handler)(void))
+{
+    usb_refresh_handler = handler;
+}
+
+char *multirom_get_klog(void)
+{
+    int len = klogctl(10, NULL, 0);
+    if      (len < 16*1024)      len = 16*1024;
+    else if (len > 16*1024*1024) len = 16*1024*1024;
+
+    char *buff = malloc(len + 1);
+    len = klogctl(3, buff, len);
+    if(len <= 0)
+    {
+        ERROR("Could not get klog!\n");
+        free(buff);
+        return NULL;
+    }
+    buff[len] = 0;
+    return buff;
+}
+
+int multirom_copy_log(char *klog, const char *dest_path_relative)
+{
+    int res = 0;
+    int freeLog = (klog == NULL);
+
+    if(!klog)
+        klog = multirom_get_klog();
+
+    if(klog)
+    {
+        char path[256];
+        snprintf(path, sizeof(path), "%s/%s", mrom_dir(), dest_path_relative);
+        FILE *f = fopen(path, "we");
+
+        if(f)
+        {
+            fwrite(klog, 1, strlen(klog), f);
+            fclose(f);
+            chmod(path, 0777);
+        }
+        else
+        {
+            ERROR("Failed to open %s!\n", path);
+            res = -1;
+        }
+    }
+    else
+    {
+        ERROR("Could not get klog!\n");
+        res = -1;
+    }
+
+    if(freeLog)
+        free(klog);
+    return res;
+}
+
+struct usb_partition *multirom_get_partition(struct multirom_status *s, char *uuid)
+{
+    int i;
+    for(i = 0; s->partitions && s->partitions[i]; ++i)
+        if(strcmp(s->partitions[i]->uuid, uuid) == 0)
+            return s->partitions[i];
+    return NULL;
+}
+
+int multirom_get_battery(void)
+{
+    char buff[4];
+
+    FILE *f = fopen(BATTERY_CAP, "re");
+    if(!f)
+        return -1;
+
+    fgets(buff, sizeof(buff), f);
+    fclose(f);
+
+    return atoi(buff);
+}
+
+int multirom_run_scripts(const char *type, struct multirom_rom *rom)
+{
+    char buff[512];
+    snprintf(buff, sizeof(buff), "%s/%s", rom->base_path, type);
+    if(access(buff, (R_OK | X_OK)) < 0)
+    {
+        ERROR("No %s scripts for ROM %s\n", type, rom->name);
+        return 0;
+    }
+
+    ERROR("Running %s scripts for ROM %s...\n", type, rom->name);
+
+    int res = mr_system("B=\"%s\"; P=\"%s\"; for x in $(\"$B\" ls \"$P/%s/\"*.sh); do echo Running script $x; \"$B\" sh $x \"$B\" \"$P\" || exit 1; done", busybox_path, rom->base_path, type);
+    if(res != 0)
+    {
+        ERROR("Error running scripts (%d)!\n", res);
+        return res;
+    }
+    return 0;
+}
+
+#define IC_TYPE_PREDEF 0
+#define IC_TYPE_USER   1
+#define USER_IC_PATH "../Android/data/com.tassadar.multirommgr/files"
+#define USER_IC_PATH_LEN 46
+#define DEFAULT_ICON "/icons/romic_default.png"
+#define DEFAULT_ICON_LEN 24
+
+void multirom_find_rom_icon(struct multirom_rom *rom)
+{
+    FILE *f;
+    int type = 0, len;
+    char buff[256];
+
+    snprintf(buff, sizeof(buff), "%s/.icon_data", rom->base_path);
+
+    f = fopen(buff, "re");
+    if(!f)
+        goto fail;
+
+    if(!fgets(buff, sizeof(buff), f))
+        goto fail;
+
+    if(strcmp(buff, "predef_set\n") == 0)
+        type = IC_TYPE_PREDEF;
+    else if(strcmp(buff, "user_defined\n") == 0)
+        type = IC_TYPE_USER;
+    else
+        goto fail;
+
+    if(!fgets(buff, sizeof(buff), f))
+        goto fail;
+    fclose(f);
+    f = NULL;
+
+    len = strlen(buff);
+    if(len < 2)
+        goto fail;
+
+    buff[--len] = 0; // remove \n
+
+    switch(type)
+    {
+        case IC_TYPE_PREDEF:
+        {
+            char *ic_name = strrchr(buff, '/');
+            if(!ic_name)
+                goto fail;
+
+            len = strlen(mrom_dir()) + 6 + strlen(ic_name)+4+1; // + /icons + .png + \0
+            rom->icon_path = malloc(len);
+            snprintf(rom->icon_path, len, "%s/icons%s.png", mrom_dir(), ic_name);
+            break;
+        }
+        case IC_TYPE_USER:
+        {
+            len = strlen(mrom_dir()) + 1 + USER_IC_PATH_LEN + 1 + len + 4 + 1; // + / + / + .png + \0
+            rom->icon_path = malloc(len);
+            snprintf(rom->icon_path, len, "%s/%s/%s.png", mrom_dir(), USER_IC_PATH, buff);
+            break;
+        }
+    }
+
+    if(access(rom->icon_path, F_OK) < 0)
+        goto fail;
+
+    return;
+fail:
+    if(f)
+        fclose(f);
+
+    len = strlen(mrom_dir()) + DEFAULT_ICON_LEN + 1;
+    rom->icon_path = realloc(rom->icon_path, len);
+    snprintf(rom->icon_path, len, "%s%s", mrom_dir(), DEFAULT_ICON);
+}
diff --git a/multirom.h b/multirom.h
index 04504c8..abaeae3 100755
--- a/multirom.h
+++ b/multirom.h
@@ -1,174 +1,174 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MULTIROM_H
-#define MULTIROM_H
-
-#include <pthread.h>
-#include <stdio.h>
-#include <malloc.h>
-
-#include "lib/fstab.h"
-#include "lib/containers.h"
-#include "kexec.h"
-#include "rcadditions.h"
-
-enum
-{
-    ROM_DEFAULT           = 0,
-
-    ROM_ANDROID_INTERNAL  = 1,
-    ROM_ANDROID_USB_IMG   = 2,
-    ROM_ANDROID_USB_DIR   = 3,
-
-    ROM_LINUX_INTERNAL    = 4,
-    ROM_LINUX_USB         = 5,
-
-    ROM_UNSUPPORTED_INT   = 6,
-    ROM_UNSUPPORTED_USB   = 7,
-    ROM_UNKNOWN           = 8
-};
-
-#define M(x) (1 << x)
-#define MASK_INTERNAL (M(ROM_DEFAULT) | M(ROM_ANDROID_INTERNAL) | M(ROM_UNSUPPORTED_INT) | M(ROM_LINUX_INTERNAL))
-#define MASK_USB_ROMS (M(ROM_ANDROID_USB_IMG) | M(ROM_ANDROID_USB_DIR) | M(ROM_UNSUPPORTED_USB) | M(ROM_LINUX_USB))
-#define MASK_ANDROID (M(ROM_ANDROID_USB_DIR) | M(ROM_ANDROID_USB_IMG) | M(ROM_ANDROID_INTERNAL))
-#define MASK_UNSUPPORTED (M(ROM_UNSUPPORTED_USB) | M(ROM_UNSUPPORTED_INT))
-#define MASK_LINUX (M(ROM_LINUX_INTERNAL) | M(ROM_LINUX_USB))
-#define MASK_KEXEC (MASK_LINUX)
-
-enum
-{
-    EXIT_REBOOT              = 0x01,
-    EXIT_UMOUNT              = 0x02,
-    EXIT_REBOOT_RECOVERY     = 0x04,
-    EXIT_REBOOT_BOOTLOADER   = 0x08,
-    EXIT_SHUTDOWN            = 0x10,
-    EXIT_KEXEC               = 0x20,
-
-    EXIT_REBOOT_MASK         = (EXIT_REBOOT | EXIT_REBOOT_RECOVERY | EXIT_REBOOT_BOOTLOADER | EXIT_SHUTDOWN),
-};
-
-enum
-{
-    AUTOBOOT_NAME            = 0x00,
-    AUTOBOOT_LAST            = 0x01,
-    AUTOBOOT_FORCE_CURRENT   = 0x02,
-    AUTOBOOT_CHECK_KEYS      = 0x04,
-};
-
-struct usb_partition
-{
-    char *name;
-    char *mount_path;
-    char *uuid;
-    char *fs;
-    int keep_mounted;
-};
-
-struct rom_info {
-    // for future vals?
-    map *str_vals;
-};
-
-struct multirom_rom
-{
-    int id;
-    char *name;
-    char *base_path;
-    char *icon_path;
-    int type;
-    int has_bootimg;
-    struct usb_partition *partition;
-};
-
-struct multirom_status
-{
-    int is_second_boot;
-    int is_running_in_primary_rom;
-    int auto_boot_seconds;
-    int auto_boot_type;
-    int colors;
-    int brightness;
-    int enable_adb;
-    int hide_internal;
-    char *int_display_name;
-    int rotation;
-    int force_generic_fb;
-    float anim_duration_coef;
-    struct multirom_rom *auto_boot_rom;
-    struct multirom_rom *current_rom;
-    struct multirom_rom **roms;
-    struct usb_partition **partitions;
-    char *curr_rom_part;
-    struct fstab *fstab;
-    struct rcadditions rc;
-};
-
-int multirom(const char *rom_to_boot);
-int multirom_find_base_dir(void);
-void multirom_emergency_reboot(void);
-int multirom_default_status(struct multirom_status *s);
-void multirom_find_usb_roms(struct multirom_status *s);
-int multirom_generate_rom_id(void);
-struct multirom_rom *multirom_get_internal(struct multirom_status *s);
-struct multirom_rom *multirom_get_rom(struct multirom_status *s, const char *name, const char *part_uuid);
-struct multirom_rom *multirom_get_rom_by_id(struct multirom_status *s, int id);
-int multirom_load_status(struct multirom_status *s);
-void multirom_import_internal(void);
-void multirom_dump_status(struct multirom_status *s);
-int multirom_save_status(struct multirom_status *s);
-void multirom_fixup_rom_name(struct multirom_rom *rom, char *name, const char *def);
-int multirom_prepare_for_boot(struct multirom_status *s, struct multirom_rom *to_boot);
-void multirom_free_status(struct multirom_status *s);
-void multirom_free_rom(void *rom);
-int multirom_init_fb(int rotation);
-int multirom_prep_android_mounts(struct multirom_status *s, struct multirom_rom *rom);
-int multirom_create_media_link(struct multirom_status *s);
-int multirom_process_android_fstab(char *fstab_name, int has_fw, struct fstab_part **fw_part);
-int multirom_get_api_level(const char *path);
-int multirom_get_rom_type(struct multirom_rom *rom);
-int multirom_get_trampoline_ver(void);
-int multirom_has_kexec(void);
-int multirom_load_kexec(struct multirom_status *s, struct multirom_rom *rom);
-int multirom_get_bootloader_cmdline(struct multirom_status *s, char *str, size_t size);
-int multirom_find_file(char *res, const char *name_part, const char *path);
-int multirom_fill_kexec_linux(struct multirom_status *s, struct multirom_rom *rom, struct kexec *kexec);
-int multirom_fill_kexec_android(struct multirom_status *s, struct multirom_rom *rom, struct kexec *kexec);
-int multirom_extract_bytes(const char *dst, FILE *src, size_t size);
-int multirom_update_partitions(struct multirom_status *s);
-void multirom_destroy_partition(void *part);
-void multirom_set_usb_refresh_thread(struct multirom_status *s, int run);
-void multirom_set_usb_refresh_handler(void (*handler)(void));
-int multirom_mount_usb(struct usb_partition *part);
-int multirom_copy_log(char *klog, const char *dest_path_relative);
-int multirom_scan_partition_for_roms(struct multirom_status *s, struct usb_partition *p);
-struct usb_partition *multirom_get_partition(struct multirom_status *s, char *uuid);
-int multirom_path_exists(char *base, char *filename);
-struct rom_info *multirom_parse_rom_info(struct multirom_status *s, struct multirom_rom *rom);
-void multirom_destroy_rom_info(struct rom_info *info);
-char **multirom_get_rom_info_str(struct rom_info *info, char *key);
-int multirom_replace_aliases_cmdline(char **s, struct rom_info *i, struct multirom_status *status, struct multirom_rom *rom);
-int multirom_replace_aliases_root_path(char **s, struct multirom_rom *rom);
-char *multirom_get_klog(void);
-int multirom_get_battery(void);
-int multirom_run_scripts(const char *type, struct multirom_rom *rom);
-int multirom_update_rd_trampoline(const char *path);
-char *multirom_find_fstab_in_rc(const char *rcfile);
-void multirom_find_rom_icon(struct multirom_rom *rom);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MULTIROM_H
+#define MULTIROM_H
+
+#include <pthread.h>
+#include <stdio.h>
+#include <malloc.h>
+
+#include "lib/fstab.h"
+#include "lib/containers.h"
+#include "kexec.h"
+#include "rcadditions.h"
+
+enum
+{
+    ROM_DEFAULT           = 0,
+
+    ROM_ANDROID_INTERNAL  = 1,
+    ROM_ANDROID_USB_IMG   = 2,
+    ROM_ANDROID_USB_DIR   = 3,
+
+    ROM_LINUX_INTERNAL    = 4,
+    ROM_LINUX_USB         = 5,
+
+    ROM_UNSUPPORTED_INT   = 6,
+    ROM_UNSUPPORTED_USB   = 7,
+    ROM_UNKNOWN           = 8
+};
+
+#define M(x) (1 << x)
+#define MASK_INTERNAL (M(ROM_DEFAULT) | M(ROM_ANDROID_INTERNAL) | M(ROM_UNSUPPORTED_INT) | M(ROM_LINUX_INTERNAL))
+#define MASK_USB_ROMS (M(ROM_ANDROID_USB_IMG) | M(ROM_ANDROID_USB_DIR) | M(ROM_UNSUPPORTED_USB) | M(ROM_LINUX_USB))
+#define MASK_ANDROID (M(ROM_ANDROID_USB_DIR) | M(ROM_ANDROID_USB_IMG) | M(ROM_ANDROID_INTERNAL))
+#define MASK_UNSUPPORTED (M(ROM_UNSUPPORTED_USB) | M(ROM_UNSUPPORTED_INT))
+#define MASK_LINUX (M(ROM_LINUX_INTERNAL) | M(ROM_LINUX_USB))
+#define MASK_KEXEC (MASK_LINUX)
+
+enum
+{
+    EXIT_REBOOT              = 0x01,
+    EXIT_UMOUNT              = 0x02,
+    EXIT_REBOOT_RECOVERY     = 0x04,
+    EXIT_REBOOT_BOOTLOADER   = 0x08,
+    EXIT_SHUTDOWN            = 0x10,
+    EXIT_KEXEC               = 0x20,
+
+    EXIT_REBOOT_MASK         = (EXIT_REBOOT | EXIT_REBOOT_RECOVERY | EXIT_REBOOT_BOOTLOADER | EXIT_SHUTDOWN),
+};
+
+enum
+{
+    AUTOBOOT_NAME            = 0x00,
+    AUTOBOOT_LAST            = 0x01,
+    AUTOBOOT_FORCE_CURRENT   = 0x02,
+    AUTOBOOT_CHECK_KEYS      = 0x04,
+};
+
+struct usb_partition
+{
+    char *name;
+    char *mount_path;
+    char *uuid;
+    char *fs;
+    int keep_mounted;
+};
+
+struct rom_info {
+    // for future vals?
+    map *str_vals;
+};
+
+struct multirom_rom
+{
+    int id;
+    char *name;
+    char *base_path;
+    char *icon_path;
+    int type;
+    int has_bootimg;
+    struct usb_partition *partition;
+};
+
+struct multirom_status
+{
+    int is_second_boot;
+    int is_running_in_primary_rom;
+    int auto_boot_seconds;
+    int auto_boot_type;
+    int colors;
+    int brightness;
+    int enable_adb;
+    int hide_internal;
+    char *int_display_name;
+    int rotation;
+    int force_generic_fb;
+    float anim_duration_coef;
+    struct multirom_rom *auto_boot_rom;
+    struct multirom_rom *current_rom;
+    struct multirom_rom **roms;
+    struct usb_partition **partitions;
+    char *curr_rom_part;
+    struct fstab *fstab;
+    struct rcadditions rc;
+};
+
+int multirom(const char *rom_to_boot);
+int multirom_find_base_dir(void);
+void multirom_emergency_reboot(void);
+int multirom_default_status(struct multirom_status *s);
+void multirom_find_usb_roms(struct multirom_status *s);
+int multirom_generate_rom_id(void);
+struct multirom_rom *multirom_get_internal(struct multirom_status *s);
+struct multirom_rom *multirom_get_rom(struct multirom_status *s, const char *name, const char *part_uuid);
+struct multirom_rom *multirom_get_rom_by_id(struct multirom_status *s, int id);
+int multirom_load_status(struct multirom_status *s);
+void multirom_import_internal(void);
+void multirom_dump_status(struct multirom_status *s);
+int multirom_save_status(struct multirom_status *s);
+void multirom_fixup_rom_name(struct multirom_rom *rom, char *name, const char *def);
+int multirom_prepare_for_boot(struct multirom_status *s, struct multirom_rom *to_boot);
+void multirom_free_status(struct multirom_status *s);
+void multirom_free_rom(void *rom);
+int multirom_init_fb(int rotation);
+int multirom_prep_android_mounts(struct multirom_status *s, struct multirom_rom *rom);
+int multirom_create_media_link(struct multirom_status *s);
+int multirom_process_android_fstab(char *fstab_name, int has_fw, struct fstab_part **fw_part);
+int multirom_get_api_level(const char *path);
+int multirom_get_rom_type(struct multirom_rom *rom);
+int multirom_get_trampoline_ver(void);
+int multirom_has_kexec(void);
+int multirom_load_kexec(struct multirom_status *s, struct multirom_rom *rom);
+int multirom_get_bootloader_cmdline(struct multirom_status *s, char *str, size_t size);
+int multirom_find_file(char *res, const char *name_part, const char *path);
+int multirom_fill_kexec_linux(struct multirom_status *s, struct multirom_rom *rom, struct kexec *kexec);
+int multirom_fill_kexec_android(struct multirom_status *s, struct multirom_rom *rom, struct kexec *kexec);
+int multirom_extract_bytes(const char *dst, FILE *src, size_t size);
+int multirom_update_partitions(struct multirom_status *s);
+void multirom_destroy_partition(void *part);
+void multirom_set_usb_refresh_thread(struct multirom_status *s, int run);
+void multirom_set_usb_refresh_handler(void (*handler)(void));
+int multirom_mount_usb(struct usb_partition *part);
+int multirom_copy_log(char *klog, const char *dest_path_relative);
+int multirom_scan_partition_for_roms(struct multirom_status *s, struct usb_partition *p);
+struct usb_partition *multirom_get_partition(struct multirom_status *s, char *uuid);
+int multirom_path_exists(char *base, char *filename);
+struct rom_info *multirom_parse_rom_info(struct multirom_status *s, struct multirom_rom *rom);
+void multirom_destroy_rom_info(struct rom_info *info);
+char **multirom_get_rom_info_str(struct rom_info *info, char *key);
+int multirom_replace_aliases_cmdline(char **s, struct rom_info *i, struct multirom_status *status, struct multirom_rom *rom);
+int multirom_replace_aliases_root_path(char **s, struct multirom_rom *rom);
+char *multirom_get_klog(void);
+int multirom_get_battery(void);
+int multirom_run_scripts(const char *type, struct multirom_rom *rom);
+int multirom_update_rd_trampoline(const char *path);
+char *multirom_find_fstab_in_rc(const char *rcfile);
+void multirom_find_rom_icon(struct multirom_rom *rom);
+
+#endif
diff --git a/multirom_ui.c b/multirom_ui.c
index 6144aa6..2106368 100755
--- a/multirom_ui.c
+++ b/multirom_ui.c
@@ -1,725 +1,725 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <unistd.h>
-#include <stdio.h>
-#include <assert.h>
-#include <pthread.h>
-#include <dirent.h>
-#include <errno.h>
-#include <string.h>
-
-#include <malloc.h>
-
-#include "lib/framebuffer.h"
-#include "lib/input.h"
-#include "lib/log.h"
-#include "lib/listview.h"
-#include "lib/util.h"
-#include "lib/button.h"
-#include "lib/progressdots.h"
-#include "lib/workers.h"
-#include "lib/containers.h"
-#include "lib/animation.h"
-#include "lib/notification_card.h"
-#include "lib/tabview.h"
-#include "lib/colors.h"
-
-#include "multirom_ui.h"
-#include "multirom_ui_themes.h"
-#include "hooks.h"
-#include "version.h"
-#include "pong.h"
-
-static struct multirom_status *mrom_status = NULL;
-static struct multirom_rom *selected_rom = NULL;
-static volatile int exit_ui_code = -1;
-static volatile int loop_act = 0;
-static multirom_themes_info *themes_info = NULL;
-static multirom_theme *cur_theme = NULL;
-
-static pthread_mutex_t exit_code_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-static struct auto_boot_data
-{
-    ncard_builder *b;
-    int seconds;
-    int destroy;
-    pthread_mutex_t mutex;
-} auto_boot_data = {
-    .b = NULL,
-    .seconds = 0,
-    .destroy = 0,
-    .mutex = PTHREAD_MUTEX_INITIALIZER,
-};
-
-uint32_t CLR_PRIMARY = LBLUE;
-uint32_t CLR_SECONDARY = LBLUE2;
-
-#define LOOP_UPDATE_USB 0x01
-#define LOOP_START_PONG 0x02
-#define LOOP_CHANGE_CLR 0x04
-
-static void list_block(char *path, int rec)
-{
-    ERROR("Listing %s", path);
-    DIR *d = opendir(path);
-    if(!d)
-    {
-        ERROR("Failed to open %s", path);
-        return;
-    }
-
-    struct dirent *dr;
-    struct stat info;
-    while((dr = readdir(d)))
-    {
-        if(dr->d_name[0] == '.')
-            continue;
-
-        ERROR("%s/%s (%d)", path, dr->d_name, dr->d_type);
-        if(dr->d_type == 4 && rec)
-        {
-            char name[256];
-            sprintf(name, "%s/%s", path, dr->d_name);
-            list_block(name, 1);
-        }
-    }
-
-    closedir(d);
-}
-
-static void reveal_rect_alpha_step(void *data, float interpolated)
-{
-    fb_rect *r = data;
-    interpolated = 1.f - interpolated;
-    r->color = (r->color & ~(0xFF << 24)) | (((int)(0xFF*interpolated)) << 24);
-    fb_request_draw();
-}
-
-int multirom_ui(struct multirom_status *s, struct multirom_rom **to_boot)
-{
-    if(s->auto_boot_rom && (s->auto_boot_type & AUTOBOOT_CHECK_KEYS))
-    {
-        start_input_thread_wait(1);
-        int res = is_any_key_pressed() || get_last_key() != -1;
-        stop_input_thread();
-
-        if(!res)
-        {
-            *to_boot = s->auto_boot_rom;
-            return UI_EXIT_BOOT_ROM;
-        }
-    }
-
-    if(multirom_init_fb(s->rotation) < 0)
-        return UI_EXIT_BOOT_ROM;
-
-    fb_freeze(1);
-
-    mrom_status = s;
-
-    exit_ui_code = -1;
-    selected_rom = NULL;
-
-    colors_select(s->colors);
-    themes_info = multirom_ui_init_themes();
-    if((cur_theme = multirom_ui_select_theme(themes_info, fb_width, fb_height)) == NULL)
-    {
-        fb_freeze(0);
-
-        ERROR("Couldn't find theme for resolution %dx%d!\n", fb_width, fb_height);
-        fb_add_text(0, 0, WHITE, SIZE_SMALL, "Couldn't find theme for resolution %dx%d!\nPress POWER to reboot.", fb_width, fb_height);
-        fb_force_draw();
-
-        start_input_thread();
-        while(wait_for_key() != KEY_POWER);
-        stop_input_thread();
-
-        fb_clear();
-        fb_close();
-        return UI_EXIT_REBOOT;
-    }
-
-    workers_start();
-    anim_init(s->anim_duration_coef);
-
-    multirom_ui_init_theme(TAB_INTERNAL);
-
-    start_input_thread();
-    keyaction_enable(1);
-
-    fb_set_brightness(s->brightness);
-
-    if(s->auto_boot_rom && s->auto_boot_seconds > 0 && (s->auto_boot_type & AUTOBOOT_CHECK_KEYS) == 0)
-        multirom_ui_auto_boot();
-    else
-    {
-        fb_rect *r = fb_add_rect_lvl(1000, 0, 0, fb_width, fb_height, BLACK);
-        call_anim *a = call_anim_create(r, reveal_rect_alpha_step, 500, INTERPOLATOR_ACCELERATE);
-        a->on_finished_call = fb_remove_item;
-        a->on_finished_data = r;
-        call_anim_add(a);
-    }
-
-    fb_freeze(0);
-
-    fb_request_draw();
-
-    while(1)
-    {
-        pthread_mutex_lock(&exit_code_mutex);
-        if(exit_ui_code != -1)
-        {
-            pthread_mutex_unlock(&exit_code_mutex);
-            break;
-        }
-
-        if(loop_act & LOOP_UPDATE_USB)
-        {
-            multirom_find_usb_roms(mrom_status);
-            multirom_ui_tab_rom_update_usb();
-            loop_act &= ~(LOOP_UPDATE_USB);
-        }
-
-        if(loop_act & LOOP_START_PONG)
-        {
-            loop_act &= ~(LOOP_START_PONG);
-            keyaction_enable(0);
-            input_push_context();
-            anim_push_context();
-            fb_push_context();
-
-            pong();
-
-            fb_pop_context();
-            anim_pop_context();
-            input_pop_context();
-            keyaction_enable(1);
-        }
-
-        if(loop_act & LOOP_CHANGE_CLR)
-        {
-            pthread_mutex_unlock(&exit_code_mutex);
-            fb_freeze(1);
-
-            multirom_ui_destroy_theme();
-            colors_select(s->colors);
-            multirom_ui_init_theme(TAB_MISC);
-
-            fb_freeze(0);
-            fb_request_draw();
-
-            pthread_mutex_lock(&exit_code_mutex);
-            loop_act &= ~(LOOP_CHANGE_CLR);
-        }
-
-        pthread_mutex_unlock(&exit_code_mutex);
-
-        usleep(100000);
-    }
-
-    keyaction_enable(0);
-    keyaction_clear();
-
-    ncard_builder *b = ncard_create_builder();
-    ncard_set_pos(b, NCARD_POS_CENTER);
-
-    switch(exit_ui_code)
-    {
-        case UI_EXIT_BOOT_ROM:
-        {
-            *to_boot = selected_rom;
-            ncard_set_title(b, "Booting...");
-
-            char buff[64];
-            snprintf(buff, sizeof(buff), "<i>%s</i>", selected_rom->name);
-            ncard_set_text(b, buff);
-            break;
-        }
-        case UI_EXIT_REBOOT:
-            ncard_set_text(b, "\nRebooting...\n\n");
-            break;
-        case UI_EXIT_REBOOT_RECOVERY:
-            ncard_set_text(b, "\nRebooting to recovery...\n\n");
-            break;
-        case UI_EXIT_REBOOT_BOOTLOADER:
-            ncard_set_text(b, "\nRebooting to bootloader...\n\n");
-            break;
-        case UI_EXIT_SHUTDOWN:
-            ncard_set_text(b, "\nShutting down...\n\n");
-            break;
-    }
-
-    ncard_show(b, 1);
-    anim_stop(1);
-    fb_freeze(1);
-    fb_force_draw();
-
-    multirom_ui_destroy_theme();
-    multirom_ui_free_themes(themes_info);
-    themes_info = NULL;
-
-    stop_input_thread();
-    workers_stop();
-
-#if MR_DEVICE_HOOKS >= 2
-    mrom_hook_before_fb_close();
-#endif
-    fb_close();
-    return exit_ui_code;
-}
-
-void multirom_ui_init_theme(int tab)
-{
-    memset(themes_info->data, 0, sizeof(multirom_theme_data));
-    themes_info->data->selected_tab = -1;
-
-    multirom_ui_init_header();
-    fb_set_background(C_BACKGROUND);
-
-    themes_info->data->tabs->on_page_changed_by_swipe = multirom_ui_switch;
-    themes_info->data->tabs->on_pos_changed = multirom_ui_change_header_selector_pos;
-
-    int i;
-    for(i = 0; i < TAB_COUNT; ++i)
-    {
-        tabview_add_page(themes_info->data->tabs, -1);
-        switch(i)
-        {
-            case TAB_USB:
-            case TAB_INTERNAL:
-                themes_info->data->tab_data[i] = multirom_ui_tab_rom_init(i);
-                break;
-            case TAB_MISC:
-                themes_info->data->tab_data[i] = multirom_ui_tab_misc_init();
-                break;
-        }
-    }
-    add_touch_handler(&tabview_touch_handler, themes_info->data->tabs);
-    tabview_update_positions(themes_info->data->tabs);
-    multirom_ui_switch(tab);
-}
-
-void multirom_ui_destroy_theme(void)
-{
-    cur_theme->destroy(themes_info->data);
-
-    tabview_destroy(themes_info->data->tabs);
-    themes_info->data->tabs = NULL;
-
-    int i;
-    for(i = 0; i < TAB_COUNT; ++i)
-    {
-        button_destroy(themes_info->data->tab_btns[i]);
-        themes_info->data->tab_btns[i] = NULL;
-        multirom_ui_destroy_tab(i);
-    }
-
-    fb_clear();
-}
-
-void multirom_ui_init_header(void)
-{
-    cur_theme->init_header(themes_info->data);
-}
-
-void multirom_ui_change_header_selector_pos(float pos)
-{
-    cur_theme->header_set_tab_selector_pos(themes_info->data, pos);
-}
-
-void multirom_ui_destroy_tab(int tab)
-{
-    switch(tab)
-    {
-        case -1:
-            break;
-        case TAB_USB:
-        case TAB_INTERNAL:
-            multirom_ui_tab_rom_destroy(themes_info->data->tab_data[tab]);
-            break;
-        case TAB_MISC:
-            multirom_ui_tab_misc_destroy(themes_info->data->tab_data[tab]);
-            break;
-        default:
-            assert(0);
-            break;
-    }
-    themes_info->data->tab_data[tab] = NULL;
-}
-
-void multirom_ui_switch_btn(void *data)
-{
-    multirom_ui_switch(*((int*)data));
-}
-
-void multirom_ui_switch(int tab)
-{
-    if(tab == themes_info->data->selected_tab)
-        return;
-
-    tabview_set_active_page(themes_info->data->tabs, tab,
-            themes_info->data->selected_tab == -1 ? 0 : 200);
-    themes_info->data->selected_tab = tab;
-}
-
-void multirom_ui_fill_rom_list(listview *view, int mask)
-{
-    int i;
-    struct multirom_rom *rom;
-    void *data;
-    char part_desc[64];
-    for(i = 0; mrom_status->roms && mrom_status->roms[i]; ++i)
-    {
-        rom = mrom_status->roms[i];
-
-        if(!(M(rom->type) & mask))
-            continue;
-
-        if(rom->partition)
-            sprintf(part_desc, "%s (%s)", rom->partition->name, rom->partition->fs);
-
-        if(rom->type == ROM_DEFAULT && mrom_status->hide_internal)
-            continue;
-
-        data = rom_item_create(rom->name, rom->partition ? part_desc : NULL, rom->icon_path);
-        listview_add_item(view, rom->id, data);
-    }
-}
-
-static void multirom_ui_destroy_auto_boot_data(void)
-{
-    if(auto_boot_data.b)
-    {
-        ncard_destroy_builder(auto_boot_data.b);
-        auto_boot_data.b = NULL;
-    }
-    auto_boot_data.destroy = 1;
-}
-
-static void multirom_ui_auto_boot_hidden(UNUSED void *data)
-{
-    pthread_mutex_lock(&auto_boot_data.mutex);
-    multirom_ui_destroy_auto_boot_data();
-    pthread_mutex_unlock(&auto_boot_data.mutex);
-}
-
-static void multirom_ui_auto_boot_now(void *data)
-{
-    multirom_ui_auto_boot_hidden(data);
-
-    pthread_mutex_lock(&exit_code_mutex);
-    selected_rom = mrom_status->auto_boot_rom;
-    exit_ui_code = UI_EXIT_BOOT_ROM;
-    pthread_mutex_unlock(&exit_code_mutex);
-}
-
-static void multirom_ui_auto_boot_tick(UNUSED void *data)
-{
-    char buff[128];
-
-    pthread_mutex_lock(&auto_boot_data.mutex);
-
-    if(auto_boot_data.destroy)
-    {
-        pthread_mutex_unlock(&auto_boot_data.mutex);
-        return;
-    }
-
-    if(--auto_boot_data.seconds == 0)
-    {
-        multirom_ui_destroy_auto_boot_data();
-        pthread_mutex_unlock(&auto_boot_data.mutex);
-
-        pthread_mutex_lock(&exit_code_mutex);
-        selected_rom = mrom_status->auto_boot_rom;
-        exit_ui_code = UI_EXIT_BOOT_ROM;
-        pthread_mutex_unlock(&exit_code_mutex);
-    }
-    else
-    {
-        call_anim *a = call_anim_create(NULL, NULL, 1000, INTERPOLATOR_LINEAR);
-        a->duration = 1000; // in call_anim_create, duration is multiplied by coef - we don't want that here
-        a->on_finished_call = multirom_ui_auto_boot_tick;
-        call_anim_add(a);
-
-        snprintf(buff, sizeof(buff), "\n<b>ROM:</b> <y>%s</y>\n\nBooting in %d second%s.",
-            mrom_status->auto_boot_rom->name, auto_boot_data.seconds, auto_boot_data.seconds != 1 ? "s" : "");
-        ncard_set_text(auto_boot_data.b, buff);
-        ncard_show(auto_boot_data.b, 0);
-    }
-
-    pthread_mutex_unlock(&auto_boot_data.mutex);
-}
-
-void multirom_ui_auto_boot(void)
-{
-    ncard_builder *b = ncard_create_builder();
-    auto_boot_data.b = b;
-    auto_boot_data.seconds = mrom_status->auto_boot_seconds + 1;
-    auto_boot_data.destroy = 0;
-
-    ncard_set_pos(b, NCARD_POS_CENTER);
-    ncard_set_cancelable(b, 1);
-    ncard_set_title(b, "Auto-boot");
-    ncard_add_btn(b, BTN_NEGATIVE, "Cancel", ncard_hide_callback, NULL);
-    ncard_add_btn(b, BTN_POSITIVE, "Boot now", multirom_ui_auto_boot_now, NULL);
-    ncard_set_on_hidden(b, multirom_ui_auto_boot_hidden, NULL);
-    ncard_set_from_black(b, 1);
-
-    multirom_ui_auto_boot_tick(NULL);
-}
-
-void multirom_ui_refresh_usb_handler(void)
-{
-    pthread_mutex_lock(&exit_code_mutex);
-    loop_act |= LOOP_UPDATE_USB;
-    pthread_mutex_unlock(&exit_code_mutex);
-}
-
-void multirom_ui_start_pong(UNUSED void *data)
-{
-    pthread_mutex_lock(&exit_code_mutex);
-    loop_act |= LOOP_START_PONG;
-    pthread_mutex_unlock(&exit_code_mutex);
-}
-
-void *multirom_ui_tab_rom_init(int tab_type)
-{
-    tab_data_roms *t = mzalloc(sizeof(tab_data_roms));
-    themes_info->data->tab_data[tab_type] = t;
-
-    t->list = mzalloc(sizeof(listview));
-    t->list->item_draw = &rom_item_draw;
-    t->list->item_hide = &rom_item_hide;
-    t->list->item_height = &rom_item_height;
-    t->list->item_destroy = &rom_item_destroy;
-    t->list->item_confirmed = &multirom_ui_tab_rom_confirmed;
-
-    cur_theme->tab_rom_init(themes_info->data, t, tab_type);
-
-    listview_init_ui(t->list);
-    tabview_add_item(themes_info->data->tabs, tab_type, t->list);
-
-    if(tab_type == TAB_INTERNAL)
-        multirom_ui_fill_rom_list(t->list, MASK_INTERNAL);
-    else
-        multirom_ui_fill_rom_list(t->list, MASK_USB_ROMS);
-
-    listview_update_ui(t->list);
-
-    int has_roms = (int)(t->list->items == NULL);
-    multirom_ui_tab_rom_set_empty((void*)t, has_roms);
-
-    if(tab_type == TAB_USB)
-    {
-        multirom_set_usb_refresh_handler(&multirom_ui_refresh_usb_handler);
-        multirom_set_usb_refresh_thread(mrom_status, 1);
-    }
-    return t;
-}
-
-void multirom_ui_tab_rom_destroy(void *data)
-{
-    multirom_set_usb_refresh_thread(mrom_status, 0);
-    pthread_mutex_lock(&exit_code_mutex);
-    loop_act &= ~(LOOP_UPDATE_USB);
-    pthread_mutex_unlock(&exit_code_mutex);
-
-    tab_data_roms *t = (tab_data_roms*)data;
-
-    list_clear(&t->buttons, &button_destroy);
-    list_clear(&t->ui_elements, &fb_remove_item);
-
-    listview_destroy(t->list);
-
-    if(t->usb_prog)
-        progdots_destroy(t->usb_prog);
-
-    free(t);
-}
-
-void multirom_ui_tab_rom_confirmed(UNUSED listview_item *it)
-{
-    multirom_ui_tab_rom_boot();
-}
-
-void multirom_ui_tab_rom_boot(void)
-{
-    int cur_tab = themes_info->data->selected_tab;
-    if(!themes_info->data->tab_data[cur_tab])
-        return;
-
-    tab_data_roms *t = themes_info->data->tab_data[cur_tab];
-    if(!t->list->selected)
-        return;
-
-    struct multirom_rom *rom = multirom_get_rom_by_id(mrom_status, t->list->selected->id);
-    if(!rom)
-        return;
-
-    int error = 0;
-    ncard_builder *b = ncard_create_builder();
-    ncard_set_pos(b, NCARD_POS_CENTER);
-    ncard_add_btn(b, BTN_NEGATIVE, "ok", ncard_hide_callback, NULL);
-    ncard_set_cancelable(b, 1);
-    ncard_set_title(b, "Error");
-
-    int m = M(rom->type);
-    if(m & MASK_UNSUPPORTED)
-    {
-        ncard_set_text(b, "Unsupported ROM type, see XDA thread for more info!");
-        error = 1;
-    }
-    else if (((m & MASK_KEXEC) || ((m & MASK_ANDROID) && rom->has_bootimg)) &&
-        !multirom_has_kexec())
-    {
-        ncard_set_text(b, "Kexec-hardboot support is required to boot this ROM.\n\n"
-                "Install kernel with kexec-hardboot support to your Internal ROM!");
-        error = 1;
-    }
-    else if((m & MASK_KEXEC) && strchr(rom->name, ' '))
-    {
-        ncard_set_text(b, "ROM's name contains spaces. Please remove spaces from this ROM's name");
-        error = 1;
-    }
-
-    if(error)
-    {
-        ncard_show(b, 1);
-        return;
-    }
-    else
-        ncard_destroy_builder(b);
-
-    pthread_mutex_lock(&exit_code_mutex);
-    selected_rom = rom;
-    exit_ui_code = UI_EXIT_BOOT_ROM;
-    pthread_mutex_unlock(&exit_code_mutex);
-}
-
-void multirom_ui_tab_rom_update_usb(void)
-{
-    tab_data_roms *t = (tab_data_roms*)themes_info->data->tab_data[TAB_USB];
-    listview_clear(t->list);
-
-    multirom_ui_fill_rom_list(t->list, MASK_USB_ROMS);
-    listview_update_ui(t->list);
-
-    multirom_ui_tab_rom_set_empty(t, (int)(t->list->items == NULL));
-    fb_request_draw();
-}
-
-void multirom_ui_tab_rom_refresh_usb(UNUSED int action)
-{
-    multirom_update_partitions(mrom_status);
-}
-
-void multirom_ui_tab_rom_set_empty(void *data, int empty)
-{
-    assert(empty == 0 || empty == 1);
-
-    tab_data_roms *t = (tab_data_roms*)data;
-
-    if(t->boot_btn)
-        button_enable(t->boot_btn, !empty);
-
-    if(empty && !t->usb_text)
-    {
-        fb_text_proto *p = fb_text_create(0, 0, C_TEXT, SIZE_NORMAL, "This list is refreshed automagically, just plug in the USB drive and wait.");
-        p->wrap_w = t->list->w - 100*DPI_MUL;
-        p->justify = JUSTIFY_CENTER;
-        t->usb_text = fb_text_finalize(p);
-        list_add(&t->ui_elements, t->usb_text);
-        tabview_add_item(themes_info->data->tabs, TAB_USB, t->usb_text);
-
-        center_text(t->usb_text, t->list->x, -1, t->list->w, -1);
-        t->usb_text->y = t->list->y + t->list->h*0.2;
-
-        int x = t->list->x + ((t->list->w/2) - (PROGDOTS_W/2));
-        t->usb_prog = progdots_create(x, t->usb_text->y+100*DPI_MUL);
-        tabview_add_item(themes_info->data->tabs, TAB_USB, t->usb_prog->rect);
-        tabview_add_item(themes_info->data->tabs, TAB_USB, t->usb_prog);
-    }
-    else if(!empty && t->usb_text)
-    {
-        tabview_rm_item(themes_info->data->tabs, TAB_USB, t->usb_prog->rect);
-        tabview_rm_item(themes_info->data->tabs, TAB_USB, t->usb_prog);
-        progdots_destroy(t->usb_prog);
-        t->usb_prog = NULL;
-
-        tabview_rm_item(themes_info->data->tabs, TAB_USB, t->usb_text);
-        list_rm(&t->ui_elements, t->usb_text, &fb_remove_item);
-        t->usb_text = NULL;
-    }
-}
-
-void *multirom_ui_tab_misc_init(void)
-{
-    tab_data_misc *t = mzalloc(sizeof(tab_data_misc));
-    cur_theme->tab_misc_init(themes_info->data, t, mrom_status->colors);
-    return t;
-}
-
-void multirom_ui_tab_misc_destroy(void *data)
-{
-    tab_data_misc *t = (tab_data_misc*)data;
-
-    list_clear(&t->ui_elements, &fb_remove_item);
-    list_clear(&t->buttons, &button_destroy);
-
-    free(t);
-}
-
-void multirom_ui_tab_misc_change_clr(void *data)
-{
-    int clr = *((int*)data);
-
-    if((loop_act & LOOP_CHANGE_CLR) || mrom_status->colors == clr)
-        return;
-
-    pthread_mutex_lock(&exit_code_mutex);
-    mrom_status->colors = clr;
-    loop_act |= LOOP_CHANGE_CLR;
-    pthread_mutex_unlock(&exit_code_mutex);
-}
-
-void multirom_ui_reboot_btn(void *data)
-{
-    int action = *((int*)data);
-    pthread_mutex_lock(&exit_code_mutex);
-    exit_ui_code = action;
-    pthread_mutex_unlock(&exit_code_mutex);
-}
-
-void multirom_ui_tab_misc_copy_log(UNUSED void *data)
-{
-    multirom_dump_status(mrom_status);
-
-    int res = multirom_copy_log(NULL, "../multirom_log.txt");
-
-    static const char *text[] = { "Failed to copy log to sdcard!", "Error log was saved to:\n\n<s>/sdcard/multirom_log.txt</s>" };
-
-    ncard_builder *b = ncard_create_builder();
-    ncard_set_pos(b, NCARD_POS_CENTER);
-    ncard_add_btn(b, BTN_NEGATIVE, "ok", ncard_hide_callback, NULL);
-    ncard_set_title(b, "Save error log");
-    ncard_set_text(b, text[res+1]);
-    ncard_set_cancelable(b, 1);
-    ncard_show(b, 1);
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <assert.h>
+#include <pthread.h>
+#include <dirent.h>
+#include <errno.h>
+#include <string.h>
+
+#include <malloc.h>
+
+#include "lib/framebuffer.h"
+#include "lib/input.h"
+#include "lib/log.h"
+#include "lib/listview.h"
+#include "lib/util.h"
+#include "lib/button.h"
+#include "lib/progressdots.h"
+#include "lib/workers.h"
+#include "lib/containers.h"
+#include "lib/animation.h"
+#include "lib/notification_card.h"
+#include "lib/tabview.h"
+#include "lib/colors.h"
+
+#include "multirom_ui.h"
+#include "multirom_ui_themes.h"
+#include "hooks.h"
+#include "version.h"
+#include "pong.h"
+
+static struct multirom_status *mrom_status = NULL;
+static struct multirom_rom *selected_rom = NULL;
+static volatile int exit_ui_code = -1;
+static volatile int loop_act = 0;
+static multirom_themes_info *themes_info = NULL;
+static multirom_theme *cur_theme = NULL;
+
+static pthread_mutex_t exit_code_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static struct auto_boot_data
+{
+    ncard_builder *b;
+    int seconds;
+    int destroy;
+    pthread_mutex_t mutex;
+} auto_boot_data = {
+    .b = NULL,
+    .seconds = 0,
+    .destroy = 0,
+    .mutex = PTHREAD_MUTEX_INITIALIZER,
+};
+
+uint32_t CLR_PRIMARY = LBLUE;
+uint32_t CLR_SECONDARY = LBLUE2;
+
+#define LOOP_UPDATE_USB 0x01
+#define LOOP_START_PONG 0x02
+#define LOOP_CHANGE_CLR 0x04
+
+static void list_block(char *path, int rec)
+{
+    ERROR("Listing %s", path);
+    DIR *d = opendir(path);
+    if(!d)
+    {
+        ERROR("Failed to open %s", path);
+        return;
+    }
+
+    struct dirent *dr;
+    struct stat info;
+    while((dr = readdir(d)))
+    {
+        if(dr->d_name[0] == '.')
+            continue;
+
+        ERROR("%s/%s (%d)", path, dr->d_name, dr->d_type);
+        if(dr->d_type == 4 && rec)
+        {
+            char name[256];
+            sprintf(name, "%s/%s", path, dr->d_name);
+            list_block(name, 1);
+        }
+    }
+
+    closedir(d);
+}
+
+static void reveal_rect_alpha_step(void *data, float interpolated)
+{
+    fb_rect *r = data;
+    interpolated = 1.f - interpolated;
+    r->color = (r->color & ~(0xFF << 24)) | (((int)(0xFF*interpolated)) << 24);
+    fb_request_draw();
+}
+
+int multirom_ui(struct multirom_status *s, struct multirom_rom **to_boot)
+{
+    if(s->auto_boot_rom && (s->auto_boot_type & AUTOBOOT_CHECK_KEYS))
+    {
+        start_input_thread_wait(1);
+        int res = is_any_key_pressed() || get_last_key() != -1;
+        stop_input_thread();
+
+        if(!res)
+        {
+            *to_boot = s->auto_boot_rom;
+            return UI_EXIT_BOOT_ROM;
+        }
+    }
+
+    if(multirom_init_fb(s->rotation) < 0)
+        return UI_EXIT_BOOT_ROM;
+
+    fb_freeze(1);
+
+    mrom_status = s;
+
+    exit_ui_code = -1;
+    selected_rom = NULL;
+
+    colors_select(s->colors);
+    themes_info = multirom_ui_init_themes();
+    if((cur_theme = multirom_ui_select_theme(themes_info, fb_width, fb_height)) == NULL)
+    {
+        fb_freeze(0);
+
+        ERROR("Couldn't find theme for resolution %dx%d!\n", fb_width, fb_height);
+        fb_add_text(0, 0, WHITE, SIZE_SMALL, "Couldn't find theme for resolution %dx%d!\nPress POWER to reboot.", fb_width, fb_height);
+        fb_force_draw();
+
+        start_input_thread();
+        while(wait_for_key() != KEY_POWER);
+        stop_input_thread();
+
+        fb_clear();
+        fb_close();
+        return UI_EXIT_REBOOT;
+    }
+
+    workers_start();
+    anim_init(s->anim_duration_coef);
+
+    multirom_ui_init_theme(TAB_INTERNAL);
+
+    start_input_thread();
+    keyaction_enable(1);
+
+    fb_set_brightness(s->brightness);
+
+    if(s->auto_boot_rom && s->auto_boot_seconds > 0 && (s->auto_boot_type & AUTOBOOT_CHECK_KEYS) == 0)
+        multirom_ui_auto_boot();
+    else
+    {
+        fb_rect *r = fb_add_rect_lvl(1000, 0, 0, fb_width, fb_height, BLACK);
+        call_anim *a = call_anim_create(r, reveal_rect_alpha_step, 500, INTERPOLATOR_ACCELERATE);
+        a->on_finished_call = fb_remove_item;
+        a->on_finished_data = r;
+        call_anim_add(a);
+    }
+
+    fb_freeze(0);
+
+    fb_request_draw();
+
+    while(1)
+    {
+        pthread_mutex_lock(&exit_code_mutex);
+        if(exit_ui_code != -1)
+        {
+            pthread_mutex_unlock(&exit_code_mutex);
+            break;
+        }
+
+        if(loop_act & LOOP_UPDATE_USB)
+        {
+            multirom_find_usb_roms(mrom_status);
+            multirom_ui_tab_rom_update_usb();
+            loop_act &= ~(LOOP_UPDATE_USB);
+        }
+
+        if(loop_act & LOOP_START_PONG)
+        {
+            loop_act &= ~(LOOP_START_PONG);
+            keyaction_enable(0);
+            input_push_context();
+            anim_push_context();
+            fb_push_context();
+
+            pong();
+
+            fb_pop_context();
+            anim_pop_context();
+            input_pop_context();
+            keyaction_enable(1);
+        }
+
+        if(loop_act & LOOP_CHANGE_CLR)
+        {
+            pthread_mutex_unlock(&exit_code_mutex);
+            fb_freeze(1);
+
+            multirom_ui_destroy_theme();
+            colors_select(s->colors);
+            multirom_ui_init_theme(TAB_MISC);
+
+            fb_freeze(0);
+            fb_request_draw();
+
+            pthread_mutex_lock(&exit_code_mutex);
+            loop_act &= ~(LOOP_CHANGE_CLR);
+        }
+
+        pthread_mutex_unlock(&exit_code_mutex);
+
+        usleep(100000);
+    }
+
+    keyaction_enable(0);
+    keyaction_clear();
+
+    ncard_builder *b = ncard_create_builder();
+    ncard_set_pos(b, NCARD_POS_CENTER);
+
+    switch(exit_ui_code)
+    {
+        case UI_EXIT_BOOT_ROM:
+        {
+            *to_boot = selected_rom;
+            ncard_set_title(b, "Booting...");
+
+            char buff[64];
+            snprintf(buff, sizeof(buff), "<i>%s</i>", selected_rom->name);
+            ncard_set_text(b, buff);
+            break;
+        }
+        case UI_EXIT_REBOOT:
+            ncard_set_text(b, "\nRebooting...\n\n");
+            break;
+        case UI_EXIT_REBOOT_RECOVERY:
+            ncard_set_text(b, "\nRebooting to recovery...\n\n");
+            break;
+        case UI_EXIT_REBOOT_BOOTLOADER:
+            ncard_set_text(b, "\nRebooting to bootloader...\n\n");
+            break;
+        case UI_EXIT_SHUTDOWN:
+            ncard_set_text(b, "\nShutting down...\n\n");
+            break;
+    }
+
+    ncard_show(b, 1);
+    anim_stop(1);
+    fb_freeze(1);
+    fb_force_draw();
+
+    multirom_ui_destroy_theme();
+    multirom_ui_free_themes(themes_info);
+    themes_info = NULL;
+
+    stop_input_thread();
+    workers_stop();
+
+#if MR_DEVICE_HOOKS >= 2
+    mrom_hook_before_fb_close();
+#endif
+    fb_close();
+    return exit_ui_code;
+}
+
+void multirom_ui_init_theme(int tab)
+{
+    memset(themes_info->data, 0, sizeof(multirom_theme_data));
+    themes_info->data->selected_tab = -1;
+
+    multirom_ui_init_header();
+    fb_set_background(C_BACKGROUND);
+
+    themes_info->data->tabs->on_page_changed_by_swipe = multirom_ui_switch;
+    themes_info->data->tabs->on_pos_changed = multirom_ui_change_header_selector_pos;
+
+    int i;
+    for(i = 0; i < TAB_COUNT; ++i)
+    {
+        tabview_add_page(themes_info->data->tabs, -1);
+        switch(i)
+        {
+            case TAB_USB:
+            case TAB_INTERNAL:
+                themes_info->data->tab_data[i] = multirom_ui_tab_rom_init(i);
+                break;
+            case TAB_MISC:
+                themes_info->data->tab_data[i] = multirom_ui_tab_misc_init();
+                break;
+        }
+    }
+    add_touch_handler(&tabview_touch_handler, themes_info->data->tabs);
+    tabview_update_positions(themes_info->data->tabs);
+    multirom_ui_switch(tab);
+}
+
+void multirom_ui_destroy_theme(void)
+{
+    cur_theme->destroy(themes_info->data);
+
+    tabview_destroy(themes_info->data->tabs);
+    themes_info->data->tabs = NULL;
+
+    int i;
+    for(i = 0; i < TAB_COUNT; ++i)
+    {
+        button_destroy(themes_info->data->tab_btns[i]);
+        themes_info->data->tab_btns[i] = NULL;
+        multirom_ui_destroy_tab(i);
+    }
+
+    fb_clear();
+}
+
+void multirom_ui_init_header(void)
+{
+    cur_theme->init_header(themes_info->data);
+}
+
+void multirom_ui_change_header_selector_pos(float pos)
+{
+    cur_theme->header_set_tab_selector_pos(themes_info->data, pos);
+}
+
+void multirom_ui_destroy_tab(int tab)
+{
+    switch(tab)
+    {
+        case -1:
+            break;
+        case TAB_USB:
+        case TAB_INTERNAL:
+            multirom_ui_tab_rom_destroy(themes_info->data->tab_data[tab]);
+            break;
+        case TAB_MISC:
+            multirom_ui_tab_misc_destroy(themes_info->data->tab_data[tab]);
+            break;
+        default:
+            assert(0);
+            break;
+    }
+    themes_info->data->tab_data[tab] = NULL;
+}
+
+void multirom_ui_switch_btn(void *data)
+{
+    multirom_ui_switch(*((int*)data));
+}
+
+void multirom_ui_switch(int tab)
+{
+    if(tab == themes_info->data->selected_tab)
+        return;
+
+    tabview_set_active_page(themes_info->data->tabs, tab,
+            themes_info->data->selected_tab == -1 ? 0 : 200);
+    themes_info->data->selected_tab = tab;
+}
+
+void multirom_ui_fill_rom_list(listview *view, int mask)
+{
+    int i;
+    struct multirom_rom *rom;
+    void *data;
+    char part_desc[64];
+    for(i = 0; mrom_status->roms && mrom_status->roms[i]; ++i)
+    {
+        rom = mrom_status->roms[i];
+
+        if(!(M(rom->type) & mask))
+            continue;
+
+        if(rom->partition)
+            sprintf(part_desc, "%s (%s)", rom->partition->name, rom->partition->fs);
+
+        if(rom->type == ROM_DEFAULT && mrom_status->hide_internal)
+            continue;
+
+        data = rom_item_create(rom->name, rom->partition ? part_desc : NULL, rom->icon_path);
+        listview_add_item(view, rom->id, data);
+    }
+}
+
+static void multirom_ui_destroy_auto_boot_data(void)
+{
+    if(auto_boot_data.b)
+    {
+        ncard_destroy_builder(auto_boot_data.b);
+        auto_boot_data.b = NULL;
+    }
+    auto_boot_data.destroy = 1;
+}
+
+static void multirom_ui_auto_boot_hidden(UNUSED void *data)
+{
+    pthread_mutex_lock(&auto_boot_data.mutex);
+    multirom_ui_destroy_auto_boot_data();
+    pthread_mutex_unlock(&auto_boot_data.mutex);
+}
+
+static void multirom_ui_auto_boot_now(void *data)
+{
+    multirom_ui_auto_boot_hidden(data);
+
+    pthread_mutex_lock(&exit_code_mutex);
+    selected_rom = mrom_status->auto_boot_rom;
+    exit_ui_code = UI_EXIT_BOOT_ROM;
+    pthread_mutex_unlock(&exit_code_mutex);
+}
+
+static void multirom_ui_auto_boot_tick(UNUSED void *data)
+{
+    char buff[128];
+
+    pthread_mutex_lock(&auto_boot_data.mutex);
+
+    if(auto_boot_data.destroy)
+    {
+        pthread_mutex_unlock(&auto_boot_data.mutex);
+        return;
+    }
+
+    if(--auto_boot_data.seconds == 0)
+    {
+        multirom_ui_destroy_auto_boot_data();
+        pthread_mutex_unlock(&auto_boot_data.mutex);
+
+        pthread_mutex_lock(&exit_code_mutex);
+        selected_rom = mrom_status->auto_boot_rom;
+        exit_ui_code = UI_EXIT_BOOT_ROM;
+        pthread_mutex_unlock(&exit_code_mutex);
+    }
+    else
+    {
+        call_anim *a = call_anim_create(NULL, NULL, 1000, INTERPOLATOR_LINEAR);
+        a->duration = 1000; // in call_anim_create, duration is multiplied by coef - we don't want that here
+        a->on_finished_call = multirom_ui_auto_boot_tick;
+        call_anim_add(a);
+
+        snprintf(buff, sizeof(buff), "\n<b>ROM:</b> <y>%s</y>\n\nBooting in %d second%s.",
+            mrom_status->auto_boot_rom->name, auto_boot_data.seconds, auto_boot_data.seconds != 1 ? "s" : "");
+        ncard_set_text(auto_boot_data.b, buff);
+        ncard_show(auto_boot_data.b, 0);
+    }
+
+    pthread_mutex_unlock(&auto_boot_data.mutex);
+}
+
+void multirom_ui_auto_boot(void)
+{
+    ncard_builder *b = ncard_create_builder();
+    auto_boot_data.b = b;
+    auto_boot_data.seconds = mrom_status->auto_boot_seconds + 1;
+    auto_boot_data.destroy = 0;
+
+    ncard_set_pos(b, NCARD_POS_CENTER);
+    ncard_set_cancelable(b, 1);
+    ncard_set_title(b, "Auto-boot");
+    ncard_add_btn(b, BTN_NEGATIVE, "Cancel", ncard_hide_callback, NULL);
+    ncard_add_btn(b, BTN_POSITIVE, "Boot now", multirom_ui_auto_boot_now, NULL);
+    ncard_set_on_hidden(b, multirom_ui_auto_boot_hidden, NULL);
+    ncard_set_from_black(b, 1);
+
+    multirom_ui_auto_boot_tick(NULL);
+}
+
+void multirom_ui_refresh_usb_handler(void)
+{
+    pthread_mutex_lock(&exit_code_mutex);
+    loop_act |= LOOP_UPDATE_USB;
+    pthread_mutex_unlock(&exit_code_mutex);
+}
+
+void multirom_ui_start_pong(UNUSED void *data)
+{
+    pthread_mutex_lock(&exit_code_mutex);
+    loop_act |= LOOP_START_PONG;
+    pthread_mutex_unlock(&exit_code_mutex);
+}
+
+void *multirom_ui_tab_rom_init(int tab_type)
+{
+    tab_data_roms *t = mzalloc(sizeof(tab_data_roms));
+    themes_info->data->tab_data[tab_type] = t;
+
+    t->list = mzalloc(sizeof(listview));
+    t->list->item_draw = &rom_item_draw;
+    t->list->item_hide = &rom_item_hide;
+    t->list->item_height = &rom_item_height;
+    t->list->item_destroy = &rom_item_destroy;
+    t->list->item_confirmed = &multirom_ui_tab_rom_confirmed;
+
+    cur_theme->tab_rom_init(themes_info->data, t, tab_type);
+
+    listview_init_ui(t->list);
+    tabview_add_item(themes_info->data->tabs, tab_type, t->list);
+
+    if(tab_type == TAB_INTERNAL)
+        multirom_ui_fill_rom_list(t->list, MASK_INTERNAL);
+    else
+        multirom_ui_fill_rom_list(t->list, MASK_USB_ROMS);
+
+    listview_update_ui(t->list);
+
+    int has_roms = (int)(t->list->items == NULL);
+    multirom_ui_tab_rom_set_empty((void*)t, has_roms);
+
+    if(tab_type == TAB_USB)
+    {
+        multirom_set_usb_refresh_handler(&multirom_ui_refresh_usb_handler);
+        multirom_set_usb_refresh_thread(mrom_status, 1);
+    }
+    return t;
+}
+
+void multirom_ui_tab_rom_destroy(void *data)
+{
+    multirom_set_usb_refresh_thread(mrom_status, 0);
+    pthread_mutex_lock(&exit_code_mutex);
+    loop_act &= ~(LOOP_UPDATE_USB);
+    pthread_mutex_unlock(&exit_code_mutex);
+
+    tab_data_roms *t = (tab_data_roms*)data;
+
+    list_clear(&t->buttons, &button_destroy);
+    list_clear(&t->ui_elements, &fb_remove_item);
+
+    listview_destroy(t->list);
+
+    if(t->usb_prog)
+        progdots_destroy(t->usb_prog);
+
+    free(t);
+}
+
+void multirom_ui_tab_rom_confirmed(UNUSED listview_item *it)
+{
+    multirom_ui_tab_rom_boot();
+}
+
+void multirom_ui_tab_rom_boot(void)
+{
+    int cur_tab = themes_info->data->selected_tab;
+    if(!themes_info->data->tab_data[cur_tab])
+        return;
+
+    tab_data_roms *t = themes_info->data->tab_data[cur_tab];
+    if(!t->list->selected)
+        return;
+
+    struct multirom_rom *rom = multirom_get_rom_by_id(mrom_status, t->list->selected->id);
+    if(!rom)
+        return;
+
+    int error = 0;
+    ncard_builder *b = ncard_create_builder();
+    ncard_set_pos(b, NCARD_POS_CENTER);
+    ncard_add_btn(b, BTN_NEGATIVE, "ok", ncard_hide_callback, NULL);
+    ncard_set_cancelable(b, 1);
+    ncard_set_title(b, "Error");
+
+    int m = M(rom->type);
+    if(m & MASK_UNSUPPORTED)
+    {
+        ncard_set_text(b, "Unsupported ROM type, see XDA thread for more info!");
+        error = 1;
+    }
+    else if (((m & MASK_KEXEC) || ((m & MASK_ANDROID) && rom->has_bootimg)) &&
+        !multirom_has_kexec())
+    {
+        ncard_set_text(b, "Kexec-hardboot support is required to boot this ROM.\n\n"
+                "Install kernel with kexec-hardboot support to your Internal ROM!");
+        error = 1;
+    }
+    else if((m & MASK_KEXEC) && strchr(rom->name, ' '))
+    {
+        ncard_set_text(b, "ROM's name contains spaces. Please remove spaces from this ROM's name");
+        error = 1;
+    }
+
+    if(error)
+    {
+        ncard_show(b, 1);
+        return;
+    }
+    else
+        ncard_destroy_builder(b);
+
+    pthread_mutex_lock(&exit_code_mutex);
+    selected_rom = rom;
+    exit_ui_code = UI_EXIT_BOOT_ROM;
+    pthread_mutex_unlock(&exit_code_mutex);
+}
+
+void multirom_ui_tab_rom_update_usb(void)
+{
+    tab_data_roms *t = (tab_data_roms*)themes_info->data->tab_data[TAB_USB];
+    listview_clear(t->list);
+
+    multirom_ui_fill_rom_list(t->list, MASK_USB_ROMS);
+    listview_update_ui(t->list);
+
+    multirom_ui_tab_rom_set_empty(t, (int)(t->list->items == NULL));
+    fb_request_draw();
+}
+
+void multirom_ui_tab_rom_refresh_usb(UNUSED int action)
+{
+    multirom_update_partitions(mrom_status);
+}
+
+void multirom_ui_tab_rom_set_empty(void *data, int empty)
+{
+    assert(empty == 0 || empty == 1);
+
+    tab_data_roms *t = (tab_data_roms*)data;
+
+    if(t->boot_btn)
+        button_enable(t->boot_btn, !empty);
+
+    if(empty && !t->usb_text)
+    {
+        fb_text_proto *p = fb_text_create(0, 0, C_TEXT, SIZE_NORMAL, "This list is refreshed automagically, just plug in the USB drive and wait.");
+        p->wrap_w = t->list->w - 100*DPI_MUL;
+        p->justify = JUSTIFY_CENTER;
+        t->usb_text = fb_text_finalize(p);
+        list_add(&t->ui_elements, t->usb_text);
+        tabview_add_item(themes_info->data->tabs, TAB_USB, t->usb_text);
+
+        center_text(t->usb_text, t->list->x, -1, t->list->w, -1);
+        t->usb_text->y = t->list->y + t->list->h*0.2;
+
+        int x = t->list->x + ((t->list->w/2) - (PROGDOTS_W/2));
+        t->usb_prog = progdots_create(x, t->usb_text->y+100*DPI_MUL);
+        tabview_add_item(themes_info->data->tabs, TAB_USB, t->usb_prog->rect);
+        tabview_add_item(themes_info->data->tabs, TAB_USB, t->usb_prog);
+    }
+    else if(!empty && t->usb_text)
+    {
+        tabview_rm_item(themes_info->data->tabs, TAB_USB, t->usb_prog->rect);
+        tabview_rm_item(themes_info->data->tabs, TAB_USB, t->usb_prog);
+        progdots_destroy(t->usb_prog);
+        t->usb_prog = NULL;
+
+        tabview_rm_item(themes_info->data->tabs, TAB_USB, t->usb_text);
+        list_rm(&t->ui_elements, t->usb_text, &fb_remove_item);
+        t->usb_text = NULL;
+    }
+}
+
+void *multirom_ui_tab_misc_init(void)
+{
+    tab_data_misc *t = mzalloc(sizeof(tab_data_misc));
+    cur_theme->tab_misc_init(themes_info->data, t, mrom_status->colors);
+    return t;
+}
+
+void multirom_ui_tab_misc_destroy(void *data)
+{
+    tab_data_misc *t = (tab_data_misc*)data;
+
+    list_clear(&t->ui_elements, &fb_remove_item);
+    list_clear(&t->buttons, &button_destroy);
+
+    free(t);
+}
+
+void multirom_ui_tab_misc_change_clr(void *data)
+{
+    int clr = *((int*)data);
+
+    if((loop_act & LOOP_CHANGE_CLR) || mrom_status->colors == clr)
+        return;
+
+    pthread_mutex_lock(&exit_code_mutex);
+    mrom_status->colors = clr;
+    loop_act |= LOOP_CHANGE_CLR;
+    pthread_mutex_unlock(&exit_code_mutex);
+}
+
+void multirom_ui_reboot_btn(void *data)
+{
+    int action = *((int*)data);
+    pthread_mutex_lock(&exit_code_mutex);
+    exit_ui_code = action;
+    pthread_mutex_unlock(&exit_code_mutex);
+}
+
+void multirom_ui_tab_misc_copy_log(UNUSED void *data)
+{
+    multirom_dump_status(mrom_status);
+
+    int res = multirom_copy_log(NULL, "../multirom_log.txt");
+
+    static const char *text[] = { "Failed to copy log to sdcard!", "Error log was saved to:\n\n<s>/sdcard/multirom_log.txt</s>" };
+
+    ncard_builder *b = ncard_create_builder();
+    ncard_set_pos(b, NCARD_POS_CENTER);
+    ncard_add_btn(b, BTN_NEGATIVE, "ok", ncard_hide_callback, NULL);
+    ncard_set_title(b, "Save error log");
+    ncard_set_text(b, text[res+1]);
+    ncard_set_cancelable(b, 1);
+    ncard_show(b, 1);
+}
diff --git a/multirom_ui.h b/multirom_ui.h
index 392b6a6..b9593dd 100755
--- a/multirom_ui.h
+++ b/multirom_ui.h
@@ -1,72 +1,72 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MULTIROM_UI_H
-#define MULTIROM_UI_H
-
-#include "multirom.h"
-#include "lib/input.h"
-#include "lib/listview.h"
-
-enum
-{
-    TAB_INTERNAL = 0,
-    TAB_USB,
-    TAB_MISC,
-
-    TAB_COUNT
-};
-
-enum
-{
-    UI_EXIT_BOOT_ROM          = 1,
-    UI_EXIT_REBOOT            = 2,
-    UI_EXIT_REBOOT_RECOVERY   = 3,
-    UI_EXIT_REBOOT_BOOTLOADER = 4,
-    UI_EXIT_SHUTDOWN          = 5
-};
-
-int multirom_ui(struct multirom_status *s, struct multirom_rom **to_boot);
-void multirom_ui_init_header(void);
-void multirom_ui_change_header_selector_pos(float pos);
-void multirom_ui_destroy_tab(int tab);
-int multirom_ui_destroy_msgbox(void);
-void multirom_ui_switch(int tab);
-void multirom_ui_switch_btn(void *data);
-void multirom_ui_fill_rom_list(listview *view, int mask);
-void multirom_ui_auto_boot(void);
-void multirom_ui_refresh_usb_handler(void);
-void multirom_ui_start_pong(void *data);
-void multirom_ui_init_theme(int tab);
-void multirom_ui_destroy_theme(void);
-
-void *multirom_ui_tab_rom_init(int tab_type);
-void multirom_ui_tab_rom_destroy(void *data);
-void multirom_ui_tab_rom_boot(void);
-void multirom_ui_tab_rom_confirmed(listview_item *it);
-void multirom_ui_tab_rom_refresh_usb(int action);
-void multirom_ui_tab_rom_update_usb(void);
-void multirom_ui_tab_rom_set_empty(void *data, int empty);
-
-void *multirom_ui_tab_misc_init(void);
-void multirom_ui_tab_misc_destroy(void *data);
-void multirom_ui_tab_misc_copy_log(void *data);
-void multirom_ui_tab_misc_change_clr(void *data);
-
-void multirom_ui_reboot_btn(void *data);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MULTIROM_UI_H
+#define MULTIROM_UI_H
+
+#include "multirom.h"
+#include "lib/input.h"
+#include "lib/listview.h"
+
+enum
+{
+    TAB_INTERNAL = 0,
+    TAB_USB,
+    TAB_MISC,
+
+    TAB_COUNT
+};
+
+enum
+{
+    UI_EXIT_BOOT_ROM          = 1,
+    UI_EXIT_REBOOT            = 2,
+    UI_EXIT_REBOOT_RECOVERY   = 3,
+    UI_EXIT_REBOOT_BOOTLOADER = 4,
+    UI_EXIT_SHUTDOWN          = 5
+};
+
+int multirom_ui(struct multirom_status *s, struct multirom_rom **to_boot);
+void multirom_ui_init_header(void);
+void multirom_ui_change_header_selector_pos(float pos);
+void multirom_ui_destroy_tab(int tab);
+int multirom_ui_destroy_msgbox(void);
+void multirom_ui_switch(int tab);
+void multirom_ui_switch_btn(void *data);
+void multirom_ui_fill_rom_list(listview *view, int mask);
+void multirom_ui_auto_boot(void);
+void multirom_ui_refresh_usb_handler(void);
+void multirom_ui_start_pong(void *data);
+void multirom_ui_init_theme(int tab);
+void multirom_ui_destroy_theme(void);
+
+void *multirom_ui_tab_rom_init(int tab_type);
+void multirom_ui_tab_rom_destroy(void *data);
+void multirom_ui_tab_rom_boot(void);
+void multirom_ui_tab_rom_confirmed(listview_item *it);
+void multirom_ui_tab_rom_refresh_usb(int action);
+void multirom_ui_tab_rom_update_usb(void);
+void multirom_ui_tab_rom_set_empty(void *data, int empty);
+
+void *multirom_ui_tab_misc_init(void);
+void multirom_ui_tab_misc_destroy(void *data);
+void multirom_ui_tab_misc_copy_log(void *data);
+void multirom_ui_tab_misc_change_clr(void *data);
+
+void multirom_ui_reboot_btn(void *data);
+
+#endif
diff --git a/multirom_ui_landscape.c b/multirom_ui_landscape.c
index f6be8b5..2bc4bf8 100755
--- a/multirom_ui_landscape.c
+++ b/multirom_ui_landscape.c
@@ -1,285 +1,285 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#include "multirom_ui.h"
-#include "multirom_ui_themes.h"
-#include "multirom.h"
-#include "version.h"
-#include "lib/framebuffer.h"
-#include "lib/util.h"
-#include "lib/button.h"
-#include "lib/input.h"
-#include "lib/log.h"
-#include "lib/animation.h"
-#include "lib/notification_card.h"
-#include "lib/tabview.h"
-#include "lib/colors.h"
-
-#define HEADER_HEIGHT (80*DPI_MUL)
-#define TABS_HEIGHT (HEADER_HEIGHT - STATUS_HEIGHT)
-#define MIRI_W (60*DPI_MUL)
-
-#define LISTVIEW_MARGIN (20*DPI_MUL)
-
-#define REFRESHBTN_W (400*DPI_MUL)
-#define REFRESHBTN_H (60*DPI_MUL)
-
-#define MISCBTN_W (530*DPI_MUL)
-#define MISCBTN_H (100*DPI_MUL)
-
-#define CLRBTN_W (50*DPI_MUL)
-#define CLRBTN_B (10*DPI_MUL)
-#define CLRBTN_TOTAL (CLRBTN_W+CLRBTN_B)
-#define CLRBTN_Y (1150*DPI_MUL)
-#define CLRBTN_MARGIN (8*DPI_MUL)
-
-#define SELECTED_RECT_H (6*DPI_MUL)
-#define BTN_SHADOW_OFF (5*DPI_MUL)
-
-static void destroy(UNUSED multirom_theme_data *t)
-{
-
-}
-
-static void header_set_tab_selector_pos(multirom_theme_data *t, float pos)
-{
-    const int TAB_BTN_WIDTH = t->tab_btns[0]->w;
-    int dest_x = t->tab_btns[0]->x + TAB_BTN_WIDTH*pos;
-    int dest_w = TAB_BTN_WIDTH;
-
-    const int selected = imin(TAB_COUNT-1, imax(0, (int)(pos+0.5f)));
-    int i, rect_i = 0;
-    for(i = 0; i < TAB_COUNT; ++i)
-    {
-        if(selected == i)
-            continue;
-
-        t->selected_rect[rect_i]->x = t->tab_texts[i]->x;
-        t->selected_rect[rect_i]->y = t->tab_texts[i]->y;
-        t->selected_rect[rect_i]->w = t->tab_texts[i]->w;
-        t->selected_rect[rect_i]->h = t->tab_texts[i]->h;
-        ++rect_i;
-    }
-
-    if(dest_x < t->tab_btns[0]->x)
-    {
-        dest_w -= t->tab_btns[0]->x - dest_x;
-        dest_x = t->tab_btns[0]->x;
-    }
-    else if(dest_x > t->tab_btns[TAB_COUNT-1]->x)
-    {
-        dest_w = (t->tab_btns[TAB_COUNT-1]->x + t->tab_btns[TAB_COUNT-1]->w) - dest_x;
-    }
-
-    t->selected_tab_rect->x = dest_x;
-    t->selected_tab_rect->w = dest_w;
-}
-
-static void init_header(multirom_theme_data *t)
-{
-    button **tab_btns = t->tab_btns;
-    fb_text **tab_texts = t->tab_texts;
-    const int TAB_BTN_WIDTH = fb_width*0.21;
-    int i, x;
-    static const char *str[] = { "INTERNAL", "EXTERNAL", "MISC" };
-    char buff[64];
-
-    fb_add_rect_lvl(100, 0, 0, fb_width, HEADER_HEIGHT, C_HIGHLIGHT_BG);
-    fb_add_rect(0, HEADER_HEIGHT, fb_width, (3*DPI_MUL), C_BTN_FAKE_SHADOW);
-    ncard_set_top_offset(HEADER_HEIGHT);
-
-    int maxW = 0;
-    for(i = 0; i < TAB_COUNT; ++i)
-    {
-        fb_text_proto *p = fb_text_create(0, 0, C_HIGHLIGHT_TEXT, SIZE_NORMAL, str[i]);
-        p->level = 110;
-        p->style = STYLE_MEDIUM;
-        tab_texts[i] = fb_text_finalize(p);
-        maxW = imax(maxW, tab_texts[i]->w);
-    }
-
-    maxW += (30*DPI_MUL);
-    x = fb_width/2 - (maxW*TAB_COUNT)/2;
-
-    snprintf(buff, sizeof(buff), ":/miri_%dx%d.png", (int)MIRI_W, (int)MIRI_W);
-    fb_add_png_img_lvl(110, 10*DPI_MUL, HEADER_HEIGHT/2 - MIRI_W/2, MIRI_W, MIRI_W, buff);
-
-    for(i = 0; i < TAB_COUNT; ++i)
-    {
-        center_text(tab_texts[i], x, 0, maxW, HEADER_HEIGHT);
-
-        tab_btns[i] = mzalloc(sizeof(button));
-        tab_btns[i]->x = x;
-        tab_btns[i]->y = 0;
-        tab_btns[i]->w = maxW;
-        tab_btns[i]->h = HEADER_HEIGHT;
-        tab_btns[i]->clicked_data = malloc(sizeof(int));
-        *((int*)tab_btns[i]->clicked_data) = i;
-        tab_btns[i]->clicked = &multirom_ui_switch_btn;
-        tab_btns[i]->level_off = 100;
-        button_init_ui(tab_btns[i], "", 0);
-
-        keyaction_add(tab_btns[i], button_keyaction_call, tab_btns[i]);
-
-        x += maxW;
-
-         if(i < TAB_COUNT-1)
-            t->selected_rect[i] = fb_add_rect_lvl(120, 0, 0, 0, 0, (0x4C << 24) | (C_HIGHLIGHT_BG & 0x00FFFFFF));
-    }
-
-    t->selected_tab_rect = fb_add_rect_lvl(110, tab_btns[0]->x, HEADER_HEIGHT-SELECTED_RECT_H + (3*DPI_MUL), maxW, SELECTED_RECT_H, C_HIGHLIGHT_TEXT);
-    t->tabs = tabview_create(0, HEADER_HEIGHT, fb_width, fb_height-HEADER_HEIGHT);
-    header_set_tab_selector_pos(t, 0.f);
-}
-
-static void tab_rom_init(UNUSED multirom_theme_data *t, tab_data_roms *d, UNUSED int tab_type)
-{
-    d->list->x = fb_width/2 - fb_height/2;
-    d->list->y = HEADER_HEIGHT + LISTVIEW_MARGIN;
-    d->list->w = fb_height;
-    d->list->h = fb_height - d->list->y - LISTVIEW_MARGIN;
-}
-
-static void tab_misc_init(multirom_theme_data *t, tab_data_misc *d, int color_scheme)
-{
-    int i;
-    int x = fb_width/2 - (MISCBTN_W + 30*DPI_MUL);
-    int y = HEADER_HEIGHT + ((fb_height - HEADER_HEIGHT)/2 - 2*(MISCBTN_H + 30*DPI_MUL));
-    fb_rect *shadow;
-
-    y += MISCBTN_H + 30*DPI_MUL;
-
-    button *b = mzalloc(sizeof(button));
-    b->x = x;
-    b->y = y;
-    b->w = MISCBTN_W;
-    b->h = MISCBTN_H;
-    b->clicked = &multirom_ui_tab_misc_copy_log;
-    shadow = fb_add_rect_lvl(LEVEL_RECT, b->x + BTN_SHADOW_OFF, b->y + BTN_SHADOW_OFF, b->w, b->h, C_BTN_FAKE_SHADOW);
-    button_init_ui(b, "COPY LOG TO /SDCARD", SIZE_NORMAL);
-    list_add(&d->buttons, b);
-    list_add(&d->ui_elements, shadow);
-    tabview_add_item(t->tabs, TAB_MISC, b->text);
-    tabview_add_item(t->tabs, TAB_MISC, b->rect);
-    tabview_add_item(t->tabs, TAB_MISC, b);
-
-    const int max_colors = colors_count();
-    x += (MISCBTN_W/2 - (max_colors*(CLRBTN_TOTAL+CLRBTN_MARGIN))/2);
-    y += MISCBTN_H+30*DPI_MUL + (MISCBTN_H/2 - CLRBTN_TOTAL/2);
-    fb_rect *r;
-    for(i = 0; i < max_colors; ++i)
-    {
-        const struct mrom_color_theme *th = colors_get(i);
-
-        r = fb_add_rect(x, y, CLRBTN_TOTAL, CLRBTN_TOTAL, i == color_scheme ? 0xFFFFCC00 : WHITE);
-        list_add(&d->ui_elements, r);
-
-        r = fb_add_rect(x+CLRBTN_B/2, y+CLRBTN_B/2, CLRBTN_W, CLRBTN_W, th->highlight_bg);
-        list_add(&d->ui_elements, r);
-
-        b = mzalloc(sizeof(button));
-        b->x = x;
-        b->y = y;
-        b->w = CLRBTN_TOTAL;
-        b->h = CLRBTN_TOTAL;
-        b->clicked_data = malloc(sizeof(int));
-        *((int*)b->clicked_data) = i;
-        b->clicked = &multirom_ui_tab_misc_change_clr;
-        button_init_ui(b, NULL, 0);
-        list_add(&d->buttons, b);
-        tabview_add_item(t->tabs, TAB_MISC, b);
-
-        x += CLRBTN_TOTAL + CLRBTN_MARGIN;
-    }
-
-    x = fb_width/2 - (MISCBTN_W + 30*DPI_MUL) + MISCBTN_W + 30*DPI_MUL;
-    y = HEADER_HEIGHT + ((fb_height - HEADER_HEIGHT)/2 - 2*(MISCBTN_H + 30*DPI_MUL));
-
-    static const char *texts[] =
-    {
-        "REBOOT",               // 0
-        "REBOOT TO RECOVERY",   // 1
-        "REBOOT TO BOOTLOADER", // 2
-        "SHUTDOWN",             // 3
-        NULL
-    };
-
-    static const int exit_codes[] = {
-        UI_EXIT_REBOOT, UI_EXIT_REBOOT_RECOVERY,
-        UI_EXIT_REBOOT_BOOTLOADER, UI_EXIT_SHUTDOWN
-    };
-
-    for(i = 0; texts[i]; ++i)
-    {
-        b = mzalloc(sizeof(button));
-        b->x = x;
-        b->y = y;
-        b->w = MISCBTN_W;
-        b->h = MISCBTN_H;
-        b->clicked_data = malloc(sizeof(int));
-        *((int*)b->clicked_data) = exit_codes[i];
-        b->clicked = &multirom_ui_reboot_btn;
-        shadow = fb_add_rect_lvl(LEVEL_RECT, b->x + BTN_SHADOW_OFF, b->y + BTN_SHADOW_OFF, b->w, b->h, C_BTN_FAKE_SHADOW);
-        button_init_ui(b, texts[i], SIZE_NORMAL);
-        list_add(&d->buttons, b);
-        list_add(&d->ui_elements, shadow);
-        tabview_add_item(t->tabs, TAB_MISC, b->text);
-        tabview_add_item(t->tabs, TAB_MISC, b->rect);
-        tabview_add_item(t->tabs, TAB_MISC, b);
-
-        y += MISCBTN_H+30*DPI_MUL;
-    }
-
-    fb_text *text = fb_add_text(5*DPI_MUL, 0, C_TEXT_SECONDARY, SIZE_SMALL, "MultiROM v%d"VERSION_DEV_FIX" with trampoline v%d.",
-                               VERSION_MULTIROM, multirom_get_trampoline_ver());
-    text->y = fb_height - text->h;
-    list_add(&d->ui_elements, text);
-
-    text = fb_add_text(0, 0, C_TEXT_SECONDARY, SIZE_SMALL, "Battery: %d%%", multirom_get_battery());
-    text->x = fb_width - text->w - 5*DPI_MUL;
-    text->y = fb_height - text->h;
-    list_add(&d->ui_elements, text);
-
-    for(i = 0; d->buttons[i]; ++i)
-        keyaction_add(d->buttons[i], button_keyaction_call, d->buttons[i]);
-
-    tabview_add_items(t->tabs, TAB_MISC, d->ui_elements);
-}
-
-static int get_tab_width(UNUSED multirom_theme_data *t)
-{
-    return fb_width;
-}
-
-static int get_tab_height(UNUSED multirom_theme_data *t)
-{
-    return fb_height - HEADER_HEIGHT;
-}
-
-const struct multirom_theme theme_info_landscape = {
-    .width = TH_LANDSCAPE,
-    .height = TH_LANDSCAPE,
-
-    .destroy = &destroy,
-    .init_header = &init_header,
-    .header_set_tab_selector_pos = &header_set_tab_selector_pos,
-    .tab_rom_init = &tab_rom_init,
-    .tab_misc_init = &tab_misc_init,
-    .get_tab_width = &get_tab_width,
-    .get_tab_height = &get_tab_height,
-};
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "multirom_ui.h"
+#include "multirom_ui_themes.h"
+#include "multirom.h"
+#include "version.h"
+#include "lib/framebuffer.h"
+#include "lib/util.h"
+#include "lib/button.h"
+#include "lib/input.h"
+#include "lib/log.h"
+#include "lib/animation.h"
+#include "lib/notification_card.h"
+#include "lib/tabview.h"
+#include "lib/colors.h"
+
+#define HEADER_HEIGHT (80*DPI_MUL)
+#define TABS_HEIGHT (HEADER_HEIGHT - STATUS_HEIGHT)
+#define MIRI_W (60*DPI_MUL)
+
+#define LISTVIEW_MARGIN (20*DPI_MUL)
+
+#define REFRESHBTN_W (400*DPI_MUL)
+#define REFRESHBTN_H (60*DPI_MUL)
+
+#define MISCBTN_W (530*DPI_MUL)
+#define MISCBTN_H (100*DPI_MUL)
+
+#define CLRBTN_W (50*DPI_MUL)
+#define CLRBTN_B (10*DPI_MUL)
+#define CLRBTN_TOTAL (CLRBTN_W+CLRBTN_B)
+#define CLRBTN_Y (1150*DPI_MUL)
+#define CLRBTN_MARGIN (8*DPI_MUL)
+
+#define SELECTED_RECT_H (6*DPI_MUL)
+#define BTN_SHADOW_OFF (5*DPI_MUL)
+
+static void destroy(UNUSED multirom_theme_data *t)
+{
+
+}
+
+static void header_set_tab_selector_pos(multirom_theme_data *t, float pos)
+{
+    const int TAB_BTN_WIDTH = t->tab_btns[0]->w;
+    int dest_x = t->tab_btns[0]->x + TAB_BTN_WIDTH*pos;
+    int dest_w = TAB_BTN_WIDTH;
+
+    const int selected = imin(TAB_COUNT-1, imax(0, (int)(pos+0.5f)));
+    int i, rect_i = 0;
+    for(i = 0; i < TAB_COUNT; ++i)
+    {
+        if(selected == i)
+            continue;
+
+        t->selected_rect[rect_i]->x = t->tab_texts[i]->x;
+        t->selected_rect[rect_i]->y = t->tab_texts[i]->y;
+        t->selected_rect[rect_i]->w = t->tab_texts[i]->w;
+        t->selected_rect[rect_i]->h = t->tab_texts[i]->h;
+        ++rect_i;
+    }
+
+    if(dest_x < t->tab_btns[0]->x)
+    {
+        dest_w -= t->tab_btns[0]->x - dest_x;
+        dest_x = t->tab_btns[0]->x;
+    }
+    else if(dest_x > t->tab_btns[TAB_COUNT-1]->x)
+    {
+        dest_w = (t->tab_btns[TAB_COUNT-1]->x + t->tab_btns[TAB_COUNT-1]->w) - dest_x;
+    }
+
+    t->selected_tab_rect->x = dest_x;
+    t->selected_tab_rect->w = dest_w;
+}
+
+static void init_header(multirom_theme_data *t)
+{
+    button **tab_btns = t->tab_btns;
+    fb_text **tab_texts = t->tab_texts;
+    const int TAB_BTN_WIDTH = fb_width*0.21;
+    int i, x;
+    static const char *str[] = { "INTERNAL", "EXTERNAL", "MISC" };
+    char buff[64];
+
+    fb_add_rect_lvl(100, 0, 0, fb_width, HEADER_HEIGHT, C_HIGHLIGHT_BG);
+    fb_add_rect(0, HEADER_HEIGHT, fb_width, (3*DPI_MUL), C_BTN_FAKE_SHADOW);
+    ncard_set_top_offset(HEADER_HEIGHT);
+
+    int maxW = 0;
+    for(i = 0; i < TAB_COUNT; ++i)
+    {
+        fb_text_proto *p = fb_text_create(0, 0, C_HIGHLIGHT_TEXT, SIZE_NORMAL, str[i]);
+        p->level = 110;
+        p->style = STYLE_MEDIUM;
+        tab_texts[i] = fb_text_finalize(p);
+        maxW = imax(maxW, tab_texts[i]->w);
+    }
+
+    maxW += (30*DPI_MUL);
+    x = fb_width/2 - (maxW*TAB_COUNT)/2;
+
+    snprintf(buff, sizeof(buff), ":/miri_%dx%d.png", (int)MIRI_W, (int)MIRI_W);
+    fb_add_png_img_lvl(110, 10*DPI_MUL, HEADER_HEIGHT/2 - MIRI_W/2, MIRI_W, MIRI_W, buff);
+
+    for(i = 0; i < TAB_COUNT; ++i)
+    {
+        center_text(tab_texts[i], x, 0, maxW, HEADER_HEIGHT);
+
+        tab_btns[i] = mzalloc(sizeof(button));
+        tab_btns[i]->x = x;
+        tab_btns[i]->y = 0;
+        tab_btns[i]->w = maxW;
+        tab_btns[i]->h = HEADER_HEIGHT;
+        tab_btns[i]->clicked_data = malloc(sizeof(int));
+        *((int*)tab_btns[i]->clicked_data) = i;
+        tab_btns[i]->clicked = &multirom_ui_switch_btn;
+        tab_btns[i]->level_off = 100;
+        button_init_ui(tab_btns[i], "", 0);
+
+        keyaction_add(tab_btns[i], button_keyaction_call, tab_btns[i]);
+
+        x += maxW;
+
+         if(i < TAB_COUNT-1)
+            t->selected_rect[i] = fb_add_rect_lvl(120, 0, 0, 0, 0, (0x4C << 24) | (C_HIGHLIGHT_BG & 0x00FFFFFF));
+    }
+
+    t->selected_tab_rect = fb_add_rect_lvl(110, tab_btns[0]->x, HEADER_HEIGHT-SELECTED_RECT_H + (3*DPI_MUL), maxW, SELECTED_RECT_H, C_HIGHLIGHT_TEXT);
+    t->tabs = tabview_create(0, HEADER_HEIGHT, fb_width, fb_height-HEADER_HEIGHT);
+    header_set_tab_selector_pos(t, 0.f);
+}
+
+static void tab_rom_init(UNUSED multirom_theme_data *t, tab_data_roms *d, UNUSED int tab_type)
+{
+    d->list->x = fb_width/2 - fb_height/2;
+    d->list->y = HEADER_HEIGHT + LISTVIEW_MARGIN;
+    d->list->w = fb_height;
+    d->list->h = fb_height - d->list->y - LISTVIEW_MARGIN;
+}
+
+static void tab_misc_init(multirom_theme_data *t, tab_data_misc *d, int color_scheme)
+{
+    int i;
+    int x = fb_width/2 - (MISCBTN_W + 30*DPI_MUL);
+    int y = HEADER_HEIGHT + ((fb_height - HEADER_HEIGHT)/2 - 2*(MISCBTN_H + 30*DPI_MUL));
+    fb_rect *shadow;
+
+    y += MISCBTN_H + 30*DPI_MUL;
+
+    button *b = mzalloc(sizeof(button));
+    b->x = x;
+    b->y = y;
+    b->w = MISCBTN_W;
+    b->h = MISCBTN_H;
+    b->clicked = &multirom_ui_tab_misc_copy_log;
+    shadow = fb_add_rect_lvl(LEVEL_RECT, b->x + BTN_SHADOW_OFF, b->y + BTN_SHADOW_OFF, b->w, b->h, C_BTN_FAKE_SHADOW);
+    button_init_ui(b, "COPY LOG TO /SDCARD", SIZE_NORMAL);
+    list_add(&d->buttons, b);
+    list_add(&d->ui_elements, shadow);
+    tabview_add_item(t->tabs, TAB_MISC, b->text);
+    tabview_add_item(t->tabs, TAB_MISC, b->rect);
+    tabview_add_item(t->tabs, TAB_MISC, b);
+
+    const int max_colors = colors_count();
+    x += (MISCBTN_W/2 - (max_colors*(CLRBTN_TOTAL+CLRBTN_MARGIN))/2);
+    y += MISCBTN_H+30*DPI_MUL + (MISCBTN_H/2 - CLRBTN_TOTAL/2);
+    fb_rect *r;
+    for(i = 0; i < max_colors; ++i)
+    {
+        const struct mrom_color_theme *th = colors_get(i);
+
+        r = fb_add_rect(x, y, CLRBTN_TOTAL, CLRBTN_TOTAL, i == color_scheme ? 0xFFFFCC00 : WHITE);
+        list_add(&d->ui_elements, r);
+
+        r = fb_add_rect(x+CLRBTN_B/2, y+CLRBTN_B/2, CLRBTN_W, CLRBTN_W, th->highlight_bg);
+        list_add(&d->ui_elements, r);
+
+        b = mzalloc(sizeof(button));
+        b->x = x;
+        b->y = y;
+        b->w = CLRBTN_TOTAL;
+        b->h = CLRBTN_TOTAL;
+        b->clicked_data = malloc(sizeof(int));
+        *((int*)b->clicked_data) = i;
+        b->clicked = &multirom_ui_tab_misc_change_clr;
+        button_init_ui(b, NULL, 0);
+        list_add(&d->buttons, b);
+        tabview_add_item(t->tabs, TAB_MISC, b);
+
+        x += CLRBTN_TOTAL + CLRBTN_MARGIN;
+    }
+
+    x = fb_width/2 - (MISCBTN_W + 30*DPI_MUL) + MISCBTN_W + 30*DPI_MUL;
+    y = HEADER_HEIGHT + ((fb_height - HEADER_HEIGHT)/2 - 2*(MISCBTN_H + 30*DPI_MUL));
+
+    static const char *texts[] =
+    {
+        "REBOOT",               // 0
+        "REBOOT TO RECOVERY",   // 1
+        "REBOOT TO BOOTLOADER", // 2
+        "SHUTDOWN",             // 3
+        NULL
+    };
+
+    static const int exit_codes[] = {
+        UI_EXIT_REBOOT, UI_EXIT_REBOOT_RECOVERY,
+        UI_EXIT_REBOOT_BOOTLOADER, UI_EXIT_SHUTDOWN
+    };
+
+    for(i = 0; texts[i]; ++i)
+    {
+        b = mzalloc(sizeof(button));
+        b->x = x;
+        b->y = y;
+        b->w = MISCBTN_W;
+        b->h = MISCBTN_H;
+        b->clicked_data = malloc(sizeof(int));
+        *((int*)b->clicked_data) = exit_codes[i];
+        b->clicked = &multirom_ui_reboot_btn;
+        shadow = fb_add_rect_lvl(LEVEL_RECT, b->x + BTN_SHADOW_OFF, b->y + BTN_SHADOW_OFF, b->w, b->h, C_BTN_FAKE_SHADOW);
+        button_init_ui(b, texts[i], SIZE_NORMAL);
+        list_add(&d->buttons, b);
+        list_add(&d->ui_elements, shadow);
+        tabview_add_item(t->tabs, TAB_MISC, b->text);
+        tabview_add_item(t->tabs, TAB_MISC, b->rect);
+        tabview_add_item(t->tabs, TAB_MISC, b);
+
+        y += MISCBTN_H+30*DPI_MUL;
+    }
+
+    fb_text *text = fb_add_text(5*DPI_MUL, 0, C_TEXT_SECONDARY, SIZE_SMALL, "MultiROM v%d"VERSION_DEV_FIX" with trampoline v%d.",
+                               VERSION_MULTIROM, multirom_get_trampoline_ver());
+    text->y = fb_height - text->h;
+    list_add(&d->ui_elements, text);
+
+    text = fb_add_text(0, 0, C_TEXT_SECONDARY, SIZE_SMALL, "Battery: %d%%", multirom_get_battery());
+    text->x = fb_width - text->w - 5*DPI_MUL;
+    text->y = fb_height - text->h;
+    list_add(&d->ui_elements, text);
+
+    for(i = 0; d->buttons[i]; ++i)
+        keyaction_add(d->buttons[i], button_keyaction_call, d->buttons[i]);
+
+    tabview_add_items(t->tabs, TAB_MISC, d->ui_elements);
+}
+
+static int get_tab_width(UNUSED multirom_theme_data *t)
+{
+    return fb_width;
+}
+
+static int get_tab_height(UNUSED multirom_theme_data *t)
+{
+    return fb_height - HEADER_HEIGHT;
+}
+
+const struct multirom_theme theme_info_landscape = {
+    .width = TH_LANDSCAPE,
+    .height = TH_LANDSCAPE,
+
+    .destroy = &destroy,
+    .init_header = &init_header,
+    .header_set_tab_selector_pos = &header_set_tab_selector_pos,
+    .tab_rom_init = &tab_rom_init,
+    .tab_misc_init = &tab_misc_init,
+    .get_tab_width = &get_tab_width,
+    .get_tab_height = &get_tab_height,
+};
diff --git a/multirom_ui_portrait.c b/multirom_ui_portrait.c
index 09c54ff..0d183dc 100755
--- a/multirom_ui_portrait.c
+++ b/multirom_ui_portrait.c
@@ -1,297 +1,297 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "multirom_ui.h"
-#include "multirom_ui_themes.h"
-#include "multirom.h"
-#include "version.h"
-#include "lib/framebuffer.h"
-#include "lib/util.h"
-#include "lib/button.h"
-#include "lib/input.h"
-#include "lib/log.h"
-#include "lib/animation.h"
-#include "lib/notification_card.h"
-#include "lib/tabview.h"
-#include "lib/colors.h"
-
-#define HEADER_HEIGHT (110*DPI_MUL)
-#define TABS_HEIGHT (HEADER_HEIGHT - STATUS_HEIGHT)
-#define MIRI_W (90*DPI_MUL)
-
-#define LISTVIEW_MARGIN (20*DPI_MUL)
-
-#define REFRESHBTN_W (400*DPI_MUL)
-#define REFRESHBTN_H (60*DPI_MUL)
-
-#define MISCBTN_W (530*DPI_MUL)
-#define MISCBTN_H (100*DPI_MUL)
-
-#define CLRBTN_W (50*DPI_MUL)
-#define CLRBTN_B (10*DPI_MUL)
-#define CLRBTN_TOTAL (CLRBTN_W+CLRBTN_B)
-#define CLRBTN_Y (1100*DPI_MUL)
-#define CLRBTN_MARGIN (8*DPI_MUL)
-
-#define SELECTED_RECT_H (6*DPI_MUL)
-#define BTN_SHADOW_OFF (5*DPI_MUL)
-
-static button *pong_btn = NULL;
-static void destroy(UNUSED multirom_theme_data *t)
-{
-    if(pong_btn)
-    {
-        button_destroy(pong_btn);
-        pong_btn = NULL;
-    }
-}
-
-static void header_set_tab_selector_pos(multirom_theme_data *t, float pos)
-{
-    const int TAB_BTN_WIDTH = t->tab_btns[0]->w;
-
-    int dest_x = t->tab_btns[0]->x + TAB_BTN_WIDTH*pos;
-    int dest_w = TAB_BTN_WIDTH;
-
-    const int selected = imin(TAB_COUNT-1, imax(0, (int)(pos+0.5f)));
-    int i, rect_i = 0;
-    for(i = 0; i < TAB_COUNT; ++i)
-    {
-        if(selected == i)
-            continue;
-
-        t->selected_rect[rect_i]->x = t->tab_texts[i]->x;
-        t->selected_rect[rect_i]->y = t->tab_texts[i]->y;
-        t->selected_rect[rect_i]->w = t->tab_texts[i]->w;
-        t->selected_rect[rect_i]->h = t->tab_texts[i]->h;
-        ++rect_i;
-    }
-
-    if(dest_x < t->tab_btns[0]->x)
-    {
-        dest_w -= t->tab_btns[0]->x - dest_x;
-        dest_x = t->tab_btns[0]->x;
-    }
-    else if(dest_x > t->tab_btns[TAB_COUNT-1]->x)
-    {
-        dest_w = (t->tab_btns[TAB_COUNT-1]->x + t->tab_btns[TAB_COUNT-1]->w) - dest_x;
-    }
-
-    t->selected_tab_rect->x = dest_x;
-    t->selected_tab_rect->w = dest_w;
-}
-
-static void init_header(multirom_theme_data *t)
-{
-    button **tab_btns = t->tab_btns;
-    fb_text **tab_texts = t->tab_texts;
-    int i, x;
-    static const char *str[] = { "INTERNAL", "EXTERNAL", "MISC" };
-    char buff[64];
-
-    fb_add_rect_lvl(100, 0, 0, fb_width, HEADER_HEIGHT, C_HIGHLIGHT_BG);
-    fb_add_rect(0, HEADER_HEIGHT, fb_width, (3*DPI_MUL), C_BTN_FAKE_SHADOW);
-    ncard_set_top_offset(HEADER_HEIGHT);
-
-    int maxW = 0;
-    for(i = 0; i < TAB_COUNT; ++i)
-    {
-        fb_text_proto *p = fb_text_create(0, 0, C_HIGHLIGHT_TEXT, SIZE_NORMAL, str[i]);
-        p->level = 110;
-        p->style = STYLE_MEDIUM;
-        tab_texts[i] = fb_text_finalize(p);
-        maxW = imax(maxW, tab_texts[i]->w);
-    }
-
-    maxW += (20*DPI_MUL);
-    x = fb_width/2 - (maxW*TAB_COUNT)/2;
-
-    snprintf(buff, sizeof(buff), ":/miri_%dx%d.png", (int)MIRI_W, (int)MIRI_W);
-    fb_img *logo = fb_add_png_img_lvl(110, 10*DPI_MUL, HEADER_HEIGHT/2 - MIRI_W/2, MIRI_W, MIRI_W, buff);
-    if(logo)
-    {
-        pong_btn = mzalloc(sizeof(button));
-        pong_btn->x = logo->x;
-        pong_btn->y = logo->y;
-        pong_btn->w = logo->w;
-        pong_btn->h = logo->h;
-        pong_btn->clicked = &multirom_ui_start_pong;
-        button_init_ui(pong_btn, NULL, 0);
-    }
-
-    for(i = 0; i < TAB_COUNT; ++i)
-    {
-        center_text(tab_texts[i], x, 0, maxW, HEADER_HEIGHT);
-
-        tab_btns[i] = mzalloc(sizeof(button));
-        tab_btns[i]->x = x;
-        tab_btns[i]->y = 0;
-        tab_btns[i]->w = maxW;
-        tab_btns[i]->h = HEADER_HEIGHT;
-        tab_btns[i]->clicked_data = malloc(sizeof(int));
-        *((int*)tab_btns[i]->clicked_data) = i;
-        tab_btns[i]->clicked = &multirom_ui_switch_btn;
-        tab_btns[i]->level_off = 100;
-        button_init_ui(tab_btns[i], "", 0);
-
-        keyaction_add(tab_btns[i], button_keyaction_call, tab_btns[i]);
-
-        x += maxW;
-
-        if(i < TAB_COUNT-1)
-            t->selected_rect[i] = fb_add_rect_lvl(120, 0, 0, 0, 0, (0x4C << 24) | (C_HIGHLIGHT_BG & 0x00FFFFFF));
-    }
-
-    t->selected_tab_rect = fb_add_rect_lvl(110, tab_btns[0]->x, HEADER_HEIGHT-SELECTED_RECT_H + (3*DPI_MUL), maxW, SELECTED_RECT_H, C_HIGHLIGHT_TEXT);
-    t->tabs = tabview_create(0, HEADER_HEIGHT, fb_width, fb_height-HEADER_HEIGHT);
-    header_set_tab_selector_pos(t, 0.f);
-}
-
-static void tab_rom_init(UNUSED multirom_theme_data *t, tab_data_roms *d, UNUSED int tab_type)
-{
-    d->list->x = LISTVIEW_MARGIN;
-    d->list->y = HEADER_HEIGHT+LISTVIEW_MARGIN;
-    d->list->w = fb_width - LISTVIEW_MARGIN;
-    d->list->h = fb_height - d->list->y - LISTVIEW_MARGIN;
-}
-
-static void tab_misc_init(multirom_theme_data *t, tab_data_misc *d, int color_scheme)
-{
-    int x = fb_width/2 - MISCBTN_W/2;
-    int y = 270*DPI_MUL;
-    fb_rect *shadow;
-
-    button *b = mzalloc(sizeof(button));
-    b->x = x;
-    b->y = y;
-    b->w = MISCBTN_W;
-    b->h = MISCBTN_H;
-    b->clicked = &multirom_ui_tab_misc_copy_log;
-    shadow = fb_add_rect_lvl(LEVEL_RECT, b->x + BTN_SHADOW_OFF, b->y + BTN_SHADOW_OFF, b->w, b->h, C_BTN_FAKE_SHADOW);
-    button_init_ui(b, "COPY LOG TO /SDCARD", SIZE_NORMAL);
-    list_add(&d->buttons, b);
-    list_add(&d->ui_elements, shadow);
-    tabview_add_item(t->tabs, TAB_MISC, b->text);
-    tabview_add_item(t->tabs, TAB_MISC, b->rect);
-    tabview_add_item(t->tabs, TAB_MISC, b);
-
-    y += MISCBTN_H+70*DPI_MUL;
-
-    static const char *texts[] =
-    {
-        "REBOOT",               // 0
-        "REBOOT TO RECOVERY",   // 1
-        "REBOOT TO BOOTLOADER", // 2
-        "SHUTDOWN",             // 3
-        NULL
-    };
-
-    static const int exit_codes[] = {
-        UI_EXIT_REBOOT, UI_EXIT_REBOOT_RECOVERY,
-        UI_EXIT_REBOOT_BOOTLOADER, UI_EXIT_SHUTDOWN
-    };
-
-    int i;
-    for(i = 0; texts[i]; ++i)
-    {
-        b = mzalloc(sizeof(button));
-        b->x = x;
-        b->y = y;
-        b->w = MISCBTN_W;
-        b->h = MISCBTN_H;
-        b->clicked_data = malloc(sizeof(int));
-        *((int*)b->clicked_data) = exit_codes[i];
-        b->clicked = &multirom_ui_reboot_btn;
-        shadow = fb_add_rect_lvl(LEVEL_RECT, b->x + BTN_SHADOW_OFF, b->y + BTN_SHADOW_OFF, b->w, b->h, C_BTN_FAKE_SHADOW);
-        button_init_ui(b, texts[i], SIZE_NORMAL);
-        list_add(&d->buttons, b);
-        list_add(&d->ui_elements, shadow);
-        tabview_add_item(t->tabs, TAB_MISC, b->text);
-        tabview_add_item(t->tabs, TAB_MISC, b->rect);
-        tabview_add_item(t->tabs, TAB_MISC, b);
-
-        y += MISCBTN_H+20*DPI_MUL;
-        if(i == 2)
-            y += 50*DPI_MUL;
-    }
-
-    fb_text *text = fb_add_text(5*DPI_MUL, 0, C_TEXT_SECONDARY, SIZE_SMALL, "MultiROM v%d"VERSION_DEV_FIX" with trampoline v%d.",
-                               VERSION_MULTIROM, multirom_get_trampoline_ver());
-    text->y = fb_height - text->h;
-    list_add(&d->ui_elements, text);
-
-    text = fb_add_text(0, 0, C_TEXT_SECONDARY, SIZE_SMALL, "Battery: %d%%", multirom_get_battery());
-    text->x = fb_width - text->w - 5*DPI_MUL;
-    text->y = fb_height - text->h;
-    list_add(&d->ui_elements, text);
-
-    const int max_colors = colors_count();
-    x = fb_width/2 - (max_colors*(CLRBTN_TOTAL+CLRBTN_MARGIN))/2;
-    fb_rect *r;
-    for(i = 0; i < max_colors; ++i)
-    {
-        const struct mrom_color_theme *th = colors_get(i);
-
-        r = fb_add_rect(x, CLRBTN_Y, CLRBTN_TOTAL, CLRBTN_TOTAL, i == color_scheme ? 0xFFFFCC00 : WHITE);
-        list_add(&d->ui_elements, r);
-
-        r = fb_add_rect(x+CLRBTN_B/2, CLRBTN_Y+CLRBTN_B/2, CLRBTN_W, CLRBTN_W, th->highlight_bg);
-        list_add(&d->ui_elements, r);
-
-        b = mzalloc(sizeof(button));
-        b->x = x;
-        b->y = CLRBTN_Y;
-        b->w = CLRBTN_TOTAL;
-        b->h = CLRBTN_TOTAL;
-        b->clicked_data = malloc(sizeof(int));
-        *((int*)b->clicked_data) = i;
-        b->clicked = &multirom_ui_tab_misc_change_clr;
-        button_init_ui(b, NULL, 0);
-        list_add(&d->buttons, b);
-        tabview_add_item(t->tabs, TAB_MISC, b);
-
-        x += CLRBTN_TOTAL + CLRBTN_MARGIN;
-    }
-
-    for(i = 0; d->buttons[i]; ++i)
-        keyaction_add(d->buttons[i], button_keyaction_call, d->buttons[i]);
-
-    tabview_add_items(t->tabs, TAB_MISC, d->ui_elements);
-}
-
-static int get_tab_width(UNUSED multirom_theme_data *t)
-{
-    return fb_width;
-}
-
-static int get_tab_height(UNUSED multirom_theme_data *t)
-{
-    return fb_height - HEADER_HEIGHT;
-}
-
-const struct multirom_theme theme_info_portrait = {
-    .width = TH_PORTRAIT,
-    .height = TH_PORTRAIT,
-
-    .destroy = &destroy,
-    .init_header = &init_header,
-    .header_set_tab_selector_pos = &header_set_tab_selector_pos,
-    .tab_rom_init = &tab_rom_init,
-    .tab_misc_init = &tab_misc_init,
-    .get_tab_width = &get_tab_width,
-    .get_tab_height = &get_tab_height,
-};
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "multirom_ui.h"
+#include "multirom_ui_themes.h"
+#include "multirom.h"
+#include "version.h"
+#include "lib/framebuffer.h"
+#include "lib/util.h"
+#include "lib/button.h"
+#include "lib/input.h"
+#include "lib/log.h"
+#include "lib/animation.h"
+#include "lib/notification_card.h"
+#include "lib/tabview.h"
+#include "lib/colors.h"
+
+#define HEADER_HEIGHT (110*DPI_MUL)
+#define TABS_HEIGHT (HEADER_HEIGHT - STATUS_HEIGHT)
+#define MIRI_W (90*DPI_MUL)
+
+#define LISTVIEW_MARGIN (20*DPI_MUL)
+
+#define REFRESHBTN_W (400*DPI_MUL)
+#define REFRESHBTN_H (60*DPI_MUL)
+
+#define MISCBTN_W (530*DPI_MUL)
+#define MISCBTN_H (100*DPI_MUL)
+
+#define CLRBTN_W (50*DPI_MUL)
+#define CLRBTN_B (10*DPI_MUL)
+#define CLRBTN_TOTAL (CLRBTN_W+CLRBTN_B)
+#define CLRBTN_Y (1100*DPI_MUL)
+#define CLRBTN_MARGIN (8*DPI_MUL)
+
+#define SELECTED_RECT_H (6*DPI_MUL)
+#define BTN_SHADOW_OFF (5*DPI_MUL)
+
+static button *pong_btn = NULL;
+static void destroy(UNUSED multirom_theme_data *t)
+{
+    if(pong_btn)
+    {
+        button_destroy(pong_btn);
+        pong_btn = NULL;
+    }
+}
+
+static void header_set_tab_selector_pos(multirom_theme_data *t, float pos)
+{
+    const int TAB_BTN_WIDTH = t->tab_btns[0]->w;
+
+    int dest_x = t->tab_btns[0]->x + TAB_BTN_WIDTH*pos;
+    int dest_w = TAB_BTN_WIDTH;
+
+    const int selected = imin(TAB_COUNT-1, imax(0, (int)(pos+0.5f)));
+    int i, rect_i = 0;
+    for(i = 0; i < TAB_COUNT; ++i)
+    {
+        if(selected == i)
+            continue;
+
+        t->selected_rect[rect_i]->x = t->tab_texts[i]->x;
+        t->selected_rect[rect_i]->y = t->tab_texts[i]->y;
+        t->selected_rect[rect_i]->w = t->tab_texts[i]->w;
+        t->selected_rect[rect_i]->h = t->tab_texts[i]->h;
+        ++rect_i;
+    }
+
+    if(dest_x < t->tab_btns[0]->x)
+    {
+        dest_w -= t->tab_btns[0]->x - dest_x;
+        dest_x = t->tab_btns[0]->x;
+    }
+    else if(dest_x > t->tab_btns[TAB_COUNT-1]->x)
+    {
+        dest_w = (t->tab_btns[TAB_COUNT-1]->x + t->tab_btns[TAB_COUNT-1]->w) - dest_x;
+    }
+
+    t->selected_tab_rect->x = dest_x;
+    t->selected_tab_rect->w = dest_w;
+}
+
+static void init_header(multirom_theme_data *t)
+{
+    button **tab_btns = t->tab_btns;
+    fb_text **tab_texts = t->tab_texts;
+    int i, x;
+    static const char *str[] = { "INTERNAL", "EXTERNAL", "MISC" };
+    char buff[64];
+
+    fb_add_rect_lvl(100, 0, 0, fb_width, HEADER_HEIGHT, C_HIGHLIGHT_BG);
+    fb_add_rect(0, HEADER_HEIGHT, fb_width, (3*DPI_MUL), C_BTN_FAKE_SHADOW);
+    ncard_set_top_offset(HEADER_HEIGHT);
+
+    int maxW = 0;
+    for(i = 0; i < TAB_COUNT; ++i)
+    {
+        fb_text_proto *p = fb_text_create(0, 0, C_HIGHLIGHT_TEXT, SIZE_NORMAL, str[i]);
+        p->level = 110;
+        p->style = STYLE_MEDIUM;
+        tab_texts[i] = fb_text_finalize(p);
+        maxW = imax(maxW, tab_texts[i]->w);
+    }
+
+    maxW += (20*DPI_MUL);
+    x = fb_width/2 - (maxW*TAB_COUNT)/2;
+
+    snprintf(buff, sizeof(buff), ":/miri_%dx%d.png", (int)MIRI_W, (int)MIRI_W);
+    fb_img *logo = fb_add_png_img_lvl(110, 10*DPI_MUL, HEADER_HEIGHT/2 - MIRI_W/2, MIRI_W, MIRI_W, buff);
+    if(logo)
+    {
+        pong_btn = mzalloc(sizeof(button));
+        pong_btn->x = logo->x;
+        pong_btn->y = logo->y;
+        pong_btn->w = logo->w;
+        pong_btn->h = logo->h;
+        pong_btn->clicked = &multirom_ui_start_pong;
+        button_init_ui(pong_btn, NULL, 0);
+    }
+
+    for(i = 0; i < TAB_COUNT; ++i)
+    {
+        center_text(tab_texts[i], x, 0, maxW, HEADER_HEIGHT);
+
+        tab_btns[i] = mzalloc(sizeof(button));
+        tab_btns[i]->x = x;
+        tab_btns[i]->y = 0;
+        tab_btns[i]->w = maxW;
+        tab_btns[i]->h = HEADER_HEIGHT;
+        tab_btns[i]->clicked_data = malloc(sizeof(int));
+        *((int*)tab_btns[i]->clicked_data) = i;
+        tab_btns[i]->clicked = &multirom_ui_switch_btn;
+        tab_btns[i]->level_off = 100;
+        button_init_ui(tab_btns[i], "", 0);
+
+        keyaction_add(tab_btns[i], button_keyaction_call, tab_btns[i]);
+
+        x += maxW;
+
+        if(i < TAB_COUNT-1)
+            t->selected_rect[i] = fb_add_rect_lvl(120, 0, 0, 0, 0, (0x4C << 24) | (C_HIGHLIGHT_BG & 0x00FFFFFF));
+    }
+
+    t->selected_tab_rect = fb_add_rect_lvl(110, tab_btns[0]->x, HEADER_HEIGHT-SELECTED_RECT_H + (3*DPI_MUL), maxW, SELECTED_RECT_H, C_HIGHLIGHT_TEXT);
+    t->tabs = tabview_create(0, HEADER_HEIGHT, fb_width, fb_height-HEADER_HEIGHT);
+    header_set_tab_selector_pos(t, 0.f);
+}
+
+static void tab_rom_init(UNUSED multirom_theme_data *t, tab_data_roms *d, UNUSED int tab_type)
+{
+    d->list->x = LISTVIEW_MARGIN;
+    d->list->y = HEADER_HEIGHT+LISTVIEW_MARGIN;
+    d->list->w = fb_width - LISTVIEW_MARGIN;
+    d->list->h = fb_height - d->list->y - LISTVIEW_MARGIN;
+}
+
+static void tab_misc_init(multirom_theme_data *t, tab_data_misc *d, int color_scheme)
+{
+    int x = fb_width/2 - MISCBTN_W/2;
+    int y = 270*DPI_MUL;
+    fb_rect *shadow;
+
+    button *b = mzalloc(sizeof(button));
+    b->x = x;
+    b->y = y;
+    b->w = MISCBTN_W;
+    b->h = MISCBTN_H;
+    b->clicked = &multirom_ui_tab_misc_copy_log;
+    shadow = fb_add_rect_lvl(LEVEL_RECT, b->x + BTN_SHADOW_OFF, b->y + BTN_SHADOW_OFF, b->w, b->h, C_BTN_FAKE_SHADOW);
+    button_init_ui(b, "COPY LOG TO /SDCARD", SIZE_NORMAL);
+    list_add(&d->buttons, b);
+    list_add(&d->ui_elements, shadow);
+    tabview_add_item(t->tabs, TAB_MISC, b->text);
+    tabview_add_item(t->tabs, TAB_MISC, b->rect);
+    tabview_add_item(t->tabs, TAB_MISC, b);
+
+    y += MISCBTN_H+70*DPI_MUL;
+
+    static const char *texts[] =
+    {
+        "REBOOT",               // 0
+        "REBOOT TO RECOVERY",   // 1
+        "REBOOT TO BOOTLOADER", // 2
+        "SHUTDOWN",             // 3
+        NULL
+    };
+
+    static const int exit_codes[] = {
+        UI_EXIT_REBOOT, UI_EXIT_REBOOT_RECOVERY,
+        UI_EXIT_REBOOT_BOOTLOADER, UI_EXIT_SHUTDOWN
+    };
+
+    int i;
+    for(i = 0; texts[i]; ++i)
+    {
+        b = mzalloc(sizeof(button));
+        b->x = x;
+        b->y = y;
+        b->w = MISCBTN_W;
+        b->h = MISCBTN_H;
+        b->clicked_data = malloc(sizeof(int));
+        *((int*)b->clicked_data) = exit_codes[i];
+        b->clicked = &multirom_ui_reboot_btn;
+        shadow = fb_add_rect_lvl(LEVEL_RECT, b->x + BTN_SHADOW_OFF, b->y + BTN_SHADOW_OFF, b->w, b->h, C_BTN_FAKE_SHADOW);
+        button_init_ui(b, texts[i], SIZE_NORMAL);
+        list_add(&d->buttons, b);
+        list_add(&d->ui_elements, shadow);
+        tabview_add_item(t->tabs, TAB_MISC, b->text);
+        tabview_add_item(t->tabs, TAB_MISC, b->rect);
+        tabview_add_item(t->tabs, TAB_MISC, b);
+
+        y += MISCBTN_H+20*DPI_MUL;
+        if(i == 2)
+            y += 50*DPI_MUL;
+    }
+
+    fb_text *text = fb_add_text(5*DPI_MUL, 0, C_TEXT_SECONDARY, SIZE_SMALL, "MultiROM v%d"VERSION_DEV_FIX" with trampoline v%d.",
+                               VERSION_MULTIROM, multirom_get_trampoline_ver());
+    text->y = fb_height - text->h;
+    list_add(&d->ui_elements, text);
+
+    text = fb_add_text(0, 0, C_TEXT_SECONDARY, SIZE_SMALL, "Battery: %d%%", multirom_get_battery());
+    text->x = fb_width - text->w - 5*DPI_MUL;
+    text->y = fb_height - text->h;
+    list_add(&d->ui_elements, text);
+
+    const int max_colors = colors_count();
+    x = fb_width/2 - (max_colors*(CLRBTN_TOTAL+CLRBTN_MARGIN))/2;
+    fb_rect *r;
+    for(i = 0; i < max_colors; ++i)
+    {
+        const struct mrom_color_theme *th = colors_get(i);
+
+        r = fb_add_rect(x, CLRBTN_Y, CLRBTN_TOTAL, CLRBTN_TOTAL, i == color_scheme ? 0xFFFFCC00 : WHITE);
+        list_add(&d->ui_elements, r);
+
+        r = fb_add_rect(x+CLRBTN_B/2, CLRBTN_Y+CLRBTN_B/2, CLRBTN_W, CLRBTN_W, th->highlight_bg);
+        list_add(&d->ui_elements, r);
+
+        b = mzalloc(sizeof(button));
+        b->x = x;
+        b->y = CLRBTN_Y;
+        b->w = CLRBTN_TOTAL;
+        b->h = CLRBTN_TOTAL;
+        b->clicked_data = malloc(sizeof(int));
+        *((int*)b->clicked_data) = i;
+        b->clicked = &multirom_ui_tab_misc_change_clr;
+        button_init_ui(b, NULL, 0);
+        list_add(&d->buttons, b);
+        tabview_add_item(t->tabs, TAB_MISC, b);
+
+        x += CLRBTN_TOTAL + CLRBTN_MARGIN;
+    }
+
+    for(i = 0; d->buttons[i]; ++i)
+        keyaction_add(d->buttons[i], button_keyaction_call, d->buttons[i]);
+
+    tabview_add_items(t->tabs, TAB_MISC, d->ui_elements);
+}
+
+static int get_tab_width(UNUSED multirom_theme_data *t)
+{
+    return fb_width;
+}
+
+static int get_tab_height(UNUSED multirom_theme_data *t)
+{
+    return fb_height - HEADER_HEIGHT;
+}
+
+const struct multirom_theme theme_info_portrait = {
+    .width = TH_PORTRAIT,
+    .height = TH_PORTRAIT,
+
+    .destroy = &destroy,
+    .init_header = &init_header,
+    .header_set_tab_selector_pos = &header_set_tab_selector_pos,
+    .tab_rom_init = &tab_rom_init,
+    .tab_misc_init = &tab_misc_init,
+    .get_tab_width = &get_tab_width,
+    .get_tab_height = &get_tab_height,
+};
diff --git a/multirom_ui_themes.c b/multirom_ui_themes.c
index d53007d..fbd38fa 100755
--- a/multirom_ui_themes.c
+++ b/multirom_ui_themes.c
@@ -1,69 +1,69 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "multirom_ui.h"
-#include "multirom_ui_themes.h"
-#include "multirom.h"
-#include "lib/util.h"
-#include "lib/log.h"
-
-multirom_themes_info *multirom_ui_init_themes(void)
-{
-    multirom_themes_info *i = mzalloc(sizeof(multirom_themes_info));
-
-    i->data = mzalloc(sizeof(multirom_theme_data));
-
-#define ADD_THEME(RES) \
-    extern struct multirom_theme theme_info_ ## RES; \
-    list_add(&i->themes, &theme_info_ ## RES);
-
-    // universal themes which scale according to DPI_MUL
-    ADD_THEME(landscape);
-    ADD_THEME(portrait);
-    return i;
-}
-
-void multirom_ui_free_themes(multirom_themes_info *i)
-{
-    list_clear(&i->themes, NULL);
-    free(i->data);
-    free(i);
-}
-
-multirom_theme *multirom_ui_select_theme(multirom_themes_info *i, int w, int h)
-{
-    if(i->themes == NULL)
-        return NULL;
-
-    multirom_theme *universal = NULL;
-    const int uni_type = (w > h) ? TH_LANDSCAPE : TH_PORTRAIT;
-
-    multirom_theme **itr;
-    for(itr = i->themes; *itr; ++itr)
-    {
-        if((*itr)->width == w && (*itr)->height == h)
-            return *itr;
-
-        if((*itr)->width == uni_type)
-            universal = *itr;
-    }
-
-    if(universal)
-        INFO("Using universal theme (%d)\n", uni_type);
-
-    return universal;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "multirom_ui.h"
+#include "multirom_ui_themes.h"
+#include "multirom.h"
+#include "lib/util.h"
+#include "lib/log.h"
+
+multirom_themes_info *multirom_ui_init_themes(void)
+{
+    multirom_themes_info *i = mzalloc(sizeof(multirom_themes_info));
+
+    i->data = mzalloc(sizeof(multirom_theme_data));
+
+#define ADD_THEME(RES) \
+    extern struct multirom_theme theme_info_ ## RES; \
+    list_add(&i->themes, &theme_info_ ## RES);
+
+    // universal themes which scale according to DPI_MUL
+    ADD_THEME(landscape);
+    ADD_THEME(portrait);
+    return i;
+}
+
+void multirom_ui_free_themes(multirom_themes_info *i)
+{
+    list_clear(&i->themes, NULL);
+    free(i->data);
+    free(i);
+}
+
+multirom_theme *multirom_ui_select_theme(multirom_themes_info *i, int w, int h)
+{
+    if(i->themes == NULL)
+        return NULL;
+
+    multirom_theme *universal = NULL;
+    const int uni_type = (w > h) ? TH_LANDSCAPE : TH_PORTRAIT;
+
+    multirom_theme **itr;
+    for(itr = i->themes; *itr; ++itr)
+    {
+        if((*itr)->width == w && (*itr)->height == h)
+            return *itr;
+
+        if((*itr)->width == uni_type)
+            universal = *itr;
+    }
+
+    if(universal)
+        INFO("Using universal theme (%d)\n", uni_type);
+
+    return universal;
+}
diff --git a/multirom_ui_themes.h b/multirom_ui_themes.h
index 8a2dbe3..24fd836 100755
--- a/multirom_ui_themes.h
+++ b/multirom_ui_themes.h
@@ -1,86 +1,86 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MULTIROM_UI_P_H
-#define MULTIROM_UI_P_H
-
-#include "lib/framebuffer.h"
-#include "lib/button.h"
-#include "lib/progressdots.h"
-#include "lib/listview.h"
-#include "lib/tabview.h"
-#include "multirom_ui.h"
-
-// universal themes has these as width and height,
-// instead of real resolution
-#define TH_PORTRAIT  (-1)
-#define TH_LANDSCAPE (-2)
-
-typedef struct
-{
-    listview *list;
-    button **buttons;
-    void **ui_elements;
-    fb_text *title_text;
-    fb_text *usb_text;
-    button *boot_btn;
-    progdots *usb_prog;
-} tab_data_roms;
-
-typedef struct
-{
-    button **buttons;
-    void **ui_elements;
-} tab_data_misc;
-
-typedef struct
-{
-    fb_text *tab_texts[TAB_COUNT];
-    fb_rect *selected_tab_rect;
-    fb_rect *selected_rect[TAB_COUNT-1];
-    button *tab_btns[TAB_COUNT];
-    tabview *tabs;
-    int selected_tab;
-    void *tab_data[TAB_COUNT];
-} multirom_theme_data;
-
-struct multirom_theme
-{
-    int16_t width;
-    int16_t height;
-
-    void (*destroy)(multirom_theme_data *t);
-    void (*init_header)(multirom_theme_data *t);
-    void (*header_set_tab_selector_pos)(multirom_theme_data *t, float pos);
-    void (*tab_rom_init)(multirom_theme_data *t, tab_data_roms *d, int tab_type);
-    void (*tab_misc_init)(multirom_theme_data *t, tab_data_misc *d, int color_scheme);
-    int (*get_tab_width)(multirom_theme_data *t);
-    int (*get_tab_height)(multirom_theme_data *t);
-};
-typedef struct multirom_theme multirom_theme;
-
-typedef struct
-{
-    multirom_theme **themes;
-    multirom_theme_data *data;
-} multirom_themes_info;
-
-multirom_themes_info *multirom_ui_init_themes(void);
-void multirom_ui_free_themes(multirom_themes_info *info);
-multirom_theme *multirom_ui_select_theme(multirom_themes_info *i, int w, int h);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MULTIROM_UI_P_H
+#define MULTIROM_UI_P_H
+
+#include "lib/framebuffer.h"
+#include "lib/button.h"
+#include "lib/progressdots.h"
+#include "lib/listview.h"
+#include "lib/tabview.h"
+#include "multirom_ui.h"
+
+// universal themes has these as width and height,
+// instead of real resolution
+#define TH_PORTRAIT  (-1)
+#define TH_LANDSCAPE (-2)
+
+typedef struct
+{
+    listview *list;
+    button **buttons;
+    void **ui_elements;
+    fb_text *title_text;
+    fb_text *usb_text;
+    button *boot_btn;
+    progdots *usb_prog;
+} tab_data_roms;
+
+typedef struct
+{
+    button **buttons;
+    void **ui_elements;
+} tab_data_misc;
+
+typedef struct
+{
+    fb_text *tab_texts[TAB_COUNT];
+    fb_rect *selected_tab_rect;
+    fb_rect *selected_rect[TAB_COUNT-1];
+    button *tab_btns[TAB_COUNT];
+    tabview *tabs;
+    int selected_tab;
+    void *tab_data[TAB_COUNT];
+} multirom_theme_data;
+
+struct multirom_theme
+{
+    int16_t width;
+    int16_t height;
+
+    void (*destroy)(multirom_theme_data *t);
+    void (*init_header)(multirom_theme_data *t);
+    void (*header_set_tab_selector_pos)(multirom_theme_data *t, float pos);
+    void (*tab_rom_init)(multirom_theme_data *t, tab_data_roms *d, int tab_type);
+    void (*tab_misc_init)(multirom_theme_data *t, tab_data_misc *d, int color_scheme);
+    int (*get_tab_width)(multirom_theme_data *t);
+    int (*get_tab_height)(multirom_theme_data *t);
+};
+typedef struct multirom_theme multirom_theme;
+
+typedef struct
+{
+    multirom_theme **themes;
+    multirom_theme_data *data;
+} multirom_themes_info;
+
+multirom_themes_info *multirom_ui_init_themes(void);
+void multirom_ui_free_themes(multirom_themes_info *info);
+multirom_theme *multirom_ui_select_theme(multirom_themes_info *i, int w, int h);
+
+#endif
diff --git a/pong.c b/pong.c
index 892c41d..745e82d 100755
--- a/pong.c
+++ b/pong.c
@@ -1,344 +1,344 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdint.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <time.h>
-#include <math.h>
-#include <stdio.h>
-
-#include <string.h>
-#include <malloc.h>
-
-#include "lib/framebuffer.h"
-#include "lib/input.h"
-#include "pong.h"
-#include "lib/util.h"
-#include "lib/containers.h"
-
-#define SCORE_SPACE (75*DPI_MUL)
-#define L 0
-#define R 1
-
-#define PADDLE_W (150*DPI_MUL)
-#define PADDLE_H (60*DPI_MUL)
-#define PADDLE_REF ((PADDLE_H/3)*2)
-#define PADDLE_Y (20*DPI_MUL)
-
-#define BALL_W (25*DPI_MUL)
-#define DEFAULT_BALL_SPEED (10*DPI_MUL)
-#define BALL_SPEED_MOD ((PADDLE_W/2)/ball_speed)
-
-#define COMPUTER L
-#define COMPUTER_SPEED (10*DPI_MUL)
-
-static fb_text *score[2] = { NULL, NULL };
-static fb_rect *paddles[2] = { NULL, NULL };
-static fb_rect *ball = NULL;
-static int paddle_last_x[2] = { -1, -1 };
-static int paddle_touch_id[2] = { -1, -1 };
-static int score_val[2];
-static int ball_speed = DEFAULT_BALL_SPEED;
-static int enable_computer = 1;
-
-typedef struct
-{
-    int x;
-    int y;
-    int collision;
-} ball_step;
-
-enum
-{
-    COL_NONE    = 0,
-    COL_LEFT    = 1,
-    COL_RIGHT   = 2,
-    COL_TOP     = 3,
-    COL_BOTTOM  = 4,
-};
-
-static ball_step **movement_steps = NULL;
-static float ball_speed_x = 0;
-static float ball_speed_y = 0;
-
-static float ai_last_speed = -1000;
-static int ai_hit_pos = 0;
-
-void pong(void)
-{
-    enable_computer = 1;
-    paddle_touch_id[L] = -1;
-    paddle_touch_id[R] = -1;
-
-    score_val[L] = 0;
-    score_val[R] = 0;
-
-    fb_set_background(BLACK);
-
-    fb_text_proto *p = fb_text_create(0, 0, GRAYISH, SIZE_SMALL, "Press power button to go back");
-    p->style = STYLE_ITALIC;
-    fb_text *help = fb_text_finalize(p);
-    help->y = fb_height/2 - help->h*1.5;
-    center_text(help, 0, -1, fb_width, -1);
-
-    // middle line
-    fb_add_rect(0, fb_height/2 - 1, fb_width, 1, WHITE);
-
-    score[L] = fb_add_text(0, 0, WHITE, SIZE_EXTRA, "0");
-    score[L]->y = fb_height/2 - score[L]->h - 20*DPI_MUL;
-    score[R] = fb_add_text(0, fb_height/2 + 20*DPI_MUL, WHITE, SIZE_EXTRA, "0");
-
-    paddles[L] = fb_add_rect(100, PADDLE_Y, PADDLE_W, PADDLE_H, WHITE);
-    paddles[R] = fb_add_rect(100, fb_height-PADDLE_Y-PADDLE_H, PADDLE_W, PADDLE_H, WHITE);
-
-    ball = fb_add_rect(0, 0, BALL_W, BALL_W, WHITE);
-
-    pong_spawn_ball(rand()%2);
-    pong_calc_movement();
-
-    add_touch_handler(&pong_touch_handler, NULL);
-
-    int step = 0;
-    volatile int run = 1;
-    while(run)
-    {
-        switch(get_last_key())
-        {
-            case KEY_POWER:
-                run = 0;
-                break;
-            case KEY_VOLUMEUP:
-                ball_speed += 5;
-                pong_spawn_ball(rand()%2);
-                pong_calc_movement();
-                step = 0;
-                break;
-            case KEY_VOLUMEDOWN:
-                if(ball_speed > 5)
-                    ball_speed -= 5;
-                pong_spawn_ball(rand()%2);
-                pong_calc_movement();
-                step = 0;
-                break;
-        }
-
-        step = pong_do_movement(step);
-
-        fb_request_draw();
-        usleep(16000);
-    }
-
-    rm_touch_handler(&pong_touch_handler, NULL);
-
-    list_clear(&movement_steps, &free);
-}
-
-int pong_do_movement(int step)
-{
-    if(!movement_steps[step])
-    {
-        pong_calc_movement();
-        return 0;
-    }
-
-    int col = movement_steps[step]->collision;
-    if(col == COL_NONE || col == COL_LEFT || col == COL_RIGHT)
-    {
-        ball->x = movement_steps[step]->x;
-        ball->y = movement_steps[step]->y;
-        if(enable_computer)
-            pong_handle_ai();
-    }
-
-    switch(col)
-    {
-        case COL_NONE:
-            return step+1;
-        case COL_TOP:
-        case COL_BOTTOM:
-            ball_speed_x = -ball_speed_x;
-            break;
-        case COL_LEFT:
-        case COL_RIGHT:
-        {
-            int s = col - 1;
-            if(ball->x+BALL_W >= paddles[s]->x && ball->x <= paddles[s]->x+PADDLE_W)
-            {
-                // Increase X speed according to distance from center of paddle.
-                ball_speed_x = (float)((ball->x + BALL_W/2) - (paddles[s]->x + PADDLE_W/2))/BALL_SPEED_MOD;
-                ball_speed_y = -ball_speed_y;
-            }
-            else
-            {
-                pong_add_score(!s);
-                for(col = 0; col < 1000; col += 16)
-                {
-                    fb_request_draw();
-                    usleep(16000);
-                }
-                pong_spawn_ball(s);
-            }
-            break;
-        }
-    }
-
-    pong_calc_movement();
-    return 0;
-}
-
-int pong_touch_handler(touch_event *ev, UNUSED void *data)
-{
-    int i = 0;
-    for(; i < 2; ++i)
-    {
-        if (paddle_touch_id[i] == -1 && (ev->changed & TCHNG_ADDED) &&
-            in_rect(ev->x, ev->y, paddles[i]->x, paddles[i]->y, paddles[i]->w, paddles[i]->h))
-        {
-            paddle_touch_id[i] = ev->id;
-            paddle_last_x[i] = ev->x;
-            if(i == L)
-                enable_computer = 0;
-            return 0;
-        }
-
-        if(ev->id != paddle_touch_id[i])
-            continue;
-
-        if(ev->changed & TCHNG_REMOVED)
-        {
-            paddle_touch_id[i] = -1;
-            return 0;
-        }
-
-        int newX = paddles[i]->x + (ev->x - paddle_last_x[i]);
-        paddle_last_x[i] = ev->x;
-
-        if(newX > 0 && newX < (int)fb_width-PADDLE_W)
-            paddles[i]->x = newX;
-        return 0;
-    }
-    return -1;
-}
-
-void pong_spawn_ball(int side)
-{
-    float angle;
-    if(side == L)
-        angle = 6.28319 - (float)(rand()%1570)/1000.f - 0.785398;
-    else
-        angle = (float)(rand()%1570)/1000.f + 0.785398;
-
-    ball_speed_x = cos(angle)*ball_speed;
-    ball_speed_y = sin(angle)*ball_speed;
-
-    ball->x = rand()%(int)(fb_width-BALL_W);
-    ball->y = fb_height/2 - BALL_W/2;
-}
-
-void pong_calc_movement(void)
-{
-    list_clear(&movement_steps, &free);
-
-    ball_step *step = NULL;
-    float x = ball->x;
-    float y = ball->y;
-
-    if(y < PADDLE_Y+PADDLE_H)
-        y = PADDLE_Y+PADDLE_H;
-    else if(y > fb_height-PADDLE_Y-PADDLE_H-BALL_W)
-        y = fb_height-PADDLE_Y-PADDLE_H-BALL_W;
-
-    if(x < 0)
-        x = 0;
-    else if(x > fb_width-BALL_W)
-        x = fb_width-BALL_W;
-
-    while(!step || step->collision == COL_NONE)
-    {
-        x += ball_speed_x;
-        y += ball_speed_y;
-
-        step = malloc(sizeof(ball_step));
-        step->x = x;
-        step->y = y;
-        step->collision = pong_get_collision(x, y);
-        list_add(&movement_steps, step);
-    }
-}
-
-int pong_get_collision(int x, int y)
-{
-    if(y < PADDLE_Y+PADDLE_REF)
-        return COL_LEFT;
-    if(y > (int)fb_height-PADDLE_Y-PADDLE_REF-BALL_W)
-        return COL_RIGHT;
-
-    if(x < 0)
-        return COL_BOTTOM;
-    if(x > (int)fb_width-BALL_W)
-        return COL_TOP;
-
-    return COL_NONE;
-}
-
-void pong_add_score(int side)
-{
-    char buff[8];
-    snprintf(buff, sizeof(buff), "%d", ++score_val[side]);
-    fb_text_set_content(score[side], buff);
-}
-
-void pong_handle_ai(void)
-{
-    int ball_center = (ball->x + BALL_W/2);
-
-    if(ai_last_speed != ball_speed_x)
-    {
-        ai_hit_pos = rand()%3;
-        ai_last_speed = ball_speed_x;
-    }
-
-    int computer_x = 0;
-    switch(ai_hit_pos)
-    {
-        case 0:
-            computer_x = paddles[COMPUTER]->x + PADDLE_W/2;
-            break;
-        case 1:
-            computer_x = paddles[COMPUTER]->x;
-            break;
-        case 2:
-            computer_x = paddles[COMPUTER]->x + PADDLE_W;
-            break;
-    }
-
-    int move_dist = abs(computer_x - ball_center);
-    if(move_dist > COMPUTER_SPEED)
-        move_dist = COMPUTER_SPEED;
-
-    if(ball_center > computer_x)
-    {
-        if(paddles[COMPUTER]->x + PADDLE_W + COMPUTER_SPEED <= (int)fb_width)
-            paddles[COMPUTER]->x += move_dist;
-    }
-    else
-    {
-        if(paddles[COMPUTER]->x - COMPUTER_SPEED >= 0)
-            paddles[COMPUTER]->x -= move_dist;
-    }
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdint.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <time.h>
+#include <math.h>
+#include <stdio.h>
+
+#include <string.h>
+#include <malloc.h>
+
+#include "lib/framebuffer.h"
+#include "lib/input.h"
+#include "pong.h"
+#include "lib/util.h"
+#include "lib/containers.h"
+
+#define SCORE_SPACE (75*DPI_MUL)
+#define L 0
+#define R 1
+
+#define PADDLE_W (150*DPI_MUL)
+#define PADDLE_H (60*DPI_MUL)
+#define PADDLE_REF ((PADDLE_H/3)*2)
+#define PADDLE_Y (20*DPI_MUL)
+
+#define BALL_W (25*DPI_MUL)
+#define DEFAULT_BALL_SPEED (10*DPI_MUL)
+#define BALL_SPEED_MOD ((PADDLE_W/2)/ball_speed)
+
+#define COMPUTER L
+#define COMPUTER_SPEED (10*DPI_MUL)
+
+static fb_text *score[2] = { NULL, NULL };
+static fb_rect *paddles[2] = { NULL, NULL };
+static fb_rect *ball = NULL;
+static int paddle_last_x[2] = { -1, -1 };
+static int paddle_touch_id[2] = { -1, -1 };
+static int score_val[2];
+static int ball_speed = DEFAULT_BALL_SPEED;
+static int enable_computer = 1;
+
+typedef struct
+{
+    int x;
+    int y;
+    int collision;
+} ball_step;
+
+enum
+{
+    COL_NONE    = 0,
+    COL_LEFT    = 1,
+    COL_RIGHT   = 2,
+    COL_TOP     = 3,
+    COL_BOTTOM  = 4,
+};
+
+static ball_step **movement_steps = NULL;
+static float ball_speed_x = 0;
+static float ball_speed_y = 0;
+
+static float ai_last_speed = -1000;
+static int ai_hit_pos = 0;
+
+void pong(void)
+{
+    enable_computer = 1;
+    paddle_touch_id[L] = -1;
+    paddle_touch_id[R] = -1;
+
+    score_val[L] = 0;
+    score_val[R] = 0;
+
+    fb_set_background(BLACK);
+
+    fb_text_proto *p = fb_text_create(0, 0, GRAYISH, SIZE_SMALL, "Press power button to go back");
+    p->style = STYLE_ITALIC;
+    fb_text *help = fb_text_finalize(p);
+    help->y = fb_height/2 - help->h*1.5;
+    center_text(help, 0, -1, fb_width, -1);
+
+    // middle line
+    fb_add_rect(0, fb_height/2 - 1, fb_width, 1, WHITE);
+
+    score[L] = fb_add_text(0, 0, WHITE, SIZE_EXTRA, "0");
+    score[L]->y = fb_height/2 - score[L]->h - 20*DPI_MUL;
+    score[R] = fb_add_text(0, fb_height/2 + 20*DPI_MUL, WHITE, SIZE_EXTRA, "0");
+
+    paddles[L] = fb_add_rect(100, PADDLE_Y, PADDLE_W, PADDLE_H, WHITE);
+    paddles[R] = fb_add_rect(100, fb_height-PADDLE_Y-PADDLE_H, PADDLE_W, PADDLE_H, WHITE);
+
+    ball = fb_add_rect(0, 0, BALL_W, BALL_W, WHITE);
+
+    pong_spawn_ball(rand()%2);
+    pong_calc_movement();
+
+    add_touch_handler(&pong_touch_handler, NULL);
+
+    int step = 0;
+    volatile int run = 1;
+    while(run)
+    {
+        switch(get_last_key())
+        {
+            case KEY_POWER:
+                run = 0;
+                break;
+            case KEY_VOLUMEUP:
+                ball_speed += 5;
+                pong_spawn_ball(rand()%2);
+                pong_calc_movement();
+                step = 0;
+                break;
+            case KEY_VOLUMEDOWN:
+                if(ball_speed > 5)
+                    ball_speed -= 5;
+                pong_spawn_ball(rand()%2);
+                pong_calc_movement();
+                step = 0;
+                break;
+        }
+
+        step = pong_do_movement(step);
+
+        fb_request_draw();
+        usleep(16000);
+    }
+
+    rm_touch_handler(&pong_touch_handler, NULL);
+
+    list_clear(&movement_steps, &free);
+}
+
+int pong_do_movement(int step)
+{
+    if(!movement_steps[step])
+    {
+        pong_calc_movement();
+        return 0;
+    }
+
+    int col = movement_steps[step]->collision;
+    if(col == COL_NONE || col == COL_LEFT || col == COL_RIGHT)
+    {
+        ball->x = movement_steps[step]->x;
+        ball->y = movement_steps[step]->y;
+        if(enable_computer)
+            pong_handle_ai();
+    }
+
+    switch(col)
+    {
+        case COL_NONE:
+            return step+1;
+        case COL_TOP:
+        case COL_BOTTOM:
+            ball_speed_x = -ball_speed_x;
+            break;
+        case COL_LEFT:
+        case COL_RIGHT:
+        {
+            int s = col - 1;
+            if(ball->x+BALL_W >= paddles[s]->x && ball->x <= paddles[s]->x+PADDLE_W)
+            {
+                // Increase X speed according to distance from center of paddle.
+                ball_speed_x = (float)((ball->x + BALL_W/2) - (paddles[s]->x + PADDLE_W/2))/BALL_SPEED_MOD;
+                ball_speed_y = -ball_speed_y;
+            }
+            else
+            {
+                pong_add_score(!s);
+                for(col = 0; col < 1000; col += 16)
+                {
+                    fb_request_draw();
+                    usleep(16000);
+                }
+                pong_spawn_ball(s);
+            }
+            break;
+        }
+    }
+
+    pong_calc_movement();
+    return 0;
+}
+
+int pong_touch_handler(touch_event *ev, UNUSED void *data)
+{
+    int i = 0;
+    for(; i < 2; ++i)
+    {
+        if (paddle_touch_id[i] == -1 && (ev->changed & TCHNG_ADDED) &&
+            in_rect(ev->x, ev->y, paddles[i]->x, paddles[i]->y, paddles[i]->w, paddles[i]->h))
+        {
+            paddle_touch_id[i] = ev->id;
+            paddle_last_x[i] = ev->x;
+            if(i == L)
+                enable_computer = 0;
+            return 0;
+        }
+
+        if(ev->id != paddle_touch_id[i])
+            continue;
+
+        if(ev->changed & TCHNG_REMOVED)
+        {
+            paddle_touch_id[i] = -1;
+            return 0;
+        }
+
+        int newX = paddles[i]->x + (ev->x - paddle_last_x[i]);
+        paddle_last_x[i] = ev->x;
+
+        if(newX > 0 && newX < (int)fb_width-PADDLE_W)
+            paddles[i]->x = newX;
+        return 0;
+    }
+    return -1;
+}
+
+void pong_spawn_ball(int side)
+{
+    float angle;
+    if(side == L)
+        angle = 6.28319 - (float)(rand()%1570)/1000.f - 0.785398;
+    else
+        angle = (float)(rand()%1570)/1000.f + 0.785398;
+
+    ball_speed_x = cos(angle)*ball_speed;
+    ball_speed_y = sin(angle)*ball_speed;
+
+    ball->x = rand()%(int)(fb_width-BALL_W);
+    ball->y = fb_height/2 - BALL_W/2;
+}
+
+void pong_calc_movement(void)
+{
+    list_clear(&movement_steps, &free);
+
+    ball_step *step = NULL;
+    float x = ball->x;
+    float y = ball->y;
+
+    if(y < PADDLE_Y+PADDLE_H)
+        y = PADDLE_Y+PADDLE_H;
+    else if(y > fb_height-PADDLE_Y-PADDLE_H-BALL_W)
+        y = fb_height-PADDLE_Y-PADDLE_H-BALL_W;
+
+    if(x < 0)
+        x = 0;
+    else if(x > fb_width-BALL_W)
+        x = fb_width-BALL_W;
+
+    while(!step || step->collision == COL_NONE)
+    {
+        x += ball_speed_x;
+        y += ball_speed_y;
+
+        step = malloc(sizeof(ball_step));
+        step->x = x;
+        step->y = y;
+        step->collision = pong_get_collision(x, y);
+        list_add(&movement_steps, step);
+    }
+}
+
+int pong_get_collision(int x, int y)
+{
+    if(y < PADDLE_Y+PADDLE_REF)
+        return COL_LEFT;
+    if(y > (int)fb_height-PADDLE_Y-PADDLE_REF-BALL_W)
+        return COL_RIGHT;
+
+    if(x < 0)
+        return COL_BOTTOM;
+    if(x > (int)fb_width-BALL_W)
+        return COL_TOP;
+
+    return COL_NONE;
+}
+
+void pong_add_score(int side)
+{
+    char buff[8];
+    snprintf(buff, sizeof(buff), "%d", ++score_val[side]);
+    fb_text_set_content(score[side], buff);
+}
+
+void pong_handle_ai(void)
+{
+    int ball_center = (ball->x + BALL_W/2);
+
+    if(ai_last_speed != ball_speed_x)
+    {
+        ai_hit_pos = rand()%3;
+        ai_last_speed = ball_speed_x;
+    }
+
+    int computer_x = 0;
+    switch(ai_hit_pos)
+    {
+        case 0:
+            computer_x = paddles[COMPUTER]->x + PADDLE_W/2;
+            break;
+        case 1:
+            computer_x = paddles[COMPUTER]->x;
+            break;
+        case 2:
+            computer_x = paddles[COMPUTER]->x + PADDLE_W;
+            break;
+    }
+
+    int move_dist = abs(computer_x - ball_center);
+    if(move_dist > COMPUTER_SPEED)
+        move_dist = COMPUTER_SPEED;
+
+    if(ball_center > computer_x)
+    {
+        if(paddles[COMPUTER]->x + PADDLE_W + COMPUTER_SPEED <= (int)fb_width)
+            paddles[COMPUTER]->x += move_dist;
+    }
+    else
+    {
+        if(paddles[COMPUTER]->x - COMPUTER_SPEED >= 0)
+            paddles[COMPUTER]->x -= move_dist;
+    }
+}
diff --git a/pong.h b/pong.h
index f235f2e..2a3233e 100755
--- a/pong.h
+++ b/pong.h
@@ -1,32 +1,32 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef PONG_H
-#define PONG_H
-
-#include "lib/input.h"
-
-void pong(void);
-int pong_touch_handler(touch_event *ev, void *data);
-void pong_spawn_ball(int side);
-void pong_calc_movement(void);
-void pong_add_score(int side);
-void pong_handle_ai(void);
-int pong_do_movement(int step);
-int pong_get_collision(int x, int y);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef PONG_H
+#define PONG_H
+
+#include "lib/input.h"
+
+void pong(void);
+int pong_touch_handler(touch_event *ev, void *data);
+void pong_spawn_ball(int side);
+void pong_calc_movement(void);
+void pong_add_score(int side);
+void pong_handle_ai(void);
+int pong_do_movement(int step);
+int pong_get_collision(int x, int y);
+
+#endif
diff --git a/rcadditions.c b/rcadditions.c
index 34b5299..b344eb6 100755
--- a/rcadditions.c
+++ b/rcadditions.c
@@ -1,125 +1,125 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <string.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/stat.h>
-
-#include <malloc.h>
-
-#include "lib/log.h"
-#include "rcadditions.h"
-
-static void append_string_buffer(char **buf, const char *what) {
-    size_t old_len = 0;
-    if(*buf)
-        old_len += strlen(*buf);
-
-    *buf = realloc(*buf, old_len + strlen(what) + 1);
-    (*buf)[old_len] = 0;
-    strcat(*buf, what);
-}
-
-void rcadditions_append_trigger(struct rcadditions *r, const char *trigger, const char *what) {
-    if(r->triggers == NULL)
-        r->triggers = map_create();
-
-    char **ref = (char**)map_get_ref(r->triggers, trigger);
-    if(ref == NULL)
-        map_add_not_exist(r->triggers, trigger, strdup(what));
-    else
-        append_string_buffer(ref, what);
-}
-
-void rcadditions_append_file(struct rcadditions *r, const char *what) {
-    append_string_buffer(&r->eof_append, what);
-}
-
-void rcadditions_append_contexts(struct rcadditions *r, const char *what) {
-    append_string_buffer(&r->file_contexts_append, what);
-}
-
-void rcadditions_free(struct rcadditions *r)
-{
-    free(r->eof_append);
-    r->eof_append = NULL;
-
-    free(r->file_contexts_append);
-    r->file_contexts_append = NULL;
-
-    map_destroy(r->triggers, &free);
-    r->triggers = NULL;
-}
-
-void rcadditions_write_to_files(struct rcadditions *r)
-{
-    if(r->eof_append || r->triggers)
-    {
-        FILE *f = fopen("/init.multirom.rc", "we");
-        if(!f)
-        {
-            ERROR("Failed to create init.multirom.rc: %s\n", strerror(errno));
-            return;
-        }
-
-        fputs("# This file is autogenerated by MultiROM during boot\n\n", f);
-
-        if(r->triggers)
-        {
-            size_t i = 0;
-            for(; i < r->triggers->size; ++i)
-            {
-                fprintf(f, "on %s\n", r->triggers->keys[i]);
-                fputs((char*)r->triggers->values[i], f);
-                fputc('\n', f);
-            }
-        }
-
-        if(r->eof_append)
-        {
-            fputc('\n', f);
-            fputs(r->eof_append, f);
-        }
-        fclose(f);
-
-        chmod("/init.multirom.rc", 0750);
-
-        f = fopen("/init.rc", "ae");
-        if(!f)
-        {
-            ERROR("Failed to open init.rc: %s\n", strerror(errno));
-            return;
-        }
-        fputs("\n# Added by MultiROM\nimport /init.multirom.rc\n", f);
-        fclose(f);
-    }
-
-    if(r->file_contexts_append)
-    {
-        FILE *f = fopen("/file_contexts", "ae");
-        if(!f)
-        {
-            ERROR("Failed to open file_contexts: %s\n", strerror(errno));
-            return;
-        }
-        fputs("\n# Added by multirom during boot\n", f);
-        fputs(r->file_contexts_append, f);
-        fclose(f);
-    }
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+
+#include <malloc.h>
+
+#include "lib/log.h"
+#include "rcadditions.h"
+
+static void append_string_buffer(char **buf, const char *what) {
+    size_t old_len = 0;
+    if(*buf)
+        old_len += strlen(*buf);
+
+    *buf = realloc(*buf, old_len + strlen(what) + 1);
+    (*buf)[old_len] = 0;
+    strcat(*buf, what);
+}
+
+void rcadditions_append_trigger(struct rcadditions *r, const char *trigger, const char *what) {
+    if(r->triggers == NULL)
+        r->triggers = map_create();
+
+    char **ref = (char**)map_get_ref(r->triggers, trigger);
+    if(ref == NULL)
+        map_add_not_exist(r->triggers, trigger, strdup(what));
+    else
+        append_string_buffer(ref, what);
+}
+
+void rcadditions_append_file(struct rcadditions *r, const char *what) {
+    append_string_buffer(&r->eof_append, what);
+}
+
+void rcadditions_append_contexts(struct rcadditions *r, const char *what) {
+    append_string_buffer(&r->file_contexts_append, what);
+}
+
+void rcadditions_free(struct rcadditions *r)
+{
+    free(r->eof_append);
+    r->eof_append = NULL;
+
+    free(r->file_contexts_append);
+    r->file_contexts_append = NULL;
+
+    map_destroy(r->triggers, &free);
+    r->triggers = NULL;
+}
+
+void rcadditions_write_to_files(struct rcadditions *r)
+{
+    if(r->eof_append || r->triggers)
+    {
+        FILE *f = fopen("/init.multirom.rc", "we");
+        if(!f)
+        {
+            ERROR("Failed to create init.multirom.rc: %s\n", strerror(errno));
+            return;
+        }
+
+        fputs("# This file is autogenerated by MultiROM during boot\n\n", f);
+
+        if(r->triggers)
+        {
+            size_t i = 0;
+            for(; i < r->triggers->size; ++i)
+            {
+                fprintf(f, "on %s\n", r->triggers->keys[i]);
+                fputs((char*)r->triggers->values[i], f);
+                fputc('\n', f);
+            }
+        }
+
+        if(r->eof_append)
+        {
+            fputc('\n', f);
+            fputs(r->eof_append, f);
+        }
+        fclose(f);
+
+        chmod("/init.multirom.rc", 0750);
+
+        f = fopen("/init.rc", "ae");
+        if(!f)
+        {
+            ERROR("Failed to open init.rc: %s\n", strerror(errno));
+            return;
+        }
+        fputs("\n# Added by MultiROM\nimport /init.multirom.rc\n", f);
+        fclose(f);
+    }
+
+    if(r->file_contexts_append)
+    {
+        FILE *f = fopen("/file_contexts", "ae");
+        if(!f)
+        {
+            ERROR("Failed to open file_contexts: %s\n", strerror(errno));
+            return;
+        }
+        fputs("\n# Added by multirom during boot\n", f);
+        fputs(r->file_contexts_append, f);
+        fclose(f);
+    }
+}
diff --git a/rcadditions.h b/rcadditions.h
index 87577da..7304106 100755
--- a/rcadditions.h
+++ b/rcadditions.h
@@ -1,36 +1,36 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef RCADDITIONS_H
-#define RCADDITIONS_H
-
-#include "lib/containers.h"
-
-struct rcadditions
-{
-    map *triggers;
-    char *eof_append;
-    char *file_contexts_append;
-};
-
-void rcadditions_append_trigger(struct rcadditions *r, const char *trigger, const char *what);
-void rcadditions_append_file(struct rcadditions *r, const char *what);
-void rcadditions_append_contexts(struct rcadditions *r, const char *what);
-void rcadditions_free(struct rcadditions *r);
-void rcadditions_write_to_files(struct rcadditions *r);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef RCADDITIONS_H
+#define RCADDITIONS_H
+
+#include "lib/containers.h"
+
+struct rcadditions
+{
+    map *triggers;
+    char *eof_append;
+    char *file_contexts_append;
+};
+
+void rcadditions_append_trigger(struct rcadditions *r, const char *trigger, const char *what);
+void rcadditions_append_file(struct rcadditions *r, const char *what);
+void rcadditions_append_contexts(struct rcadditions *r, const char *what);
+void rcadditions_free(struct rcadditions *r);
+void rcadditions_write_to_files(struct rcadditions *r);
+
+#endif
diff --git a/rom_info.txt b/rom_info.txt
index 9d61a2d..92784ab 100755
--- a/rom_info.txt
+++ b/rom_info.txt
@@ -1,44 +1,44 @@
-# This file contains info about ROMs capabilites and boot process.
-# It should be placed in ROM's folder (eg. /media/multirom/roms/*rom_name*)
-# and must be named "rom_info.txt".
-# Make sure you got the syntax correct, as the parser is probably pretty
-# dumb. Lines with comments must start with #. Beware the whitespaces.
-# If you need to use " character in string, just use it, no need to escape it
-# MultiROM searches for first and last " on the line.
-# These comments should not be deleted.
-
-# So far, the only supported ROM type for these files is kexec-based linux
-type="kexec"
-
-# Paths to root of the ROM.
-# Both image and folder can be specified at one time, MultiROM will use 
-# the one which it can find. If both are present, folder is used.
-# Must _not_ contain spaces.
-# Path is from root of the root partition, but you will usually want
-# to use following alias:
-# - %m - ROM's folder (eg. /media/multirom/roms/*rom_name*)
-root_dir="%m/root"
-root_img="%m/root.img"
-root_img_fs="ext4"
-
-# Path to kernel and initrd. Kernel path _must_ be specified.
-# Paths are relative to the folder in which is this file
-# Those can be outside the root folder/image, or use %r if it is in there:
-# kernel_path="%r/boot/vmlinuz"
-# If ROM is in images, it will mount the image and load it from there.
-# You can use  * _at the end of the filename_ as wildcard character.
-kernel_path="%r/boot/vmlinuz"
-initrd_path="%r/boot/initrd.img"
-
-# Set up the cmdline
-# img_cmdline and dir_cmdline are appended to base_cmdline.
-# Several aliases are used:
-#  - %b - base command line from bootloader. You want this as first thing in cmdline.
-#  - %d - root device. is either "UUID=..." (USB drive) or "/dev/mmcblk0p9" or "/dev/mmcblk0p10"
-#  - %r - root fs type
-#  - %s - root directory, from root of the root device
-#  - %i - root image, from root of the root device
-#  - %f - fs of the root image
-base_cmdline="%b root=%d rootfstype=%r rw console=tty0 access=m2 quiet splash rootflags=defaults,noatime,nodiratime"
-img_cmdline="loop=%i loopfstype=%f"
-dir_cmdline="rootsubdir=%s"
+# This file contains info about ROMs capabilites and boot process.
+# It should be placed in ROM's folder (eg. /media/multirom/roms/*rom_name*)
+# and must be named "rom_info.txt".
+# Make sure you got the syntax correct, as the parser is probably pretty
+# dumb. Lines with comments must start with #. Beware the whitespaces.
+# If you need to use " character in string, just use it, no need to escape it
+# MultiROM searches for first and last " on the line.
+# These comments should not be deleted.
+
+# So far, the only supported ROM type for these files is kexec-based linux
+type="kexec"
+
+# Paths to root of the ROM.
+# Both image and folder can be specified at one time, MultiROM will use 
+# the one which it can find. If both are present, folder is used.
+# Must _not_ contain spaces.
+# Path is from root of the root partition, but you will usually want
+# to use following alias:
+# - %m - ROM's folder (eg. /media/multirom/roms/*rom_name*)
+root_dir="%m/root"
+root_img="%m/root.img"
+root_img_fs="ext4"
+
+# Path to kernel and initrd. Kernel path _must_ be specified.
+# Paths are relative to the folder in which is this file
+# Those can be outside the root folder/image, or use %r if it is in there:
+# kernel_path="%r/boot/vmlinuz"
+# If ROM is in images, it will mount the image and load it from there.
+# You can use  * _at the end of the filename_ as wildcard character.
+kernel_path="%r/boot/vmlinuz"
+initrd_path="%r/boot/initrd.img"
+
+# Set up the cmdline
+# img_cmdline and dir_cmdline are appended to base_cmdline.
+# Several aliases are used:
+#  - %b - base command line from bootloader. You want this as first thing in cmdline.
+#  - %d - root device. is either "UUID=..." (USB drive) or "/dev/mmcblk0p9" or "/dev/mmcblk0p10"
+#  - %r - root fs type
+#  - %s - root directory, from root of the root device
+#  - %i - root image, from root of the root device
+#  - %f - fs of the root image
+base_cmdline="%b root=%d rootfstype=%r rw console=tty0 access=m2 quiet splash rootflags=defaults,noatime,nodiratime"
+img_cmdline="loop=%i loopfstype=%f"
+dir_cmdline="rootsubdir=%s"
diff --git a/rom_quirks.c b/rom_quirks.c
index ee78982..269e2af 100755
--- a/rom_quirks.c
+++ b/rom_quirks.c
@@ -1,142 +1,142 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <unistd.h>
-#include <stdio.h>
-#include <string.h>
-#include <dirent.h>
-#include <stdlib.h>
-#include <ctype.h>
-#include <sys/types.h>
-
-#include <malloc.h>
-
-#include "rom_quirks.h"
-#include "lib/log.h"
-#include "lib/util.h"
-
-static void workaround_mount_in_sh(const char *path)
-{
-    char line[512];
-    char *tmp_name = NULL;
-    FILE *f_in, *f_out;
-
-    f_in = fopen(path, "re");
-    if(!f_in)
-        return;
-
-    const int size = strlen(path) + 5;
-    tmp_name = malloc(size);
-    snprintf(tmp_name, size, "%s-new", path);
-    f_out = fopen(tmp_name, "we");
-    if(!f_out)
-    {
-        fclose(f_in);
-        free(tmp_name);
-        return;
-    }
-
-    while(fgets(line, sizeof(line), f_in))
-    {
-        if(strstr(line, "mount ") && strstr(line, "/system"))
-            fputc('#', f_out);
-        fputs(line, f_out);
-    }
-
-    fclose(f_in);
-    fclose(f_out);
-    rename(tmp_name, path);
-    free(tmp_name);
-}
-
-static void inject_file_contexts(void)
-{
-    FILE *f;
-    char line[512];
-
-    f = fopen("/file_contexts", "re");
-    if(!f)
-    {
-        ERROR("Failed to open /file_contexts!");
-        return;
-    }
-
-    while(fgets(line, sizeof(line), f))
-    {
-        if(strstartswith(line, "/data/media/multirom"))
-        {
-            INFO("/file_contexts has been already injected.");
-            fclose(f);
-            return;
-        }
-    }
-
-    fclose(f);
-
-    INFO("Injecting /file_contexts\n");
-    f = fopen("/file_contexts", "ae");
-    if(!f)
-    {
-        ERROR("Failed to open /file_contexts for appending!");
-        return;
-    }
-
-    fputs("\n"
-        "# MultiROM folders\n"
-        "/data/media/multirom(/.*)?          <<none>>\n"
-        "/data/media/0/multirom(/.*)?        <<none>>\n"
-        "/realdata/media/multirom(/.*)?      <<none>>\n"
-        "/realdata/media/0/multirom(/.*)?    <<none>>\n"
-        "/mnt/mrom(/.*)?                     <<none>>\n",
-        f);
-    fclose(f);
-}
-
-void rom_quirks_on_initrd_finalized(void)
-{
-    // walk over all _regular_ files in /
-    DIR *d = opendir("/");
-    if(d)
-    {
-        struct dirent *dt;
-        char buff[128];
-        while((dt = readdir(d)))
-        {
-            if(dt->d_type != DT_REG)
-                continue;
-
-            // The Android L and later releases have SELinux
-            // set to "enforcing" and "restorecon_recursive /data" line in init.rc.
-            // Restorecon on /data goes into /data/media/0/multirom/roms/ and changes
-            // context of all secondary ROMs files to that of /data, including the files
-            // in secondary ROMs /system dirs. We need to prevent that.
-            // Right now, we do that by adding entries into /file_contexts that say
-            // MultiROM folders don't have any context
-            if(strcmp(dt->d_name, "file_contexts") == 0)
-                inject_file_contexts();
-
-            // franco.Kernel includes script init.fk.sh which remounts /system as read only
-            // comment out lines with mount and /system in all .sh scripts in /
-            if(strendswith(dt->d_name, ".sh"))
-            {
-                snprintf(buff, sizeof(buff), "/%s", dt->d_name);
-                workaround_mount_in_sh(buff);
-            }
-        }
-        closedir(d);
-    }
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/types.h>
+
+#include <malloc.h>
+
+#include "rom_quirks.h"
+#include "lib/log.h"
+#include "lib/util.h"
+
+static void workaround_mount_in_sh(const char *path)
+{
+    char line[512];
+    char *tmp_name = NULL;
+    FILE *f_in, *f_out;
+
+    f_in = fopen(path, "re");
+    if(!f_in)
+        return;
+
+    const int size = strlen(path) + 5;
+    tmp_name = malloc(size);
+    snprintf(tmp_name, size, "%s-new", path);
+    f_out = fopen(tmp_name, "we");
+    if(!f_out)
+    {
+        fclose(f_in);
+        free(tmp_name);
+        return;
+    }
+
+    while(fgets(line, sizeof(line), f_in))
+    {
+        if(strstr(line, "mount ") && strstr(line, "/system"))
+            fputc('#', f_out);
+        fputs(line, f_out);
+    }
+
+    fclose(f_in);
+    fclose(f_out);
+    rename(tmp_name, path);
+    free(tmp_name);
+}
+
+static void inject_file_contexts(void)
+{
+    FILE *f;
+    char line[512];
+
+    f = fopen("/file_contexts", "re");
+    if(!f)
+    {
+        ERROR("Failed to open /file_contexts!");
+        return;
+    }
+
+    while(fgets(line, sizeof(line), f))
+    {
+        if(strstartswith(line, "/data/media/multirom"))
+        {
+            INFO("/file_contexts has been already injected.");
+            fclose(f);
+            return;
+        }
+    }
+
+    fclose(f);
+
+    INFO("Injecting /file_contexts\n");
+    f = fopen("/file_contexts", "ae");
+    if(!f)
+    {
+        ERROR("Failed to open /file_contexts for appending!");
+        return;
+    }
+
+    fputs("\n"
+        "# MultiROM folders\n"
+        "/data/media/multirom(/.*)?          <<none>>\n"
+        "/data/media/0/multirom(/.*)?        <<none>>\n"
+        "/realdata/media/multirom(/.*)?      <<none>>\n"
+        "/realdata/media/0/multirom(/.*)?    <<none>>\n"
+        "/mnt/mrom(/.*)?                     <<none>>\n",
+        f);
+    fclose(f);
+}
+
+void rom_quirks_on_initrd_finalized(void)
+{
+    // walk over all _regular_ files in /
+    DIR *d = opendir("/");
+    if(d)
+    {
+        struct dirent *dt;
+        char buff[128];
+        while((dt = readdir(d)))
+        {
+            if(dt->d_type != DT_REG)
+                continue;
+
+            // The Android L and later releases have SELinux
+            // set to "enforcing" and "restorecon_recursive /data" line in init.rc.
+            // Restorecon on /data goes into /data/media/0/multirom/roms/ and changes
+            // context of all secondary ROMs files to that of /data, including the files
+            // in secondary ROMs /system dirs. We need to prevent that.
+            // Right now, we do that by adding entries into /file_contexts that say
+            // MultiROM folders don't have any context
+            if(strcmp(dt->d_name, "file_contexts") == 0)
+                inject_file_contexts();
+
+            // franco.Kernel includes script init.fk.sh which remounts /system as read only
+            // comment out lines with mount and /system in all .sh scripts in /
+            if(strendswith(dt->d_name, ".sh"))
+            {
+                snprintf(buff, sizeof(buff), "/%s", dt->d_name);
+                workaround_mount_in_sh(buff);
+            }
+        }
+        closedir(d);
+    }
+}
diff --git a/rom_quirks.h b/rom_quirks.h
index 342e502..820e629 100755
--- a/rom_quirks.h
+++ b/rom_quirks.h
@@ -1,24 +1,24 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ROM_QUIRKS_H
-#define ROM_QUIRKS_H
-
-struct multirom_rom;
-
-void rom_quirks_on_initrd_finalized(void);
-
-#endif
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ROM_QUIRKS_H
+#define ROM_QUIRKS_H
+
+struct multirom_rom;
+
+void rom_quirks_on_initrd_finalized(void);
+
+#endif
diff --git a/trampoline/Android.mk b/trampoline/Android.mk
index 8d12437..85cc771 100755
--- a/trampoline/Android.mk
+++ b/trampoline/Android.mk
@@ -1,54 +1,54 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_C_INCLUDES += $(multirom_local_path) $(multirom_local_path)/lib
-LOCAL_SRC_FILES:= \
-    trampoline.c \
-    devices.c \
-    adb.c \
-
-LOCAL_MODULE:= trampoline
-LOCAL_MODULE_TAGS := eng
-
-LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
-LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
-LOCAL_STATIC_LIBRARIES := libcutils libc libmultirom_static libbootimg
-LOCAL_FORCE_STATIC_EXECUTABLE := true
-
-ifeq ($(MR_INIT_DEVICES),)
-    $(info MR_INIT_DEVICES was not defined in device files!)
-endif
-LOCAL_SRC_FILES += ../../../../$(MR_INIT_DEVICES)
-
-# for adb
-LOCAL_CFLAGS += -DPRODUCT_MODEL="\"$(PRODUCT_MODEL)\"" -DPRODUCT_MANUFACTURER="\"$(PRODUCT_MANUFACTURER)\""
-
-# to find fstab
-LOCAL_CFLAGS += -DTARGET_DEVICE="\"$(TARGET_DEVICE)\""
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-ifneq ($(MR_DEVICE_HOOKS),)
-ifeq ($(MR_DEVICE_HOOKS_VER),)
-    $(info MR_DEVICE_HOOKS is set but MR_DEVICE_HOOKS_VER is not specified!)
-else
-    LOCAL_CFLAGS += -DMR_DEVICE_HOOKS=$(MR_DEVICE_HOOKS_VER)
-    LOCAL_SRC_FILES += ../../../../$(MR_DEVICE_HOOKS)
-endif
-endif
-
-ifeq ($(MR_ENCRYPTION),true)
-    LOCAL_CFLAGS += -DMR_ENCRYPTION
-    LOCAL_SRC_FILES += encryption.c
-
-    # ANCLARK MODIFIED ON 2017-4-7
-    # Add keymaster support
-    ifeq ($(MR_USE_KEYMASTER), true)
-        LOCAL_C_INCLUDES += -DMR_USE_KEYMASTER
-    endif
-
-endif
-
-include $(BUILD_EXECUTABLE)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_C_INCLUDES += $(multirom_local_path) $(multirom_local_path)/lib
+LOCAL_SRC_FILES:= \
+    trampoline.c \
+    devices.c \
+    adb.c \
+
+LOCAL_MODULE:= trampoline
+LOCAL_MODULE_TAGS := eng
+
+LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
+LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
+LOCAL_STATIC_LIBRARIES := libcutils libc libmultirom_static libbootimg
+LOCAL_FORCE_STATIC_EXECUTABLE := true
+
+ifeq ($(MR_INIT_DEVICES),)
+    $(info MR_INIT_DEVICES was not defined in device files!)
+endif
+LOCAL_SRC_FILES += ../../../../$(MR_INIT_DEVICES)
+
+# for adb
+LOCAL_CFLAGS += -DPRODUCT_MODEL="\"$(PRODUCT_MODEL)\"" -DPRODUCT_MANUFACTURER="\"$(PRODUCT_MANUFACTURER)\""
+
+# to find fstab
+LOCAL_CFLAGS += -DTARGET_DEVICE="\"$(TARGET_DEVICE)\""
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+ifneq ($(MR_DEVICE_HOOKS),)
+ifeq ($(MR_DEVICE_HOOKS_VER),)
+    $(info MR_DEVICE_HOOKS is set but MR_DEVICE_HOOKS_VER is not specified!)
+else
+    LOCAL_CFLAGS += -DMR_DEVICE_HOOKS=$(MR_DEVICE_HOOKS_VER)
+    LOCAL_SRC_FILES += ../../../../$(MR_DEVICE_HOOKS)
+endif
+endif
+
+ifeq ($(MR_ENCRYPTION),true)
+    LOCAL_CFLAGS += -DMR_ENCRYPTION
+    LOCAL_SRC_FILES += encryption.c
+
+    # ANCLARK MODIFIED ON 2017-4-7
+    # Add keymaster support
+    ifeq ($(MR_USE_KEYMASTER), true)
+        LOCAL_C_INCLUDES += -DMR_USE_KEYMASTER
+    endif
+
+endif
+
+include $(BUILD_EXECUTABLE)
diff --git a/trampoline/adb.c b/trampoline/adb.c
index 59634cf..700ccc6 100755
--- a/trampoline/adb.c
+++ b/trampoline/adb.c
@@ -1,242 +1,242 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <pthread.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <sys/mount.h>
-#include <sys/klog.h>
-#include <linux/loop.h>
-
-#include <malloc.h>
-
-#include "adb.h"
-#include "../lib/util.h"
-#include "../lib/log.h"
-
-static pthread_t adb_thread;
-static volatile int run_thread = 0;
-static pid_t adb_pid = -1;
-
-static char busybox_path[64] = { 0 };
-static char adbd_path[64] = { 0 };
-
-static char * const ENV[] = {
-    "PATH=/sbin:/bin:/usr/bin:/usr/sbin:/mrom_bin",
-    "LD_LIBRARY_PATH=.:/sbin",
-    "ANDROID_ROOT=/system",
-    "ANDROID_DATA=/data",
-    "EXTERNAL_STORAGE=/sdcard",
-    "ANDROID_PROPERTY_WORKSPACE=8,49152",
-    "SHELL=/mrom_bin/sh",
-
-    NULL
-};
-
-static void *adb_thread_work(void *mrom_path)
-{
-    int enabled = adb_is_enabled((char*)mrom_path);
-    free(mrom_path);
-
-    if(enabled == 0)
-        return NULL;
-
-    adb_init_usb();
-
-    if(adb_init_busybox() < 0)
-        return NULL;
-
-    adb_init_fs();
-
-    chmod(adbd_path, 0755);
-
-    while(run_thread)
-    {
-        adb_pid = fork();
-        if(adb_pid == 0) // child
-        {
-            umask(077);
-            setsid();
-            stdio_to_null();
-            setpgid(0, getpid());
-
-            static char * const cmd[] = { adbd_path, NULL };
-            execve(cmd[0], cmd, ENV);
-            exit(0);
-        }
-        else
-        {
-            int status = 0;
-            waitpid(adb_pid, &status, 0);
-        }
-        usleep(300000);
-    }
-
-    adb_cleanup();
-
-    return NULL;
-}
-
-void adb_init(char *mrom_path)
-{
-    if(run_thread)
-        return;
-
-    sprintf(busybox_path, "%s/busybox", mrom_path);
-    sprintf(adbd_path, "%s/adbd", mrom_path);
-
-    INFO("Starting adbd\n");
-    run_thread = 1;
-    pthread_create(&adb_thread, NULL, adb_thread_work, strdup(mrom_path));
-}
-
-void adb_quit(void)
-{
-    if(!run_thread)
-        return;
-
-    INFO("Stopping adbd\n");
-
-    run_thread = 0;
-
-    if(adb_pid != -1)
-    {
-        kill(adb_pid, 9);
-        adb_pid = -1;
-    }
-
-    pthread_join(adb_thread, NULL);
-}
-
-void adb_init_usb(void)
-{
-    mkdir_with_perms("/dev/usb-ffs", 0770, "shell", "shell");
-    mkdir_with_perms("/dev/usb-ffs/adb", 0770, "shell", "shell");
-    mount("adb", "/dev/usb-ffs/adb", "functionfs", 0, "uid=2000,gid=2000");
-
-    write_file("/sys/class/android_usb/android0/enable", "0");
-
-    char serial[64] = { 0 };
-    adb_get_serial(serial, sizeof(serial));
-
-    // this vid and pid is used in TWRP, CWM and AOSP recovery
-    // for all devices, so I guess it is universal
-    write_file("/sys/class/android_usb/android0/idVendor", "18d1");
-    write_file("/sys/class/android_usb/android0/idProduct", "d001");
-    write_file("/sys/class/android_usb/android0/f_ffs/aliases", "adb");
-    write_file("/sys/class/android_usb/android0/functions", "adb");
-    write_file("/sys/class/android_usb/android0/iManufacturer", PRODUCT_MANUFACTURER);
-    write_file("/sys/class/android_usb/android0/iProduct", PRODUCT_MODEL);
-    write_file("/sys/class/android_usb/android0/iSerial", serial);
-
-    write_file("/sys/class/android_usb/android0/enable", "1");
-    write_file("/sys/devices/platform/android_usb/usb_function_switch", "3");
-}
-
-int adb_init_busybox(void)
-{
-    mkdir("/mrom_bin", 0777);
-
-    copy_file(busybox_path, "/mrom_bin/busybox");
-    chmod("/mrom_bin/busybox", 0755);
-
-    static const char *install_cmd[] = {
-        "/mrom_bin/busybox", "--install", "/mrom_bin/", NULL
-    };
-
-    if(run_cmd((char**)install_cmd) != 0)
-    {
-        ERROR("adb: failed to --install busybox\n");
-        return -1;
-    }
-
-    mkdir("/dev/pts", 0666);
-    if(mount("devpts", "/dev/pts", "devpts", 0, NULL) < 0)
-    {
-        ERROR("Failed to mount devpts: %d (%s)\n", errno, strerror(errno));
-        return -1;
-    }
-
-    return 0;
-}
-
-void adb_init_fs(void)
-{
-    mkdir("/sdcard", 0777);
-    if(strstr(adbd_path, "/realdata/media/0/multirom"))
-        mount("/realdata/media/0/", "/sdcard/", "auto", MS_BIND, "");
-    else
-        mount("/realdata/media/", "/sdcard/", "auto", MS_BIND, "");
-}
-
-void adb_cleanup(void)
-{
-    if(umount("/sdcard") >= 0)
-        remove_dir("/sdcard");
-
-    remove_dir("/mrom_bin");
-
-    umount("/dev/pts");
-    rmdir("/dev/pts");
-
-    umount("/dev/usb-ffs/adb");
-    rmdir("/dev/usb-ffs/adb");
-    rmdir("/dev/usb-ffs");
-}
-
-int adb_get_serial(char *serial, int maxlen)
-{
-    FILE *f = fopen("/proc/cmdline", "re");
-    if(!f)
-        return -1;
-
-    int res = -1;
-
-    char cmdline[1024];
-    static const char *tag = "androidboot.serialno=";
-    if(fgets(cmdline, sizeof(cmdline), f))
-    {
-        char *start = strstr(cmdline, tag);
-        if(start)
-        {
-            start += strlen(tag);
-            char *end = strchr(start, ' ');
-            if(end && end-start < maxlen)
-            {
-                strncpy(serial, start, end-start);
-                res = 0;
-            }
-        }
-    }
-    fclose(f);
-    return res;
-}
-
-int adb_is_enabled(char *mrom_path)
-{
-    char cfg[64];
-    char *cmd[] = { busybox_path, "grep", "^enable_adb=1$", cfg, NULL };
-    sprintf(cfg, "%s/multirom.ini", mrom_path);
-
-    return run_cmd(cmd) == 0 ? 1 : 0;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <pthread.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <sys/mount.h>
+#include <sys/klog.h>
+#include <linux/loop.h>
+
+#include <malloc.h>
+
+#include "adb.h"
+#include "../lib/util.h"
+#include "../lib/log.h"
+
+static pthread_t adb_thread;
+static volatile int run_thread = 0;
+static pid_t adb_pid = -1;
+
+static char busybox_path[64] = { 0 };
+static char adbd_path[64] = { 0 };
+
+static char * const ENV[] = {
+    "PATH=/sbin:/bin:/usr/bin:/usr/sbin:/mrom_bin",
+    "LD_LIBRARY_PATH=.:/sbin",
+    "ANDROID_ROOT=/system",
+    "ANDROID_DATA=/data",
+    "EXTERNAL_STORAGE=/sdcard",
+    "ANDROID_PROPERTY_WORKSPACE=8,49152",
+    "SHELL=/mrom_bin/sh",
+
+    NULL
+};
+
+static void *adb_thread_work(void *mrom_path)
+{
+    int enabled = adb_is_enabled((char*)mrom_path);
+    free(mrom_path);
+
+    if(enabled == 0)
+        return NULL;
+
+    adb_init_usb();
+
+    if(adb_init_busybox() < 0)
+        return NULL;
+
+    adb_init_fs();
+
+    chmod(adbd_path, 0755);
+
+    while(run_thread)
+    {
+        adb_pid = fork();
+        if(adb_pid == 0) // child
+        {
+            umask(077);
+            setsid();
+            stdio_to_null();
+            setpgid(0, getpid());
+
+            static char * const cmd[] = { adbd_path, NULL };
+            execve(cmd[0], cmd, ENV);
+            exit(0);
+        }
+        else
+        {
+            int status = 0;
+            waitpid(adb_pid, &status, 0);
+        }
+        usleep(300000);
+    }
+
+    adb_cleanup();
+
+    return NULL;
+}
+
+void adb_init(char *mrom_path)
+{
+    if(run_thread)
+        return;
+
+    sprintf(busybox_path, "%s/busybox", mrom_path);
+    sprintf(adbd_path, "%s/adbd", mrom_path);
+
+    INFO("Starting adbd\n");
+    run_thread = 1;
+    pthread_create(&adb_thread, NULL, adb_thread_work, strdup(mrom_path));
+}
+
+void adb_quit(void)
+{
+    if(!run_thread)
+        return;
+
+    INFO("Stopping adbd\n");
+
+    run_thread = 0;
+
+    if(adb_pid != -1)
+    {
+        kill(adb_pid, 9);
+        adb_pid = -1;
+    }
+
+    pthread_join(adb_thread, NULL);
+}
+
+void adb_init_usb(void)
+{
+    mkdir_with_perms("/dev/usb-ffs", 0770, "shell", "shell");
+    mkdir_with_perms("/dev/usb-ffs/adb", 0770, "shell", "shell");
+    mount("adb", "/dev/usb-ffs/adb", "functionfs", 0, "uid=2000,gid=2000");
+
+    write_file("/sys/class/android_usb/android0/enable", "0");
+
+    char serial[64] = { 0 };
+    adb_get_serial(serial, sizeof(serial));
+
+    // this vid and pid is used in TWRP, CWM and AOSP recovery
+    // for all devices, so I guess it is universal
+    write_file("/sys/class/android_usb/android0/idVendor", "18d1");
+    write_file("/sys/class/android_usb/android0/idProduct", "d001");
+    write_file("/sys/class/android_usb/android0/f_ffs/aliases", "adb");
+    write_file("/sys/class/android_usb/android0/functions", "adb");
+    write_file("/sys/class/android_usb/android0/iManufacturer", PRODUCT_MANUFACTURER);
+    write_file("/sys/class/android_usb/android0/iProduct", PRODUCT_MODEL);
+    write_file("/sys/class/android_usb/android0/iSerial", serial);
+
+    write_file("/sys/class/android_usb/android0/enable", "1");
+    write_file("/sys/devices/platform/android_usb/usb_function_switch", "3");
+}
+
+int adb_init_busybox(void)
+{
+    mkdir("/mrom_bin", 0777);
+
+    copy_file(busybox_path, "/mrom_bin/busybox");
+    chmod("/mrom_bin/busybox", 0755);
+
+    static const char *install_cmd[] = {
+        "/mrom_bin/busybox", "--install", "/mrom_bin/", NULL
+    };
+
+    if(run_cmd((char**)install_cmd) != 0)
+    {
+        ERROR("adb: failed to --install busybox\n");
+        return -1;
+    }
+
+    mkdir("/dev/pts", 0666);
+    if(mount("devpts", "/dev/pts", "devpts", 0, NULL) < 0)
+    {
+        ERROR("Failed to mount devpts: %d (%s)\n", errno, strerror(errno));
+        return -1;
+    }
+
+    return 0;
+}
+
+void adb_init_fs(void)
+{
+    mkdir("/sdcard", 0777);
+    if(strstr(adbd_path, "/realdata/media/0/multirom"))
+        mount("/realdata/media/0/", "/sdcard/", "auto", MS_BIND, "");
+    else
+        mount("/realdata/media/", "/sdcard/", "auto", MS_BIND, "");
+}
+
+void adb_cleanup(void)
+{
+    if(umount("/sdcard") >= 0)
+        remove_dir("/sdcard");
+
+    remove_dir("/mrom_bin");
+
+    umount("/dev/pts");
+    rmdir("/dev/pts");
+
+    umount("/dev/usb-ffs/adb");
+    rmdir("/dev/usb-ffs/adb");
+    rmdir("/dev/usb-ffs");
+}
+
+int adb_get_serial(char *serial, int maxlen)
+{
+    FILE *f = fopen("/proc/cmdline", "re");
+    if(!f)
+        return -1;
+
+    int res = -1;
+
+    char cmdline[1024];
+    static const char *tag = "androidboot.serialno=";
+    if(fgets(cmdline, sizeof(cmdline), f))
+    {
+        char *start = strstr(cmdline, tag);
+        if(start)
+        {
+            start += strlen(tag);
+            char *end = strchr(start, ' ');
+            if(end && end-start < maxlen)
+            {
+                strncpy(serial, start, end-start);
+                res = 0;
+            }
+        }
+    }
+    fclose(f);
+    return res;
+}
+
+int adb_is_enabled(char *mrom_path)
+{
+    char cfg[64];
+    char *cmd[] = { busybox_path, "grep", "^enable_adb=1$", cfg, NULL };
+    sprintf(cfg, "%s/multirom.ini", mrom_path);
+
+    return run_cmd(cmd) == 0 ? 1 : 0;
+}
diff --git a/trampoline/adb.h b/trampoline/adb.h
index 87c8180..cf57906 100755
--- a/trampoline/adb.h
+++ b/trampoline/adb.h
@@ -1,30 +1,30 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef ADB_H
-#define ADB_H
-
-void adb_init(char *mrom_path);
-void adb_quit(void);
-void adb_init_usb(void);
-int adb_init_busybox(void);
-void adb_init_fs(void);
-void adb_cleanup(void);
-int adb_get_serial(char *serial, int maxlen);
-int adb_is_enabled(char *mrom_path);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef ADB_H
+#define ADB_H
+
+void adb_init(char *mrom_path);
+void adb_quit(void);
+void adb_init_usb(void);
+int adb_init_busybox(void);
+void adb_init_fs(void);
+void adb_cleanup(void);
+int adb_get_serial(char *serial, int maxlen);
+int adb_is_enabled(char *mrom_path);
+
+#endif
diff --git a/trampoline/devices.c b/trampoline/devices.c
index 096653f..b80a18b 100755
--- a/trampoline/devices.c
+++ b/trampoline/devices.c
@@ -1,987 +1,987 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <errno.h>
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <fcntl.h>
-#include <dirent.h>
-#include <unistd.h>
-#include <string.h>
-#include <poll.h>
-#include <pthread.h>
-
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <linux/netlink.h>
-
-#ifdef HAVE_SELINUX
-#include <selinux/selinux.h>
-#include <selinux/label.h>
-#endif
-
-#include <private/android_filesystem_config.h>
-#include <sys/time.h>
-#include <sys/wait.h>
-
-#include <cutils/list.h>
-#include <cutils/uevent.h>
-
-#include "devices.h"
-#include "../lib/util.h"
-#include "../lib/log.h"
-
-//#define DEBUG_MISSING_UEVENTS 1
-
-#ifdef DEBUG_MISSING_UEVENTS
-#define UEVENT_ERR(x...) ERROR(x)
-#else
-#define UEVENT_ERR(x...)
-#endif
-
-#if 0
-#define DEBUG(x...) INFO(x)
-#else
-#define DEBUG(x...)
-#endif
-
-#define SYSFS_PREFIX    "/sys"
-
-static const char *firmware_dirs[] = { "/etc/firmware",
-                                       "/vendor/firmware",
-                                       "/firmware/image" };
-
-#ifdef HAVE_SELINUX
-static struct selabel_handle *sehandle;
-#endif
-
-extern const char *mr_init_devices[];
-
-static int device_fd = -1;
-static volatile int run_event_thread = 1;
-static pthread_t uevent_thread;
-
-static void *uevent_thread_work(UNUSED void *cookie)
-{
-    struct pollfd ufd;
-    int nr;
-
-    ufd.events = POLLIN;
-    ufd.fd = get_device_fd();
-
-    while(run_event_thread) {
-        ufd.revents = 0;
-        nr = poll(&ufd, 1, 0);
-
-        if (nr > 0 && (ufd.revents & POLLIN))
-            handle_device_fd();
-
-        usleep(100000);
-    }
-    return NULL;
-}
-
-static void init_single_path(const char *path)
-{
-    int fd, dfd;
-    DIR *d;
-
-    DEBUG("Initializing device %s\n", path);
-    d = opendir(path);
-    if(!d)
-    {
-        UEVENT_ERR("Failed to open folder %s\n", path);
-        return;
-    }
-
-    dfd = dirfd(d);
-
-    fd = openat(dfd, "uevent", O_WRONLY | O_CLOEXEC);
-    if(fd >= 0)
-    {
-        write(fd, "add\n", 4);
-        close(fd);
-        handle_device_fd();
-    }
-    else
-    {
-        UEVENT_ERR("Failed to open uevent at %s\n", path);
-    }
-
-    closedir(d);
-}
-
-static void init_folder(const char *path)
-{
-    init_single_path(path);
-
-    DIR *d = opendir(path);
-    if(!d)
-    {
-        UEVENT_ERR("Failed to open folder %s\n", path);
-        return;
-    }
-
-    struct dirent *dr;
-    while((dr = readdir(d)))
-    {
-        if (dr->d_type != DT_DIR ||
-           (dr->d_name[0] == '.' && (dr->d_name[1] == 0 || dr->d_name[1] == '.')))
-           continue;
-
-        char *p = malloc(strlen(path) + strlen(dr->d_name) + 2);
-        strcpy(p, path);
-        strcat(p, "/");
-        strcat(p, dr->d_name);
-
-        init_folder(p);
-
-        free(p);
-    }
-    closedir(d);
-}
-
-void devices_init(void)
-{
-    /* is 256K enough? udev uses 16MB! */
-    device_fd = uevent_open_socket(256*1024, true);
-    if(device_fd < 0)
-        return;
-
-    fcntl(device_fd, F_SETFL, O_NONBLOCK);
-
-    int i, len;
-    for(i = 0; mr_init_devices[i]; ++i)
-    {
-        len = strlen(mr_init_devices[i]);
-        if(mr_init_devices[i][len-1] != '*')
-            init_single_path(mr_init_devices[i]);
-        else
-        {
-            char *path = strndup(mr_init_devices[i], len-1);
-            init_folder(path);
-            free(path);
-        }
-    }
-
-    // /dev/null
-    init_single_path("/sys/devices/virtual/mem/null");
-
-    // /dev/fuse
-    init_single_path("/sys/devices/virtual/misc/fuse");
-
-    run_event_thread = 1;
-    pthread_create(&uevent_thread, NULL, uevent_thread_work, NULL);
-}
-
-void devices_close(void)
-{
-    run_event_thread = 0;
-    pthread_join(uevent_thread, NULL);
-
-    close(device_fd);
-    device_fd = -1;
-}
-
-struct uevent {
-    const char *action;
-    const char *path;
-    const char *subsystem;
-    const char *firmware;
-    const char *partition_name;
-    const char *device_name;
-    int partition_num;
-    int major;
-    int minor;
-};
-
-struct perms_ {
-    char *name;
-    char *attr;
-    mode_t perm;
-    unsigned int uid;
-    unsigned int gid;
-    unsigned short prefix;
-};
-
-struct perm_node {
-    struct perms_ dp;
-    struct listnode plist;
-};
-
-struct platform_node {
-    char *name;
-    char *path;
-    int path_len;
-    struct listnode list;
-};
-
-static list_declare(sys_perms);
-static list_declare(dev_perms);
-static list_declare(platform_names);
-
-int add_dev_perms(const char *name, const char *attr,
-                  mode_t perm, unsigned int uid, unsigned int gid,
-                  unsigned short prefix) {
-    struct perm_node *node = calloc(1, sizeof(*node));
-    if (!node)
-        return -ENOMEM;
-
-    node->dp.name = strdup(name);
-    if (!node->dp.name)
-        return -ENOMEM;
-
-    if (attr) {
-        node->dp.attr = strdup(attr);
-        if (!node->dp.attr)
-            return -ENOMEM;
-    }
-
-    node->dp.perm = perm;
-    node->dp.uid = uid;
-    node->dp.gid = gid;
-    node->dp.prefix = prefix;
-
-    if (attr)
-        list_add_tail(&sys_perms, &node->plist);
-    else
-        list_add_tail(&dev_perms, &node->plist);
-
-    return 0;
-}
-
-void fixup_sys_perms(const char *upath)
-{
-    char buf[512];
-    struct listnode *node;
-    struct perms_ *dp;
-
-        /* upaths omit the "/sys" that paths in this list
-         * contain, so we add 4 when comparing...
-         */
-    list_for_each(node, &sys_perms) {
-        dp = &(node_to_item(node, struct perm_node, plist))->dp;
-        if (dp->prefix) {
-            if (strncmp(upath, dp->name + 4, strlen(dp->name + 4)))
-                continue;
-        } else {
-            if (strcmp(upath, dp->name + 4))
-                continue;
-        }
-
-        if ((strlen(upath) + strlen(dp->attr) + 6) > sizeof(buf))
-            return;
-
-        snprintf(buf, sizeof(buf), "/sys%s/%s", upath, dp->attr);
-        DEBUG("fixup %s %d %d 0%o\n", buf, dp->uid, dp->gid, dp->perm);
-        chown(buf, dp->uid, dp->gid);
-        chmod(buf, dp->perm);
-    }
-}
-
-static mode_t get_device_perm(const char *path, unsigned *uid, unsigned *gid)
-{
-    mode_t perm;
-    struct listnode *node;
-    struct perm_node *perm_node;
-    struct perms_ *dp;
-
-    /* search the perms list in reverse so that ueventd.$hardware can
-     * override ueventd.rc
-     */
-    list_for_each_reverse(node, &dev_perms) {
-        perm_node = node_to_item(node, struct perm_node, plist);
-        dp = &perm_node->dp;
-
-        if (dp->prefix) {
-            if (strncmp(path, dp->name, strlen(dp->name)))
-                continue;
-        } else {
-            if (strcmp(path, dp->name))
-                continue;
-        }
-        *uid = dp->uid;
-        *gid = dp->gid;
-        return dp->perm;
-    }
-    /* Default if nothing found. */
-    *uid = 0;
-    *gid = 0;
-    return 0600;
-}
-
-static void make_device(const char *path,
-                        UNUSED const char *upath,
-                        int block, int major, int minor)
-{
-    unsigned uid;
-    unsigned gid;
-    mode_t mode;
-    dev_t dev;
-#ifdef HAVE_SELINUX
-    char *secontext = NULL;
-#endif
-
-    mode = get_device_perm(path, &uid, &gid) | (block ? S_IFBLK : S_IFCHR);
-#ifdef HAVE_SELINUX
-    if (sehandle) {
-        selabel_lookup(sehandle, &secontext, path, mode);
-        setfscreatecon(secontext);
-    }
-#endif
-    dev = makedev(major, minor);
-    /* Temporarily change egid to avoid race condition setting the gid of the
-     * device node. Unforunately changing the euid would prevent creation of
-     * some device nodes, so the uid has to be set with chown() and is still
-     * racy. Fixing the gid race at least fixed the issue with system_server
-     * opening dynamic input devices under the AID_INPUT gid. */
-    setegid(gid);
-    mknod(path, mode, dev);
-    chown(path, uid, -1);
-    setegid(AID_ROOT);
-#ifdef HAVE_SELINUX
-    if (secontext) {
-        freecon(secontext);
-        setfscreatecon(NULL);
-    }
-#endif
-}
-
-
-static int make_dir(const char *path, mode_t mode)
-{
-    int rc;
-
-#ifdef HAVE_SELINUX
-    char *secontext = NULL;
-
-    if (sehandle) {
-        selabel_lookup(sehandle, &secontext, path, mode);
-        setfscreatecon(secontext);
-    }
-#endif
-
-    rc = mkdir(path, mode);
-
-#ifdef HAVE_SELINUX
-    if (secontext) {
-        freecon(secontext);
-        setfscreatecon(NULL);
-    }
-#endif
-    return rc;
-}
-
-
-static void add_platform_device(const char *path)
-{
-    int path_len = strlen(path);
-    struct platform_node *bus;
-    const char *name = path;
-
-    if (!strncmp(path, "/devices/", 9)) {
-        name += 9;
-        if (!strncmp(name, "platform/", 9))
-            name += 9;
-    }
-
-    DEBUG("adding platform device %s (%s)\n", name, path);
-
-    bus = calloc(1, sizeof(struct platform_node));
-    bus->path = strdup(path);
-    bus->path_len = path_len;
-    bus->name = bus->path + (name - path);
-    list_add_tail(&platform_names, &bus->list);
-}
-
-/*
- * given a path that may start with a platform device, find the length of the
- * platform device prefix.  If it doesn't start with a platform device, return
- * 0.
- */
-static struct platform_node *find_platform_device(const char *path)
-{
-    int path_len = strlen(path);
-    struct listnode *node;
-    struct platform_node *bus;
-
-    list_for_each_reverse(node, &platform_names) {
-        bus = node_to_item(node, struct platform_node, list);
-        if ((bus->path_len < path_len) &&
-                (path[bus->path_len] == '/') &&
-                !strncmp(path, bus->path, bus->path_len))
-            return bus;
-    }
-
-    return NULL;
-}
-
-static void remove_platform_device(const char *path)
-{
-    struct listnode *node;
-    struct platform_node *bus;
-
-    list_for_each_reverse(node, &platform_names) {
-        bus = node_to_item(node, struct platform_node, list);
-        if (!strcmp(path, bus->path)) {
-            DEBUG("removing platform device %s\n", bus->name);
-            free(bus->path);
-            list_remove(node);
-            free(bus);
-            return;
-        }
-    }
-}
-
-#if LOG_UEVENTS
-
-static inline suseconds_t get_usecs(void)
-{
-    struct timeval tv;
-    gettimeofday(&tv, 0);
-    return tv.tv_sec * (suseconds_t) 1000000 + tv.tv_usec;
-}
-
-#define log_event_print(x...) INFO(x)
-
-#else
-
-#define log_event_print(fmt, args...)   do { } while (0)
-#define get_usecs()                     0
-
-#endif
-
-static void parse_event(const char *msg, struct uevent *uevent)
-{
-    uevent->action = "";
-    uevent->path = "";
-    uevent->subsystem = "";
-    uevent->firmware = "";
-    uevent->major = -1;
-    uevent->minor = -1;
-    uevent->partition_name = NULL;
-    uevent->partition_num = -1;
-    uevent->device_name = NULL;
-
-        /* currently ignoring SEQNUM */
-    while(*msg) {
-        if(!strncmp(msg, "ACTION=", 7)) {
-            msg += 7;
-            uevent->action = msg;
-        } else if(!strncmp(msg, "DEVPATH=", 8)) {
-            msg += 8;
-            uevent->path = msg;
-        } else if(!strncmp(msg, "SUBSYSTEM=", 10)) {
-            msg += 10;
-            uevent->subsystem = msg;
-        } else if(!strncmp(msg, "FIRMWARE=", 9)) {
-            msg += 9;
-            uevent->firmware = msg;
-        } else if(!strncmp(msg, "MAJOR=", 6)) {
-            msg += 6;
-            uevent->major = atoi(msg);
-        } else if(!strncmp(msg, "MINOR=", 6)) {
-            msg += 6;
-            uevent->minor = atoi(msg);
-        } else if(!strncmp(msg, "PARTN=", 6)) {
-            msg += 6;
-            uevent->partition_num = atoi(msg);
-        } else if(!strncmp(msg, "PARTNAME=", 9)) {
-            msg += 9;
-            uevent->partition_name = msg;
-        } else if(!strncmp(msg, "DEVNAME=", 8)) {
-            msg += 8;
-            uevent->device_name = msg;
-        }
-
-        /* advance to after the next \0 */
-        while(*msg++)
-            ;
-    }
-
-    log_event_print("event { '%s', '%s', '%s', '%s', %d, %d }\n",
-                    uevent->action, uevent->path, uevent->subsystem,
-                    uevent->firmware, uevent->major, uevent->minor);
-}
-
-static char **get_character_device_symlinks(struct uevent *uevent)
-{
-    const char *parent;
-    char *slash;
-    char **links;
-    int link_num = 0;
-    int width;
-    struct platform_node *pdev;
-
-    pdev = find_platform_device(uevent->path);
-    if (!pdev)
-        return NULL;
-
-    links = malloc(sizeof(char *) * 2);
-    if (!links)
-        return NULL;
-    memset(links, 0, sizeof(char *) * 2);
-
-    /* skip "/devices/platform/<driver>" */
-    parent = strchr(uevent->path + pdev->path_len, '/');
-    if (!parent)
-        goto err;
-
-    if (!strncmp(parent, "/usb", 4)) {
-        /* skip root hub name and device. use device interface */
-        while (*++parent && *parent != '/');
-        if (*parent)
-            while (*++parent && *parent != '/');
-        if (!*parent)
-            goto err;
-        slash = strchr(++parent, '/');
-        if (!slash)
-            goto err;
-        width = slash - parent;
-        if (width <= 0)
-            goto err;
-
-        if (asprintf(&links[link_num], "/dev/usb/%s%.*s", uevent->subsystem, width, parent) > 0)
-            link_num++;
-        else
-            links[link_num] = NULL;
-        mkdir("/dev/usb", 0755);
-    }
-    else {
-        goto err;
-    }
-
-    return links;
-err:
-    free(links);
-    return NULL;
-}
-
-static char **parse_platform_block_device(struct uevent *uevent)
-{
-    const char *device;
-    struct platform_node *pdev;
-    char *slash;
-    int width;
-    char buf[256];
-    char link_path[256];
-    int fd;
-    int link_num = 0;
-    int ret;
-    char *p;
-    unsigned int size;
-    struct stat info;
-
-    pdev = find_platform_device(uevent->path);
-    if (!pdev)
-        return NULL;
-    device = pdev->name;
-
-    char **links = malloc(sizeof(char *) * 4);
-    if (!links)
-        return NULL;
-    memset(links, 0, sizeof(char *) * 4);
-
-    DEBUG("found platform device %s\n", device);
-
-    snprintf(link_path, sizeof(link_path), "/dev/block/platform/%s", device);
-
-    if (uevent->partition_name) {
-        p = strdup(uevent->partition_name);
-        sanitize(p);
-        DEBUG("Linking partition '%s' as '%s', %s/by-name/%s\n", uevent->partition_name, p, link_path, p);
-        if (strcmp(uevent->partition_name, p))
-            INFO("Linking partition '%s' as '%s'\n", uevent->partition_name, p);
-        if (asprintf(&links[link_num], "%s/by-name/%s", link_path, p) > 0)
-            link_num++;
-        else
-            links[link_num] = NULL;
-        free(p);
-    }
-
-    if (uevent->partition_num >= 0) {
-        if (asprintf(&links[link_num], "%s/by-num/p%d", link_path, uevent->partition_num) > 0)
-            link_num++;
-        else
-            links[link_num] = NULL;
-    }
-
-    slash = strrchr(uevent->path, '/');
-    if (asprintf(&links[link_num], "%s/%s", link_path, slash + 1) > 0)
-        link_num++;
-    else
-        links[link_num] = NULL;
-
-    return links;
-}
-
-static void handle_device(const char *action, const char *devpath,
-        const char *path, int block, int major, int minor, char **links)
-{
-    int i;
-
-    if(!strcmp(action, "add")) {
-        make_device(devpath, path, block, major, minor);
-        if (links) {
-            for (i = 0; links[i]; i++)
-                make_link(devpath, links[i]);
-        }
-    }
-
-    if(!strcmp(action, "remove")) {
-        if (links) {
-            for (i = 0; links[i]; i++)
-                remove_link(devpath, links[i]);
-        }
-        unlink(devpath);
-    }
-
-    if (links) {
-        for (i = 0; links[i]; i++)
-            free(links[i]);
-        free(links);
-    }
-}
-
-static void handle_platform_device_event(struct uevent *uevent)
-{
-    const char *path = uevent->path;
-
-    if (!strcmp(uevent->action, "add"))
-        add_platform_device(path);
-    else if (!strcmp(uevent->action, "remove"))
-        remove_platform_device(path);
-}
-
-static const char *parse_device_name(struct uevent *uevent, unsigned int len)
-{
-    const char *name;
-
-    /* if it's not a /dev device, nothing else to do */
-    if((uevent->major < 0) || (uevent->minor < 0))
-        return NULL;
-
-    /* do we have a name? */
-    name = strrchr(uevent->path, '/');
-    if(!name)
-        return NULL;
-    name++;
-
-    /* too-long names would overrun our buffer */
-    if(strlen(name) > len)
-        return NULL;
-
-    return name;
-}
-
-static void handle_block_device_event(struct uevent *uevent)
-{
-    const char *base = "/dev/block/";
-    const char *name;
-    char devpath[96];
-    char **links = NULL;
-
-    name = parse_device_name(uevent, 64);
-    if (!name)
-        return;
-
-    snprintf(devpath, sizeof(devpath), "%s%s", base, name);
-    make_dir(base, 0755);
-
-    if (!strncmp(uevent->path, "/devices/", 9))
-        links = parse_platform_block_device(uevent);
-
-    handle_device(uevent->action, devpath, uevent->path, 1,
-            uevent->major, uevent->minor, links);
-}
-
-static void handle_generic_device_event(struct uevent *uevent)
-{
-    char *base = NULL;
-    const char *name;
-    char devpath[96] = {0};
-    char **links = NULL;
-
-    name = parse_device_name(uevent, 64);
-    if (!name)
-        return;
-
-    if (!strncmp(uevent->subsystem, "usb", 3)) {
-         if (!strcmp(uevent->subsystem, "usb")) {
-            if (uevent->device_name) {
-                /*
-                 * create device node provided by kernel if present
-                 * see drivers/base/core.c
-                 */
-                char *p = devpath;
-                snprintf(devpath, sizeof(devpath), "/dev/%s", uevent->device_name);
-                /* skip leading /dev/ */
-                p += 5;
-                /* build directories */
-                while (*p) {
-                    if (*p == '/') {
-                        *p = 0;
-                        make_dir(devpath, 0755);
-                        *p = '/';
-                    }
-                    p++;
-                }
-             }
-             else {
-                 /* This imitates the file system that would be created
-                  * if we were using devfs instead.
-                  * Minors are broken up into groups of 128, starting at "001"
-                  */
-                 int bus_id = uevent->minor / 128 + 1;
-                 int device_id = uevent->minor % 128 + 1;
-                 /* build directories */
-                 make_dir("/dev/bus", 0755);
-                 make_dir("/dev/bus/usb", 0755);
-                 snprintf(devpath, sizeof(devpath), "/dev/bus/usb/%03d", bus_id);
-                 make_dir(devpath, 0755);
-                 snprintf(devpath, sizeof(devpath), "/dev/bus/usb/%03d/%03d", bus_id, device_id);
-             }
-         } else {
-             /* ignore other USB events */
-             return;
-         }
-     } else if (!strncmp(uevent->subsystem, "graphics", 8)) {
-         base = "/dev/graphics/";
-         make_dir(base, 0755);
-     } else if (!strncmp(uevent->subsystem, "oncrpc", 6)) {
-         base = "/dev/oncrpc/";
-         make_dir(base, 0755);
-     } else if (!strncmp(uevent->subsystem, "adsp", 4)) {
-         base = "/dev/adsp/";
-         make_dir(base, 0755);
-     } else if (!strncmp(uevent->subsystem, "msm_camera", 10)) {
-         base = "/dev/msm_camera/";
-         make_dir(base, 0755);
-     } else if(!strncmp(uevent->subsystem, "input", 5)) {
-         base = "/dev/input/";
-         make_dir(base, 0755);
-     } else if(!strncmp(uevent->subsystem, "mtd", 3)) {
-         base = "/dev/mtd/";
-         make_dir(base, 0755);
-     } else if(!strncmp(uevent->subsystem, "sound", 5)) {
-         base = "/dev/snd/";
-         make_dir(base, 0755);
-     } else if(!strncmp(uevent->subsystem, "misc", 4) &&
-                 !strncmp(name, "log_", 4)) {
-         base = "/dev/log/";
-         make_dir(base, 0755);
-         name += 4;
-     } else
-         base = "/dev/";
-     links = get_character_device_symlinks(uevent);
-
-     if (!devpath[0])
-         snprintf(devpath, sizeof(devpath), "%s%s", base, name);
-
-     handle_device(uevent->action, devpath, uevent->path, 0,
-             uevent->major, uevent->minor, links);
-}
-
-static void handle_device_event(struct uevent *uevent)
-{
-    if (!strcmp(uevent->action,"add"))
-        fixup_sys_perms(uevent->path);
-
-    if (!strncmp(uevent->subsystem, "block", 5)) {
-        handle_block_device_event(uevent);
-    } else if (!strncmp(uevent->subsystem, "platform", 8)) {
-        handle_platform_device_event(uevent);
-    } else {
-        handle_generic_device_event(uevent);
-    }
-}
-
-static int load_firmware(int fw_fd, int loading_fd, int data_fd)
-{
-    struct stat st;
-    long len_to_copy;
-    int ret = 0;
-
-    if(fstat(fw_fd, &st) < 0)
-        return -1;
-    len_to_copy = st.st_size;
-
-    write(loading_fd, "1", 1);  /* start transfer */
-
-    while (len_to_copy > 0) {
-        char buf[PAGE_SIZE];
-        ssize_t nr;
-
-        nr = read(fw_fd, buf, sizeof(buf));
-        if(!nr)
-            break;
-        if(nr < 0) {
-            ret = -1;
-            break;
-        }
-
-        len_to_copy -= nr;
-        while (nr > 0) {
-            ssize_t nw = 0;
-
-            nw = write(data_fd, buf + nw, nr);
-            if(nw <= 0) {
-                ret = -1;
-                goto out;
-            }
-            nr -= nw;
-        }
-    }
-
-out:
-    if(!ret)
-        write(loading_fd, "0", 1);  /* successful end of transfer */
-    else
-        write(loading_fd, "-1", 2); /* abort transfer */
-
-    return ret;
-}
-
-static int is_booting(void)
-{
-    return access("/dev/.booting", F_OK) == 0;
-}
-
-static void process_firmware_event(struct uevent *uevent)
-{
-    char *root, *loading, *data;
-    int l, loading_fd, data_fd, fw_fd, i;
-    int booting = is_booting();
-
-    DEBUG("firmware: loading '%s' for '%s'\n",
-         uevent->firmware, uevent->path);
-
-    l = asprintf(&root, SYSFS_PREFIX"%s/", uevent->path);
-    if (l == -1)
-        return;
-
-    l = asprintf(&loading, "%sloading", root);
-    if (l == -1)
-        goto root_free_out;
-
-    l = asprintf(&data, "%sdata", root);
-    if (l == -1)
-        goto loading_free_out;
-
-    loading_fd = open(loading, O_WRONLY | O_CLOEXEC);
-    if(loading_fd < 0)
-        goto data_free_out;
-
-    data_fd = open(data, O_WRONLY | O_CLOEXEC);
-    if(data_fd < 0)
-        goto loading_close_out;
-
-try_loading_again:
-    for (i = 0; i < ARRAY_SIZE(firmware_dirs); i++) {
-        char *file = NULL;
-        l = asprintf(&file, "%s/%s", firmware_dirs[i], uevent->firmware);
-        if (l == -1)
-            goto data_free_out;
-        fw_fd = open(file, O_RDONLY|O_CLOEXEC);
-        free(file);
-        if (fw_fd >= 0) {
-            if(!load_firmware(fw_fd, loading_fd, data_fd))
-                INFO("firmware: copy success { '%s', '%s' }\n", root, uevent->firmware);
-            else
-                INFO("firmware: copy failure { '%s', '%s' }\n", root, uevent->firmware);
-            break;
-        }
-    }
-
-    if (fw_fd < 0) {
-// disable for multirom to prevent loop
-#if 0
-        if (booting) {
-            /* If we're not fully booted, we may be missing
-             * filesystems needed for firmware, wait and retry.
-             */
-            usleep(100000);
-            booting = is_booting();
-            goto try_loading_again;
-        }
-#endif
-        INFO("firmware: could not open '%s': %s\n", uevent->firmware, strerror(errno));
-        write(loading_fd, "-1", 2);
-        goto data_close_out;
-    }
-
-    close(fw_fd);
-data_close_out:
-    close(data_fd);
-loading_close_out:
-    close(loading_fd);
-data_free_out:
-    free(data);
-loading_free_out:
-    free(loading);
-root_free_out:
-    free(root);
-}
-
-static void handle_firmware_event(struct uevent *uevent)
-{
-    pid_t pid;
-    int ret;
-
-    if(strcmp(uevent->subsystem, "firmware"))
-        return;
-
-    if(strcmp(uevent->action, "add"))
-        return;
-
-    /* we fork, to avoid making large memory allocations in init proper */
-    pid = fork();
-    if (!pid) {
-        process_firmware_event(uevent);
-        _exit(EXIT_SUCCESS);
-    } else if (pid < 0) {
-        log_event_print("could not fork to process firmware event: %s\n", strerror(errno));
-    }
-}
-
-#define UEVENT_MSG_LEN  2048
-void handle_device_fd(void)
-{
-    char msg[UEVENT_MSG_LEN+2];
-    int n;
-    while ((n = uevent_kernel_multicast_recv(device_fd, msg, UEVENT_MSG_LEN)) > 0) {
-        if(n >= UEVENT_MSG_LEN)   /* overflow -- discard */
-            continue;
-
-        msg[n] = '\0';
-        msg[n+1] = '\0';
-
-        struct uevent uevent;
-        parse_event(msg, &uevent);
-
-        handle_device_event(&uevent);
-        handle_firmware_event(&uevent);
-    }
-}
-
-int get_device_fd()
-{
-    return device_fd;
-}
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <fcntl.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <string.h>
+#include <poll.h>
+#include <pthread.h>
+
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <linux/netlink.h>
+
+#ifdef HAVE_SELINUX
+#include <selinux/selinux.h>
+#include <selinux/label.h>
+#endif
+
+#include <private/android_filesystem_config.h>
+#include <sys/time.h>
+#include <sys/wait.h>
+
+#include <cutils/list.h>
+#include <cutils/uevent.h>
+
+#include "devices.h"
+#include "../lib/util.h"
+#include "../lib/log.h"
+
+//#define DEBUG_MISSING_UEVENTS 1
+
+#ifdef DEBUG_MISSING_UEVENTS
+#define UEVENT_ERR(x...) ERROR(x)
+#else
+#define UEVENT_ERR(x...)
+#endif
+
+#if 0
+#define DEBUG(x...) INFO(x)
+#else
+#define DEBUG(x...)
+#endif
+
+#define SYSFS_PREFIX    "/sys"
+
+static const char *firmware_dirs[] = { "/etc/firmware",
+                                       "/vendor/firmware",
+                                       "/firmware/image" };
+
+#ifdef HAVE_SELINUX
+static struct selabel_handle *sehandle;
+#endif
+
+extern const char *mr_init_devices[];
+
+static int device_fd = -1;
+static volatile int run_event_thread = 1;
+static pthread_t uevent_thread;
+
+static void *uevent_thread_work(UNUSED void *cookie)
+{
+    struct pollfd ufd;
+    int nr;
+
+    ufd.events = POLLIN;
+    ufd.fd = get_device_fd();
+
+    while(run_event_thread) {
+        ufd.revents = 0;
+        nr = poll(&ufd, 1, 0);
+
+        if (nr > 0 && (ufd.revents & POLLIN))
+            handle_device_fd();
+
+        usleep(100000);
+    }
+    return NULL;
+}
+
+static void init_single_path(const char *path)
+{
+    int fd, dfd;
+    DIR *d;
+
+    DEBUG("Initializing device %s\n", path);
+    d = opendir(path);
+    if(!d)
+    {
+        UEVENT_ERR("Failed to open folder %s\n", path);
+        return;
+    }
+
+    dfd = dirfd(d);
+
+    fd = openat(dfd, "uevent", O_WRONLY | O_CLOEXEC);
+    if(fd >= 0)
+    {
+        write(fd, "add\n", 4);
+        close(fd);
+        handle_device_fd();
+    }
+    else
+    {
+        UEVENT_ERR("Failed to open uevent at %s\n", path);
+    }
+
+    closedir(d);
+}
+
+static void init_folder(const char *path)
+{
+    init_single_path(path);
+
+    DIR *d = opendir(path);
+    if(!d)
+    {
+        UEVENT_ERR("Failed to open folder %s\n", path);
+        return;
+    }
+
+    struct dirent *dr;
+    while((dr = readdir(d)))
+    {
+        if (dr->d_type != DT_DIR ||
+           (dr->d_name[0] == '.' && (dr->d_name[1] == 0 || dr->d_name[1] == '.')))
+           continue;
+
+        char *p = malloc(strlen(path) + strlen(dr->d_name) + 2);
+        strcpy(p, path);
+        strcat(p, "/");
+        strcat(p, dr->d_name);
+
+        init_folder(p);
+
+        free(p);
+    }
+    closedir(d);
+}
+
+void devices_init(void)
+{
+    /* is 256K enough? udev uses 16MB! */
+    device_fd = uevent_open_socket(256*1024, true);
+    if(device_fd < 0)
+        return;
+
+    fcntl(device_fd, F_SETFL, O_NONBLOCK);
+
+    int i, len;
+    for(i = 0; mr_init_devices[i]; ++i)
+    {
+        len = strlen(mr_init_devices[i]);
+        if(mr_init_devices[i][len-1] != '*')
+            init_single_path(mr_init_devices[i]);
+        else
+        {
+            char *path = strndup(mr_init_devices[i], len-1);
+            init_folder(path);
+            free(path);
+        }
+    }
+
+    // /dev/null
+    init_single_path("/sys/devices/virtual/mem/null");
+
+    // /dev/fuse
+    init_single_path("/sys/devices/virtual/misc/fuse");
+
+    run_event_thread = 1;
+    pthread_create(&uevent_thread, NULL, uevent_thread_work, NULL);
+}
+
+void devices_close(void)
+{
+    run_event_thread = 0;
+    pthread_join(uevent_thread, NULL);
+
+    close(device_fd);
+    device_fd = -1;
+}
+
+struct uevent {
+    const char *action;
+    const char *path;
+    const char *subsystem;
+    const char *firmware;
+    const char *partition_name;
+    const char *device_name;
+    int partition_num;
+    int major;
+    int minor;
+};
+
+struct perms_ {
+    char *name;
+    char *attr;
+    mode_t perm;
+    unsigned int uid;
+    unsigned int gid;
+    unsigned short prefix;
+};
+
+struct perm_node {
+    struct perms_ dp;
+    struct listnode plist;
+};
+
+struct platform_node {
+    char *name;
+    char *path;
+    int path_len;
+    struct listnode list;
+};
+
+static list_declare(sys_perms);
+static list_declare(dev_perms);
+static list_declare(platform_names);
+
+int add_dev_perms(const char *name, const char *attr,
+                  mode_t perm, unsigned int uid, unsigned int gid,
+                  unsigned short prefix) {
+    struct perm_node *node = calloc(1, sizeof(*node));
+    if (!node)
+        return -ENOMEM;
+
+    node->dp.name = strdup(name);
+    if (!node->dp.name)
+        return -ENOMEM;
+
+    if (attr) {
+        node->dp.attr = strdup(attr);
+        if (!node->dp.attr)
+            return -ENOMEM;
+    }
+
+    node->dp.perm = perm;
+    node->dp.uid = uid;
+    node->dp.gid = gid;
+    node->dp.prefix = prefix;
+
+    if (attr)
+        list_add_tail(&sys_perms, &node->plist);
+    else
+        list_add_tail(&dev_perms, &node->plist);
+
+    return 0;
+}
+
+void fixup_sys_perms(const char *upath)
+{
+    char buf[512];
+    struct listnode *node;
+    struct perms_ *dp;
+
+        /* upaths omit the "/sys" that paths in this list
+         * contain, so we add 4 when comparing...
+         */
+    list_for_each(node, &sys_perms) {
+        dp = &(node_to_item(node, struct perm_node, plist))->dp;
+        if (dp->prefix) {
+            if (strncmp(upath, dp->name + 4, strlen(dp->name + 4)))
+                continue;
+        } else {
+            if (strcmp(upath, dp->name + 4))
+                continue;
+        }
+
+        if ((strlen(upath) + strlen(dp->attr) + 6) > sizeof(buf))
+            return;
+
+        snprintf(buf, sizeof(buf), "/sys%s/%s", upath, dp->attr);
+        DEBUG("fixup %s %d %d 0%o\n", buf, dp->uid, dp->gid, dp->perm);
+        chown(buf, dp->uid, dp->gid);
+        chmod(buf, dp->perm);
+    }
+}
+
+static mode_t get_device_perm(const char *path, unsigned *uid, unsigned *gid)
+{
+    mode_t perm;
+    struct listnode *node;
+    struct perm_node *perm_node;
+    struct perms_ *dp;
+
+    /* search the perms list in reverse so that ueventd.$hardware can
+     * override ueventd.rc
+     */
+    list_for_each_reverse(node, &dev_perms) {
+        perm_node = node_to_item(node, struct perm_node, plist);
+        dp = &perm_node->dp;
+
+        if (dp->prefix) {
+            if (strncmp(path, dp->name, strlen(dp->name)))
+                continue;
+        } else {
+            if (strcmp(path, dp->name))
+                continue;
+        }
+        *uid = dp->uid;
+        *gid = dp->gid;
+        return dp->perm;
+    }
+    /* Default if nothing found. */
+    *uid = 0;
+    *gid = 0;
+    return 0600;
+}
+
+static void make_device(const char *path,
+                        UNUSED const char *upath,
+                        int block, int major, int minor)
+{
+    unsigned uid;
+    unsigned gid;
+    mode_t mode;
+    dev_t dev;
+#ifdef HAVE_SELINUX
+    char *secontext = NULL;
+#endif
+
+    mode = get_device_perm(path, &uid, &gid) | (block ? S_IFBLK : S_IFCHR);
+#ifdef HAVE_SELINUX
+    if (sehandle) {
+        selabel_lookup(sehandle, &secontext, path, mode);
+        setfscreatecon(secontext);
+    }
+#endif
+    dev = makedev(major, minor);
+    /* Temporarily change egid to avoid race condition setting the gid of the
+     * device node. Unforunately changing the euid would prevent creation of
+     * some device nodes, so the uid has to be set with chown() and is still
+     * racy. Fixing the gid race at least fixed the issue with system_server
+     * opening dynamic input devices under the AID_INPUT gid. */
+    setegid(gid);
+    mknod(path, mode, dev);
+    chown(path, uid, -1);
+    setegid(AID_ROOT);
+#ifdef HAVE_SELINUX
+    if (secontext) {
+        freecon(secontext);
+        setfscreatecon(NULL);
+    }
+#endif
+}
+
+
+static int make_dir(const char *path, mode_t mode)
+{
+    int rc;
+
+#ifdef HAVE_SELINUX
+    char *secontext = NULL;
+
+    if (sehandle) {
+        selabel_lookup(sehandle, &secontext, path, mode);
+        setfscreatecon(secontext);
+    }
+#endif
+
+    rc = mkdir(path, mode);
+
+#ifdef HAVE_SELINUX
+    if (secontext) {
+        freecon(secontext);
+        setfscreatecon(NULL);
+    }
+#endif
+    return rc;
+}
+
+
+static void add_platform_device(const char *path)
+{
+    int path_len = strlen(path);
+    struct platform_node *bus;
+    const char *name = path;
+
+    if (!strncmp(path, "/devices/", 9)) {
+        name += 9;
+        if (!strncmp(name, "platform/", 9))
+            name += 9;
+    }
+
+    DEBUG("adding platform device %s (%s)\n", name, path);
+
+    bus = calloc(1, sizeof(struct platform_node));
+    bus->path = strdup(path);
+    bus->path_len = path_len;
+    bus->name = bus->path + (name - path);
+    list_add_tail(&platform_names, &bus->list);
+}
+
+/*
+ * given a path that may start with a platform device, find the length of the
+ * platform device prefix.  If it doesn't start with a platform device, return
+ * 0.
+ */
+static struct platform_node *find_platform_device(const char *path)
+{
+    int path_len = strlen(path);
+    struct listnode *node;
+    struct platform_node *bus;
+
+    list_for_each_reverse(node, &platform_names) {
+        bus = node_to_item(node, struct platform_node, list);
+        if ((bus->path_len < path_len) &&
+                (path[bus->path_len] == '/') &&
+                !strncmp(path, bus->path, bus->path_len))
+            return bus;
+    }
+
+    return NULL;
+}
+
+static void remove_platform_device(const char *path)
+{
+    struct listnode *node;
+    struct platform_node *bus;
+
+    list_for_each_reverse(node, &platform_names) {
+        bus = node_to_item(node, struct platform_node, list);
+        if (!strcmp(path, bus->path)) {
+            DEBUG("removing platform device %s\n", bus->name);
+            free(bus->path);
+            list_remove(node);
+            free(bus);
+            return;
+        }
+    }
+}
+
+#if LOG_UEVENTS
+
+static inline suseconds_t get_usecs(void)
+{
+    struct timeval tv;
+    gettimeofday(&tv, 0);
+    return tv.tv_sec * (suseconds_t) 1000000 + tv.tv_usec;
+}
+
+#define log_event_print(x...) INFO(x)
+
+#else
+
+#define log_event_print(fmt, args...)   do { } while (0)
+#define get_usecs()                     0
+
+#endif
+
+static void parse_event(const char *msg, struct uevent *uevent)
+{
+    uevent->action = "";
+    uevent->path = "";
+    uevent->subsystem = "";
+    uevent->firmware = "";
+    uevent->major = -1;
+    uevent->minor = -1;
+    uevent->partition_name = NULL;
+    uevent->partition_num = -1;
+    uevent->device_name = NULL;
+
+        /* currently ignoring SEQNUM */
+    while(*msg) {
+        if(!strncmp(msg, "ACTION=", 7)) {
+            msg += 7;
+            uevent->action = msg;
+        } else if(!strncmp(msg, "DEVPATH=", 8)) {
+            msg += 8;
+            uevent->path = msg;
+        } else if(!strncmp(msg, "SUBSYSTEM=", 10)) {
+            msg += 10;
+            uevent->subsystem = msg;
+        } else if(!strncmp(msg, "FIRMWARE=", 9)) {
+            msg += 9;
+            uevent->firmware = msg;
+        } else if(!strncmp(msg, "MAJOR=", 6)) {
+            msg += 6;
+            uevent->major = atoi(msg);
+        } else if(!strncmp(msg, "MINOR=", 6)) {
+            msg += 6;
+            uevent->minor = atoi(msg);
+        } else if(!strncmp(msg, "PARTN=", 6)) {
+            msg += 6;
+            uevent->partition_num = atoi(msg);
+        } else if(!strncmp(msg, "PARTNAME=", 9)) {
+            msg += 9;
+            uevent->partition_name = msg;
+        } else if(!strncmp(msg, "DEVNAME=", 8)) {
+            msg += 8;
+            uevent->device_name = msg;
+        }
+
+        /* advance to after the next \0 */
+        while(*msg++)
+            ;
+    }
+
+    log_event_print("event { '%s', '%s', '%s', '%s', %d, %d }\n",
+                    uevent->action, uevent->path, uevent->subsystem,
+                    uevent->firmware, uevent->major, uevent->minor);
+}
+
+static char **get_character_device_symlinks(struct uevent *uevent)
+{
+    const char *parent;
+    char *slash;
+    char **links;
+    int link_num = 0;
+    int width;
+    struct platform_node *pdev;
+
+    pdev = find_platform_device(uevent->path);
+    if (!pdev)
+        return NULL;
+
+    links = malloc(sizeof(char *) * 2);
+    if (!links)
+        return NULL;
+    memset(links, 0, sizeof(char *) * 2);
+
+    /* skip "/devices/platform/<driver>" */
+    parent = strchr(uevent->path + pdev->path_len, '/');
+    if (!parent)
+        goto err;
+
+    if (!strncmp(parent, "/usb", 4)) {
+        /* skip root hub name and device. use device interface */
+        while (*++parent && *parent != '/');
+        if (*parent)
+            while (*++parent && *parent != '/');
+        if (!*parent)
+            goto err;
+        slash = strchr(++parent, '/');
+        if (!slash)
+            goto err;
+        width = slash - parent;
+        if (width <= 0)
+            goto err;
+
+        if (asprintf(&links[link_num], "/dev/usb/%s%.*s", uevent->subsystem, width, parent) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+        mkdir("/dev/usb", 0755);
+    }
+    else {
+        goto err;
+    }
+
+    return links;
+err:
+    free(links);
+    return NULL;
+}
+
+static char **parse_platform_block_device(struct uevent *uevent)
+{
+    const char *device;
+    struct platform_node *pdev;
+    char *slash;
+    int width;
+    char buf[256];
+    char link_path[256];
+    int fd;
+    int link_num = 0;
+    int ret;
+    char *p;
+    unsigned int size;
+    struct stat info;
+
+    pdev = find_platform_device(uevent->path);
+    if (!pdev)
+        return NULL;
+    device = pdev->name;
+
+    char **links = malloc(sizeof(char *) * 4);
+    if (!links)
+        return NULL;
+    memset(links, 0, sizeof(char *) * 4);
+
+    DEBUG("found platform device %s\n", device);
+
+    snprintf(link_path, sizeof(link_path), "/dev/block/platform/%s", device);
+
+    if (uevent->partition_name) {
+        p = strdup(uevent->partition_name);
+        sanitize(p);
+        DEBUG("Linking partition '%s' as '%s', %s/by-name/%s\n", uevent->partition_name, p, link_path, p);
+        if (strcmp(uevent->partition_name, p))
+            INFO("Linking partition '%s' as '%s'\n", uevent->partition_name, p);
+        if (asprintf(&links[link_num], "%s/by-name/%s", link_path, p) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+        free(p);
+    }
+
+    if (uevent->partition_num >= 0) {
+        if (asprintf(&links[link_num], "%s/by-num/p%d", link_path, uevent->partition_num) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+    }
+
+    slash = strrchr(uevent->path, '/');
+    if (asprintf(&links[link_num], "%s/%s", link_path, slash + 1) > 0)
+        link_num++;
+    else
+        links[link_num] = NULL;
+
+    return links;
+}
+
+static void handle_device(const char *action, const char *devpath,
+        const char *path, int block, int major, int minor, char **links)
+{
+    int i;
+
+    if(!strcmp(action, "add")) {
+        make_device(devpath, path, block, major, minor);
+        if (links) {
+            for (i = 0; links[i]; i++)
+                make_link(devpath, links[i]);
+        }
+    }
+
+    if(!strcmp(action, "remove")) {
+        if (links) {
+            for (i = 0; links[i]; i++)
+                remove_link(devpath, links[i]);
+        }
+        unlink(devpath);
+    }
+
+    if (links) {
+        for (i = 0; links[i]; i++)
+            free(links[i]);
+        free(links);
+    }
+}
+
+static void handle_platform_device_event(struct uevent *uevent)
+{
+    const char *path = uevent->path;
+
+    if (!strcmp(uevent->action, "add"))
+        add_platform_device(path);
+    else if (!strcmp(uevent->action, "remove"))
+        remove_platform_device(path);
+}
+
+static const char *parse_device_name(struct uevent *uevent, unsigned int len)
+{
+    const char *name;
+
+    /* if it's not a /dev device, nothing else to do */
+    if((uevent->major < 0) || (uevent->minor < 0))
+        return NULL;
+
+    /* do we have a name? */
+    name = strrchr(uevent->path, '/');
+    if(!name)
+        return NULL;
+    name++;
+
+    /* too-long names would overrun our buffer */
+    if(strlen(name) > len)
+        return NULL;
+
+    return name;
+}
+
+static void handle_block_device_event(struct uevent *uevent)
+{
+    const char *base = "/dev/block/";
+    const char *name;
+    char devpath[96];
+    char **links = NULL;
+
+    name = parse_device_name(uevent, 64);
+    if (!name)
+        return;
+
+    snprintf(devpath, sizeof(devpath), "%s%s", base, name);
+    make_dir(base, 0755);
+
+    if (!strncmp(uevent->path, "/devices/", 9))
+        links = parse_platform_block_device(uevent);
+
+    handle_device(uevent->action, devpath, uevent->path, 1,
+            uevent->major, uevent->minor, links);
+}
+
+static void handle_generic_device_event(struct uevent *uevent)
+{
+    char *base = NULL;
+    const char *name;
+    char devpath[96] = {0};
+    char **links = NULL;
+
+    name = parse_device_name(uevent, 64);
+    if (!name)
+        return;
+
+    if (!strncmp(uevent->subsystem, "usb", 3)) {
+         if (!strcmp(uevent->subsystem, "usb")) {
+            if (uevent->device_name) {
+                /*
+                 * create device node provided by kernel if present
+                 * see drivers/base/core.c
+                 */
+                char *p = devpath;
+                snprintf(devpath, sizeof(devpath), "/dev/%s", uevent->device_name);
+                /* skip leading /dev/ */
+                p += 5;
+                /* build directories */
+                while (*p) {
+                    if (*p == '/') {
+                        *p = 0;
+                        make_dir(devpath, 0755);
+                        *p = '/';
+                    }
+                    p++;
+                }
+             }
+             else {
+                 /* This imitates the file system that would be created
+                  * if we were using devfs instead.
+                  * Minors are broken up into groups of 128, starting at "001"
+                  */
+                 int bus_id = uevent->minor / 128 + 1;
+                 int device_id = uevent->minor % 128 + 1;
+                 /* build directories */
+                 make_dir("/dev/bus", 0755);
+                 make_dir("/dev/bus/usb", 0755);
+                 snprintf(devpath, sizeof(devpath), "/dev/bus/usb/%03d", bus_id);
+                 make_dir(devpath, 0755);
+                 snprintf(devpath, sizeof(devpath), "/dev/bus/usb/%03d/%03d", bus_id, device_id);
+             }
+         } else {
+             /* ignore other USB events */
+             return;
+         }
+     } else if (!strncmp(uevent->subsystem, "graphics", 8)) {
+         base = "/dev/graphics/";
+         make_dir(base, 0755);
+     } else if (!strncmp(uevent->subsystem, "oncrpc", 6)) {
+         base = "/dev/oncrpc/";
+         make_dir(base, 0755);
+     } else if (!strncmp(uevent->subsystem, "adsp", 4)) {
+         base = "/dev/adsp/";
+         make_dir(base, 0755);
+     } else if (!strncmp(uevent->subsystem, "msm_camera", 10)) {
+         base = "/dev/msm_camera/";
+         make_dir(base, 0755);
+     } else if(!strncmp(uevent->subsystem, "input", 5)) {
+         base = "/dev/input/";
+         make_dir(base, 0755);
+     } else if(!strncmp(uevent->subsystem, "mtd", 3)) {
+         base = "/dev/mtd/";
+         make_dir(base, 0755);
+     } else if(!strncmp(uevent->subsystem, "sound", 5)) {
+         base = "/dev/snd/";
+         make_dir(base, 0755);
+     } else if(!strncmp(uevent->subsystem, "misc", 4) &&
+                 !strncmp(name, "log_", 4)) {
+         base = "/dev/log/";
+         make_dir(base, 0755);
+         name += 4;
+     } else
+         base = "/dev/";
+     links = get_character_device_symlinks(uevent);
+
+     if (!devpath[0])
+         snprintf(devpath, sizeof(devpath), "%s%s", base, name);
+
+     handle_device(uevent->action, devpath, uevent->path, 0,
+             uevent->major, uevent->minor, links);
+}
+
+static void handle_device_event(struct uevent *uevent)
+{
+    if (!strcmp(uevent->action,"add"))
+        fixup_sys_perms(uevent->path);
+
+    if (!strncmp(uevent->subsystem, "block", 5)) {
+        handle_block_device_event(uevent);
+    } else if (!strncmp(uevent->subsystem, "platform", 8)) {
+        handle_platform_device_event(uevent);
+    } else {
+        handle_generic_device_event(uevent);
+    }
+}
+
+static int load_firmware(int fw_fd, int loading_fd, int data_fd)
+{
+    struct stat st;
+    long len_to_copy;
+    int ret = 0;
+
+    if(fstat(fw_fd, &st) < 0)
+        return -1;
+    len_to_copy = st.st_size;
+
+    write(loading_fd, "1", 1);  /* start transfer */
+
+    while (len_to_copy > 0) {
+        char buf[PAGE_SIZE];
+        ssize_t nr;
+
+        nr = read(fw_fd, buf, sizeof(buf));
+        if(!nr)
+            break;
+        if(nr < 0) {
+            ret = -1;
+            break;
+        }
+
+        len_to_copy -= nr;
+        while (nr > 0) {
+            ssize_t nw = 0;
+
+            nw = write(data_fd, buf + nw, nr);
+            if(nw <= 0) {
+                ret = -1;
+                goto out;
+            }
+            nr -= nw;
+        }
+    }
+
+out:
+    if(!ret)
+        write(loading_fd, "0", 1);  /* successful end of transfer */
+    else
+        write(loading_fd, "-1", 2); /* abort transfer */
+
+    return ret;
+}
+
+static int is_booting(void)
+{
+    return access("/dev/.booting", F_OK) == 0;
+}
+
+static void process_firmware_event(struct uevent *uevent)
+{
+    char *root, *loading, *data;
+    int l, loading_fd, data_fd, fw_fd, i;
+    int booting = is_booting();
+
+    DEBUG("firmware: loading '%s' for '%s'\n",
+         uevent->firmware, uevent->path);
+
+    l = asprintf(&root, SYSFS_PREFIX"%s/", uevent->path);
+    if (l == -1)
+        return;
+
+    l = asprintf(&loading, "%sloading", root);
+    if (l == -1)
+        goto root_free_out;
+
+    l = asprintf(&data, "%sdata", root);
+    if (l == -1)
+        goto loading_free_out;
+
+    loading_fd = open(loading, O_WRONLY | O_CLOEXEC);
+    if(loading_fd < 0)
+        goto data_free_out;
+
+    data_fd = open(data, O_WRONLY | O_CLOEXEC);
+    if(data_fd < 0)
+        goto loading_close_out;
+
+try_loading_again:
+    for (i = 0; i < ARRAY_SIZE(firmware_dirs); i++) {
+        char *file = NULL;
+        l = asprintf(&file, "%s/%s", firmware_dirs[i], uevent->firmware);
+        if (l == -1)
+            goto data_free_out;
+        fw_fd = open(file, O_RDONLY|O_CLOEXEC);
+        free(file);
+        if (fw_fd >= 0) {
+            if(!load_firmware(fw_fd, loading_fd, data_fd))
+                INFO("firmware: copy success { '%s', '%s' }\n", root, uevent->firmware);
+            else
+                INFO("firmware: copy failure { '%s', '%s' }\n", root, uevent->firmware);
+            break;
+        }
+    }
+
+    if (fw_fd < 0) {
+// disable for multirom to prevent loop
+#if 0
+        if (booting) {
+            /* If we're not fully booted, we may be missing
+             * filesystems needed for firmware, wait and retry.
+             */
+            usleep(100000);
+            booting = is_booting();
+            goto try_loading_again;
+        }
+#endif
+        INFO("firmware: could not open '%s': %s\n", uevent->firmware, strerror(errno));
+        write(loading_fd, "-1", 2);
+        goto data_close_out;
+    }
+
+    close(fw_fd);
+data_close_out:
+    close(data_fd);
+loading_close_out:
+    close(loading_fd);
+data_free_out:
+    free(data);
+loading_free_out:
+    free(loading);
+root_free_out:
+    free(root);
+}
+
+static void handle_firmware_event(struct uevent *uevent)
+{
+    pid_t pid;
+    int ret;
+
+    if(strcmp(uevent->subsystem, "firmware"))
+        return;
+
+    if(strcmp(uevent->action, "add"))
+        return;
+
+    /* we fork, to avoid making large memory allocations in init proper */
+    pid = fork();
+    if (!pid) {
+        process_firmware_event(uevent);
+        _exit(EXIT_SUCCESS);
+    } else if (pid < 0) {
+        log_event_print("could not fork to process firmware event: %s\n", strerror(errno));
+    }
+}
+
+#define UEVENT_MSG_LEN  2048
+void handle_device_fd(void)
+{
+    char msg[UEVENT_MSG_LEN+2];
+    int n;
+    while ((n = uevent_kernel_multicast_recv(device_fd, msg, UEVENT_MSG_LEN)) > 0) {
+        if(n >= UEVENT_MSG_LEN)   /* overflow -- discard */
+            continue;
+
+        msg[n] = '\0';
+        msg[n+1] = '\0';
+
+        struct uevent uevent;
+        parse_event(msg, &uevent);
+
+        handle_device_event(&uevent);
+        handle_firmware_event(&uevent);
+    }
+}
+
+int get_device_fd()
+{
+    return device_fd;
+}
diff --git a/trampoline/devices.h b/trampoline/devices.h
index d6ba64b..e842232 100755
--- a/trampoline/devices.h
+++ b/trampoline/devices.h
@@ -1,15 +1,15 @@
-#ifndef DEVICES_H
-#define DEVICES_H
-
-void devices_init(void);
-
-#include <sys/stat.h>
-
-extern void devices_close(void);
-extern void handle_device_fd(void);
-extern int add_dev_perms(const char *name, const char *attr,
-                         mode_t perm, unsigned int uid,
-                         unsigned int gid, unsigned short prefix);
-int get_device_fd(void);
-
+#ifndef DEVICES_H
+#define DEVICES_H
+
+void devices_init(void);
+
+#include <sys/stat.h>
+
+extern void devices_close(void);
+extern void handle_device_fd(void);
+extern int add_dev_perms(const char *name, const char *attr,
+                         mode_t perm, unsigned int uid,
+                         unsigned int gid, unsigned short prefix);
+int get_device_fd(void);
+
 #endif
\ No newline at end of file
diff --git a/trampoline/encryption.c b/trampoline/encryption.c
index 8954638..3ec5605 100755
--- a/trampoline/encryption.c
+++ b/trampoline/encryption.c
@@ -1,164 +1,164 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <ctype.h>
-#include <stdio.h>
-#include <sys/mount.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <errno.h>
-
-#include <string.h>
-
-#include "../lib/fstab.h"
-#include "../lib/util.h"
-#include "../lib/log.h"
-#include "encryption.h"
-#include "../trampoline_encmnt/encmnt_defines.h"
-
-static char encmnt_cmd_arg[64] = { 0 };
-static char *const encmnt_cmd[] = { "/mrom_enc/trampoline_encmnt", encmnt_cmd_arg, NULL };
-static char *const encmnt_envp[] = { "LD_LIBRARY_PATH=/mrom_enc/", NULL };
-static int g_decrypted = 0;
-
-int encryption_before_mount(struct fstab *fstab)
-{
-    int exit_code = -1;
-    char *output = NULL, *itr;
-    int res = ENC_RES_ERR;
-
-    mkdir_recursive("/system/bin", 0755);
-    remove("/system/bin/linker");
-    symlink("/mrom_enc/linker", "/system/bin/linker");
-    chmod("/mrom_enc/linker", 0775);
-    chmod("/mrom_enc/trampoline_encmnt", 0775);
-
-#ifdef MR_USE_KEYMASTER
-    //ANCLARK MODIFIED 2017-4-7
-    // Prepare keystore library
-#if defined(__LP64__)
-    remove("/system/lib64");
-    mkdir_recursive("/system/lib64/hw", 0755);
-    symlink("/mrom_enc/keystore.default.so", "/system/lib64/hw/keystore.default.so");
-#else
-    remove("/system/lib");
-    mkdir_recursive("/system/lib/hw", 0755);
-    symlink("/mrom_enc/keystore.default.so", "/system/lib/hw/keystore.default.so");
-#endif
-
-#endif
-
-    remove("/vendor");
-    symlink("/mrom_enc/vendor", "/vendor");
-
-    mkdir("/firmware", 0775);
-    struct fstab_part *fwpart = fstab_find_first_by_path(fstab, "/firmware");
-    if(fwpart && strcmp(fwpart->type, "emmc") != 0)
-    {
-        if(mount(fwpart->device, "/firmware", fwpart->type, fwpart->mountflags, NULL) < 0)
-            ERROR("Mounting /firmware for encryption failed with %s\n", strerror(errno));
-    }
-
-    INFO("Running trampoline_encmnt\n");
-
-    strcpy(encmnt_cmd_arg, "decrypt");
-    output = run_get_stdout_with_exit_with_env(encmnt_cmd, &exit_code, encmnt_envp);
-    if(exit_code != 0 || !output)
-    {
-        ERROR("Failed to run trampoline_encmnt, exit code %d: %s\n", exit_code, output);
-        goto exit;
-    }
-
-    itr = output + strlen(output) - 1;
-    while(itr >= output && isspace(*itr))
-        *itr-- = 0;
-
-    if(strcmp(output, ENCMNT_BOOT_INTERNAL_OUTPUT) == 0)
-    {
-        INFO("trampoline_encmnt requested to boot internal ROM.\n");
-        res = ENC_RES_BOOT_INTERNAL;
-        goto exit;
-    }
-
-    if(!strstartswith(output, "/dev"))
-    {
-        ERROR("Invalid trampoline_encmnt output: %s\n", output);
-        goto exit;
-    }
-
-    g_decrypted = 1;
-
-    struct fstab_part *datap = fstab_find_first_by_path(fstab, "/data");
-    if(!datap)
-    {
-        ERROR("Failed to find /data in fstab!\n");
-        goto exit;
-    }
-
-    INFO("Updating device %s to %s in fstab due to encryption.\n", datap->device, output);
-    fstab_update_device(fstab, datap->device, output);
-
-    res = ENC_RES_OK;
-exit:
-    free(output);
-    return res;
-}
-
-void encryption_destroy(void)
-{
-    int res = -1;
-    int exit_code = -1;
-    char *output = NULL;
-    struct stat info;
-
-    if(g_decrypted)
-    {
-        strcpy(encmnt_cmd_arg, "remove");
-        output = run_get_stdout_with_exit_with_env(encmnt_cmd, &exit_code, encmnt_envp);
-        if(exit_code != 0)
-            ERROR("Failed to run trampoline_encmnt: %s\n", output);
-        g_decrypted = 0;
-        free(output);
-    }
-
-    // Make sure we're removing our symlink and not ROM's linker
-    if(lstat("/system/bin/linker", &info) >= 0 && S_ISLNK(info.st_mode))
-        remove("/system/bin/linker");
-}
-
-int encryption_cleanup(void)
-{
-    remove("/vendor");
-
-#ifdef MR_USE_KEYMASTER
-
-#if defined(__LP64__)
-    remove("/system/lib64");
-#else
-    remove("/system/lib");
-#endif
-
-#endif
-
-    if(access("/firmware", R_OK) >= 0 && umount("/firmware") < 0)
-        ERROR("encryption_cleanup: failed to unmount /firmware: %s\n", strerror(errno));
-
-    rmdir("/firmware");
-    return 0;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <sys/mount.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+
+#include <string.h>
+
+#include "../lib/fstab.h"
+#include "../lib/util.h"
+#include "../lib/log.h"
+#include "encryption.h"
+#include "../trampoline_encmnt/encmnt_defines.h"
+
+static char encmnt_cmd_arg[64] = { 0 };
+static char *const encmnt_cmd[] = { "/mrom_enc/trampoline_encmnt", encmnt_cmd_arg, NULL };
+static char *const encmnt_envp[] = { "LD_LIBRARY_PATH=/mrom_enc/", NULL };
+static int g_decrypted = 0;
+
+int encryption_before_mount(struct fstab *fstab)
+{
+    int exit_code = -1;
+    char *output = NULL, *itr;
+    int res = ENC_RES_ERR;
+
+    mkdir_recursive("/system/bin", 0755);
+    remove("/system/bin/linker");
+    symlink("/mrom_enc/linker", "/system/bin/linker");
+    chmod("/mrom_enc/linker", 0775);
+    chmod("/mrom_enc/trampoline_encmnt", 0775);
+
+#ifdef MR_USE_KEYMASTER
+    //ANCLARK MODIFIED 2017-4-7
+    // Prepare keystore library
+#if defined(__LP64__)
+    remove("/system/lib64");
+    mkdir_recursive("/system/lib64/hw", 0755);
+    symlink("/mrom_enc/keystore.default.so", "/system/lib64/hw/keystore.default.so");
+#else
+    remove("/system/lib");
+    mkdir_recursive("/system/lib/hw", 0755);
+    symlink("/mrom_enc/keystore.default.so", "/system/lib/hw/keystore.default.so");
+#endif
+
+#endif
+
+    remove("/vendor");
+    symlink("/mrom_enc/vendor", "/vendor");
+
+    mkdir("/firmware", 0775);
+    struct fstab_part *fwpart = fstab_find_first_by_path(fstab, "/firmware");
+    if(fwpart && strcmp(fwpart->type, "emmc") != 0)
+    {
+        if(mount(fwpart->device, "/firmware", fwpart->type, fwpart->mountflags, NULL) < 0)
+            ERROR("Mounting /firmware for encryption failed with %s\n", strerror(errno));
+    }
+
+    INFO("Running trampoline_encmnt\n");
+
+    strcpy(encmnt_cmd_arg, "decrypt");
+    output = run_get_stdout_with_exit_with_env(encmnt_cmd, &exit_code, encmnt_envp);
+    if(exit_code != 0 || !output)
+    {
+        ERROR("Failed to run trampoline_encmnt, exit code %d: %s\n", exit_code, output);
+        goto exit;
+    }
+
+    itr = output + strlen(output) - 1;
+    while(itr >= output && isspace(*itr))
+        *itr-- = 0;
+
+    if(strcmp(output, ENCMNT_BOOT_INTERNAL_OUTPUT) == 0)
+    {
+        INFO("trampoline_encmnt requested to boot internal ROM.\n");
+        res = ENC_RES_BOOT_INTERNAL;
+        goto exit;
+    }
+
+    if(!strstartswith(output, "/dev"))
+    {
+        ERROR("Invalid trampoline_encmnt output: %s\n", output);
+        goto exit;
+    }
+
+    g_decrypted = 1;
+
+    struct fstab_part *datap = fstab_find_first_by_path(fstab, "/data");
+    if(!datap)
+    {
+        ERROR("Failed to find /data in fstab!\n");
+        goto exit;
+    }
+
+    INFO("Updating device %s to %s in fstab due to encryption.\n", datap->device, output);
+    fstab_update_device(fstab, datap->device, output);
+
+    res = ENC_RES_OK;
+exit:
+    free(output);
+    return res;
+}
+
+void encryption_destroy(void)
+{
+    int res = -1;
+    int exit_code = -1;
+    char *output = NULL;
+    struct stat info;
+
+    if(g_decrypted)
+    {
+        strcpy(encmnt_cmd_arg, "remove");
+        output = run_get_stdout_with_exit_with_env(encmnt_cmd, &exit_code, encmnt_envp);
+        if(exit_code != 0)
+            ERROR("Failed to run trampoline_encmnt: %s\n", output);
+        g_decrypted = 0;
+        free(output);
+    }
+
+    // Make sure we're removing our symlink and not ROM's linker
+    if(lstat("/system/bin/linker", &info) >= 0 && S_ISLNK(info.st_mode))
+        remove("/system/bin/linker");
+}
+
+int encryption_cleanup(void)
+{
+    remove("/vendor");
+
+#ifdef MR_USE_KEYMASTER
+
+#if defined(__LP64__)
+    remove("/system/lib64");
+#else
+    remove("/system/lib");
+#endif
+
+#endif
+
+    if(access("/firmware", R_OK) >= 0 && umount("/firmware") < 0)
+        ERROR("encryption_cleanup: failed to unmount /firmware: %s\n", strerror(errno));
+
+    rmdir("/firmware");
+    return 0;
+}
diff --git a/trampoline/encryption.h b/trampoline/encryption.h
index 5a1b300..641f388 100755
--- a/trampoline/encryption.h
+++ b/trampoline/encryption.h
@@ -1,35 +1,35 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef ENCRYPTION_H
-#define ENCRYPTION_H
-
-#define ENC_RES_ERR -1
-#define ENC_RES_OK 0
-#define ENC_RES_BOOT_INTERNAL 1
-
-#ifdef MR_ENCRYPTION
-int encryption_before_mount(struct fstab *fstab);
-void encryption_destroy(void);
-int encryption_cleanup(void);
-#else
-int encryption_before_mount(struct fstab *fstab) { return ENC_RES_OK; }
-void encryption_destroy(void) { }
-int encryption_cleanup(void) { return 0; }
-#endif
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef ENCRYPTION_H
+#define ENCRYPTION_H
+
+#define ENC_RES_ERR -1
+#define ENC_RES_OK 0
+#define ENC_RES_BOOT_INTERNAL 1
+
+#ifdef MR_ENCRYPTION
+int encryption_before_mount(struct fstab *fstab);
+void encryption_destroy(void);
+int encryption_cleanup(void);
+#else
+int encryption_before_mount(struct fstab *fstab) { return ENC_RES_OK; }
+void encryption_destroy(void) { }
+int encryption_cleanup(void) { return 0; }
+#endif
+
+#endif
diff --git a/trampoline/trampoline.c b/trampoline/trampoline.c
index 2d002c0..b9a10e9 100755
--- a/trampoline/trampoline.c
+++ b/trampoline/trampoline.c
@@ -1,393 +1,393 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <sys/stat.h>
-#include <sys/mount.h>
-#include <errno.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/wait.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <cutils/android_reboot.h>
-
-#include "devices.h"
-#include "../lib/log.h"
-#include "../lib/util.h"
-#include "../lib/fstab.h"
-#include "../lib/inject.h"
-#include "../version.h"
-#include "adb.h"
-#include "../hooks.h"
-#include "encryption.h"
-
-#define EXEC_MASK (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)
-#define REALDATA "/realdata"
-#define MULTIROM_BIN "multirom"
-#define BUSYBOX_BIN "busybox"
-#define KEEP_REALDATA "/dev/.keep_realdata"
-
-// Not defined in android includes?
-#define MS_RELATIME (1<<21)
-
-static char path_multirom[64] = { 0 };
-
-static int find_multirom(void)
-{
-    int i;
-    struct stat info;
-
-    static const char *paths[] = {
-        REALDATA"/media/0/multirom", // 4.2
-        REALDATA"/media/multirom",
-        NULL,
-    };
-
-    for(i = 0; paths[i]; ++i)
-    {
-        if(stat(paths[i], &info) < 0)
-            continue;
-
-        strcpy(path_multirom, paths[i]);
-        return 0;
-    }
-    return -1;
-}
-
-static void run_multirom(void)
-{
-    char path[256];
-    struct stat info;
-
-    // busybox
-    sprintf(path, "%s/%s", path_multirom, BUSYBOX_BIN);
-    if (stat(path, &info) < 0)
-    {
-        ERROR("Could not find busybox: %s\n", path);
-        return;
-    }
-    chmod(path, EXEC_MASK);
-
-    // restart after crash
-    sprintf(path, "%s/restart_after_crash", path_multirom);
-    int restart = (stat(path, &info) >= 0);
-
-    // multirom
-    sprintf(path, "%s/%s", path_multirom, MULTIROM_BIN);
-    if (stat(path, &info) < 0)
-    {
-        ERROR("Could not find multirom: %s\n", path);
-        return;
-    }
-    chmod(path, EXEC_MASK);
-
-    char *cmd[] = { path, NULL };
-    do
-    {
-        ERROR("Running multirom\n");
-        int res = run_cmd(cmd);
-        if(res == 0)
-            break;
-        else
-            ERROR("MultiROM exited with status code %d!\n", res);
-    }
-    while(restart);
-}
-
-static int try_mount_all_entries(struct fstab *fstab, struct fstab_part *first_data_p)
-{
-    size_t i;
-    struct fstab_part *p_itr = first_data_p;
-
-    do
-    {
-        // Remove nosuid flag, because secondary ROMs have
-        // su binaries on /data
-        p_itr->mountflags &= ~(MS_NOSUID);
-
-        if(mount(p_itr->device, REALDATA, p_itr->type, p_itr->mountflags, p_itr->options) >= 0)
-            return 0;
-    }
-    while((p_itr = fstab_find_next_by_path(fstab, "/data", p_itr)));
-
-    ERROR("Failed to mount /realdata with data from fstab, trying all filesystems\n");
-
-    const char *fs_types[] = { "ext4", "f2fs", "ext3", "ext2" };
-    const char *fs_opts [] = {
-        "barrier=1,data=ordered,nomblk_io_submit,noauto_da_alloc,errors=panic", // ext4
-        "inline_xattr,flush_merge,errors=recover", // f2fs
-        "", // ext3
-        "" // ext2
-    };
-
-    for(i = 0; i < ARRAY_SIZE(fs_types); ++i)
-    {
-        if(mount(first_data_p->device, REALDATA, fs_types[i], first_data_p->mountflags, fs_opts[i]) >= 0)
-        {
-            INFO("/realdata successfuly mounted with fs %s\n", fs_types[i]);
-            return 0;
-        }
-    }
-
-    return -1;
-}
-
-static int mount_and_run(struct fstab *fstab)
-{
-    struct fstab_part *datap = fstab_find_first_by_path(fstab, "/data");
-    if(!datap)
-    {
-        ERROR("Failed to find /data partition in fstab\n");
-        return -1;
-    }
-
-    if(access(datap->device, R_OK) < 0)
-    {
-        INFO("Waiting for %s\n", datap->device);
-        if(wait_for_file(datap->device, 5) < 0)
-        {
-            ERROR("Waiting too long for dev %s\n", datap->device);
-            return -1;
-        }
-    }
-
-    mkdir(REALDATA, 0755);
-
-    if(try_mount_all_entries(fstab, datap) < 0)
-    {
-#ifndef MR_ENCRYPTION
-        ERROR("Failed to mount /data with all possible filesystems!\n");
-        return -1;
-#else
-        INFO("Failed to mount /data, trying encryption...\n");
-        switch(encryption_before_mount(fstab))
-        {
-            case ENC_RES_ERR:
-                ERROR("/data decryption failed!\n");
-                return -1;
-            case ENC_RES_BOOT_INTERNAL:
-                return 0;
-            default:
-            case ENC_RES_OK:
-            {
-                if(try_mount_all_entries(fstab, datap) < 0)
-                {
-                    ERROR("Failed to mount decrypted /data with all possible filesystems!\n");
-                    return -1;
-                }
-                break;
-            }
-        }
-#endif
-    }
-
-    if(find_multirom() == -1)
-    {
-        ERROR("Could not find multirom folder!\n");
-        return -1;
-    }
-
-    adb_init(path_multirom);
-    run_multirom();
-    adb_quit();
-    return 0;
-}
-
-static int is_charger_mode(void)
-{
-    char buff[2048] = { 0 };
-
-    FILE *f = fopen("/proc/cmdline", "re");
-    if(!f)
-        return 0;
-
-    fgets(buff, sizeof(buff), f);
-    fclose(f);
-
-    return (strstr(buff, "androidboot.mode=charger") != NULL);
-}
-
-static void fixup_symlinks(void)
-{
-    static const char *init_links[] = { "/sbin/ueventd", "/sbin/watchdogd" };
-
-    size_t i;
-    ssize_t len;
-    char buff[64];
-    struct stat info;
-
-    for(i = 0; i < ARRAY_SIZE(init_links); ++i)
-    {
-        if(lstat(init_links[i], &info) < 0 || !S_ISLNK(info.st_mode))
-            continue;
-
-        if (info.st_size < sizeof(buff)-1)
-        {
-            len = readlink(init_links[i], buff, sizeof(buff)-1);
-            if(len >= 0)
-            {
-                buff[len] = 0;
-                // if the symlink already points to ../init, skip it.
-                if(strcmp(buff, "../init") == 0)
-                    continue;
-            }
-        }
-
-        ERROR("Fixing up symlink '%s' -> '%s' to '%s' -> '../init')\n", init_links[i], buff, init_links[i]);
-        unlink(init_links[i]);
-        symlink("../init", init_links[i]);
-    }
-}
-
-int main(int argc, char *argv[])
-{
-    int i, res;
-    static char *const cmd[] = { "/init", NULL };
-    struct fstab *fstab = NULL;
-    char *inject_path = NULL;
-    char *mrom_dir = NULL;
-    int force_inject = 0;
-
-    for(i = 1; i < argc; ++i)
-    {
-        if(strcmp(argv[i], "-v") == 0)
-        {
-            printf("%d\n", VERSION_TRAMPOLINE);
-            fflush(stdout);
-            return 0;
-        }
-        else if(strstartswith(argv[i], "--inject="))
-            inject_path = argv[i] + strlen("--inject=");
-        else if(strstartswith(argv[i], "--mrom_dir="))
-            mrom_dir = argv[i] + strlen("--mrom_dir=");
-        else if(strcmp(argv[i], "-f") == 0)
-            force_inject = 1;
-    }
-
-    if(inject_path)
-    {
-        if(!mrom_dir)
-        {
-            printf("--mrom_dir=[path to multirom's data dir] needs to be specified!\n");
-            fflush(stdout);
-            return 1;
-        }
-
-        mrom_set_dir(mrom_dir);
-        mrom_set_log_tag("trampoline_inject");
-        return inject_bootimg(inject_path, force_inject);
-    }
-
-    umask(000);
-
-    // Init only the little we need, leave the rest for real init
-    mkdir("/dev", 0755);
-    mkdir("/dev/pts", 0755);
-    mkdir("/dev/socket", 0755);
-    mkdir("/proc", 0755);
-    mkdir("/sys", 0755);
-
-    mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
-    mount("devpts", "/dev/pts", "devpts", 0, NULL);
-    mount("proc", "/proc", "proc", 0, NULL);
-    mount("sysfs", "/sys", "sysfs", 0, NULL);
-    mount("pstore", "/sys/fs/pstore", "pstore", 0, NULL);
-
-    klog_init();
-    // output all messages to dmesg,
-    // but it is possible to filter out INFO messages
-    klog_set_level(6);
-
-    mrom_set_log_tag("trampoline");
-    INFO("Running trampoline v%d\n", VERSION_TRAMPOLINE);
-
-    if(is_charger_mode())
-    {
-        INFO("Charger mode detected, skipping multirom\n");
-        goto run_main_init;
-    }
-
-#if MR_DEVICE_HOOKS >= 3
-    tramp_hook_before_device_init();
-#endif
-
-    INFO("Initializing devices...\n");
-    devices_init();
-    INFO("Done initializing\n");
-
-    if(wait_for_file("/dev/graphics/fb0", 5) < 0)
-    {
-        ERROR("Waiting too long for fb0");
-        goto exit;
-    }
-
-    fstab = fstab_auto_load();
-    if(!fstab)
-        goto exit;
-
-#if 0
-    fstab_dump(fstab); //debug
-#endif
-
-    // mount and run multirom from sdcard
-    if(mount_and_run(fstab) < 0 && mrom_is_second_boot())
-    {
-        ERROR("This is second boot and we couldn't mount /data, reboot!\n");
-        sync();
-        android_reboot(ANDROID_RB_RESTART, 0, 0);
-        while(1)
-            sleep(1);
-    }
-
-exit:
-    if(fstab)
-        fstab_destroy(fstab);
-
-    // close and destroy everything
-    devices_close();
-
-run_main_init:
-    umount("/dev/pts");
-    rmdir("/dev/pts");
-    rmdir("/dev/socket");
-
-    if(access(KEEP_REALDATA, F_OK) < 0)
-    {
-        umount(REALDATA);
-        umount("/dev");
-        rmdir(REALDATA);
-        encryption_destroy();
-    }
-
-    encryption_cleanup();
-
-    umount("/proc");
-    umount("/sys/fs/pstore");
-    umount("/sys");
-
-    INFO("Running main_init\n");
-
-    fixup_symlinks();
-
-    chmod("/main_init", EXEC_MASK);
-    rename("/main_init", "/init");
-
-    res = execve(cmd[0], cmd, NULL);
-    ERROR("execve returned %d %d %s\n", res, errno, strerror(errno));
-    return 0;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/wait.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <cutils/android_reboot.h>
+
+#include "devices.h"
+#include "../lib/log.h"
+#include "../lib/util.h"
+#include "../lib/fstab.h"
+#include "../lib/inject.h"
+#include "../version.h"
+#include "adb.h"
+#include "../hooks.h"
+#include "encryption.h"
+
+#define EXEC_MASK (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)
+#define REALDATA "/realdata"
+#define MULTIROM_BIN "multirom"
+#define BUSYBOX_BIN "busybox"
+#define KEEP_REALDATA "/dev/.keep_realdata"
+
+// Not defined in android includes?
+#define MS_RELATIME (1<<21)
+
+static char path_multirom[64] = { 0 };
+
+static int find_multirom(void)
+{
+    int i;
+    struct stat info;
+
+    static const char *paths[] = {
+        REALDATA"/media/0/multirom", // 4.2
+        REALDATA"/media/multirom",
+        NULL,
+    };
+
+    for(i = 0; paths[i]; ++i)
+    {
+        if(stat(paths[i], &info) < 0)
+            continue;
+
+        strcpy(path_multirom, paths[i]);
+        return 0;
+    }
+    return -1;
+}
+
+static void run_multirom(void)
+{
+    char path[256];
+    struct stat info;
+
+    // busybox
+    sprintf(path, "%s/%s", path_multirom, BUSYBOX_BIN);
+    if (stat(path, &info) < 0)
+    {
+        ERROR("Could not find busybox: %s\n", path);
+        return;
+    }
+    chmod(path, EXEC_MASK);
+
+    // restart after crash
+    sprintf(path, "%s/restart_after_crash", path_multirom);
+    int restart = (stat(path, &info) >= 0);
+
+    // multirom
+    sprintf(path, "%s/%s", path_multirom, MULTIROM_BIN);
+    if (stat(path, &info) < 0)
+    {
+        ERROR("Could not find multirom: %s\n", path);
+        return;
+    }
+    chmod(path, EXEC_MASK);
+
+    char *cmd[] = { path, NULL };
+    do
+    {
+        ERROR("Running multirom\n");
+        int res = run_cmd(cmd);
+        if(res == 0)
+            break;
+        else
+            ERROR("MultiROM exited with status code %d!\n", res);
+    }
+    while(restart);
+}
+
+static int try_mount_all_entries(struct fstab *fstab, struct fstab_part *first_data_p)
+{
+    size_t i;
+    struct fstab_part *p_itr = first_data_p;
+
+    do
+    {
+        // Remove nosuid flag, because secondary ROMs have
+        // su binaries on /data
+        p_itr->mountflags &= ~(MS_NOSUID);
+
+        if(mount(p_itr->device, REALDATA, p_itr->type, p_itr->mountflags, p_itr->options) >= 0)
+            return 0;
+    }
+    while((p_itr = fstab_find_next_by_path(fstab, "/data", p_itr)));
+
+    ERROR("Failed to mount /realdata with data from fstab, trying all filesystems\n");
+
+    const char *fs_types[] = { "ext4", "f2fs", "ext3", "ext2" };
+    const char *fs_opts [] = {
+        "barrier=1,data=ordered,nomblk_io_submit,noauto_da_alloc,errors=panic", // ext4
+        "inline_xattr,flush_merge,errors=recover", // f2fs
+        "", // ext3
+        "" // ext2
+    };
+
+    for(i = 0; i < ARRAY_SIZE(fs_types); ++i)
+    {
+        if(mount(first_data_p->device, REALDATA, fs_types[i], first_data_p->mountflags, fs_opts[i]) >= 0)
+        {
+            INFO("/realdata successfuly mounted with fs %s\n", fs_types[i]);
+            return 0;
+        }
+    }
+
+    return -1;
+}
+
+static int mount_and_run(struct fstab *fstab)
+{
+    struct fstab_part *datap = fstab_find_first_by_path(fstab, "/data");
+    if(!datap)
+    {
+        ERROR("Failed to find /data partition in fstab\n");
+        return -1;
+    }
+
+    if(access(datap->device, R_OK) < 0)
+    {
+        INFO("Waiting for %s\n", datap->device);
+        if(wait_for_file(datap->device, 5) < 0)
+        {
+            ERROR("Waiting too long for dev %s\n", datap->device);
+            return -1;
+        }
+    }
+
+    mkdir(REALDATA, 0755);
+
+    if(try_mount_all_entries(fstab, datap) < 0)
+    {
+#ifndef MR_ENCRYPTION
+        ERROR("Failed to mount /data with all possible filesystems!\n");
+        return -1;
+#else
+        INFO("Failed to mount /data, trying encryption...\n");
+        switch(encryption_before_mount(fstab))
+        {
+            case ENC_RES_ERR:
+                ERROR("/data decryption failed!\n");
+                return -1;
+            case ENC_RES_BOOT_INTERNAL:
+                return 0;
+            default:
+            case ENC_RES_OK:
+            {
+                if(try_mount_all_entries(fstab, datap) < 0)
+                {
+                    ERROR("Failed to mount decrypted /data with all possible filesystems!\n");
+                    return -1;
+                }
+                break;
+            }
+        }
+#endif
+    }
+
+    if(find_multirom() == -1)
+    {
+        ERROR("Could not find multirom folder!\n");
+        return -1;
+    }
+
+    adb_init(path_multirom);
+    run_multirom();
+    adb_quit();
+    return 0;
+}
+
+static int is_charger_mode(void)
+{
+    char buff[2048] = { 0 };
+
+    FILE *f = fopen("/proc/cmdline", "re");
+    if(!f)
+        return 0;
+
+    fgets(buff, sizeof(buff), f);
+    fclose(f);
+
+    return (strstr(buff, "androidboot.mode=charger") != NULL);
+}
+
+static void fixup_symlinks(void)
+{
+    static const char *init_links[] = { "/sbin/ueventd", "/sbin/watchdogd" };
+
+    size_t i;
+    ssize_t len;
+    char buff[64];
+    struct stat info;
+
+    for(i = 0; i < ARRAY_SIZE(init_links); ++i)
+    {
+        if(lstat(init_links[i], &info) < 0 || !S_ISLNK(info.st_mode))
+            continue;
+
+        if (info.st_size < sizeof(buff)-1)
+        {
+            len = readlink(init_links[i], buff, sizeof(buff)-1);
+            if(len >= 0)
+            {
+                buff[len] = 0;
+                // if the symlink already points to ../init, skip it.
+                if(strcmp(buff, "../init") == 0)
+                    continue;
+            }
+        }
+
+        ERROR("Fixing up symlink '%s' -> '%s' to '%s' -> '../init')\n", init_links[i], buff, init_links[i]);
+        unlink(init_links[i]);
+        symlink("../init", init_links[i]);
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    int i, res;
+    static char *const cmd[] = { "/init", NULL };
+    struct fstab *fstab = NULL;
+    char *inject_path = NULL;
+    char *mrom_dir = NULL;
+    int force_inject = 0;
+
+    for(i = 1; i < argc; ++i)
+    {
+        if(strcmp(argv[i], "-v") == 0)
+        {
+            printf("%d\n", VERSION_TRAMPOLINE);
+            fflush(stdout);
+            return 0;
+        }
+        else if(strstartswith(argv[i], "--inject="))
+            inject_path = argv[i] + strlen("--inject=");
+        else if(strstartswith(argv[i], "--mrom_dir="))
+            mrom_dir = argv[i] + strlen("--mrom_dir=");
+        else if(strcmp(argv[i], "-f") == 0)
+            force_inject = 1;
+    }
+
+    if(inject_path)
+    {
+        if(!mrom_dir)
+        {
+            printf("--mrom_dir=[path to multirom's data dir] needs to be specified!\n");
+            fflush(stdout);
+            return 1;
+        }
+
+        mrom_set_dir(mrom_dir);
+        mrom_set_log_tag("trampoline_inject");
+        return inject_bootimg(inject_path, force_inject);
+    }
+
+    umask(000);
+
+    // Init only the little we need, leave the rest for real init
+    mkdir("/dev", 0755);
+    mkdir("/dev/pts", 0755);
+    mkdir("/dev/socket", 0755);
+    mkdir("/proc", 0755);
+    mkdir("/sys", 0755);
+
+    mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
+    mount("devpts", "/dev/pts", "devpts", 0, NULL);
+    mount("proc", "/proc", "proc", 0, NULL);
+    mount("sysfs", "/sys", "sysfs", 0, NULL);
+    mount("pstore", "/sys/fs/pstore", "pstore", 0, NULL);
+
+    klog_init();
+    // output all messages to dmesg,
+    // but it is possible to filter out INFO messages
+    klog_set_level(6);
+
+    mrom_set_log_tag("trampoline");
+    INFO("Running trampoline v%d\n", VERSION_TRAMPOLINE);
+
+    if(is_charger_mode())
+    {
+        INFO("Charger mode detected, skipping multirom\n");
+        goto run_main_init;
+    }
+
+#if MR_DEVICE_HOOKS >= 3
+    tramp_hook_before_device_init();
+#endif
+
+    INFO("Initializing devices...\n");
+    devices_init();
+    INFO("Done initializing\n");
+
+    if(wait_for_file("/dev/graphics/fb0", 5) < 0)
+    {
+        ERROR("Waiting too long for fb0");
+        goto exit;
+    }
+
+    fstab = fstab_auto_load();
+    if(!fstab)
+        goto exit;
+
+#if 0
+    fstab_dump(fstab); //debug
+#endif
+
+    // mount and run multirom from sdcard
+    if(mount_and_run(fstab) < 0 && mrom_is_second_boot())
+    {
+        ERROR("This is second boot and we couldn't mount /data, reboot!\n");
+        sync();
+        android_reboot(ANDROID_RB_RESTART, 0, 0);
+        while(1)
+            sleep(1);
+    }
+
+exit:
+    if(fstab)
+        fstab_destroy(fstab);
+
+    // close and destroy everything
+    devices_close();
+
+run_main_init:
+    umount("/dev/pts");
+    rmdir("/dev/pts");
+    rmdir("/dev/socket");
+
+    if(access(KEEP_REALDATA, F_OK) < 0)
+    {
+        umount(REALDATA);
+        umount("/dev");
+        rmdir(REALDATA);
+        encryption_destroy();
+    }
+
+    encryption_cleanup();
+
+    umount("/proc");
+    umount("/sys/fs/pstore");
+    umount("/sys");
+
+    INFO("Running main_init\n");
+
+    fixup_symlinks();
+
+    chmod("/main_init", EXEC_MASK);
+    rename("/main_init", "/init");
+
+    res = execve(cmd[0], cmd, NULL);
+    ERROR("execve returned %d %d %s\n", res, errno, strerror(errno));
+    return 0;
+}
diff --git a/trampoline_encmnt/Android.mk b/trampoline_encmnt/Android.mk
index 857dcbc..76ed9e7 100755
--- a/trampoline_encmnt/Android.mk
+++ b/trampoline_encmnt/Android.mk
@@ -1,42 +1,42 @@
-LOCAL_PATH:= $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE:= trampoline_encmnt
-LOCAL_MODULE_TAGS := eng
-LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
-LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
-
-# AnClark Modified on 2017-4-3
-# Add dependencies for those libraries
-# TODO: Too many dependencies derive from libcryptfslollipop -> libcryptfs_hw -> libutils.
-LOCAL_SHARED_LIBRARIES := libcryptfslollipop libcutils libcryptfs_hw libhardware
-LOCAL_STATIC_LIBRARIES := libmultirom_static
-LOCAL_WHOLE_STATIC_LIBRARIES := libm libpng libz libft2_mrom_static
-
-
-ifneq ($(wildcard bootable/recovery/crypto/lollipop/cryptfs.h),)
-    mr_twrp_path := bootable/recovery
-else ifneq ($(wildcard bootable/recovery-twrp/crypto/lollipop/cryptfs.h),)
-    mr_twrp_path := bootable/recovery-twrp
-else
-    $(error Failed to find path to TWRP, which is required to build MultiROM with encryption support)
-endif
-
-LOCAL_C_INCLUDES += $(multirom_local_path) $(mr_twrp_path) $(mr_twrp_path)/crypto/scrypt/lib/crypto external/openssl/include external/boringssl/include
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-
-LOCAL_SRC_FILES := \
-    encmnt.c \
-    pw_ui.c \
-    ../rom_quirks.c \
-
-include $(multirom_local_path)/device_defines.mk
-
-include $(BUILD_EXECUTABLE)
-
-
+LOCAL_PATH:= $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_MODULE:= trampoline_encmnt
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
+LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
+
+# AnClark Modified on 2017-4-3
+# Add dependencies for those libraries
+# TODO: Too many dependencies derive from libcryptfslollipop -> libcryptfs_hw -> libutils.
+LOCAL_SHARED_LIBRARIES := libcryptfslollipop libcutils libcryptfs_hw libhardware
+LOCAL_STATIC_LIBRARIES := libmultirom_static
+LOCAL_WHOLE_STATIC_LIBRARIES := libm libpng libz libft2_mrom_static
+
+
+ifneq ($(wildcard bootable/recovery/crypto/lollipop/cryptfs.h),)
+    mr_twrp_path := bootable/recovery
+else ifneq ($(wildcard bootable/recovery-twrp/crypto/lollipop/cryptfs.h),)
+    mr_twrp_path := bootable/recovery-twrp
+else
+    $(error Failed to find path to TWRP, which is required to build MultiROM with encryption support)
+endif
+
+LOCAL_C_INCLUDES += $(multirom_local_path) $(mr_twrp_path) $(mr_twrp_path)/crypto/scrypt/lib/crypto external/openssl/include external/boringssl/include
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+
+LOCAL_SRC_FILES := \
+    encmnt.c \
+    pw_ui.c \
+    ../rom_quirks.c \
+
+include $(multirom_local_path)/device_defines.mk
+
+include $(BUILD_EXECUTABLE)
+
+
diff --git a/trampoline_encmnt/Android.mk.bak b/trampoline_encmnt/Android.mk.bak
index ba50756..308474c 100755
--- a/trampoline_encmnt/Android.mk.bak
+++ b/trampoline_encmnt/Android.mk.bak
@@ -1,33 +1,33 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE:= trampoline_encmnt
-LOCAL_MODULE_TAGS := eng
-LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
-LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
-LOCAL_SHARED_LIBRARIES := libcryptfslollipop libcutils
-LOCAL_STATIC_LIBRARIES := libmultirom_static
-LOCAL_WHOLE_STATIC_LIBRARIES := libm libpng libz libft2_mrom_static
-
-ifneq ($(wildcard bootable/recovery/crypto/lollipop/cryptfs.h),)
-    mr_twrp_path := bootable/recovery
-else ifneq ($(wildcard bootable/recovery-twrp/crypto/lollipop/cryptfs.h),)
-    mr_twrp_path := bootable/recovery-twrp
-else
-    $(error Failed to find path to TWRP, which is required to build MultiROM with encryption support)
-endif
-
-LOCAL_C_INCLUDES += $(multirom_local_path) $(mr_twrp_path) $(mr_twrp_path)/crypto/scrypt/lib/crypto external/openssl/include external/boringssl/include
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-LOCAL_SRC_FILES := \
-    encmnt.c \
-    pw_ui.c \
-    ../rom_quirks.c \
-
-include $(multirom_local_path)/device_defines.mk
-
-include $(BUILD_EXECUTABLE)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE:= trampoline_encmnt
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
+LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
+LOCAL_SHARED_LIBRARIES := libcryptfslollipop libcutils
+LOCAL_STATIC_LIBRARIES := libmultirom_static
+LOCAL_WHOLE_STATIC_LIBRARIES := libm libpng libz libft2_mrom_static
+
+ifneq ($(wildcard bootable/recovery/crypto/lollipop/cryptfs.h),)
+    mr_twrp_path := bootable/recovery
+else ifneq ($(wildcard bootable/recovery-twrp/crypto/lollipop/cryptfs.h),)
+    mr_twrp_path := bootable/recovery-twrp
+else
+    $(error Failed to find path to TWRP, which is required to build MultiROM with encryption support)
+endif
+
+LOCAL_C_INCLUDES += $(multirom_local_path) $(mr_twrp_path) $(mr_twrp_path)/crypto/scrypt/lib/crypto external/openssl/include external/boringssl/include
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+LOCAL_SRC_FILES := \
+    encmnt.c \
+    pw_ui.c \
+    ../rom_quirks.c \
+
+include $(multirom_local_path)/device_defines.mk
+
+include $(BUILD_EXECUTABLE)
diff --git a/trampoline_encmnt/Android.mk.bak2 b/trampoline_encmnt/Android.mk.bak2
index f6ef4e6..b1139c7 100755
--- a/trampoline_encmnt/Android.mk.bak2
+++ b/trampoline_encmnt/Android.mk.bak2
@@ -1,38 +1,38 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE:= trampoline_encmnt
-LOCAL_MODULE_TAGS := eng
-LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
-LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
-
-# AnClark Modified on 2017-4-3
-# Add dependencies for those libraries
-# TODO: Too many dependencies derive from libcryptfslollipop -> libcryptfs_hw -> libutils.
-# 	We may should have to build trampoline_encmnt into static!
-LOCAL_SHARED_LIBRARIES := libcryptfslollipop libcutils libcryptfs_hw libutils
-LOCAL_STATIC_LIBRARIES := libmultirom_static
-LOCAL_WHOLE_STATIC_LIBRARIES := libm libpng libz libft2_mrom_static
-
-ifneq ($(wildcard bootable/recovery/crypto/lollipop/cryptfs.h),)
-    mr_twrp_path := bootable/recovery
-else ifneq ($(wildcard bootable/recovery-twrp/crypto/lollipop/cryptfs.h),)
-    mr_twrp_path := bootable/recovery-twrp
-else
-    $(error Failed to find path to TWRP, which is required to build MultiROM with encryption support)
-endif
-
-LOCAL_C_INCLUDES += $(multirom_local_path) $(mr_twrp_path) $(mr_twrp_path)/crypto/scrypt/lib/crypto external/openssl/include external/boringssl/include
-
-# ANCLARK MODIFIED ON 2017-4-1
-# Define _GNU_SOURCE to deal with ambiguous errors
-LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
-
-LOCAL_SRC_FILES := \
-    encmnt.c \
-    pw_ui.c \
-    ../rom_quirks.c \
-
-include $(multirom_local_path)/device_defines.mk
-
-include $(BUILD_EXECUTABLE)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_MODULE:= trampoline_encmnt
+LOCAL_MODULE_TAGS := eng
+LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
+LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_UNSTRIPPED)
+
+# AnClark Modified on 2017-4-3
+# Add dependencies for those libraries
+# TODO: Too many dependencies derive from libcryptfslollipop -> libcryptfs_hw -> libutils.
+# 	We may should have to build trampoline_encmnt into static!
+LOCAL_SHARED_LIBRARIES := libcryptfslollipop libcutils libcryptfs_hw libutils
+LOCAL_STATIC_LIBRARIES := libmultirom_static
+LOCAL_WHOLE_STATIC_LIBRARIES := libm libpng libz libft2_mrom_static
+
+ifneq ($(wildcard bootable/recovery/crypto/lollipop/cryptfs.h),)
+    mr_twrp_path := bootable/recovery
+else ifneq ($(wildcard bootable/recovery-twrp/crypto/lollipop/cryptfs.h),)
+    mr_twrp_path := bootable/recovery-twrp
+else
+    $(error Failed to find path to TWRP, which is required to build MultiROM with encryption support)
+endif
+
+LOCAL_C_INCLUDES += $(multirom_local_path) $(mr_twrp_path) $(mr_twrp_path)/crypto/scrypt/lib/crypto external/openssl/include external/boringssl/include
+
+# ANCLARK MODIFIED ON 2017-4-1
+# Define _GNU_SOURCE to deal with ambiguous errors
+LOCAL_CFLAGS += -D_GNU_SOURCE -D__GNU_SOURCE
+
+LOCAL_SRC_FILES := \
+    encmnt.c \
+    pw_ui.c \
+    ../rom_quirks.c \
+
+include $(multirom_local_path)/device_defines.mk
+
+include $(BUILD_EXECUTABLE)
diff --git a/trampoline_encmnt/encmnt.c b/trampoline_encmnt/encmnt.c
index de57bed..64bfaf5 100755
--- a/trampoline_encmnt/encmnt.c
+++ b/trampoline_encmnt/encmnt.c
@@ -1,301 +1,301 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <errno.h>
-
-#include <malloc.h>
-
-#include "../lib/log.h"
-#include "../lib/fstab.h"
-#include "../lib/framebuffer.h"
-#include "../lib/util.h"
-
-#include "crypto/lollipop/cryptfs.h"
-
-#include "pw_ui.h"
-#include "encmnt_defines.h"
-
-#define CMD_NONE 0
-#define CMD_DECRYPT 1
-#define CMD_REMOVE 2
-#define CMD_PWTYPE 3
-
-static int get_footer_from_opts(char *output, size_t output_size, const char *opts2)
-{
-    char *r, *saveptr;
-    char *dup = strdup(opts2);
-    int res = -1;
-    int i;
-
-    r = strtok_r(dup, ",", &saveptr);
-
-    static const char *names[] = {
-        "encryptable=",
-        "forceencrypt=",
-        NULL
-    };
-
-    while(r)
-    {
-        for(i = 0; names[i]; ++i)
-        {
-            if(strstartswith(r, names[i]))
-            {
-                snprintf(output, output_size, "%s", r + strlen(names[i]));
-                res = 0;
-                goto exit;
-            }
-        }
-
-        r = strtok_r(NULL, ",", &saveptr);
-    }
-
-exit:
-    free(dup);
-    return res;
-}
-
-static void print_help(char *argv[]) {
-    printf("Usage: %s COMMAND ARGUMENTS\n"
-        "Available commands:\n"
-        "     decrypt PASSWORD - decrypt data using PASSWORD.\n"
-        "             Prints out dm block device path on success.\n"
-        "     remove - unmounts encrypted data\n"
-        "     pwtype - prints password type as integer\n"
-        "\nNOTICE: Debug messages from cryptfs will be printed.\n",
-        argv[0]);
-}
-
-static int handle_pwtype(int stdout_fd)
-{
-    INFO("WORK MODE: pwtype\n");
-
-    if(cryptfs_check_footer() < 0)
-    {
-        ERROR("cryptfs_check_footer failed!");
-        return -1;
-    }
-
-    int pwtype = cryptfs_get_password_type();
-    if(pwtype < 0)
-    {
-        ERROR("cryptfs_get_password_type failed!");
-        return -1;
-    }
-
-    char buff[32];
-    snprintf(buff, sizeof(buff), "%d\n", pwtype);
-    write(stdout_fd, buff, strlen(buff));
-    fsync(stdout_fd);
-
-    //ANCLARK MODIFY 2017-4-5
-    //Log password type to dmesg
-    INFO("Get password type succeed.\n");
-    INFO("Queried password type ID => %d\n", pwtype);
-    return 0;
-}
-
-static int handle_decrypt(int stdout_fd, const char *password)
-{
-    INFO("WORK MODE: decrypt\n");
-
-    DIR *d;
-    struct dirent *de;
-    char buff[256];
-    int res = -1;
-    static const char *default_password = "default_password";
-
-    if(cryptfs_check_footer() < 0)
-    {
-        ERROR("cryptfs_check_footer failed!");
-        return -1;
-    }
-
-    int pwtype = cryptfs_get_password_type();
-    if(pwtype < 0)
-    {
-        ERROR("cryptfs_get_password_type failed!");
-        return -1;
-    }
-    else if (pwtype == CRYPT_TYPE_DEFAULT)
-        password = default_password;
-
-    if(password)
-    {
-        if(cryptfs_check_passwd(password) < 0)
-        {
-            ERROR("cryptfs_check_passwd failed!");
-            return -1;
-        }
-    }
-    else
-    {
-        switch(pw_ui_run(pwtype))
-        {
-            default:
-            case ENCMNT_UIRES_ERROR:
-                ERROR("pw_ui_run() failed!\n");
-                return -1;
-            case ENCMNT_UIRES_BOOT_INTERNAL:
-                INFO("Wants to boot internal!\n");
-                write(stdout_fd, ENCMNT_BOOT_INTERNAL_OUTPUT, strlen(ENCMNT_BOOT_INTERNAL_OUTPUT));
-                fsync(stdout_fd);
-                return 0;
-            case ENCMNT_UIRES_PASS_OK:
-                break;
-        }
-    }
-
-    d = opendir("/dev/block/");
-    if(!d)
-    {
-        ERROR("Failed to open /dev/block, wth? %s", strerror(errno));
-        return -1;
-    }
-
-    // find the block device
-    while((de = readdir(d)))
-    {
-        if(de->d_type == DT_BLK && strncmp(de->d_name, "dm-", 3) == 0)
-        {
-            snprintf(buff, sizeof(buff), "/dev/block/%s\n", de->d_name);
-            INFO("Found block device %s\n", buff);
-            write(stdout_fd, buff, strlen(buff));
-            fsync(stdout_fd);
-            res = 0;
-            break;
-        }
-    }
-
-    closedir(d);
-    return res;
-}
-
-static int handle_remove(void)
-{
-    INFO("WORK MODE: remove\n");
-
-    if(delete_crypto_blk_dev("userdata") < 0)
-    {
-        ERROR("delete_crypto_blk_dev failed!");
-        return -1;
-    }
-    return 0;
-}
-
-int main(int argc, char *argv[])
-{
-    int i;
-    int res = 1;
-    int cmd = CMD_NONE;
-    int stdout_fd;
-    char footer_location[256];
-    struct fstab *fstab;
-    struct fstab_part *p;
-    char *argument = NULL;
-
-    klog_init();
-
-    // output all messages to dmesg,
-    // but it is possible to filter out INFO messages
-    klog_set_level(6);
-
-    mrom_set_log_tag("trampoline_encmnt");
-    mrom_set_dir("/mrom_enc/");
-
-    for(i = 1; i < argc; ++i)
-    {
-        if(!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help"))
-        {
-            print_help(argv);
-            return 0;
-        }
-        else if(cmd == CMD_NONE)
-        {
-            if(strcmp(argv[i], "decrypt") == 0)
-                cmd = CMD_DECRYPT;
-            else if(strcmp(argv[i], "remove") == 0)
-                cmd = CMD_REMOVE;
-            else if(strcmp(argv[i], "pwtype") == 0)
-                cmd = CMD_PWTYPE;
-        }
-        else if(!argument)
-        {
-            argument = argv[i];
-        }
-    }
-
-    if(argc == 1 || cmd == CMD_NONE)
-    {
-        print_help(argv);
-        return 0;
-    }
-
-    INFO("Trampoline_encmnt started\n");
-
-    fstab = fstab_auto_load();
-    if(!fstab)
-    {
-        ERROR("Failed to load fstab!");
-        return 1;
-    }
-
-    p = fstab_find_first_by_path(fstab, "/data");
-    if(!p)
-    {
-        ERROR("Failed to find /data partition in fstab\n");
-        goto exit;
-    }
-
-    if(get_footer_from_opts(footer_location, sizeof(footer_location), p->options2) < 0)
-        goto exit;
-
-    INFO("Setting encrypted partition data to %s %s %s\n", p->device, footer_location, p->type);
-    set_partition_data(p->device, footer_location, p->type);
-
-    // cryptfs prints informations, we don't want that
-    // AnClark disagree 2017-4-5: This will supress debug messages!!!!! STOP DOING THIS!!!!!
-    stdout_fd = dup(1);
-    //freopen("/dev/null", "ae", stdout);
-
-    switch(cmd)
-    {
-        case CMD_PWTYPE:
-            if(handle_pwtype(stdout_fd) < 0)
-                goto exit;
-            break;
-        case CMD_DECRYPT:
-            if(handle_decrypt(stdout_fd, argument) < 0)
-                goto exit;
-            break;
-        case CMD_REMOVE:
-            if(handle_remove() < 0)
-                goto exit;
-            break;
-    }
-
-    res = 0;
-exit:
-    
-    INFO("Exit trampoline_encmnt...");
-    fstab_destroy(fstab);
-    return res;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <errno.h>
+
+#include <malloc.h>
+
+#include "../lib/log.h"
+#include "../lib/fstab.h"
+#include "../lib/framebuffer.h"
+#include "../lib/util.h"
+
+#include "crypto/lollipop/cryptfs.h"
+
+#include "pw_ui.h"
+#include "encmnt_defines.h"
+
+#define CMD_NONE 0
+#define CMD_DECRYPT 1
+#define CMD_REMOVE 2
+#define CMD_PWTYPE 3
+
+static int get_footer_from_opts(char *output, size_t output_size, const char *opts2)
+{
+    char *r, *saveptr;
+    char *dup = strdup(opts2);
+    int res = -1;
+    int i;
+
+    r = strtok_r(dup, ",", &saveptr);
+
+    static const char *names[] = {
+        "encryptable=",
+        "forceencrypt=",
+        NULL
+    };
+
+    while(r)
+    {
+        for(i = 0; names[i]; ++i)
+        {
+            if(strstartswith(r, names[i]))
+            {
+                snprintf(output, output_size, "%s", r + strlen(names[i]));
+                res = 0;
+                goto exit;
+            }
+        }
+
+        r = strtok_r(NULL, ",", &saveptr);
+    }
+
+exit:
+    free(dup);
+    return res;
+}
+
+static void print_help(char *argv[]) {
+    printf("Usage: %s COMMAND ARGUMENTS\n"
+        "Available commands:\n"
+        "     decrypt PASSWORD - decrypt data using PASSWORD.\n"
+        "             Prints out dm block device path on success.\n"
+        "     remove - unmounts encrypted data\n"
+        "     pwtype - prints password type as integer\n"
+        "\nNOTICE: Debug messages from cryptfs will be printed.\n",
+        argv[0]);
+}
+
+static int handle_pwtype(int stdout_fd)
+{
+    INFO("WORK MODE: pwtype\n");
+
+    if(cryptfs_check_footer() < 0)
+    {
+        ERROR("cryptfs_check_footer failed!");
+        return -1;
+    }
+
+    int pwtype = cryptfs_get_password_type();
+    if(pwtype < 0)
+    {
+        ERROR("cryptfs_get_password_type failed!");
+        return -1;
+    }
+
+    char buff[32];
+    snprintf(buff, sizeof(buff), "%d\n", pwtype);
+    write(stdout_fd, buff, strlen(buff));
+    fsync(stdout_fd);
+
+    //ANCLARK MODIFY 2017-4-5
+    //Log password type to dmesg
+    INFO("Get password type succeed.\n");
+    INFO("Queried password type ID => %d\n", pwtype);
+    return 0;
+}
+
+static int handle_decrypt(int stdout_fd, const char *password)
+{
+    INFO("WORK MODE: decrypt\n");
+
+    DIR *d;
+    struct dirent *de;
+    char buff[256];
+    int res = -1;
+    static const char *default_password = "default_password";
+
+    if(cryptfs_check_footer() < 0)
+    {
+        ERROR("cryptfs_check_footer failed!");
+        return -1;
+    }
+
+    int pwtype = cryptfs_get_password_type();
+    if(pwtype < 0)
+    {
+        ERROR("cryptfs_get_password_type failed!");
+        return -1;
+    }
+    else if (pwtype == CRYPT_TYPE_DEFAULT)
+        password = default_password;
+
+    if(password)
+    {
+        if(cryptfs_check_passwd(password) < 0)
+        {
+            ERROR("cryptfs_check_passwd failed!");
+            return -1;
+        }
+    }
+    else
+    {
+        switch(pw_ui_run(pwtype))
+        {
+            default:
+            case ENCMNT_UIRES_ERROR:
+                ERROR("pw_ui_run() failed!\n");
+                return -1;
+            case ENCMNT_UIRES_BOOT_INTERNAL:
+                INFO("Wants to boot internal!\n");
+                write(stdout_fd, ENCMNT_BOOT_INTERNAL_OUTPUT, strlen(ENCMNT_BOOT_INTERNAL_OUTPUT));
+                fsync(stdout_fd);
+                return 0;
+            case ENCMNT_UIRES_PASS_OK:
+                break;
+        }
+    }
+
+    d = opendir("/dev/block/");
+    if(!d)
+    {
+        ERROR("Failed to open /dev/block, wth? %s", strerror(errno));
+        return -1;
+    }
+
+    // find the block device
+    while((de = readdir(d)))
+    {
+        if(de->d_type == DT_BLK && strncmp(de->d_name, "dm-", 3) == 0)
+        {
+            snprintf(buff, sizeof(buff), "/dev/block/%s\n", de->d_name);
+            INFO("Found block device %s\n", buff);
+            write(stdout_fd, buff, strlen(buff));
+            fsync(stdout_fd);
+            res = 0;
+            break;
+        }
+    }
+
+    closedir(d);
+    return res;
+}
+
+static int handle_remove(void)
+{
+    INFO("WORK MODE: remove\n");
+
+    if(delete_crypto_blk_dev("userdata") < 0)
+    {
+        ERROR("delete_crypto_blk_dev failed!");
+        return -1;
+    }
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    int i;
+    int res = 1;
+    int cmd = CMD_NONE;
+    int stdout_fd;
+    char footer_location[256];
+    struct fstab *fstab;
+    struct fstab_part *p;
+    char *argument = NULL;
+
+    klog_init();
+
+    // output all messages to dmesg,
+    // but it is possible to filter out INFO messages
+    klog_set_level(6);
+
+    mrom_set_log_tag("trampoline_encmnt");
+    mrom_set_dir("/mrom_enc/");
+
+    for(i = 1; i < argc; ++i)
+    {
+        if(!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help"))
+        {
+            print_help(argv);
+            return 0;
+        }
+        else if(cmd == CMD_NONE)
+        {
+            if(strcmp(argv[i], "decrypt") == 0)
+                cmd = CMD_DECRYPT;
+            else if(strcmp(argv[i], "remove") == 0)
+                cmd = CMD_REMOVE;
+            else if(strcmp(argv[i], "pwtype") == 0)
+                cmd = CMD_PWTYPE;
+        }
+        else if(!argument)
+        {
+            argument = argv[i];
+        }
+    }
+
+    if(argc == 1 || cmd == CMD_NONE)
+    {
+        print_help(argv);
+        return 0;
+    }
+
+    INFO("Trampoline_encmnt started\n");
+
+    fstab = fstab_auto_load();
+    if(!fstab)
+    {
+        ERROR("Failed to load fstab!");
+        return 1;
+    }
+
+    p = fstab_find_first_by_path(fstab, "/data");
+    if(!p)
+    {
+        ERROR("Failed to find /data partition in fstab\n");
+        goto exit;
+    }
+
+    if(get_footer_from_opts(footer_location, sizeof(footer_location), p->options2) < 0)
+        goto exit;
+
+    INFO("Setting encrypted partition data to %s %s %s\n", p->device, footer_location, p->type);
+    set_partition_data(p->device, footer_location, p->type);
+
+    // cryptfs prints informations, we don't want that
+    // AnClark disagree 2017-4-5: This will supress debug messages!!!!! STOP DOING THIS!!!!!
+    stdout_fd = dup(1);
+    //freopen("/dev/null", "ae", stdout);
+
+    switch(cmd)
+    {
+        case CMD_PWTYPE:
+            if(handle_pwtype(stdout_fd) < 0)
+                goto exit;
+            break;
+        case CMD_DECRYPT:
+            if(handle_decrypt(stdout_fd, argument) < 0)
+                goto exit;
+            break;
+        case CMD_REMOVE:
+            if(handle_remove() < 0)
+                goto exit;
+            break;
+    }
+
+    res = 0;
+exit:
+    
+    INFO("Exit trampoline_encmnt...");
+    fstab_destroy(fstab);
+    return res;
+}
diff --git a/trampoline_encmnt/encmnt.c.bak b/trampoline_encmnt/encmnt.c.bak
index 3592391..aa7e6f6 100755
--- a/trampoline_encmnt/encmnt.c.bak
+++ b/trampoline_encmnt/encmnt.c.bak
@@ -1,284 +1,284 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <errno.h>
-
-#include <malloc.h>
-
-#include "../lib/log.h"
-#include "../lib/fstab.h"
-#include "../lib/framebuffer.h"
-#include "../lib/util.h"
-
-#include "crypto/lollipop/cryptfs.h"
-
-#include "pw_ui.h"
-#include "encmnt_defines.h"
-
-#define CMD_NONE 0
-#define CMD_DECRYPT 1
-#define CMD_REMOVE 2
-#define CMD_PWTYPE 3
-
-static int get_footer_from_opts(char *output, size_t output_size, const char *opts2)
-{
-    char *r, *saveptr;
-    char *dup = strdup(opts2);
-    int res = -1;
-    int i;
-
-    r = strtok_r(dup, ",", &saveptr);
-
-    static const char *names[] = {
-        "encryptable=",
-        "forceencrypt=",
-        NULL
-    };
-
-    while(r)
-    {
-        for(i = 0; names[i]; ++i)
-        {
-            if(strstartswith(r, names[i]))
-            {
-                snprintf(output, output_size, "%s", r + strlen(names[i]));
-                res = 0;
-                goto exit;
-            }
-        }
-
-        r = strtok_r(NULL, ",", &saveptr);
-    }
-
-exit:
-    free(dup);
-    return res;
-}
-
-static void print_help(char *argv[]) {
-    printf("Usage: %s COMMAND ARGUMENTS\n"
-        "Available commands:\n"
-        "     decrypt PASSWORD - decrypt data using PASSWORD.\n"
-        "             Prints out dm block device path on success.\n"
-        "     remove - unmounts encrypted data\n"
-        "     pwtype - prints password type as integer\n",
-        argv[0]);
-}
-
-static int handle_pwtype(int stdout_fd)
-{
-    if(cryptfs_check_footer() < 0)
-    {
-        ERROR("cryptfs_check_footer failed!");
-        return -1;
-    }
-
-    int pwtype = cryptfs_get_password_type();
-    if(pwtype < 0)
-    {
-        ERROR("cryptfs_get_password_type failed!");
-        return -1;
-    }
-
-    char buff[32];
-    snprintf(buff, sizeof(buff), "%d\n", pwtype);
-    write(stdout_fd, buff, strlen(buff));
-    fsync(stdout_fd);
-    return 0;
-}
-
-static int handle_decrypt(int stdout_fd, const char *password)
-{
-    DIR *d;
-    struct dirent *de;
-    char buff[256];
-    int res = -1;
-    static const char *default_password = "default_password";
-
-    if(cryptfs_check_footer() < 0)
-    {
-        ERROR("cryptfs_check_footer failed!");
-        return -1;
-    }
-
-    int pwtype = cryptfs_get_password_type();
-    if(pwtype < 0)
-    {
-        ERROR("cryptfs_get_password_type failed!");
-        return -1;
-    }
-    else if (pwtype == CRYPT_TYPE_DEFAULT)
-        password = default_password;
-
-    if(password)
-    {
-        if(cryptfs_check_passwd(password) < 0)
-        {
-            ERROR("cryptfs_check_passwd failed!");
-            return -1;
-        }
-    }
-    else
-    {
-        switch(pw_ui_run(pwtype))
-        {
-            default:
-            case ENCMNT_UIRES_ERROR:
-                ERROR("pw_ui_run() failed!\n");
-                return -1;
-            case ENCMNT_UIRES_BOOT_INTERNAL:
-                INFO("Wants to boot internal!\n");
-                write(stdout_fd, ENCMNT_BOOT_INTERNAL_OUTPUT, strlen(ENCMNT_BOOT_INTERNAL_OUTPUT));
-                fsync(stdout_fd);
-                return 0;
-            case ENCMNT_UIRES_PASS_OK:
-                break;
-        }
-    }
-
-    d = opendir("/dev/block/");
-    if(!d)
-    {
-        ERROR("Failed to open /dev/block, wth? %s", strerror(errno));
-        return -1;
-    }
-
-    // find the block device
-    while((de = readdir(d)))
-    {
-        if(de->d_type == DT_BLK && strncmp(de->d_name, "dm-", 3) == 0)
-        {
-            snprintf(buff, sizeof(buff), "/dev/block/%s\n", de->d_name);
-            INFO("Found block device %s\n", buff);
-            write(stdout_fd, buff, strlen(buff));
-            fsync(stdout_fd);
-            res = 0;
-            break;
-        }
-    }
-
-    closedir(d);
-    return res;
-}
-
-static int handle_remove(void)
-{
-    if(delete_crypto_blk_dev("userdata") < 0)
-    {
-        ERROR("delete_crypto_blk_dev failed!");
-        return -1;
-    }
-    return 0;
-}
-
-int main(int argc, char *argv[])
-{
-    int i;
-    int res = 1;
-    int cmd = CMD_NONE;
-    int stdout_fd;
-    char footer_location[256];
-    struct fstab *fstab;
-    struct fstab_part *p;
-    char *argument = NULL;
-
-    klog_init();
-
-    // output all messages to dmesg,
-    // but it is possible to filter out INFO messages
-    klog_set_level(6);
-
-    mrom_set_log_tag("trampoline_encmnt");
-    mrom_set_dir("/mrom_enc/");
-
-    for(i = 1; i < argc; ++i)
-    {
-        if(!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help"))
-        {
-            print_help(argv);
-            return 0;
-        }
-        else if(cmd == CMD_NONE)
-        {
-            if(strcmp(argv[i], "decrypt") == 0)
-                cmd = CMD_DECRYPT;
-            else if(strcmp(argv[i], "remove") == 0)
-                cmd = CMD_REMOVE;
-            else if(strcmp(argv[i], "pwtype") == 0)
-                cmd = CMD_PWTYPE;
-        }
-        else if(!argument)
-        {
-            argument = argv[i];
-        }
-    }
-
-    if(argc == 1 || cmd == CMD_NONE)
-    {
-        print_help(argv);
-        return 0;
-    }
-
-    fstab = fstab_auto_load();
-    if(!fstab)
-    {
-        ERROR("Failed to load fstab!");
-        return 1;
-    }
-
-    p = fstab_find_first_by_path(fstab, "/data");
-    if(!p)
-    {
-        ERROR("Failed to find /data partition in fstab\n");
-        goto exit;
-    }
-
-    if(get_footer_from_opts(footer_location, sizeof(footer_location), p->options2) < 0)
-        goto exit;
-
-    INFO("Setting encrypted partition data to %s %s %s\n", p->device, footer_location, p->type);
-    set_partition_data(p->device, footer_location, p->type);
-
-    // cryptfs prints informations, we don't want that
-    stdout_fd = dup(1);
-    freopen("/dev/null", "ae", stdout);
-
-    switch(cmd)
-    {
-        case CMD_PWTYPE:
-            if(handle_pwtype(stdout_fd) < 0)
-                goto exit;
-            break;
-        case CMD_DECRYPT:
-            if(handle_decrypt(stdout_fd, argument) < 0)
-                goto exit;
-            break;
-        case CMD_REMOVE:
-            if(handle_remove() < 0)
-                goto exit;
-            break;
-    }
-
-    res = 0;
-exit:
-    fstab_destroy(fstab);
-    return res;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <errno.h>
+
+#include <malloc.h>
+
+#include "../lib/log.h"
+#include "../lib/fstab.h"
+#include "../lib/framebuffer.h"
+#include "../lib/util.h"
+
+#include "crypto/lollipop/cryptfs.h"
+
+#include "pw_ui.h"
+#include "encmnt_defines.h"
+
+#define CMD_NONE 0
+#define CMD_DECRYPT 1
+#define CMD_REMOVE 2
+#define CMD_PWTYPE 3
+
+static int get_footer_from_opts(char *output, size_t output_size, const char *opts2)
+{
+    char *r, *saveptr;
+    char *dup = strdup(opts2);
+    int res = -1;
+    int i;
+
+    r = strtok_r(dup, ",", &saveptr);
+
+    static const char *names[] = {
+        "encryptable=",
+        "forceencrypt=",
+        NULL
+    };
+
+    while(r)
+    {
+        for(i = 0; names[i]; ++i)
+        {
+            if(strstartswith(r, names[i]))
+            {
+                snprintf(output, output_size, "%s", r + strlen(names[i]));
+                res = 0;
+                goto exit;
+            }
+        }
+
+        r = strtok_r(NULL, ",", &saveptr);
+    }
+
+exit:
+    free(dup);
+    return res;
+}
+
+static void print_help(char *argv[]) {
+    printf("Usage: %s COMMAND ARGUMENTS\n"
+        "Available commands:\n"
+        "     decrypt PASSWORD - decrypt data using PASSWORD.\n"
+        "             Prints out dm block device path on success.\n"
+        "     remove - unmounts encrypted data\n"
+        "     pwtype - prints password type as integer\n",
+        argv[0]);
+}
+
+static int handle_pwtype(int stdout_fd)
+{
+    if(cryptfs_check_footer() < 0)
+    {
+        ERROR("cryptfs_check_footer failed!");
+        return -1;
+    }
+
+    int pwtype = cryptfs_get_password_type();
+    if(pwtype < 0)
+    {
+        ERROR("cryptfs_get_password_type failed!");
+        return -1;
+    }
+
+    char buff[32];
+    snprintf(buff, sizeof(buff), "%d\n", pwtype);
+    write(stdout_fd, buff, strlen(buff));
+    fsync(stdout_fd);
+    return 0;
+}
+
+static int handle_decrypt(int stdout_fd, const char *password)
+{
+    DIR *d;
+    struct dirent *de;
+    char buff[256];
+    int res = -1;
+    static const char *default_password = "default_password";
+
+    if(cryptfs_check_footer() < 0)
+    {
+        ERROR("cryptfs_check_footer failed!");
+        return -1;
+    }
+
+    int pwtype = cryptfs_get_password_type();
+    if(pwtype < 0)
+    {
+        ERROR("cryptfs_get_password_type failed!");
+        return -1;
+    }
+    else if (pwtype == CRYPT_TYPE_DEFAULT)
+        password = default_password;
+
+    if(password)
+    {
+        if(cryptfs_check_passwd(password) < 0)
+        {
+            ERROR("cryptfs_check_passwd failed!");
+            return -1;
+        }
+    }
+    else
+    {
+        switch(pw_ui_run(pwtype))
+        {
+            default:
+            case ENCMNT_UIRES_ERROR:
+                ERROR("pw_ui_run() failed!\n");
+                return -1;
+            case ENCMNT_UIRES_BOOT_INTERNAL:
+                INFO("Wants to boot internal!\n");
+                write(stdout_fd, ENCMNT_BOOT_INTERNAL_OUTPUT, strlen(ENCMNT_BOOT_INTERNAL_OUTPUT));
+                fsync(stdout_fd);
+                return 0;
+            case ENCMNT_UIRES_PASS_OK:
+                break;
+        }
+    }
+
+    d = opendir("/dev/block/");
+    if(!d)
+    {
+        ERROR("Failed to open /dev/block, wth? %s", strerror(errno));
+        return -1;
+    }
+
+    // find the block device
+    while((de = readdir(d)))
+    {
+        if(de->d_type == DT_BLK && strncmp(de->d_name, "dm-", 3) == 0)
+        {
+            snprintf(buff, sizeof(buff), "/dev/block/%s\n", de->d_name);
+            INFO("Found block device %s\n", buff);
+            write(stdout_fd, buff, strlen(buff));
+            fsync(stdout_fd);
+            res = 0;
+            break;
+        }
+    }
+
+    closedir(d);
+    return res;
+}
+
+static int handle_remove(void)
+{
+    if(delete_crypto_blk_dev("userdata") < 0)
+    {
+        ERROR("delete_crypto_blk_dev failed!");
+        return -1;
+    }
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    int i;
+    int res = 1;
+    int cmd = CMD_NONE;
+    int stdout_fd;
+    char footer_location[256];
+    struct fstab *fstab;
+    struct fstab_part *p;
+    char *argument = NULL;
+
+    klog_init();
+
+    // output all messages to dmesg,
+    // but it is possible to filter out INFO messages
+    klog_set_level(6);
+
+    mrom_set_log_tag("trampoline_encmnt");
+    mrom_set_dir("/mrom_enc/");
+
+    for(i = 1; i < argc; ++i)
+    {
+        if(!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help"))
+        {
+            print_help(argv);
+            return 0;
+        }
+        else if(cmd == CMD_NONE)
+        {
+            if(strcmp(argv[i], "decrypt") == 0)
+                cmd = CMD_DECRYPT;
+            else if(strcmp(argv[i], "remove") == 0)
+                cmd = CMD_REMOVE;
+            else if(strcmp(argv[i], "pwtype") == 0)
+                cmd = CMD_PWTYPE;
+        }
+        else if(!argument)
+        {
+            argument = argv[i];
+        }
+    }
+
+    if(argc == 1 || cmd == CMD_NONE)
+    {
+        print_help(argv);
+        return 0;
+    }
+
+    fstab = fstab_auto_load();
+    if(!fstab)
+    {
+        ERROR("Failed to load fstab!");
+        return 1;
+    }
+
+    p = fstab_find_first_by_path(fstab, "/data");
+    if(!p)
+    {
+        ERROR("Failed to find /data partition in fstab\n");
+        goto exit;
+    }
+
+    if(get_footer_from_opts(footer_location, sizeof(footer_location), p->options2) < 0)
+        goto exit;
+
+    INFO("Setting encrypted partition data to %s %s %s\n", p->device, footer_location, p->type);
+    set_partition_data(p->device, footer_location, p->type);
+
+    // cryptfs prints informations, we don't want that
+    stdout_fd = dup(1);
+    freopen("/dev/null", "ae", stdout);
+
+    switch(cmd)
+    {
+        case CMD_PWTYPE:
+            if(handle_pwtype(stdout_fd) < 0)
+                goto exit;
+            break;
+        case CMD_DECRYPT:
+            if(handle_decrypt(stdout_fd, argument) < 0)
+                goto exit;
+            break;
+        case CMD_REMOVE:
+            if(handle_remove() < 0)
+                goto exit;
+            break;
+    }
+
+    res = 0;
+exit:
+    fstab_destroy(fstab);
+    return res;
+}
diff --git a/trampoline_encmnt/encmnt_defines.h b/trampoline_encmnt/encmnt_defines.h
index 8c52342..311f1f3 100755
--- a/trampoline_encmnt/encmnt_defines.h
+++ b/trampoline_encmnt/encmnt_defines.h
@@ -1,27 +1,27 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef ENCMNT_DEFINES_H
-#define ENCMNT_DEFINES_H
-
-#define ENCMNT_BOOT_INTERNAL_OUTPUT "boot-internal-requested"
-
-#define ENCMNT_UIRES_BOOT_INTERNAL 1
-#define ENCMNT_UIRES_PASS_OK 0
-#define ENCMNT_UIRES_ERROR -1
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef ENCMNT_DEFINES_H
+#define ENCMNT_DEFINES_H
+
+#define ENCMNT_BOOT_INTERNAL_OUTPUT "boot-internal-requested"
+
+#define ENCMNT_UIRES_BOOT_INTERNAL 1
+#define ENCMNT_UIRES_PASS_OK 0
+#define ENCMNT_UIRES_ERROR -1
+
+#endif
diff --git a/trampoline_encmnt/pw_ui.c b/trampoline_encmnt/pw_ui.c
index b6a3dca..36f362b 100755
--- a/trampoline_encmnt/pw_ui.c
+++ b/trampoline_encmnt/pw_ui.c
@@ -1,541 +1,541 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <unistd.h>
-#include <pthread.h>
-#include <stdio.h>
-
-#include <string.h>
-#include <malloc.h>
-
-#include "pw_ui.h"
-#include "encmnt_defines.h"
-#include "../lib/framebuffer.h"
-#include "../lib/colors.h"
-#include "../lib/log.h"
-#include "../lib/input.h"
-#include "../lib/keyboard.h"
-#include "../lib/util.h"
-#include "../lib/notification_card.h"
-#include "../lib/animation.h"
-#include "../lib/workers.h"
-#include "../lib/containers.h"
-#include "../rom_quirks.h"
-
-#include "crypto/lollipop/cryptfs.h"
-
-#define HEADER_HEIGHT (110*DPI_MUL)
-#define PWUI_DOT_R (15*DPI_MUL)
-#define PWUI_DOT_ACTIVE_R (PWUI_DOT_R/2)
-#define PWUI_DOT_ACTIVE_OFF (PWUI_DOT_R - PWUI_DOT_ACTIVE_R)
-#define PWUI_LINE_W (12*DPI_MUL)
-#define PWUI_DOTS_CNT 9
-
-struct pwui_type_pass_data {
-    fb_text *passwd_text;
-    fb_rect *cursor_rect;
-    struct keyboard *keyboard;
-    char *pass_buf;
-    char *pass_buf_stars;
-    size_t pass_buf_cap;
-};
-
-struct pwui_type_pattern_data {
-    fb_circle **dots;
-    fb_circle **active_dots;
-    fb_line **complete_lines;
-    fb_line *cur_line;
-    int connected_dots[PWUI_DOTS_CNT];
-    size_t connected_dots_len;
-    int touch_id;
-};
-
-static pthread_mutex_t exit_code_mutex = PTHREAD_MUTEX_INITIALIZER;
-static int exit_code = ENCMNT_UIRES_ERROR;
-static void *pwui_type_data = NULL;
-static fb_text *invalid_pass_text = NULL;
-static button *boot_primary_btn = NULL;
-
-static void boot_internal_clicked(UNUSED void *data)
-{
-    ncard_builder *b = ncard_create_builder();
-    ncard_set_pos(b, NCARD_POS_CENTER);
-    ncard_set_text(b, "Booting the primary ROM...");
-    ncard_show(b, 1);
-
-    // We need to run quirks for primary ROM to prevent
-    // restorecon breaking everything
-    rom_quirks_on_initrd_finalized();
-
-    pthread_mutex_lock(&exit_code_mutex);
-    exit_code = ENCMNT_UIRES_BOOT_INTERNAL;
-    pthread_mutex_unlock(&exit_code_mutex);
-}
-
-static void fade_rect_alpha_step(void *data, float interpolated)
-{
-    fb_rect *r = data;
-    r->color = (((int)(0xFF*interpolated)) << 24);
-    fb_request_draw();
-}
-
-static void reveal_rect_alpha_step(void *data, float interpolated)
-{
-    fb_rect *r = data;
-    interpolated = 1.f - interpolated;
-    r->color = (r->color & ~(0xFF << 24)) | (((int)(0xFF*interpolated)) << 24);
-    fb_request_draw();
-}
-
-static int try_password(const char *pass)
-{
-    fb_text_set_content(invalid_pass_text, "");
-
-    ncard_builder *b = ncard_create_builder();
-    ncard_set_pos(b, NCARD_POS_CENTER);
-    ncard_set_text(b, "Verifying password...");
-    ncard_show(b, 1);
-
-    if(cryptfs_check_passwd(pass) != 0)
-    {
-        ncard_hide();
-        fb_text_set_content(invalid_pass_text, "Invalid password!");
-        center_text(invalid_pass_text, 0, -1, fb_width, -1);
-        return -1;
-    }
-    else
-    {
-        ncard_builder *b = ncard_create_builder();
-        ncard_set_pos(b, NCARD_POS_CENTER);
-        ncard_set_text(b, "Correct!");
-        ncard_show(b, 1);
-
-        fb_rect *r = fb_add_rect_lvl(10000, 0, 0, fb_width, fb_height, 0x00000000);
-        call_anim *a = call_anim_create(r, fade_rect_alpha_step, 500, INTERPOLATOR_ACCELERATE);
-        call_anim_add(a);
-
-        pthread_mutex_lock(&exit_code_mutex);
-        exit_code = ENCMNT_UIRES_PASS_OK;
-        pthread_mutex_unlock(&exit_code_mutex);
-        return 0;
-    }
-}
-
-static void type_pass_key_pressed(void *data, uint8_t code)
-{
-    struct pwui_type_pass_data *d = data;
-
-    if(code < 128)
-    {
-        size_t pass_len = strlen(d->pass_buf);
-        while(d->pass_buf_cap < pass_len + 2)
-        {
-            d->pass_buf_cap *= 2;
-            d->pass_buf = realloc(d->pass_buf, d->pass_buf_cap);
-            d->pass_buf_stars = realloc(d->pass_buf_stars, d->pass_buf_cap);
-        }
-
-        if(pass_len > 0)
-            d->pass_buf_stars[pass_len-1] = '*';
-        d->pass_buf_stars[pass_len] = (char)code;
-        d->pass_buf_stars[pass_len+1] = 0;
-
-        d->pass_buf[pass_len++] = (char)code;
-        d->pass_buf[pass_len] = 0;
-
-        fb_text_set_content(d->passwd_text, d->pass_buf_stars);
-        center_text(d->passwd_text, 0, 0, fb_width, fb_height);
-        fb_request_draw();
-
-        return;
-    }
-
-    switch(code)
-    {
-        case OSK_BACKSPACE:
-        {
-            size_t pass_len = strlen(d->pass_buf);
-            if(pass_len == 0)
-                break;
-
-            d->pass_buf_stars[--pass_len] = 0;
-            d->pass_buf[pass_len] = 0;
-
-            fb_text_set_content(d->passwd_text, d->pass_buf_stars);
-            center_text(d->passwd_text, 0, 0, fb_width, fb_height);
-            fb_request_draw();
-            break;
-        }
-        case OSK_CLEAR:
-            d->pass_buf[0] = 0;
-            d->pass_buf_stars[0] = 0;
-            fb_text_set_content(d->passwd_text, "");
-            fb_request_draw();
-            break;
-        case OSK_ENTER:
-            try_password(d->pass_buf);
-            break;
-    }
-}
-
-static void type_pass_init(int pwtype)
-{
-    struct pwui_type_pass_data *d = mzalloc(sizeof(struct pwui_type_pass_data));
-    d->keyboard = keyboard_create(pwtype == CRYPT_TYPE_PIN ? KEYBOARD_PIN : KEYBOARD_NORMAL,
-            0, fb_height*0.65, fb_width, fb_height*0.35);
-    keyboard_set_callback(d->keyboard, type_pass_key_pressed, d);
-
-    d->passwd_text = fb_add_text(0, 0, C_TEXT, SIZE_BIG, "");
-    center_text(d->passwd_text, 0, 0, fb_width, fb_height);
-
-    d->pass_buf_cap = 12;
-    d->pass_buf = mzalloc(d->pass_buf_cap);
-    d->pass_buf_stars = mzalloc(d->pass_buf_cap);
-
-    pwui_type_data = d;
-}
-
-static void type_pass_destroy(void)
-{
-    struct pwui_type_pass_data *d = pwui_type_data;
-
-    keyboard_destroy(d->keyboard);
-    free(d->pass_buf);
-    free(d->pass_buf_stars);
-    free(d);
-    pwui_type_data = NULL;
-}
-
-static inline int type_pattern_in_dot(struct pwui_type_pattern_data *d, touch_event *ev)
-{
-    int i;
-    fb_circle *c;
-    for(i = 0; d->dots[i]; ++i)
-    {
-        c = d->dots[i];
-        if(in_rect(ev->x, ev->y, c->x - PWUI_DOT_R*1.5, c->y - PWUI_DOT_R*1.5, c->w*3, c->h*3))
-            return i;
-    }
-    return -1;
-}
-
-static inline int type_pattern_dot_used(struct pwui_type_pattern_data *d, int dot_idx)
-{
-    size_t i;
-    for(i = 0; i < d->connected_dots_len; ++i)
-        if(d->connected_dots[i] == dot_idx)
-            return 1;
-    return 0;
-}
-
-static inline void type_pattern_connect_dot(struct pwui_type_pattern_data *d,  int dot_idx)
-{
-    if(d->connected_dots_len >= PWUI_DOTS_CNT)
-    {
-        ERROR("d->connected_dots_len overflowed PWUI_DOTS_CNT!\n");
-        return;
-    }
-
-    d->connected_dots[d->connected_dots_len++] = dot_idx;
-
-    fb_circle *c = d->dots[dot_idx];
-    c = fb_add_circle_lvl(100, c->x+PWUI_DOT_ACTIVE_OFF, c->y+PWUI_DOT_ACTIVE_OFF, PWUI_DOT_ACTIVE_R, C_HIGHLIGHT_TEXT);
-    list_add(&d->active_dots, c);
-}
-
-static int type_pattern_touch_handler(touch_event *ev, void *data)
-{
-    struct pwui_type_pattern_data *d = data;
-
-    if(d->touch_id == -1 && (ev->changed & TCHNG_ADDED) && !ev->consumed)
-    {
-        const int dot_idx = type_pattern_in_dot(d, ev);
-        if(dot_idx == -1)
-            return -1;
-
-        d->touch_id = ev->id;
-        d->connected_dots_len = 0;
-
-        type_pattern_connect_dot(d, dot_idx);
-
-        fb_circle *c = d->dots[dot_idx];
-        d->cur_line = fb_add_line(c->x + PWUI_DOT_R, c->y + PWUI_DOT_R, ev->x, ev->y, PWUI_LINE_W, C_HIGHLIGHT_BG);
-        fb_request_draw();
-        return 0;
-    }
-
-    if(d->touch_id != ev->id || !d->cur_line)
-        return -1;
-
-    if(ev->changed & TCHNG_POS)
-    {
-        const int dot_idx = type_pattern_in_dot(d, ev);
-        if(dot_idx != -1 && !type_pattern_dot_used(d, dot_idx))
-        {
-            fb_circle *c = d->dots[dot_idx];
-            d->cur_line->x2 = c->x + PWUI_DOT_R;
-            d->cur_line->y2 = c->y + PWUI_DOT_R;
-            list_add(&d->complete_lines, d->cur_line);
-            d->cur_line = fb_add_line(c->x + PWUI_DOT_R, c->y + PWUI_DOT_R, ev->x, ev->y, PWUI_LINE_W, C_HIGHLIGHT_BG);
-
-            const int last_dot = d->connected_dots[d->connected_dots_len-1];
-            int dot_mid = -1;
-            // The line is vertical and has crossed a point in the middle
-            if(dot_idx%3 == last_dot%3 && iabs(dot_idx - last_dot) > 3)
-                dot_mid = 3 + dot_idx%3;
-            // the line is horizontal and has crossed a point in the middle
-            else if(dot_idx/3 == last_dot/3 && iabs(dot_idx - last_dot) > 1)
-                dot_mid = (dot_idx/3)*3 + 1;
-            // the line is diagonal and has crossed the middle point
-            else if((dot_idx == 0 && last_dot == 8) || (dot_idx == 8 && last_dot == 0) ||
-                    (dot_idx == 2 && last_dot == 6) || (dot_idx == 6 && last_dot == 2))
-            {
-                dot_mid = 4;
-            }
-
-            if(dot_mid != -1 && !type_pattern_dot_used(d, dot_mid))
-                type_pattern_connect_dot(d, dot_mid);
-            type_pattern_connect_dot(d, dot_idx);
-        }
-        else
-        {
-            d->cur_line->x2 = ev->x;
-            d->cur_line->y2 = ev->y;
-        }
-        fb_request_draw();
-    }
-
-    if(ev->changed & TCHNG_REMOVED)
-    {
-        d->touch_id = -1;
-        fb_rm_line(d->cur_line);
-        d->cur_line = NULL;
-        fb_request_draw();
-
-        char *passwd = malloc(d->connected_dots_len+1);
-        size_t i;
-        for(i = 0; i < d->connected_dots_len; ++i)
-            passwd[i] = '1' + d->connected_dots[i];
-        passwd[i] = 0;
-
-        if(try_password(passwd) < 0)
-        {
-            list_clear(&d->active_dots, fb_remove_item);
-            list_clear(&d->complete_lines, fb_remove_item);
-            fb_request_draw();
-        }
-
-        free(passwd);
-    }
-
-    return 0;
-}
-
-static void type_pattern_init(void)
-{
-    struct pwui_type_pattern_data *d = mzalloc(sizeof(struct pwui_type_pattern_data));
-    int cx, cy;
-
-    const int start_x = fb_width*0.2;
-    const int step = (fb_width*0.6 - PWUI_DOT_R*2) / 2;
-    int x = start_x;
-    int y = fb_height/2 - fb_width/4;
-
-    for(cy = 0; cy < 3; ++cy)
-    {
-        for(cx = 0; cx < 3; ++cx)
-        {
-            fb_circle *c = fb_add_circle(x, y, PWUI_DOT_R, C_HIGHLIGHT_BG);
-            list_add(&d->dots, c);
-
-            x += step;
-        }
-        x = start_x;
-        y += step;
-    }
-
-    d->touch_id = -1;
-    add_touch_handler(type_pattern_touch_handler, d);
-
-    pwui_type_data = d;
-}
-
-static void type_pattern_destroy(void)
-{
-    struct pwui_type_pattern_data *d = pwui_type_data;
-    list_clear(&d->dots, fb_remove_item);
-    list_clear(&d->active_dots, fb_remove_item);
-    list_clear(&d->complete_lines, fb_remove_item);
-    fb_rm_line(d->cur_line);
-    free(d);
-
-    pwui_type_data = NULL;
-}
-
-static void init_ui(int pwtype)
-{
-    fb_add_rect_lvl(100, 0, 0, fb_width, HEADER_HEIGHT, C_HIGHLIGHT_BG);
-
-    ncard_set_top_offset(HEADER_HEIGHT);
-
-    fb_text_proto *p = fb_text_create(0, 0, C_HIGHLIGHT_TEXT, SIZE_EXTRA, "Encrypted device");
-    p->level = 110;
-    fb_text *t = fb_text_finalize(p);
-    center_text(t, -1, 0, -1, HEADER_HEIGHT);
-    t->x = t->y;
-
-    t = fb_add_text(0, HEADER_HEIGHT + 200*DPI_MUL, C_TEXT, SIZE_NORMAL, "Please enter your password:");
-    center_text(t, 0, -1, fb_width, -1);
-
-    invalid_pass_text = fb_add_text(0, 0, 0xFFFF0000, SIZE_BIG, "");
-    center_text(invalid_pass_text, -1, HEADER_HEIGHT, -1, 200*DPI_MUL);
-
-    if(!mrom_is_second_boot())
-    {
-        boot_primary_btn = mzalloc(sizeof(button));
-        boot_primary_btn->w = fb_width*0.30;
-        boot_primary_btn->h = HEADER_HEIGHT;
-        boot_primary_btn->x = fb_width - boot_primary_btn->w;
-        boot_primary_btn->y = 0;
-        boot_primary_btn->level_off = 101;
-        boot_primary_btn->clicked = &boot_internal_clicked;
-        button_init_ui(boot_primary_btn, "BOOT PRIMARY ROM", SIZE_SMALL);
-    }
-
-    switch(pwtype)
-    {
-        case CRYPT_TYPE_PASSWORD:
-        case CRYPT_TYPE_PIN:
-            type_pass_init(pwtype);
-            break;
-        case CRYPT_TYPE_PATTERN:
-            type_pattern_init();
-            break;
-        default:
-            t = fb_add_text(0, 0, C_TEXT, SIZE_NORMAL, "Error: unknown password type %d", pwtype);
-            center_text(t, 0, 0, fb_width, fb_height);
-            break;
-    }
-}
-
-static void destroy_ui(int pwtype)
-{
-    switch(pwtype)
-    {
-        case CRYPT_TYPE_PASSWORD:
-        case CRYPT_TYPE_PIN:
-            type_pass_destroy();
-            break;
-        case CRYPT_TYPE_PATTERN:
-            type_pattern_destroy();
-            break;
-    }
-
-    if(boot_primary_btn)
-        button_destroy(boot_primary_btn);
-}
-
-static int pw_ui_shutdown_counter_touch_handler(UNUSED touch_event *ev, void *data)
-{
-    int *shutdown_counter = data;
-    if(*shutdown_counter == 0)
-        return -1;
-
-    ncard_hide();
-
-    *shutdown_counter = 0;
-    return -1;
-}
-
-int pw_ui_run(int pwtype)
-{
-    int shutdown_counter = 0;
-
-    if(fb_open(0) < 0)
-    {
-        ERROR("Failed to open framebuffer\n");
-        return -1;
-    }
-
-    fb_freeze(1);
-    fb_set_background(C_BACKGROUND);
-
-    workers_start();
-    anim_init(1.f);
-
-    init_ui(pwtype);
-
-    start_input_thread();
-    add_touch_handler(pw_ui_shutdown_counter_touch_handler, &shutdown_counter);
-
-    fb_freeze(0);
-
-    fb_rect *r = fb_add_rect_lvl(1000, 0, 0, fb_width, fb_height, BLACK);
-    call_anim *a = call_anim_create(r, reveal_rect_alpha_step, 500, INTERPOLATOR_ACCELERATE);
-    a->on_finished_call = fb_remove_item;
-    a->on_finished_data = r;
-    call_anim_add(a);
-
-    while(1)
-    {
-        pthread_mutex_lock(&exit_code_mutex);
-        const int c = exit_code;
-        pthread_mutex_unlock(&exit_code_mutex);
-
-        if(c != ENCMNT_UIRES_ERROR)
-            break;
-
-        if(get_last_key() == KEY_POWER && (!ncard_is_visible() || shutdown_counter))
-        {
-            ++shutdown_counter;
-            if(shutdown_counter == 1)
-            {
-                ncard_builder *b = ncard_create_builder();
-                ncard_set_text(b, "Press power button again to shut down the device.");
-                ncard_show(b, 1);
-            }
-            else
-            {
-                ncard_builder *b = ncard_create_builder();
-                ncard_set_pos(b, NCARD_POS_CENTER);
-                ncard_set_text(b, "Shutting down...");
-                ncard_show(b, 1);
-                break;
-            }
-        }
-
-        usleep(100000);
-    }
-
-    anim_stop(1);
-    fb_freeze(1);
-    fb_force_draw();
-
-    rm_touch_handler(pw_ui_shutdown_counter_touch_handler, &shutdown_counter);
-
-    stop_input_thread();
-    workers_stop();
-
-    destroy_ui(pwtype);
-
-    if(shutdown_counter == 2)
-        do_reboot(REBOOT_SHUTDOWN);
-
-    fb_clear();
-    fb_close();
-    return exit_code;
-}
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <unistd.h>
+#include <pthread.h>
+#include <stdio.h>
+
+#include <string.h>
+#include <malloc.h>
+
+#include "pw_ui.h"
+#include "encmnt_defines.h"
+#include "../lib/framebuffer.h"
+#include "../lib/colors.h"
+#include "../lib/log.h"
+#include "../lib/input.h"
+#include "../lib/keyboard.h"
+#include "../lib/util.h"
+#include "../lib/notification_card.h"
+#include "../lib/animation.h"
+#include "../lib/workers.h"
+#include "../lib/containers.h"
+#include "../rom_quirks.h"
+
+#include "crypto/lollipop/cryptfs.h"
+
+#define HEADER_HEIGHT (110*DPI_MUL)
+#define PWUI_DOT_R (15*DPI_MUL)
+#define PWUI_DOT_ACTIVE_R (PWUI_DOT_R/2)
+#define PWUI_DOT_ACTIVE_OFF (PWUI_DOT_R - PWUI_DOT_ACTIVE_R)
+#define PWUI_LINE_W (12*DPI_MUL)
+#define PWUI_DOTS_CNT 9
+
+struct pwui_type_pass_data {
+    fb_text *passwd_text;
+    fb_rect *cursor_rect;
+    struct keyboard *keyboard;
+    char *pass_buf;
+    char *pass_buf_stars;
+    size_t pass_buf_cap;
+};
+
+struct pwui_type_pattern_data {
+    fb_circle **dots;
+    fb_circle **active_dots;
+    fb_line **complete_lines;
+    fb_line *cur_line;
+    int connected_dots[PWUI_DOTS_CNT];
+    size_t connected_dots_len;
+    int touch_id;
+};
+
+static pthread_mutex_t exit_code_mutex = PTHREAD_MUTEX_INITIALIZER;
+static int exit_code = ENCMNT_UIRES_ERROR;
+static void *pwui_type_data = NULL;
+static fb_text *invalid_pass_text = NULL;
+static button *boot_primary_btn = NULL;
+
+static void boot_internal_clicked(UNUSED void *data)
+{
+    ncard_builder *b = ncard_create_builder();
+    ncard_set_pos(b, NCARD_POS_CENTER);
+    ncard_set_text(b, "Booting the primary ROM...");
+    ncard_show(b, 1);
+
+    // We need to run quirks for primary ROM to prevent
+    // restorecon breaking everything
+    rom_quirks_on_initrd_finalized();
+
+    pthread_mutex_lock(&exit_code_mutex);
+    exit_code = ENCMNT_UIRES_BOOT_INTERNAL;
+    pthread_mutex_unlock(&exit_code_mutex);
+}
+
+static void fade_rect_alpha_step(void *data, float interpolated)
+{
+    fb_rect *r = data;
+    r->color = (((int)(0xFF*interpolated)) << 24);
+    fb_request_draw();
+}
+
+static void reveal_rect_alpha_step(void *data, float interpolated)
+{
+    fb_rect *r = data;
+    interpolated = 1.f - interpolated;
+    r->color = (r->color & ~(0xFF << 24)) | (((int)(0xFF*interpolated)) << 24);
+    fb_request_draw();
+}
+
+static int try_password(const char *pass)
+{
+    fb_text_set_content(invalid_pass_text, "");
+
+    ncard_builder *b = ncard_create_builder();
+    ncard_set_pos(b, NCARD_POS_CENTER);
+    ncard_set_text(b, "Verifying password...");
+    ncard_show(b, 1);
+
+    if(cryptfs_check_passwd(pass) != 0)
+    {
+        ncard_hide();
+        fb_text_set_content(invalid_pass_text, "Invalid password!");
+        center_text(invalid_pass_text, 0, -1, fb_width, -1);
+        return -1;
+    }
+    else
+    {
+        ncard_builder *b = ncard_create_builder();
+        ncard_set_pos(b, NCARD_POS_CENTER);
+        ncard_set_text(b, "Correct!");
+        ncard_show(b, 1);
+
+        fb_rect *r = fb_add_rect_lvl(10000, 0, 0, fb_width, fb_height, 0x00000000);
+        call_anim *a = call_anim_create(r, fade_rect_alpha_step, 500, INTERPOLATOR_ACCELERATE);
+        call_anim_add(a);
+
+        pthread_mutex_lock(&exit_code_mutex);
+        exit_code = ENCMNT_UIRES_PASS_OK;
+        pthread_mutex_unlock(&exit_code_mutex);
+        return 0;
+    }
+}
+
+static void type_pass_key_pressed(void *data, uint8_t code)
+{
+    struct pwui_type_pass_data *d = data;
+
+    if(code < 128)
+    {
+        size_t pass_len = strlen(d->pass_buf);
+        while(d->pass_buf_cap < pass_len + 2)
+        {
+            d->pass_buf_cap *= 2;
+            d->pass_buf = realloc(d->pass_buf, d->pass_buf_cap);
+            d->pass_buf_stars = realloc(d->pass_buf_stars, d->pass_buf_cap);
+        }
+
+        if(pass_len > 0)
+            d->pass_buf_stars[pass_len-1] = '*';
+        d->pass_buf_stars[pass_len] = (char)code;
+        d->pass_buf_stars[pass_len+1] = 0;
+
+        d->pass_buf[pass_len++] = (char)code;
+        d->pass_buf[pass_len] = 0;
+
+        fb_text_set_content(d->passwd_text, d->pass_buf_stars);
+        center_text(d->passwd_text, 0, 0, fb_width, fb_height);
+        fb_request_draw();
+
+        return;
+    }
+
+    switch(code)
+    {
+        case OSK_BACKSPACE:
+        {
+            size_t pass_len = strlen(d->pass_buf);
+            if(pass_len == 0)
+                break;
+
+            d->pass_buf_stars[--pass_len] = 0;
+            d->pass_buf[pass_len] = 0;
+
+            fb_text_set_content(d->passwd_text, d->pass_buf_stars);
+            center_text(d->passwd_text, 0, 0, fb_width, fb_height);
+            fb_request_draw();
+            break;
+        }
+        case OSK_CLEAR:
+            d->pass_buf[0] = 0;
+            d->pass_buf_stars[0] = 0;
+            fb_text_set_content(d->passwd_text, "");
+            fb_request_draw();
+            break;
+        case OSK_ENTER:
+            try_password(d->pass_buf);
+            break;
+    }
+}
+
+static void type_pass_init(int pwtype)
+{
+    struct pwui_type_pass_data *d = mzalloc(sizeof(struct pwui_type_pass_data));
+    d->keyboard = keyboard_create(pwtype == CRYPT_TYPE_PIN ? KEYBOARD_PIN : KEYBOARD_NORMAL,
+            0, fb_height*0.65, fb_width, fb_height*0.35);
+    keyboard_set_callback(d->keyboard, type_pass_key_pressed, d);
+
+    d->passwd_text = fb_add_text(0, 0, C_TEXT, SIZE_BIG, "");
+    center_text(d->passwd_text, 0, 0, fb_width, fb_height);
+
+    d->pass_buf_cap = 12;
+    d->pass_buf = mzalloc(d->pass_buf_cap);
+    d->pass_buf_stars = mzalloc(d->pass_buf_cap);
+
+    pwui_type_data = d;
+}
+
+static void type_pass_destroy(void)
+{
+    struct pwui_type_pass_data *d = pwui_type_data;
+
+    keyboard_destroy(d->keyboard);
+    free(d->pass_buf);
+    free(d->pass_buf_stars);
+    free(d);
+    pwui_type_data = NULL;
+}
+
+static inline int type_pattern_in_dot(struct pwui_type_pattern_data *d, touch_event *ev)
+{
+    int i;
+    fb_circle *c;
+    for(i = 0; d->dots[i]; ++i)
+    {
+        c = d->dots[i];
+        if(in_rect(ev->x, ev->y, c->x - PWUI_DOT_R*1.5, c->y - PWUI_DOT_R*1.5, c->w*3, c->h*3))
+            return i;
+    }
+    return -1;
+}
+
+static inline int type_pattern_dot_used(struct pwui_type_pattern_data *d, int dot_idx)
+{
+    size_t i;
+    for(i = 0; i < d->connected_dots_len; ++i)
+        if(d->connected_dots[i] == dot_idx)
+            return 1;
+    return 0;
+}
+
+static inline void type_pattern_connect_dot(struct pwui_type_pattern_data *d,  int dot_idx)
+{
+    if(d->connected_dots_len >= PWUI_DOTS_CNT)
+    {
+        ERROR("d->connected_dots_len overflowed PWUI_DOTS_CNT!\n");
+        return;
+    }
+
+    d->connected_dots[d->connected_dots_len++] = dot_idx;
+
+    fb_circle *c = d->dots[dot_idx];
+    c = fb_add_circle_lvl(100, c->x+PWUI_DOT_ACTIVE_OFF, c->y+PWUI_DOT_ACTIVE_OFF, PWUI_DOT_ACTIVE_R, C_HIGHLIGHT_TEXT);
+    list_add(&d->active_dots, c);
+}
+
+static int type_pattern_touch_handler(touch_event *ev, void *data)
+{
+    struct pwui_type_pattern_data *d = data;
+
+    if(d->touch_id == -1 && (ev->changed & TCHNG_ADDED) && !ev->consumed)
+    {
+        const int dot_idx = type_pattern_in_dot(d, ev);
+        if(dot_idx == -1)
+            return -1;
+
+        d->touch_id = ev->id;
+        d->connected_dots_len = 0;
+
+        type_pattern_connect_dot(d, dot_idx);
+
+        fb_circle *c = d->dots[dot_idx];
+        d->cur_line = fb_add_line(c->x + PWUI_DOT_R, c->y + PWUI_DOT_R, ev->x, ev->y, PWUI_LINE_W, C_HIGHLIGHT_BG);
+        fb_request_draw();
+        return 0;
+    }
+
+    if(d->touch_id != ev->id || !d->cur_line)
+        return -1;
+
+    if(ev->changed & TCHNG_POS)
+    {
+        const int dot_idx = type_pattern_in_dot(d, ev);
+        if(dot_idx != -1 && !type_pattern_dot_used(d, dot_idx))
+        {
+            fb_circle *c = d->dots[dot_idx];
+            d->cur_line->x2 = c->x + PWUI_DOT_R;
+            d->cur_line->y2 = c->y + PWUI_DOT_R;
+            list_add(&d->complete_lines, d->cur_line);
+            d->cur_line = fb_add_line(c->x + PWUI_DOT_R, c->y + PWUI_DOT_R, ev->x, ev->y, PWUI_LINE_W, C_HIGHLIGHT_BG);
+
+            const int last_dot = d->connected_dots[d->connected_dots_len-1];
+            int dot_mid = -1;
+            // The line is vertical and has crossed a point in the middle
+            if(dot_idx%3 == last_dot%3 && iabs(dot_idx - last_dot) > 3)
+                dot_mid = 3 + dot_idx%3;
+            // the line is horizontal and has crossed a point in the middle
+            else if(dot_idx/3 == last_dot/3 && iabs(dot_idx - last_dot) > 1)
+                dot_mid = (dot_idx/3)*3 + 1;
+            // the line is diagonal and has crossed the middle point
+            else if((dot_idx == 0 && last_dot == 8) || (dot_idx == 8 && last_dot == 0) ||
+                    (dot_idx == 2 && last_dot == 6) || (dot_idx == 6 && last_dot == 2))
+            {
+                dot_mid = 4;
+            }
+
+            if(dot_mid != -1 && !type_pattern_dot_used(d, dot_mid))
+                type_pattern_connect_dot(d, dot_mid);
+            type_pattern_connect_dot(d, dot_idx);
+        }
+        else
+        {
+            d->cur_line->x2 = ev->x;
+            d->cur_line->y2 = ev->y;
+        }
+        fb_request_draw();
+    }
+
+    if(ev->changed & TCHNG_REMOVED)
+    {
+        d->touch_id = -1;
+        fb_rm_line(d->cur_line);
+        d->cur_line = NULL;
+        fb_request_draw();
+
+        char *passwd = malloc(d->connected_dots_len+1);
+        size_t i;
+        for(i = 0; i < d->connected_dots_len; ++i)
+            passwd[i] = '1' + d->connected_dots[i];
+        passwd[i] = 0;
+
+        if(try_password(passwd) < 0)
+        {
+            list_clear(&d->active_dots, fb_remove_item);
+            list_clear(&d->complete_lines, fb_remove_item);
+            fb_request_draw();
+        }
+
+        free(passwd);
+    }
+
+    return 0;
+}
+
+static void type_pattern_init(void)
+{
+    struct pwui_type_pattern_data *d = mzalloc(sizeof(struct pwui_type_pattern_data));
+    int cx, cy;
+
+    const int start_x = fb_width*0.2;
+    const int step = (fb_width*0.6 - PWUI_DOT_R*2) / 2;
+    int x = start_x;
+    int y = fb_height/2 - fb_width/4;
+
+    for(cy = 0; cy < 3; ++cy)
+    {
+        for(cx = 0; cx < 3; ++cx)
+        {
+            fb_circle *c = fb_add_circle(x, y, PWUI_DOT_R, C_HIGHLIGHT_BG);
+            list_add(&d->dots, c);
+
+            x += step;
+        }
+        x = start_x;
+        y += step;
+    }
+
+    d->touch_id = -1;
+    add_touch_handler(type_pattern_touch_handler, d);
+
+    pwui_type_data = d;
+}
+
+static void type_pattern_destroy(void)
+{
+    struct pwui_type_pattern_data *d = pwui_type_data;
+    list_clear(&d->dots, fb_remove_item);
+    list_clear(&d->active_dots, fb_remove_item);
+    list_clear(&d->complete_lines, fb_remove_item);
+    fb_rm_line(d->cur_line);
+    free(d);
+
+    pwui_type_data = NULL;
+}
+
+static void init_ui(int pwtype)
+{
+    fb_add_rect_lvl(100, 0, 0, fb_width, HEADER_HEIGHT, C_HIGHLIGHT_BG);
+
+    ncard_set_top_offset(HEADER_HEIGHT);
+
+    fb_text_proto *p = fb_text_create(0, 0, C_HIGHLIGHT_TEXT, SIZE_EXTRA, "Encrypted device");
+    p->level = 110;
+    fb_text *t = fb_text_finalize(p);
+    center_text(t, -1, 0, -1, HEADER_HEIGHT);
+    t->x = t->y;
+
+    t = fb_add_text(0, HEADER_HEIGHT + 200*DPI_MUL, C_TEXT, SIZE_NORMAL, "Please enter your password:");
+    center_text(t, 0, -1, fb_width, -1);
+
+    invalid_pass_text = fb_add_text(0, 0, 0xFFFF0000, SIZE_BIG, "");
+    center_text(invalid_pass_text, -1, HEADER_HEIGHT, -1, 200*DPI_MUL);
+
+    if(!mrom_is_second_boot())
+    {
+        boot_primary_btn = mzalloc(sizeof(button));
+        boot_primary_btn->w = fb_width*0.30;
+        boot_primary_btn->h = HEADER_HEIGHT;
+        boot_primary_btn->x = fb_width - boot_primary_btn->w;
+        boot_primary_btn->y = 0;
+        boot_primary_btn->level_off = 101;
+        boot_primary_btn->clicked = &boot_internal_clicked;
+        button_init_ui(boot_primary_btn, "BOOT PRIMARY ROM", SIZE_SMALL);
+    }
+
+    switch(pwtype)
+    {
+        case CRYPT_TYPE_PASSWORD:
+        case CRYPT_TYPE_PIN:
+            type_pass_init(pwtype);
+            break;
+        case CRYPT_TYPE_PATTERN:
+            type_pattern_init();
+            break;
+        default:
+            t = fb_add_text(0, 0, C_TEXT, SIZE_NORMAL, "Error: unknown password type %d", pwtype);
+            center_text(t, 0, 0, fb_width, fb_height);
+            break;
+    }
+}
+
+static void destroy_ui(int pwtype)
+{
+    switch(pwtype)
+    {
+        case CRYPT_TYPE_PASSWORD:
+        case CRYPT_TYPE_PIN:
+            type_pass_destroy();
+            break;
+        case CRYPT_TYPE_PATTERN:
+            type_pattern_destroy();
+            break;
+    }
+
+    if(boot_primary_btn)
+        button_destroy(boot_primary_btn);
+}
+
+static int pw_ui_shutdown_counter_touch_handler(UNUSED touch_event *ev, void *data)
+{
+    int *shutdown_counter = data;
+    if(*shutdown_counter == 0)
+        return -1;
+
+    ncard_hide();
+
+    *shutdown_counter = 0;
+    return -1;
+}
+
+int pw_ui_run(int pwtype)
+{
+    int shutdown_counter = 0;
+
+    if(fb_open(0) < 0)
+    {
+        ERROR("Failed to open framebuffer\n");
+        return -1;
+    }
+
+    fb_freeze(1);
+    fb_set_background(C_BACKGROUND);
+
+    workers_start();
+    anim_init(1.f);
+
+    init_ui(pwtype);
+
+    start_input_thread();
+    add_touch_handler(pw_ui_shutdown_counter_touch_handler, &shutdown_counter);
+
+    fb_freeze(0);
+
+    fb_rect *r = fb_add_rect_lvl(1000, 0, 0, fb_width, fb_height, BLACK);
+    call_anim *a = call_anim_create(r, reveal_rect_alpha_step, 500, INTERPOLATOR_ACCELERATE);
+    a->on_finished_call = fb_remove_item;
+    a->on_finished_data = r;
+    call_anim_add(a);
+
+    while(1)
+    {
+        pthread_mutex_lock(&exit_code_mutex);
+        const int c = exit_code;
+        pthread_mutex_unlock(&exit_code_mutex);
+
+        if(c != ENCMNT_UIRES_ERROR)
+            break;
+
+        if(get_last_key() == KEY_POWER && (!ncard_is_visible() || shutdown_counter))
+        {
+            ++shutdown_counter;
+            if(shutdown_counter == 1)
+            {
+                ncard_builder *b = ncard_create_builder();
+                ncard_set_text(b, "Press power button again to shut down the device.");
+                ncard_show(b, 1);
+            }
+            else
+            {
+                ncard_builder *b = ncard_create_builder();
+                ncard_set_pos(b, NCARD_POS_CENTER);
+                ncard_set_text(b, "Shutting down...");
+                ncard_show(b, 1);
+                break;
+            }
+        }
+
+        usleep(100000);
+    }
+
+    anim_stop(1);
+    fb_freeze(1);
+    fb_force_draw();
+
+    rm_touch_handler(pw_ui_shutdown_counter_touch_handler, &shutdown_counter);
+
+    stop_input_thread();
+    workers_stop();
+
+    destroy_ui(pwtype);
+
+    if(shutdown_counter == 2)
+        do_reboot(REBOOT_SHUTDOWN);
+
+    fb_clear();
+    fb_close();
+    return exit_code;
+}
diff --git a/trampoline_encmnt/pw_ui.h b/trampoline_encmnt/pw_ui.h
index db66281..1a86950 100755
--- a/trampoline_encmnt/pw_ui.h
+++ b/trampoline_encmnt/pw_ui.h
@@ -1,23 +1,23 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef PW_UI_H
-#define PW_UI_H
-
-int pw_ui_run(int pwtype);
-
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef PW_UI_H
+#define PW_UI_H
+
+int pw_ui_run(int pwtype);
+
+#endif
diff --git a/version.h b/version.h
index c1cc58a..cf97233 100755
--- a/version.h
+++ b/version.h
@@ -1,25 +1,25 @@
-/*
- * This file is part of MultiROM.
- *
- * MultiROM is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * MultiROM is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef VERSION_H
-#define VERSION_H
-    #define VERSION_MULTIROM 33
-    #define VERSION_TRAMPOLINE 27
-
-    // For device-specific fixes. Use letters, the version will then be like "12a"
-    #define VERSION_DEV_FIX ""
-#endif
+/*
+ * This file is part of MultiROM.
+ *
+ * MultiROM is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * MultiROM is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with MultiROM.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef VERSION_H
+#define VERSION_H
+    #define VERSION_MULTIROM 33
+    #define VERSION_TRAMPOLINE 27
+
+    // For device-specific fixes. Use letters, the version will then be like "12a"
+    #define VERSION_DEV_FIX ""
+#endif
